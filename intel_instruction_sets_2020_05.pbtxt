name: "x86_64"
llvm_name: "x86_64"
instruction_set {
  source_infos {
    source_name: "IntelSDMParser V2"
    metadata {
      key: "Author"
      value: "Intel Corporation"
    }
    metadata {
      key: "CreationDate"
      value: "D:20200526123021Z"
    }
    metadata {
      key: "ModDate"
      value: "D:20200526132553-07\'00\'"
    }
    metadata {
      key: "Title"
      value: "Intel\302\256 64 and IA-32 Architectures Software Developers Manual, Combined Volumes: 1, 2A, 2B, 2C, 2D, 3A, 3B, 3C, 3D and 4"
    }
  }
  instructions {
    description: "Calculates SHA1 state variable E after four rounds of operation from the current SHA1 state variable A in xmm1. The calculated value of the SHA1 state variable E is added to the scheduled dwords in xmm2/m128, and stored with some of the scheduled dwords in xmm1."
    vendor_syntax {
      mnemonic: "SHA1NEXTE"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SHA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "NP 0F 38 C8 /r"
    instruction_group_index: 0
  }
  instructions {
    description: "Insert 128 bits of integer data from xmm3/m128 and the remaining values from ymm2 into ymm1."
    vendor_syntax {
      mnemonic: "VINSERTI128"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F3A.W0 38 /r ib"
    instruction_group_index: 1
  }
  instructions {
    description: "Insert 128 bits of packed doubleword integer values from xmm3/m128 and the remaining values from ymm2 into ymm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VINSERTI32X4"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F3A.W0 38 /r ib"
    instruction_group_index: 1
  }
  instructions {
    description: "Insert 128 bits of packed doubleword integer values from xmm3/m128 and the remaining values from zmm2 into zmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VINSERTI32X4"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F3A.W0 38 /r ib"
    instruction_group_index: 1
  }
  instructions {
    description: "Insert 128 bits of packed quadword integer values from xmm3/m128 and the remaining values from ymm2 into ymm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VINSERTI64X2"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F3A.W1 38 /r ib"
    instruction_group_index: 1
  }
  instructions {
    description: "Insert 128 bits of packed quadword integer values from xmm3/m128 and the remaining values from zmm2 into zmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VINSERTI64X2"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F3A.W1 38 /r ib"
    instruction_group_index: 1
  }
  instructions {
    description: "Insert 256 bits of packed doubleword integer values from ymm3/m256 and the remaining values from zmm2 into zmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VINSERTI32X8"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.66.0F3A.W0 3A /r ib"
    instruction_group_index: 1
  }
  instructions {
    description: "Insert 256 bits of packed quadword integer values from ymm3/m256 and the remaining values from zmm2 into zmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VINSERTI64X4"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F3A.W1 3A /r ib"
    instruction_group_index: 1
  }
  instructions {
    description: "Permute single-precision floating-point elements in ymm3/m256 using indices in ymm2 and store the result in ymm1."
    vendor_syntax {
      mnemonic: "VPERMPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.NDS.256.66.0F38.W0 16 /r"
    instruction_group_index: 2
  }
  instructions {
    description: "Permute single-precision floating-point elements in ymm3/m256/m32bcst using indexes in ymm2 and store the result in ymm1 subject to write mask k1."
    vendor_syntax {
      mnemonic: "VPERMPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 16 /r"
    instruction_group_index: 2
  }
  instructions {
    description: "Permute single-precision floating-point values in zmm3/m512/m32bcst using indices in zmm2 and store the result in zmm1 subject to write mask k1."
    vendor_syntax {
      mnemonic: "VPERMPS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 16 /r"
    instruction_group_index: 2
  }
  instructions {
    description: "Rounds packed single-precision floating point values in xmm2/m128/m32bcst to a number of fraction bits specified by the imm8 field. Stores the result in xmm1 register. Under writemask."
    vendor_syntax {
      mnemonic: "VRNDSCALEPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F3A.W0 08 /r ib"
    instruction_group_index: 3
  }
  instructions {
    description: "Rounds packed single-precision floating point values in ymm2/m256/m32bcst to a number of fraction bits specified by the imm8 field. Stores the result in ymm1 register. Under writemask."
    vendor_syntax {
      mnemonic: "VRNDSCALEPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F3A.W0 08 /r ib"
    instruction_group_index: 3
  }
  instructions {
    description: "Rounds packed single-precision floating-point values in zmm2/m512/m32bcst to a number of fraction bits specified by the imm8 field. Stores the result in zmm1 register using writemask."
    vendor_syntax {
      mnemonic: "VRNDSCALEPS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F3A.W0 08 /r ib"
    instruction_group_index: 3
  }
  instructions {
    description: "Interleave low-order bytes from mm and mm/m32 into mm."
    vendor_syntax {
      mnemonic: "PUNPCKLBW"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 60 /r"
    instruction_group_index: 4
  }
  instructions {
    description: "Interleave low-order bytes from xmm1 and xmm2/m128 into xmm1."
    vendor_syntax {
      mnemonic: "PUNPCKLBW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 60 /r"
    instruction_group_index: 4
  }
  instructions {
    description: "Interleave low-order words from mm and mm/m32 into mm."
    vendor_syntax {
      mnemonic: "PUNPCKLWD"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 61 /r"
    instruction_group_index: 4
  }
  instructions {
    description: "Interleave low-order words from xmm1 and xmm2/m128 into xmm1."
    vendor_syntax {
      mnemonic: "PUNPCKLWD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 61 /r"
    instruction_group_index: 4
  }
  instructions {
    description: "Interleave low-order doublewords from mm and mm/m32 into mm."
    vendor_syntax {
      mnemonic: "PUNPCKLDQ"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 62 /r"
    instruction_group_index: 4
  }
  instructions {
    description: "Interleave low-order doublewords from xmm1 and xmm2/m128 into xmm1."
    vendor_syntax {
      mnemonic: "PUNPCKLDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 62 /r"
    instruction_group_index: 4
  }
  instructions {
    description: "Interleave low-order quadword from xmm1 and xmm2/m128 into xmm1 register."
    vendor_syntax {
      mnemonic: "PUNPCKLQDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 6C /r"
    instruction_group_index: 4
  }
  instructions {
    description: "Interleave low-order bytes from xmm2 and xmm3/m128 into xmm1."
    vendor_syntax {
      mnemonic: "VPUNPCKLBW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG 60/r"
    instruction_group_index: 4
  }
  instructions {
    description: "Interleave low-order words from xmm2 and xmm3/m128 into xmm1."
    vendor_syntax {
      mnemonic: "VPUNPCKLWD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG 61/r"
    instruction_group_index: 4
  }
  instructions {
    description: "Interleave low-order doublewords from xmm2 and xmm3/m128 into xmm1."
    vendor_syntax {
      mnemonic: "VPUNPCKLDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG 62/r"
    instruction_group_index: 4
  }
  instructions {
    description: "Interleave low-order quadword from xmm2 and xmm3/m128 into xmm1 register."
    vendor_syntax {
      mnemonic: "VPUNPCKLQDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG 6C/r"
    instruction_group_index: 4
  }
  instructions {
    description: "Interleave low-order bytes from ymm2 and ymm3/m256 into ymm1 register."
    vendor_syntax {
      mnemonic: "VPUNPCKLBW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG 60 /r"
    instruction_group_index: 4
  }
  instructions {
    description: "Interleave low-order words from ymm2 and ymm3/m256 into ymm1 register."
    vendor_syntax {
      mnemonic: "VPUNPCKLWD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG 61 /r"
    instruction_group_index: 4
  }
  instructions {
    description: "Interleave low-order doublewords from ymm2 and ymm3/m256 into ymm1 register."
    vendor_syntax {
      mnemonic: "VPUNPCKLDQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG 62 /r"
    instruction_group_index: 4
  }
  instructions {
    description: "Interleave low-order quadword from ymm2 and ymm3/m256 into ymm1 register."
    vendor_syntax {
      mnemonic: "VPUNPCKLQDQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG 6C /r"
    instruction_group_index: 4
  }
  instructions {
    description: "Interleave low-order bytes from xmm2 and xmm3/m128 into xmm1 register subject to write mask k1."
    vendor_syntax {
      mnemonic: "VPUNPCKLBW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.WIG 60 /r"
    instruction_group_index: 4
  }
  instructions {
    description: "Interleave low-order words from xmm2 and xmm3/m128 into xmm1 register subject to write mask k1."
    vendor_syntax {
      mnemonic: "VPUNPCKLWD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.WIG 61 /r"
    instruction_group_index: 4
  }
  instructions {
    description: "Interleave low-order doublewords from xmm2 and xmm3/m128/m32bcst into xmm1 register subject to write mask k1."
    vendor_syntax {
      mnemonic: "VPUNPCKLDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.128.66.0F.W0 62 /r"
    instruction_group_index: 4
  }
  instructions {
    description: "Interleave low-order quadword from zmm2 and zmm3/m512/m64bcst into zmm1 register subject to write mask k1."
    vendor_syntax {
      mnemonic: "VPUNPCKLQDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.128.66.0F.W1 6C /r"
    instruction_group_index: 4
  }
  instructions {
    description: "Interleave low-order bytes from ymm2 and ymm3/m256 into ymm1 register subject to write mask k1."
    vendor_syntax {
      mnemonic: "VPUNPCKLBW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.WIG 60 /r"
    instruction_group_index: 4
  }
  instructions {
    description: "Interleave low-order words from ymm2 and ymm3/m256 into ymm1 register subject to write mask k1."
    vendor_syntax {
      mnemonic: "VPUNPCKLWD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.WIG 61 /r"
    instruction_group_index: 4
  }
  instructions {
    description: "Interleave low-order doublewords from ymm2 and ymm3/m256/m32bcst into ymm1 register subject to write mask k1."
    vendor_syntax {
      mnemonic: "VPUNPCKLDQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.256.66.0F.W0 62 /r"
    instruction_group_index: 4
  }
  instructions {
    description: "Interleave low-order quadword from ymm2 and ymm3/m256/m64bcst into ymm1 register subject to write mask k1."
    vendor_syntax {
      mnemonic: "VPUNPCKLQDQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.256.66.0F.W1 6C /r"
    instruction_group_index: 4
  }
  instructions {
    description: "Interleave low-order bytes from zmm2 and zmm3/m512 into zmm1 register subject to write mask k1."
    vendor_syntax {
      mnemonic: "VPUNPCKLBW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.WIG 60/r"
    instruction_group_index: 4
  }
  instructions {
    description: "Interleave low-order words from zmm2 and zmm3/m512 into zmm1 register subject to write mask k1."
    vendor_syntax {
      mnemonic: "VPUNPCKLWD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.WIG 61/r"
    instruction_group_index: 4
  }
  instructions {
    description: "Interleave low-order doublewords from zmm2 and zmm3/m512/m32bcst into zmm1 register subject to write mask k1."
    vendor_syntax {
      mnemonic: "VPUNPCKLDQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.66.0F.W0 62 /r"
    instruction_group_index: 4
  }
  instructions {
    description: "Interleave low-order quadword from zmm2 and zmm3/m512/m64bcst into zmm1 register subject to write mask k1."
    vendor_syntax {
      mnemonic: "VPUNPCKLQDQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.66.0F.W1 6C /r"
    instruction_group_index: 4
  }
  instructions {
    description: "Convert two packed single precision floating-point values from zmm2/m64/m32bcst to two packed unsigned quadword values in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VCVTPS2UQQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F.W0 79 /r"
    instruction_group_index: 5
  }
  instructions {
    description: "Convert four packed single precision floating-point values from xmm2/m128/m32bcst to four packed unsigned quadword values in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VCVTPS2UQQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F.W0 79 /r"
    instruction_group_index: 5
  }
  instructions {
    description: "Convert eight packed single precision floating-point values from ymm2/m256/m32bcst to eight packed unsigned quadword values in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VCVTPS2UQQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F.W0 79 /r"
    instruction_group_index: 5
  }
  instructions {
    description: "Move odd index single-precision floating-point values from xmm2/mem and duplicate each element into xmm1."
    vendor_syntax {
      mnemonic: "MOVSHDUP"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F3 0F 16 /r"
    instruction_group_index: 6
  }
  instructions {
    description: "Move odd index single-precision floating-point values from xmm2/mem and duplicate each element into xmm1."
    vendor_syntax {
      mnemonic: "VMOVSHDUP"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.F3.0F.WIG 16 /r"
    instruction_group_index: 6
  }
  instructions {
    description: "Move odd index single-precision floating-point values from ymm2/mem and duplicate each element into ymm1."
    vendor_syntax {
      mnemonic: "VMOVSHDUP"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.F3.0F.WIG 16 /r"
    instruction_group_index: 6
  }
  instructions {
    description: "Move odd index single-precision floating-point values from xmm2/m128 and duplicate each element into xmm1 under writemask."
    vendor_syntax {
      mnemonic: "VMOVSHDUP"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.F3.0F.W0 16 /r"
    instruction_group_index: 6
  }
  instructions {
    description: "Move odd index single-precision floating-point values from ymm2/m256 and duplicate each element into ymm1 under writemask."
    vendor_syntax {
      mnemonic: "VMOVSHDUP"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.F3.0F.W0 16 /r"
    instruction_group_index: 6
  }
  instructions {
    description: "Move odd index single-precision floating-point values from zmm2/m512 and duplicate each element into zmm1 under writemask."
    vendor_syntax {
      mnemonic: "VMOVSHDUP"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.F3.0F.W0 16 /r"
    instruction_group_index: 6
  }
  instructions {
    description: "Multiply scalar double-precision floating-point value from xmm1 and xmm3/mem, negate the multiplication result and add to xmm2 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMADD132SD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.LIG.66.0F38.W1 9D /r"
    instruction_group_index: 7
  }
  instructions {
    description: "Multiply scalar double-precision floating-point value from xmm1 and xmm2, negate the multiplication result and add to xmm3/mem and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMADD213SD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.LIG.66.0F38.W1 AD /r"
    instruction_group_index: 7
  }
  instructions {
    description: "Multiply scalar double-precision floating-point value from xmm2 and xmm3/mem, negate the multiplication result and add to xmm1 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMADD231SD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.LIG.66.0F38.W1 BD /r"
    instruction_group_index: 7
  }
  instructions {
    description: "Multiply scalar double-precision floating-point value from xmm1 and xmm3/m64, negate the multiplication result and add to xmm2 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMADD132SD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.LIG.66.0F38.W1 9D /r"
    instruction_group_index: 7
  }
  instructions {
    description: "Multiply scalar double-precision floating-point value from xmm1 and xmm2, negate the multiplication result and add to xmm3/m64 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMADD213SD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.LIG.66.0F38.W1 AD /r"
    instruction_group_index: 7
  }
  instructions {
    description: "Multiply scalar double-precision floating-point value from xmm2 and xmm3/m64, negate the multiplication result and add to xmm1 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMADD231SD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.LIG.66.0F38.W1 BD /r"
    instruction_group_index: 7
  }
  instructions {
    description: "Replace ST(1) with (ST(1) \342\210\227 log2ST(0)) and pop the register stack."
    vendor_syntax {
      mnemonic: "FYL2X"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D9 F1"
    instruction_group_index: 8
  }
  instructions {
    description: "Computes the approximate reciprocals ( < 2^-28 relative error) of the packed single-precision floating-point values in zmm2/m512/m32bcst and stores the results in zmm1. Under writemask."
    vendor_syntax {
      mnemonic: "VRCP28PS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512ER"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 CA /r"
    instruction_group_index: 9
  }
  instructions {
    description: "Add 16 bits masks in k2 and k3 and place result in k1."
    vendor_syntax {
      mnemonic: "KADDW"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "k3"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVR"
    raw_encoding_specification: "VEX.NDS.L1.0F.W0 4A /r"
    instruction_group_index: 10
  }
  instructions {
    description: "Add 8 bits masks in k2 and k3 and place result in k1."
    vendor_syntax {
      mnemonic: "KADDB"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "k3"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVR"
    raw_encoding_specification: "VEX.NDS.L1.66.0F.W0 4A /r"
    instruction_group_index: 10
  }
  instructions {
    description: "Add 64 bits masks in k2 and k3 and place result in k1."
    vendor_syntax {
      mnemonic: "KADDQ"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "k3"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVR"
    raw_encoding_specification: "VEX.NDS.L1.0F.W1 4A /r"
    instruction_group_index: 10
  }
  instructions {
    description: "Add 32 bits masks in k2 and k3 and place result in k1."
    vendor_syntax {
      mnemonic: "KADDD"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "k3"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVR"
    raw_encoding_specification: "VEX.NDS.L1.66.0F.W1 4A /r"
    instruction_group_index: 10
  }
  instructions {
    description: "Compare unsigned byte integers in mm2/m64 and mm1 and returns maximum values."
    vendor_syntax {
      mnemonic: "PMAXUB"
      operands {
        name: "mm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F DE /r"
    instruction_group_index: 11
  }
  instructions {
    description: "Compare packed unsigned byte integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1."
    vendor_syntax {
      mnemonic: "PMAXUB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F DE /r"
    instruction_group_index: 11
  }
  instructions {
    description: "Compare packed unsigned word integers in xmm2/m128 and xmm1 and stores maximum packed values in xmm1."
    vendor_syntax {
      mnemonic: "PMAXUW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 38 3E/r"
    instruction_group_index: 11
  }
  instructions {
    description: "Compare packed unsigned byte integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1."
    vendor_syntax {
      mnemonic: "VPMAXUB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F DE /r"
    instruction_group_index: 11
  }
  instructions {
    description: "Compare packed unsigned word integers in xmm3/m128 and xmm2 and store maximum packed values in xmm1."
    vendor_syntax {
      mnemonic: "VPMAXUW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F38 3E/r"
    instruction_group_index: 11
  }
  instructions {
    description: "Compare packed unsigned byte integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1."
    vendor_syntax {
      mnemonic: "VPMAXUB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F DE /r"
    instruction_group_index: 11
  }
  instructions {
    description: "Compare packed unsigned word integers in ymm3/m256 and ymm2 and store maximum packed values in ymm1."
    vendor_syntax {
      mnemonic: "VPMAXUW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F38 3E/r"
    instruction_group_index: 11
  }
  instructions {
    description: "Compare packed unsigned byte integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMAXUB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.WIG DE /r"
    instruction_group_index: 11
  }
  instructions {
    description: "Compare packed unsigned byte integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMAXUB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.WIG DE /r"
    instruction_group_index: 11
  }
  instructions {
    description: "Compare packed unsigned byte integers in zmm2 and zmm3/m512 and store packed maximum values in zmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMAXUB"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.WIG DE /r"
    instruction_group_index: 11
  }
  instructions {
    description: "Compare packed unsigned word integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMAXUW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F38.WIG 3E /r"
    instruction_group_index: 11
  }
  instructions {
    description: "Compare packed unsigned word integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMAXUW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38.WIG 3E /r"
    instruction_group_index: 11
  }
  instructions {
    description: "Compare packed unsigned word integers in zmm2 and zmm3/m512 and store packed maximum values in zmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMAXUW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38.WIG 3E /r"
    instruction_group_index: 11
  }
  instructions {
    description: "Save state components specified by EDX:EAX to mem with compaction."
    vendor_syntax {
      mnemonic: "XSAVEC"
      operands {
        name: "mem"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    feature_name: "XSAVEC"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "NP 0F C7 /4"
    instruction_group_index: 12
  }
  instructions {
    description: "Save state components specified by EDX:EAX to mem with compaction."
    vendor_syntax {
      mnemonic: "XSAVEC64"
      operands {
        name: "mem"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    feature_name: "XSAVEC"
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "NP REX.W + 0F C7 /4"
    instruction_group_index: 12
  }
  instructions {
    description: "Shuffle the low words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1."
    vendor_syntax {
      mnemonic: "PSHUFLW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F2 0F 70 /r ib"
    instruction_group_index: 13
  }
  instructions {
    description: "Shuffle the low words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1."
    vendor_syntax {
      mnemonic: "VPSHUFLW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.F2.0F.WIG 70 /r ib"
    instruction_group_index: 13
  }
  instructions {
    description: "Shuffle the low words in ymm2/m256 based on the encoding in imm8 and store the result in ymm1."
    vendor_syntax {
      mnemonic: "VPSHUFLW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.F2.0F.WIG 70 /r ib"
    instruction_group_index: 13
  }
  instructions {
    description: "Shuffle the low words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1 under write mask k1."
    vendor_syntax {
      mnemonic: "VPSHUFLW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.F2.0F.WIG 70 /r ib"
    instruction_group_index: 13
  }
  instructions {
    description: "Shuffle the low words in ymm2/m256 based on the encoding in imm8 and store the result in ymm1 under write mask k1."
    vendor_syntax {
      mnemonic: "VPSHUFLW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.F2.0F.WIG 70 /r ib"
    instruction_group_index: 13
  }
  instructions {
    description: "Shuffle the low words in zmm2/m512 based on the encoding in imm8 and store the result in zmm1 under write mask k1."
    vendor_syntax {
      mnemonic: "VPSHUFLW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.F2.0F.WIG 70 /r ib"
    instruction_group_index: 13
  }
  instructions {
    description: "Subtract packed double-precision floating-point values in xmm2/mem from xmm1 and store result in xmm1."
    vendor_syntax {
      mnemonic: "SUBPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 5C /r"
    instruction_group_index: 14
  }
  instructions {
    description: "Subtract packed double-precision floating-point values in xmm3/mem from xmm2 and store result in xmm1."
    vendor_syntax {
      mnemonic: "VSUBPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG 5C /r"
    instruction_group_index: 14
  }
  instructions {
    description: "Subtract packed double-precision floating-point values in ymm3/mem from ymm2 and store result in ymm1."
    vendor_syntax {
      mnemonic: "VSUBPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG 5C /r"
    instruction_group_index: 14
  }
  instructions {
    description: "Subtract packed double-precision floating-point values from xmm3/m128/m64bcst to xmm2 and store result in xmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VSUBPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.W1 5C /r"
    instruction_group_index: 14
  }
  instructions {
    description: "Subtract packed double-precision floating-point values from ymm3/m256/m64bcst to ymm2 and store result in ymm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VSUBPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.W1 5C /r"
    instruction_group_index: 14
  }
  instructions {
    description: "Subtract packed double-precision floating-point values from zmm3/m512/m64bcst to zmm2 and store result in zmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VSUBPD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.W1 5C /r"
    instruction_group_index: 14
  }
  instructions {
    description: "Insert a single-precision floating-point value selected by imm8 from xmm2/m32 into xmm1 at the specified destination element specified by imm8 and zero out destination elements in xmm1 as indicated in imm8."
    vendor_syntax {
      mnemonic: "INSERTPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 3A 21 /r ib"
    instruction_group_index: 15
  }
  instructions {
    description: "Insert a single-precision floating-point value selected by imm8 from xmm3/m32 and merge with values in xmm2 at the specified destination element specified by imm8 and write out the result and zero out destination elements in xmm1 as indicated in imm8."
    vendor_syntax {
      mnemonic: "VINSERTPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F3A.WIG 21 /r ib"
    instruction_group_index: 15
  }
  instructions {
    description: "Insert a single-precision floating-point value selected by imm8 from xmm3/m32 and merge with values in xmm2 at the specified destination element specified by imm8 and write out the result and zero out destination elements in xmm1 as indicated in imm8."
    vendor_syntax {
      mnemonic: "VINSERTPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F3A.W0 21 /r ib"
    instruction_group_index: 15
  }
  instructions {
    description: "Replace ST(1) with arctan(ST(1)/ST(0)) and pop the register stack."
    vendor_syntax {
      mnemonic: "FPATAN"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D9 F3"
    instruction_group_index: 16
  }
  instructions {
    description: "Move double quadword from m128 to xmm1 using nontemporal hint if WC memory type."
    vendor_syntax {
      mnemonic: "MOVNTDQA"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 38 2A /r"
    instruction_group_index: 17
  }
  instructions {
    description: "Move double quadword from m128 to xmm using nontemporal hint if WC memory type."
    vendor_syntax {
      mnemonic: "VMOVNTDQA"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.WIG 2A /r"
    instruction_group_index: 17
  }
  instructions {
    description: "Move 256-bit data from m256 to ymm using non-temporal hint if WC memory type."
    vendor_syntax {
      mnemonic: "VMOVNTDQA"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.WIG 2A /r"
    instruction_group_index: 17
  }
  instructions {
    description: "Move 128-bit data from m128 to xmm using non-temporal hint if WC memory type."
    vendor_syntax {
      mnemonic: "VMOVNTDQA"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 2A /r"
    instruction_group_index: 17
  }
  instructions {
    description: "Move 256-bit data from m256 to ymm using non-temporal hint if WC memory type."
    vendor_syntax {
      mnemonic: "VMOVNTDQA"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 2A /r"
    instruction_group_index: 17
  }
  instructions {
    description: "Move 512-bit data from m512 to zmm using non-temporal hint if WC memory type."
    vendor_syntax {
      mnemonic: "VMOVNTDQA"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 2A /r"
    instruction_group_index: 17
  }
  instructions {
    description: "Serializes load and store operations."
    vendor_syntax {
      mnemonic: "MFENCE"
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "NP 0F AE F0"
    instruction_group_index: 18
  }
  instructions {
    description: "Perform 2 rounds of SHA256 operation using an initial SHA256 state (C,D,G,H) from xmm1, an initial SHA256 state (A,B,E,F) from xmm2/m128, and a pre-computed sum of the next 2 round message dwords and the corresponding round constants from the implicit operand XMM0, storing the updated SHA256 state (A,B,E,F) result in xmm1."
    vendor_syntax {
      mnemonic: "SHA256RNDS2"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "<XMM0>"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SHA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMI"
    raw_encoding_specification: "NP 0F 38 CB /r"
    instruction_group_index: 19
  }
  instructions {
    description: "Zero bits in positions 128 and higher of some YMM and ZMM registers."
    vendor_syntax {
      mnemonic: "VZEROUPPER"
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "VEX.128.0F.WIG 77"
    instruction_group_index: 20
  }
  instructions {
    description: "Selectively multiply packed DP floating-point values from xmm1 with packed DP floatingpoint values from xmm2, add and selectively store the packed DP floating-point values to xmm1."
    vendor_syntax {
      mnemonic: "DPPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMI"
    raw_encoding_specification: "66 0F 3A 41 /r ib"
    instruction_group_index: 21
  }
  instructions {
    description: "Selectively multiply packed DP floating-point values from xmm2 with packed DP floatingpoint values from xmm3, add and selectively store the packed DP floating-point values to xmm1."
    vendor_syntax {
      mnemonic: "VDPPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVMI"
    raw_encoding_specification: "VEX.128.66.0F3A.WIG 41 /r ib"
    instruction_group_index: 21
  }
  instructions {
    description: "Reads an XCR specified by ECX into EDX:EAX."
    vendor_syntax {
      mnemonic: "XGETBV"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "NP 0F 01 D0"
    instruction_group_index: 22
  }
  instructions {
    description: "Compress packed double-precision floating-point values from xmm2 to xmm1/m128 using writemask k1."
    vendor_syntax {
      mnemonic: "VCOMPRESSPD"
      operands {
        name: "xmm1/m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 8A /r"
    instruction_group_index: 23
  }
  instructions {
    description: "Compress packed double-precision floating-point values from ymm2 to ymm1/m256 using writemask k1."
    vendor_syntax {
      mnemonic: "VCOMPRESSPD"
      operands {
        name: "ymm1/m256"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 8A /r"
    instruction_group_index: 23
  }
  instructions {
    description: "Compress packed double-precision floating-point values from zmm2 using control mask k1 to zmm1/m512."
    vendor_syntax {
      mnemonic: "VCOMPRESSPD"
      operands {
        name: "zmm1/m512"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 8A /r"
    instruction_group_index: 23
  }
  instructions {
    description: "Select packed single precision floating-point values from xmm1 and xmm2/m128 from mask specified in XMM0 and store the values into xmm1."
    vendor_syntax {
      mnemonic: "BLENDVPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "<XMM0>"
        encoding: IMPLICIT_ENCODING
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM0"
    raw_encoding_specification: "66 0F 38 14 /r"
    instruction_group_index: 24
  }
  instructions {
    description: "Conditionally copy single-precision floatingpoint values from xmm2 or xmm3/m128 to xmm1, based on mask bits in the specified mask operand, xmm4."
    vendor_syntax {
      mnemonic: "VBLENDVPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm4"
        encoding: VEX_SUFFIX_ENCODING
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVMR"
    raw_encoding_specification: "VEX.128.66.0F3A.W0 4A /r /is4"
    instruction_group_index: 24
  }
  instructions {
    description: "Conditionally copy single-precision floatingpoint values from ymm2 or ymm3/m256 to ymm1, based on mask bits in the specified mask register, ymm4."
    vendor_syntax {
      mnemonic: "VBLENDVPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm4"
        encoding: VEX_SUFFIX_ENCODING
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVMR"
    raw_encoding_specification: "VEX.256.66.0F3A.W0 4A /r /is4"
    instruction_group_index: 24
  }
  instructions {
    description: "Computes approximations to the Reciprocal square root (<2^-28 relative error) of the packed single-precision floating-point values from zmm2/m512/m32bcst and stores result in zmm1with writemask k1."
    vendor_syntax {
      mnemonic: "VRSQRT28PS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512ER"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 CC /r"
    instruction_group_index: 25
  }
  instructions {
    description: "Rounds scalar double-precision floating-point value in xmm3/m64 to a number of fraction bits specified by the imm8 field. Stores the result in xmm1 register."
    vendor_syntax {
      mnemonic: "VRNDSCALESD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.LIG.66.0F3A.W1 0B /r ib"
    instruction_group_index: 26
  }
  instructions {
    description: "Terminate indirect branch in 32 bit and compatibility mode."
    vendor_syntax {
      mnemonic: "ENDBR32"
    }
    feature_name: "CET_IBT"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F3 0F 1E FB"
    instruction_group_index: 28
  }
  instructions {
    description: "Shift right and merge vectors xmm2 and xmm3/m128/m32bcst with double-word granularity using imm8 as number of elements to shift, and store the final result in xmm1, under writemask."
    vendor_syntax {
      mnemonic: "VALIGND"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F3A.W0 03 /r ib"
    instruction_group_index: 29
  }
  instructions {
    description: "Shift right and merge vectors xmm2 and xmm3/m128/m64bcst with quad-word granularity using imm8 as number of elements to shift, and store the final result in xmm1, under writemask."
    vendor_syntax {
      mnemonic: "VALIGNQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F3A.W1 03 /r ib"
    instruction_group_index: 29
  }
  instructions {
    description: "Shift right and merge vectors ymm2 and ymm3/m256/m32bcst with double-word granularity using imm8 as number of elements to shift, and store the final result in ymm1, under writemask."
    vendor_syntax {
      mnemonic: "VALIGND"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F3A.W0 03 /r ib"
    instruction_group_index: 29
  }
  instructions {
    description: "Shift right and merge vectors ymm2 and ymm3/m256/m64bcst with quad-word granularity using imm8 as number of elements to shift, and store the final result in ymm1, under writemask."
    vendor_syntax {
      mnemonic: "VALIGNQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F3A.W1 03 /r ib"
    instruction_group_index: 29
  }
  instructions {
    description: "Shift right and merge vectors zmm2 and zmm3/m512/m32bcst with double-word granularity using imm8 as number of elements to shift, and store the final result in zmm1, under writemask."
    vendor_syntax {
      mnemonic: "VALIGND"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F3A.W0 03 /r ib"
    instruction_group_index: 29
  }
  instructions {
    description: "Shift right and merge vectors zmm2 and zmm3/m512/m64bcst with quad-word granularity using imm8 as number of elements to shift, and store the final result in zmm1, under writemask."
    vendor_syntax {
      mnemonic: "VALIGNQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F3A.W1 03 /r ib"
    instruction_group_index: 29
  }
  instructions {
    description: "Pop top of stack into m16; increment stack pointer."
    vendor_syntax {
      mnemonic: "POP"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "8F /0"
    instruction_group_index: 30
  }
  instructions {
    description: "Pop top of stack into m32; increment stack pointer."
    vendor_syntax {
      mnemonic: "POP"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "8F /0"
    instruction_group_index: 30
  }
  instructions {
    description: "Pop top of stack into m64; increment stack pointer. Cannot encode 32-bit operand size."
    vendor_syntax {
      mnemonic: "POP"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "8F /0"
    instruction_group_index: 30
  }
  instructions {
    description: "Pop top of stack into r16; increment stack pointer."
    vendor_syntax {
      mnemonic: "POP"
      operands {
        name: "r16"
        encoding: OPCODE_ENCODING
        usage: USAGE_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "O"
    raw_encoding_specification: "58+ rw"
    instruction_group_index: 30
  }
  instructions {
    description: "Pop top of stack into r32; increment stack pointer."
    vendor_syntax {
      mnemonic: "POP"
      operands {
        name: "r32"
        encoding: OPCODE_ENCODING
        usage: USAGE_WRITE
      }
    }
    legacy_instruction: true
    encoding_scheme: "O"
    raw_encoding_specification: "58+ rd"
    instruction_group_index: 30
  }
  instructions {
    description: "Pop top of stack into r64; increment stack pointer. Cannot encode 32-bit operand size."
    vendor_syntax {
      mnemonic: "POP"
      operands {
        name: "r64"
        encoding: OPCODE_ENCODING
        usage: USAGE_WRITE
      }
    }
    available_in_64_bit: true
    encoding_scheme: "O"
    raw_encoding_specification: "58+ rd"
    instruction_group_index: 30
  }
  instructions {
    description: "Pop top of stack into DS; increment stack pointer."
    vendor_syntax {
      mnemonic: "POP"
      operands {
        name: "DS"
      }
    }
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "1F"
    instruction_group_index: 30
  }
  instructions {
    description: "Pop top of stack into ES; increment stack pointer."
    vendor_syntax {
      mnemonic: "POP"
      operands {
        name: "ES"
      }
    }
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "07"
    instruction_group_index: 30
  }
  instructions {
    description: "Pop top of stack into SS; increment stack pointer."
    vendor_syntax {
      mnemonic: "POP"
      operands {
        name: "SS"
      }
    }
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "17"
    instruction_group_index: 30
  }
  instructions {
    description: "Pop top of stack into FS; increment stack pointer by 16 bits."
    vendor_syntax {
      mnemonic: "POP"
      operands {
        name: "FS"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "0F A1"
    instruction_group_index: 30
  }
  instructions {
    description: "Pop top of stack into FS; increment stack pointer by 32 bits."
    vendor_syntax {
      mnemonic: "POP"
      operands {
        name: "FS"
      }
    }
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "0F A1"
    instruction_group_index: 30
  }
  instructions {
    description: "Pop top of stack into FS; increment stack pointer by 64 bits."
    vendor_syntax {
      mnemonic: "POP"
      operands {
        name: "FS"
      }
    }
    available_in_64_bit: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "0F A1"
    instruction_group_index: 30
  }
  instructions {
    description: "Pop top of stack into GS; increment stack pointer by 16 bits."
    vendor_syntax {
      mnemonic: "POP"
      operands {
        name: "GS"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "0F A9"
    instruction_group_index: 30
  }
  instructions {
    description: "Pop top of stack into GS; increment stack pointer by 32 bits."
    vendor_syntax {
      mnemonic: "POP"
      operands {
        name: "GS"
      }
    }
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "0F A9"
    instruction_group_index: 30
  }
  instructions {
    description: "Pop top of stack into GS; increment stack pointer by 64 bits."
    vendor_syntax {
      mnemonic: "POP"
      operands {
        name: "GS"
      }
    }
    available_in_64_bit: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "0F A9"
    instruction_group_index: 30
  }
  instructions {
    description: "Multiply groups of 2 pairs signed words in xmm3/m128/m32bcst with corresponding signed words of xmm2, summing those products and adding them to doubleword result in xmm1, under writemask k1."
    vendor_syntax {
      mnemonic: "VPDPWSSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VNNI && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 52 /r"
    instruction_group_index: 31
  }
  instructions {
    description: "Multiply groups of 2 pairs signed words in ymm3/m256/m32bcst with corresponding signed words of ymm2, summing those products and adding them to doubleword result in ymm1, under writemask k1."
    vendor_syntax {
      mnemonic: "VPDPWSSD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VNNI && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 52 /r"
    instruction_group_index: 31
  }
  instructions {
    description: "Multiply groups of 2 pairs signed words in zmm3/m512/m32bcst with corresponding signed words of zmm2, summing those products and adding them to doubleword result in zmm1, under writemask k1."
    vendor_syntax {
      mnemonic: "VPDPWSSD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VNNI"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 52 /r"
    instruction_group_index: 31
  }
  instructions {
    description: "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding byte in XMM1."
    vendor_syntax {
      mnemonic: "VPMOVB2M"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "EVEX.128.F3.0F38.W0 29 /r"
    instruction_group_index: 32
  }
  instructions {
    description: "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding byte in YMM1."
    vendor_syntax {
      mnemonic: "VPMOVB2M"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "EVEX.256.F3.0F38.W0 29 /r"
    instruction_group_index: 32
  }
  instructions {
    description: "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding byte in ZMM1."
    vendor_syntax {
      mnemonic: "VPMOVB2M"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "EVEX.512.F3.0F38.W0 29 /r"
    instruction_group_index: 32
  }
  instructions {
    description: "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding word in XMM1."
    vendor_syntax {
      mnemonic: "VPMOVW2M"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "EVEX.128.F3.0F38.W1 29 /r"
    instruction_group_index: 32
  }
  instructions {
    description: "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding word in YMM1."
    vendor_syntax {
      mnemonic: "VPMOVW2M"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "EVEX.256.F3.0F38.W1 29 /r"
    instruction_group_index: 32
  }
  instructions {
    description: "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding word in ZMM1."
    vendor_syntax {
      mnemonic: "VPMOVW2M"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "EVEX.512.F3.0F38.W1 29 /r"
    instruction_group_index: 32
  }
  instructions {
    description: "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding doubleword in XMM1."
    vendor_syntax {
      mnemonic: "VPMOVD2M"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "EVEX.128.F3.0F38.W0 39 /r"
    instruction_group_index: 32
  }
  instructions {
    description: "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding doubleword in YMM1."
    vendor_syntax {
      mnemonic: "VPMOVD2M"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "EVEX.256.F3.0F38.W0 39 /r"
    instruction_group_index: 32
  }
  instructions {
    description: "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding doubleword in ZMM1."
    vendor_syntax {
      mnemonic: "VPMOVD2M"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "EVEX.512.F3.0F38.W0 39 /r"
    instruction_group_index: 32
  }
  instructions {
    description: "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding quadword in XMM1."
    vendor_syntax {
      mnemonic: "VPMOVQ2M"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "EVEX.128.F3.0F38.W1 39 /r"
    instruction_group_index: 32
  }
  instructions {
    description: "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding quadword in YMM1."
    vendor_syntax {
      mnemonic: "VPMOVQ2M"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "EVEX.256.F3.0F38.W1 39 /r"
    instruction_group_index: 32
  }
  instructions {
    description: "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding quadword in ZMM1."
    vendor_syntax {
      mnemonic: "VPMOVQ2M"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "EVEX.512.F3.0F38.W1 39 /r"
    instruction_group_index: 32
  }
  instructions {
    description: "Extract 128 bits of packed floating-point values from ymm2 and store results in xmm1/m128."
    vendor_syntax {
      mnemonic: "VEXTRACTF128"
      operands {
        name: "xmm1/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F3A.W0 19 /r ib"
    instruction_group_index: 33
  }
  instructions {
    description: "Extract 128 bits of packed single-precision floatingpoint values from ymm2 and store results in xmm1/m128 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VEXTRACTF32X4"
      operands {
        name: "xmm1/m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F3A.W0 19 /r ib"
    instruction_group_index: 33
  }
  instructions {
    description: "Extract 128 bits of packed single-precision floatingpoint values from zmm2 and store results in xmm1/m128 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VEXTRACTF32x4"
      operands {
        name: "xmm1/m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F3A.W0 19 /r ib"
    instruction_group_index: 33
  }
  instructions {
    description: "Extract 128 bits of packed double-precision floating-point values from ymm2 and store results in xmm1/m128 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VEXTRACTF64X2"
      operands {
        name: "xmm1/m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F3A.W1 19 /r ib"
    instruction_group_index: 33
  }
  instructions {
    description: "Extract 128 bits of packed double-precision floating-point values from zmm2 and store results in xmm1/m128 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VEXTRACTF64X2"
      operands {
        name: "xmm1/m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F3A.W1 19 /r ib"
    instruction_group_index: 33
  }
  instructions {
    description: "Extract 256 bits of packed single-precision floatingpoint values from zmm2 and store results in ymm1/m256 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VEXTRACTF32X8"
      operands {
        name: "ymm1/m256"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.66.0F3A.W0 1B /r ib"
    instruction_group_index: 33
  }
  instructions {
    description: "Extract 256 bits of packed double-precision floating-point values from zmm2 and store results in ymm1/m256 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VEXTRACTF64x4"
      operands {
        name: "ymm1/m256"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F3A.W1 1B /r ib"
    instruction_group_index: 33
  }
  instructions {
    description: "Compare packed unsigned dword integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1."
    vendor_syntax {
      mnemonic: "PMINUD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 38 3B /r"
    instruction_group_index: 34
  }
  instructions {
    description: "Compare packed unsigned dword integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1."
    vendor_syntax {
      mnemonic: "VPMINUD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F38.WIG 3B /r"
    instruction_group_index: 34
  }
  instructions {
    description: "Compare packed unsigned dword integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1."
    vendor_syntax {
      mnemonic: "VPMINUD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F38.WIG 3B /r"
    instruction_group_index: 34
  }
  instructions {
    description: "Compare packed unsigned dword integers in xmm2 and xmm3/m128/m32bcst and store packed minimum values in xmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMINUD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 3B /r"
    instruction_group_index: 34
  }
  instructions {
    description: "Compare packed unsigned dword integers in ymm2 and ymm3/m256/m32bcst and store packed minimum values in ymm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMINUD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 3B /r"
    instruction_group_index: 34
  }
  instructions {
    description: "Compare packed unsigned dword integers in zmm2 and zmm3/m512/m32bcst and store packed minimum values in zmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMINUD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 3B /r"
    instruction_group_index: 34
  }
  instructions {
    description: "Compare packed unsigned qword integers in xmm2 and xmm3/m128/m64bcst and store packed minimum values in xmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMINUQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 3B /r"
    instruction_group_index: 34
  }
  instructions {
    description: "Compare packed unsigned qword integers in ymm2 and ymm3/m256/m64bcst and store packed minimum values in ymm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMINUQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 3B /r"
    instruction_group_index: 34
  }
  instructions {
    description: "Compare packed unsigned qword integers in zmm2 and zmm3/m512/m64bcst and store packed minimum values in zmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMINUQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 3B /r"
    instruction_group_index: 34
  }
  instructions {
    description: "Bitwise AND 16 bits masks k2 and k3 and place result in k1."
    vendor_syntax {
      mnemonic: "KANDW"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "k3"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVR"
    raw_encoding_specification: "VEX.L1.0F.W0 41 /r"
    instruction_group_index: 35
  }
  instructions {
    description: "Bitwise AND 8 bits masks k2 and k3 and place result in k1."
    vendor_syntax {
      mnemonic: "KANDB"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "k3"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVR"
    raw_encoding_specification: "VEX.NDS.L1.66.0F.W0 41 /r"
    instruction_group_index: 35
  }
  instructions {
    description: "Bitwise AND 64 bits masks k2 and k3 and place result in k1."
    vendor_syntax {
      mnemonic: "KANDQ"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "k3"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVR"
    raw_encoding_specification: "VEX.NDS.L1.0F.W1 41 /r"
    instruction_group_index: 35
  }
  instructions {
    description: "Bitwise AND 32 bits masks k2 and k3 and place result in k1."
    vendor_syntax {
      mnemonic: "KANDD"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "k3"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVR"
    raw_encoding_specification: "VEX.NDS.L1.66.0F.W1 41 /r"
    instruction_group_index: 35
  }
  instructions {
    description: "Complement CF flag."
    vendor_syntax {
      mnemonic: "CMC"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F5"
    instruction_group_index: 36
  }
  instructions {
    description: "Read a 16-bit random number and store in the destination register."
    vendor_syntax {
      mnemonic: "RDRAND"
      operands {
        name: "r16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    feature_name: "RDRAND"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "NFx 0F C7 /6"
    instruction_group_index: 37
  }
  instructions {
    description: "Read a 32-bit random number and store in the destination register."
    vendor_syntax {
      mnemonic: "RDRAND"
      operands {
        name: "r32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    feature_name: "RDRAND"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "NFx 0F C7 /6"
    instruction_group_index: 37
  }
  instructions {
    description: "Read a 64-bit random number and store in the destination register."
    vendor_syntax {
      mnemonic: "RDRAND"
      operands {
        name: "r64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    feature_name: "RDRAND"
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "NFx REX.W + 0F C7 /6"
    instruction_group_index: 37
  }
  instructions {
    description: "Compare packed signed byte values in xmm3/m128 and xmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
    vendor_syntax {
      mnemonic: "VPCMPB"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F3A.W0 3F /r ib"
    instruction_group_index: 38
  }
  instructions {
    description: "Compare packed signed byte values in ymm3/m256 and ymm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
    vendor_syntax {
      mnemonic: "VPCMPB"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F3A.W0 3F /r ib"
    instruction_group_index: 38
  }
  instructions {
    description: "Compare packed signed byte values in zmm3/m512 and zmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
    vendor_syntax {
      mnemonic: "VPCMPB"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F3A.W0 3F /r ib"
    instruction_group_index: 38
  }
  instructions {
    description: "Compare packed unsigned byte values in xmm3/m128 and xmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
    vendor_syntax {
      mnemonic: "VPCMPUB"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F3A.W0 3E /r ib"
    instruction_group_index: 38
  }
  instructions {
    description: "Compare packed unsigned byte values in ymm3/m256 and ymm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
    vendor_syntax {
      mnemonic: "VPCMPUB"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F3A.W0 3E /r ib"
    instruction_group_index: 38
  }
  instructions {
    description: "Compare packed unsigned byte values in zmm3/m512 and zmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
    vendor_syntax {
      mnemonic: "VPCMPUB"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F3A.W0 3E /r ib"
    instruction_group_index: 38
  }
  instructions {
    description: "Sets each byte in XMM1 to all 1\342\200\231s or all 0\342\200\231s based on the value of the corresponding bit in k1."
    vendor_syntax {
      mnemonic: "VPMOVM2B"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "EVEX.128.F3.0F38.W0 28 /r"
    instruction_group_index: 39
  }
  instructions {
    description: "Sets each byte in YMM1 to all 1\342\200\231s or all 0\342\200\231s based on the value of the corresponding bit in k1."
    vendor_syntax {
      mnemonic: "VPMOVM2B"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "EVEX.256.F3.0F38.W0 28 /r"
    instruction_group_index: 39
  }
  instructions {
    description: "Sets each byte in ZMM1 to all 1\342\200\231s or all 0\342\200\231s based on the value of the corresponding bit in k1."
    vendor_syntax {
      mnemonic: "VPMOVM2B"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "EVEX.512.F3.0F38.W0 28 /r"
    instruction_group_index: 39
  }
  instructions {
    description: "Sets each word in XMM1 to all 1\342\200\231s or all 0\342\200\231s based on the value of the corresponding bit in k1."
    vendor_syntax {
      mnemonic: "VPMOVM2W"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "EVEX.128.F3.0F38.W1 28 /r"
    instruction_group_index: 39
  }
  instructions {
    description: "Sets each word in YMM1 to all 1\342\200\231s or all 0\342\200\231s based on the value of the corresponding bit in k1."
    vendor_syntax {
      mnemonic: "VPMOVM2W"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "EVEX.256.F3.0F38.W1 28 /r"
    instruction_group_index: 39
  }
  instructions {
    description: "Sets each word in ZMM1 to all 1\342\200\231s or all 0\342\200\231s based on the value of the corresponding bit in k1."
    vendor_syntax {
      mnemonic: "VPMOVM2W"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "EVEX.512.F3.0F38.W1 28 /r"
    instruction_group_index: 39
  }
  instructions {
    description: "Sets each doubleword in XMM1 to all 1\342\200\231s or all 0\342\200\231s based on the value of the corresponding bit in k1."
    vendor_syntax {
      mnemonic: "VPMOVM2D"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "EVEX.128.F3.0F38.W0 38 /r"
    instruction_group_index: 39
  }
  instructions {
    description: "Sets each doubleword in YMM1 to all 1\342\200\231s or all 0\342\200\231s based on the value of the corresponding bit in k1."
    vendor_syntax {
      mnemonic: "VPMOVM2D"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "EVEX.256.F3.0F38.W0 38 /r"
    instruction_group_index: 39
  }
  instructions {
    description: "Sets each doubleword in ZMM1 to all 1\342\200\231s or all 0\342\200\231s based on the value of the corresponding bit in k1."
    vendor_syntax {
      mnemonic: "VPMOVM2D"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "EVEX.512.F3.0F38.W0 38 /r"
    instruction_group_index: 39
  }
  instructions {
    description: "Sets each quadword in XMM1 to all 1\342\200\231s or all 0\342\200\231s based on the value of the corresponding bit in k1."
    vendor_syntax {
      mnemonic: "VPMOVM2Q"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "EVEX.128.F3.0F38.W1 38 /r"
    instruction_group_index: 39
  }
  instructions {
    description: "Sets each quadword in YMM1 to all 1\342\200\231s or all 0\342\200\231s based on the value of the corresponding bit in k1."
    vendor_syntax {
      mnemonic: "VPMOVM2Q"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "EVEX.256.F3.0F38.W1 38 /r"
    instruction_group_index: 39
  }
  instructions {
    description: "Sets each quadword in ZMM1 to all 1\342\200\231s or all 0\342\200\231s based on the value of the corresponding bit in k1."
    vendor_syntax {
      mnemonic: "VPMOVM2Q"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "EVEX.512.F3.0F38.W1 38 /r"
    instruction_group_index: 39
  }
  instructions {
    description: "Invoke VMfunction specified in EAX."
    vendor_syntax {
      mnemonic: "VMFUNC"
    }
    feature_name: "VMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "NP 0F 01 D4"
    instruction_group_index: 40
  }
  instructions {
    description: "Convert two packed signed doubleword integers from mm/mem64 to two packed double-precision floating-point values in xmm."
    vendor_syntax {
      mnemonic: "CVTPI2PD"
      operands {
        name: "xmm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "66 0F 2A /r"
    instruction_group_index: 41
  }
  instructions {
    description: "AL AND imm8."
    vendor_syntax {
      mnemonic: "AND"
      operands {
        name: "AL"
        encoding: IMPLICIT_ENCODING
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "I"
    raw_encoding_specification: "24 ib"
    instruction_group_index: 42
  }
  instructions {
    description: "AX AND imm16."
    vendor_syntax {
      mnemonic: "AND"
      operands {
        name: "AX"
        encoding: IMPLICIT_ENCODING
      }
      operands {
        name: "imm16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "I"
    raw_encoding_specification: "25 iw"
    instruction_group_index: 42
  }
  instructions {
    description: "EAX AND imm32."
    vendor_syntax {
      mnemonic: "AND"
      operands {
        name: "EAX"
        encoding: IMPLICIT_ENCODING
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "I"
    raw_encoding_specification: "25 id"
    instruction_group_index: 42
  }
  instructions {
    description: "RAX AND imm32 sign-extended to 64-bits."
    vendor_syntax {
      mnemonic: "AND"
      operands {
        name: "RAX"
        encoding: IMPLICIT_ENCODING
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "I"
    raw_encoding_specification: "REX.W + 25 id"
    instruction_group_index: 42
  }
  instructions {
    description: "r/m8 AND imm8."
    vendor_syntax {
      mnemonic: "AND"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "80 /4 ib"
    instruction_group_index: 42
  }
  instructions {
    description: "r/m8 AND imm8."
    vendor_syntax {
      mnemonic: "AND"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX + 80 /4 ib"
    instruction_group_index: 42
  }
  instructions {
    description: "r/m16 AND imm16."
    vendor_syntax {
      mnemonic: "AND"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "81 /4 iw"
    instruction_group_index: 42
  }
  instructions {
    description: "r/m32 AND imm32."
    vendor_syntax {
      mnemonic: "AND"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "81 /4 id"
    instruction_group_index: 42
  }
  instructions {
    description: "r/m64 AND imm32 sign extended to 64-bits."
    vendor_syntax {
      mnemonic: "AND"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX.W + 81 /4 id"
    instruction_group_index: 42
  }
  instructions {
    description: "r/m16 AND imm8 (sign-extended)."
    vendor_syntax {
      mnemonic: "AND"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "83 /4 ib"
    instruction_group_index: 42
  }
  instructions {
    description: "r/m32 AND imm8 (sign-extended)."
    vendor_syntax {
      mnemonic: "AND"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "83 /4 ib"
    instruction_group_index: 42
  }
  instructions {
    description: "r/m64 AND imm8 (sign-extended)."
    vendor_syntax {
      mnemonic: "AND"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX.W + 83 /4 ib"
    instruction_group_index: 42
  }
  instructions {
    description: "r/m8 AND r8."
    vendor_syntax {
      mnemonic: "AND"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "20 /r"
    instruction_group_index: 42
  }
  instructions {
    description: "r/m64 AND r8 (sign-extended)."
    vendor_syntax {
      mnemonic: "AND"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MR"
    raw_encoding_specification: "REX + 20 /r"
    instruction_group_index: 42
  }
  instructions {
    description: "r/m16 AND r16."
    vendor_syntax {
      mnemonic: "AND"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "21 /r"
    instruction_group_index: 42
  }
  instructions {
    description: "r/m32 AND r32."
    vendor_syntax {
      mnemonic: "AND"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "21 /r"
    instruction_group_index: 42
  }
  instructions {
    description: "r/m64 AND r32."
    vendor_syntax {
      mnemonic: "AND"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MR"
    raw_encoding_specification: "REX.W + 21 /r"
    instruction_group_index: 42
  }
  instructions {
    description: "r8 AND r/m8."
    vendor_syntax {
      mnemonic: "AND"
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "22 /r"
    instruction_group_index: 42
  }
  instructions {
    description: "r/m64 AND r8 (sign-extended)."
    vendor_syntax {
      mnemonic: "AND"
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX + 22 /r"
    instruction_group_index: 42
  }
  instructions {
    description: "r16 AND r/m16."
    vendor_syntax {
      mnemonic: "AND"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "23 /r"
    instruction_group_index: 42
  }
  instructions {
    description: "r32 AND r/m32."
    vendor_syntax {
      mnemonic: "AND"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "23 /r"
    instruction_group_index: 42
  }
  instructions {
    description: "r64 AND r/m64."
    vendor_syntax {
      mnemonic: "AND"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 23 /r"
    instruction_group_index: 42
  }
  instructions {
    description: "Input byte from imm8 I/O port address into AL."
    vendor_syntax {
      mnemonic: "IN"
      operands {
        name: "AL"
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "I"
    raw_encoding_specification: "E4 ib"
    instruction_group_index: 43
  }
  instructions {
    description: "Input word from imm8 I/O port address into AX."
    vendor_syntax {
      mnemonic: "IN"
      operands {
        name: "AX"
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "I"
    raw_encoding_specification: "E5 ib"
    instruction_group_index: 43
  }
  instructions {
    description: "Input dword from imm8 I/O port address into EAX."
    vendor_syntax {
      mnemonic: "IN"
      operands {
        name: "EAX"
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "I"
    raw_encoding_specification: "E5 ib"
    instruction_group_index: 43
  }
  instructions {
    description: "Input byte from I/O port in DX into AL."
    vendor_syntax {
      mnemonic: "IN"
      operands {
        name: "AL"
      }
      operands {
        name: "DX"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "EC"
    instruction_group_index: 43
  }
  instructions {
    description: "Input word from I/O port in DX into AX."
    vendor_syntax {
      mnemonic: "IN"
      operands {
        name: "AX"
      }
      operands {
        name: "DX"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "ED"
    instruction_group_index: 43
  }
  instructions {
    description: "Input doubleword from I/O port in DX into EAX."
    vendor_syntax {
      mnemonic: "IN"
      operands {
        name: "EAX"
      }
      operands {
        name: "DX"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "ED"
    instruction_group_index: 43
  }
  instructions {
    description: "Compare packed qwords in xmm2/m128 and xmm1 for equality."
    vendor_syntax {
      mnemonic: "PCMPEQQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 38 29 /r"
    instruction_group_index: 44
  }
  instructions {
    description: "Compare packed quadwords in xmm3/m128 and xmm2 for equality."
    vendor_syntax {
      mnemonic: "VPCMPEQQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F38.WIG 29 /r"
    instruction_group_index: 44
  }
  instructions {
    description: "Compare packed quadwords in ymm3/m256 and ymm2 for equality."
    vendor_syntax {
      mnemonic: "VPCMPEQQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F38.WIG 29 /r"
    instruction_group_index: 44
  }
  instructions {
    description: "Compare Equal between int64 vector xmm2 and int64 vector xmm3/m128/m64bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
    vendor_syntax {
      mnemonic: "VPCMPEQQ"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 29 /r"
    instruction_group_index: 44
  }
  instructions {
    description: "Compare Equal between int64 vector ymm2 and int64 vector ymm3/m256/m64bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
    vendor_syntax {
      mnemonic: "VPCMPEQQ"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 29 /r"
    instruction_group_index: 44
  }
  instructions {
    description: "Compare Equal between int64 vector zmm2 and int64 vector zmm3/m512/m64bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
    vendor_syntax {
      mnemonic: "VPCMPEQQ"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 29 /r"
    instruction_group_index: 44
  }
  instructions {
    description: "Multiply the packed dword signed integers in xmm1 and xmm2/m128 and store the low 32 bits of each product in xmm1."
    vendor_syntax {
      mnemonic: "PMULLD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 38 40 /r"
    instruction_group_index: 46
  }
  instructions {
    description: "Multiply the packed dword signed integers in xmm2 and xmm3/m128 and store the low 32 bits of each product in xmm1."
    vendor_syntax {
      mnemonic: "VPMULLD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F38.WIG 40 /r"
    instruction_group_index: 46
  }
  instructions {
    description: "Multiply the packed dword signed integers in ymm2 and ymm3/m256 and store the low 32 bits of each product in ymm1."
    vendor_syntax {
      mnemonic: "VPMULLD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F38.WIG 40 /r"
    instruction_group_index: 46
  }
  instructions {
    description: "Multiply the packed dword signed integers in xmm2 and xmm3/m128/m32bcst and store the low 32 bits of each product in xmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMULLD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 40 /r"
    instruction_group_index: 46
  }
  instructions {
    description: "Multiply the packed dword signed integers in ymm2 and ymm3/m256/m32bcst and store the low 32 bits of each product in ymm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMULLD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 40 /r"
    instruction_group_index: 46
  }
  instructions {
    description: "Multiply the packed dword signed integers in zmm2 and zmm3/m512/m32bcst and store the low 32 bits of each product in zmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMULLD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 40 /r"
    instruction_group_index: 46
  }
  instructions {
    description: "Multiply the packed qword signed integers in xmm2 and xmm3/m128/m64bcst and store the low 64 bits of each product in xmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMULLQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 40 /r"
    instruction_group_index: 46
  }
  instructions {
    description: "Multiply the packed qword signed integers in ymm2 and ymm3/m256/m64bcst and store the low 64 bits of each product in ymm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMULLQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 40 /r"
    instruction_group_index: 46
  }
  instructions {
    description: "Multiply the packed qword signed integers in zmm2 and zmm3/m512/m64bcst and store the low 64 bits of each product in zmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMULLQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 40 /r"
    instruction_group_index: 46
  }
  instructions {
    description: "Select unaligned bytes from qwords in xmm3/m128/m64bcst using control bytes in xmm2, write byte results to xmm1 under k1."
    vendor_syntax {
      mnemonic: "VPMULTISHIFTQB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 83 /r"
    instruction_group_index: 47
  }
  instructions {
    description: "Select unaligned bytes from qwords in ymm3/m256/m64bcst using control bytes in ymm2, write byte results to ymm1 under k1."
    vendor_syntax {
      mnemonic: "VPMULTISHIFTQB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 83 /r"
    instruction_group_index: 47
  }
  instructions {
    description: "Select unaligned bytes from qwords in zmm3/m512/m64bcst using control bytes in zmm2, write byte results to zmm1 under k1."
    vendor_syntax {
      mnemonic: "VPMULTISHIFTQB"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 83 /r"
    instruction_group_index: 47
  }
  instructions {
    description: "Multiply ST(0) by m32fp and store result in ST(0)."
    vendor_syntax {
      mnemonic: "FMUL"
      operands {
        name: "m32fp"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D8 /1"
    instruction_group_index: 49
  }
  instructions {
    description: "Multiply ST(0) by m64fp and store result in ST(0)."
    vendor_syntax {
      mnemonic: "FMUL"
      operands {
        name: "m64fp"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DC /1"
    instruction_group_index: 49
  }
  instructions {
    description: "Multiply ST(0) by ST(i) and store result in ST(0)."
    vendor_syntax {
      mnemonic: "FMUL"
      operands {
        name: "ST(0)"
      }
      operands {
        name: "ST(i)"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D8 C8+i"
    instruction_group_index: 49
  }
  instructions {
    description: "Multiply ST(i) by ST(0) and store result in ST(i)."
    vendor_syntax {
      mnemonic: "FMUL"
      operands {
        name: "ST(i)"
      }
      operands {
        name: "ST(0)"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DC C8+i"
    instruction_group_index: 49
  }
  instructions {
    description: "Multiply ST(i) by ST(0), store result in ST(i), and pop the register stack."
    vendor_syntax {
      mnemonic: "FMULP"
      operands {
        name: "ST(i)"
      }
      operands {
        name: "ST(0)"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DE C8+i"
    instruction_group_index: 49
  }
  instructions {
    description: "Multiply ST(1) by ST(0), store result in ST(1), and pop the register stack."
    vendor_syntax {
      mnemonic: "FMULP"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DE C9"
    instruction_group_index: 49
  }
  instructions {
    description: "Multiply ST(0) by m32int and store result in ST(0)."
    vendor_syntax {
      mnemonic: "FIMUL"
      operands {
        name: "m32int"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DA /1"
    instruction_group_index: 49
  }
  instructions {
    description: "Multiply ST(0) by m16int and store result in ST(0)."
    vendor_syntax {
      mnemonic: "FIMUL"
      operands {
        name: "m16int"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DE /1"
    instruction_group_index: 49
  }
  instructions {
    description: "Round the low packed double precision floating-point value in xmm2/m64 and place the result in xmm1. The rounding mode is determined by imm8."
    vendor_syntax {
      mnemonic: "ROUNDSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMI"
    raw_encoding_specification: "66 0F 3A 0B /r ib"
    instruction_group_index: 50
  }
  instructions {
    description: "Round the low packed double precision floating-point value in xmm3/m64 and place the result in xmm1. The rounding mode is determined by imm8. Upper packed double precision floating-point value (bits[127:64]) from xmm2 is copied to xmm1[127:64]."
    vendor_syntax {
      mnemonic: "VROUNDSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVMI"
    raw_encoding_specification: "VEX.LIG.66.0F3A.WIG 0B /r ib"
    instruction_group_index: 50
  }
  instructions {
    description: "Compute packed SAD word results of unsigned bytes in dword block from xmm2 with unsigned bytes of dword blocks transformed from xmm3/m128 using the shuffle controls in imm8. Results are written to xmm1 under the writemask k1."
    vendor_syntax {
      mnemonic: "VDBPSADBW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F3A.W0 42 /r ib"
    instruction_group_index: 51
  }
  instructions {
    description: "Compute packed SAD word results of unsigned bytes in dword block from ymm2 with unsigned bytes of dword blocks transformed from ymm3/m256 using the shuffle controls in imm8. Results are written to ymm1 under the writemask k1."
    vendor_syntax {
      mnemonic: "VDBPSADBW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F3A.W0 42 /r ib"
    instruction_group_index: 51
  }
  instructions {
    description: "Compute packed SAD word results of unsigned bytes in dword block from zmm2 with unsigned bytes of dword blocks transformed from zmm3/m512 using the shuffle controls in imm8. Results are written to zmm1 under the writemask k1."
    vendor_syntax {
      mnemonic: "VDBPSADBW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F3A.W0 42 /r ib"
    instruction_group_index: 51
  }
  instructions {
    description: "Divide m32fp by ST(0) and store result in ST(0)."
    vendor_syntax {
      mnemonic: "FDIVR"
      operands {
        name: "m32fp"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D8 /7"
    instruction_group_index: 53
  }
  instructions {
    description: "Divide m64fp by ST(0) and store result in ST(0)."
    vendor_syntax {
      mnemonic: "FDIVR"
      operands {
        name: "m64fp"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DC /7"
    instruction_group_index: 53
  }
  instructions {
    description: "Divide ST(i) by ST(0) and store result in ST(0)."
    vendor_syntax {
      mnemonic: "FDIVR"
      operands {
        name: "ST(0)"
      }
      operands {
        name: "ST(i)"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D8 F8+i"
    instruction_group_index: 53
  }
  instructions {
    description: "Divide ST(0) by ST(i) and store result in ST(i)."
    vendor_syntax {
      mnemonic: "FDIVR"
      operands {
        name: "ST(i)"
      }
      operands {
        name: "ST(0)"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DC F0+i"
    instruction_group_index: 53
  }
  instructions {
    description: "Divide ST(0) by ST(i), store result in ST(i), and pop the register stack."
    vendor_syntax {
      mnemonic: "FDIVRP"
      operands {
        name: "ST(i)"
      }
      operands {
        name: "ST(0)"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DE F0+i"
    instruction_group_index: 53
  }
  instructions {
    description: "Divide ST(0) by ST(1), store result in ST(1), and pop the register stack."
    vendor_syntax {
      mnemonic: "FDIVRP"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DE F1"
    instruction_group_index: 53
  }
  instructions {
    description: "Divide m32int by ST(0) and store result in ST(0)."
    vendor_syntax {
      mnemonic: "FIDIVR"
      operands {
        name: "m32int"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DA /7"
    instruction_group_index: 53
  }
  instructions {
    description: "Divide m16int by ST(0) and store result in ST(0)."
    vendor_syntax {
      mnemonic: "FIDIVR"
      operands {
        name: "m16int"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DE /7"
    instruction_group_index: 53
  }
  instructions {
    description: "Computes approximations to the exponential 2^x (with less than 2^-23 of maximum relative error) of the packed doubleprecision floating-point values from zmm2/m512/m64bcst and stores the floating-point result in zmm1with writemask k1."
    vendor_syntax {
      mnemonic: "VEXP2PD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512ER"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 C8 /r"
    instruction_group_index: 54
  }
  instructions {
    description: "Bitwise AND NOT 16 bits masks k2 and k3 and place result in k1."
    vendor_syntax {
      mnemonic: "KANDNW"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "k3"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVR"
    raw_encoding_specification: "VEX.L1.0F.W0 42 /r"
    instruction_group_index: 55
  }
  instructions {
    description: "Bitwise AND NOT 8 bits masks k1 and k2 and place result in k1."
    vendor_syntax {
      mnemonic: "KANDNB"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "k3"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVR"
    raw_encoding_specification: "VEX.NDS.L1.66.0F.W0 42 /r"
    instruction_group_index: 55
  }
  instructions {
    description: "Bitwise AND NOT 64 bits masks k2 and k3 and place result in k1."
    vendor_syntax {
      mnemonic: "KANDNQ"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "k3"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVR"
    raw_encoding_specification: "VEX.NDS.L1.0F.W1 42 /r"
    instruction_group_index: 55
  }
  instructions {
    description: "Bitwise AND NOT 32 bits masks k2 and k3 and place result in k1."
    vendor_syntax {
      mnemonic: "KANDND"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "k3"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVR"
    raw_encoding_specification: "VEX.NDS.L1.66.0F.W1 42 /r"
    instruction_group_index: 55
  }
  instructions {
    description: "Add with carry imm8 to AL."
    vendor_syntax {
      mnemonic: "ADC"
      operands {
        name: "AL"
        encoding: IMPLICIT_ENCODING
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "I"
    raw_encoding_specification: "14 ib"
    instruction_group_index: 56
  }
  instructions {
    description: "Add with carry imm16 to AX."
    vendor_syntax {
      mnemonic: "ADC"
      operands {
        name: "AX"
        encoding: IMPLICIT_ENCODING
      }
      operands {
        name: "imm16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "I"
    raw_encoding_specification: "15 iw"
    instruction_group_index: 56
  }
  instructions {
    description: "Add with carry imm32 to EAX."
    vendor_syntax {
      mnemonic: "ADC"
      operands {
        name: "EAX"
        encoding: IMPLICIT_ENCODING
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "I"
    raw_encoding_specification: "15 id"
    instruction_group_index: 56
  }
  instructions {
    description: "Add with carry imm32 sign extended to 64- bits to RAX."
    vendor_syntax {
      mnemonic: "ADC"
      operands {
        name: "RAX"
        encoding: IMPLICIT_ENCODING
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "I"
    raw_encoding_specification: "REX.W + 15 id"
    instruction_group_index: 56
  }
  instructions {
    description: "Add with carry imm8 to r/m8."
    vendor_syntax {
      mnemonic: "ADC"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "80 /2 ib"
    instruction_group_index: 56
  }
  instructions {
    description: "Add with carry imm8 to r/m8."
    vendor_syntax {
      mnemonic: "ADC"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX + 80 /2 ib"
    instruction_group_index: 56
  }
  instructions {
    description: "Add with carry imm16 to r/m16."
    vendor_syntax {
      mnemonic: "ADC"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "81 /2 iw"
    instruction_group_index: 56
  }
  instructions {
    description: "Add with CF imm32 to r/m32."
    vendor_syntax {
      mnemonic: "ADC"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "81 /2 id"
    instruction_group_index: 56
  }
  instructions {
    description: "Add with CF imm32 sign extended to 64-bits to r/m64."
    vendor_syntax {
      mnemonic: "ADC"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX.W + 81 /2 id"
    instruction_group_index: 56
  }
  instructions {
    description: "Add with CF sign-extended imm8 to r/m16."
    vendor_syntax {
      mnemonic: "ADC"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "83 /2 ib"
    instruction_group_index: 56
  }
  instructions {
    description: "Add with CF sign-extended imm8 into r/m32."
    vendor_syntax {
      mnemonic: "ADC"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "83 /2 ib"
    instruction_group_index: 56
  }
  instructions {
    description: "Add with CF sign-extended imm8 into r/m64."
    vendor_syntax {
      mnemonic: "ADC"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX.W + 83 /2 ib"
    instruction_group_index: 56
  }
  instructions {
    description: "Add with carry byte register to r/m8."
    vendor_syntax {
      mnemonic: "ADC"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "10 /r"
    instruction_group_index: 56
  }
  instructions {
    description: "Add with carry byte register to r/m64."
    vendor_syntax {
      mnemonic: "ADC"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MR"
    raw_encoding_specification: "REX + 10 /r"
    instruction_group_index: 56
  }
  instructions {
    description: "Add with carry r16 to r/m16."
    vendor_syntax {
      mnemonic: "ADC"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "11 /r"
    instruction_group_index: 56
  }
  instructions {
    description: "Add with CF r32 to r/m32."
    vendor_syntax {
      mnemonic: "ADC"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "11 /r"
    instruction_group_index: 56
  }
  instructions {
    description: "Add with CF r64 to r/m64."
    vendor_syntax {
      mnemonic: "ADC"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MR"
    raw_encoding_specification: "REX.W + 11 /r"
    instruction_group_index: 56
  }
  instructions {
    description: "Add with carry r/m8 to byte register."
    vendor_syntax {
      mnemonic: "ADC"
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "12 /r"
    instruction_group_index: 56
  }
  instructions {
    description: "Add with carry r/m64 to byte register."
    vendor_syntax {
      mnemonic: "ADC"
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX + 12 /r"
    instruction_group_index: 56
  }
  instructions {
    description: "Add with carry r/m16 to r16."
    vendor_syntax {
      mnemonic: "ADC"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "13 /r"
    instruction_group_index: 56
  }
  instructions {
    description: "Add with CF r/m32 to r32."
    vendor_syntax {
      mnemonic: "ADC"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "13 /r"
    instruction_group_index: 56
  }
  instructions {
    description: "Add with CF r/m64 to r64."
    vendor_syntax {
      mnemonic: "ADC"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 13 /r"
    instruction_group_index: 56
  }
  instructions {
    description: "Convert four packed single-precision floating-point values in xmm2 to packed half-precision (16-bit) floating-point values in xmm1/m64. Imm8 provides rounding controls."
    vendor_syntax {
      mnemonic: "VCVTPS2PH"
      operands {
        name: "xmm1/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "F16C"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F3A.W0 1D /r ib"
    instruction_group_index: 57
  }
  instructions {
    description: "Convert eight packed single-precision floating-point values in ymm2 to packed half-precision (16-bit) floating-point values in xmm1/m128. Imm8 provides rounding controls."
    vendor_syntax {
      mnemonic: "VCVTPS2PH"
      operands {
        name: "xmm1/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "F16C"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F3A.W0 1D /r ib"
    instruction_group_index: 57
  }
  instructions {
    description: "Convert four packed single-precision floating-point values in xmm2 to packed half-precision (16-bit) floating-point values in xmm1/m64. Imm8 provides rounding controls."
    vendor_syntax {
      mnemonic: "VCVTPS2PH"
      operands {
        name: "xmm1/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F3A.W0 1D /r ib"
    instruction_group_index: 57
  }
  instructions {
    description: "Convert eight packed single-precision floating-point values in ymm2 to packed half-precision (16-bit) floating-point values in xmm1/m128. Imm8 provides rounding controls."
    vendor_syntax {
      mnemonic: "VCVTPS2PH"
      operands {
        name: "xmm1/m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F3A.W0 1D /r ib"
    instruction_group_index: 57
  }
  instructions {
    description: "Convert sixteen packed single-precision floating-point values in zmm2 to packed half-precision (16-bit) floatingpoint values in ymm1/m256. Imm8 provides rounding controls."
    vendor_syntax {
      mnemonic: "VCVTPS2PH"
      operands {
        name: "ymm1/m256"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F3A.W0 1D /r ib"
    instruction_group_index: 57
  }
  instructions {
    description: "Generate a #BR if the address in r/m32 is higher than the upper bound in bnd.UB (bnb.UB in 1\'s complement form)."
    vendor_syntax {
      mnemonic: "BNDCU"
      operands {
        name: "bnd"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MPX"
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "F2 0F 1A /r"
    instruction_group_index: 58
  }
  instructions {
    description: "Generate a #BR if the address in r/m64 is higher than the upper bound in bnd.UB (bnb.UB in 1\'s complement form)."
    vendor_syntax {
      mnemonic: "BNDCU"
      operands {
        name: "bnd"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MPX"
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "F2 0F 1A /r"
    instruction_group_index: 58
  }
  instructions {
    description: "Generate a #BR if the address in r/m32 is higher than the upper bound in bnd.UB (bnb.UB not in 1\'s complement form)."
    vendor_syntax {
      mnemonic: "BNDCN"
      operands {
        name: "bnd"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MPX"
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "F2 0F 1B /r"
    instruction_group_index: 58
  }
  instructions {
    description: "Generate a #BR if the address in r/m64 is higher than the upper bound in bnd.UB (bnb.UB not in 1\'s complement form)."
    vendor_syntax {
      mnemonic: "BNDCN"
      operands {
        name: "bnd"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MPX"
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "F2 0F 1B /r"
    instruction_group_index: 58
  }
  instructions {
    description: "Two\'s complement negate r/m8."
    vendor_syntax {
      mnemonic: "NEG"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "F6 /3"
    instruction_group_index: 59
  }
  instructions {
    description: "Two\'s complement negate r/m8."
    vendor_syntax {
      mnemonic: "NEG"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX + F6 /3"
    instruction_group_index: 59
  }
  instructions {
    description: "Two\'s complement negate r/m16."
    vendor_syntax {
      mnemonic: "NEG"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "F7 /3"
    instruction_group_index: 59
  }
  instructions {
    description: "Two\'s complement negate r/m32."
    vendor_syntax {
      mnemonic: "NEG"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "F7 /3"
    instruction_group_index: 59
  }
  instructions {
    description: "Two\'s complement negate r/m64."
    vendor_syntax {
      mnemonic: "NEG"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX.W + F7 /3"
    instruction_group_index: 59
  }
  instructions {
    description: "Move 64-bytes as direct-store with guaranteed 64- byte write atomicity from the source memory operand address to destination memory address specified as offset to ES segment in the register operand."
    vendor_syntax {
      mnemonic: "MOVDIR64B"
      operands {
        name: "r16/r32/r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MOVDIR64B"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 38 F8 /r"
    instruction_group_index: 60
  }
  instructions {
    description: "Zero some of the XMM, YMM and ZMM registers."
    vendor_syntax {
      mnemonic: "VZEROALL"
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "VEX.256.0F.WIG 77"
    instruction_group_index: 61
  }
  instructions {
    description: "Converts 2 packed quad-word integers from xmm2 into 2 packed word integers in xmm1/m32 with truncation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVQW"
      operands {
        name: "xmm1/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.F3.0F38.W0 34 /r"
    instruction_group_index: 62
  }
  instructions {
    description: "Converts 8 packed signed quad-word integers from zmm2 into 8 packed signed word integers in xmm1/m32 using signed saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVSQW"
      operands {
        name: "xmm1/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.F3.0F38.W0 24 /r"
    instruction_group_index: 62
  }
  instructions {
    description: "Converts 2 packed unsigned quad-word integers from xmm2 into 2 packed unsigned word integers in xmm1/m32 using unsigned saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVUSQW"
      operands {
        name: "xmm1/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.F3.0F38.W0 14 /r"
    instruction_group_index: 62
  }
  instructions {
    description: "Converts 4 packed quad-word integers from ymm2 into 4 packed word integers in xmm1/m64 with truncation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVQW"
      operands {
        name: "xmm1/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.F3.0F38.W0 34 /r"
    instruction_group_index: 62
  }
  instructions {
    description: "Converts 4 packed signed quad-word integers from ymm2 into 4 packed signed word integers in xmm1/m64 using signed saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVSQW"
      operands {
        name: "xmm1/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.F3.0F38.W0 24 /r"
    instruction_group_index: 62
  }
  instructions {
    description: "Converts 4 packed unsigned quad-word integers from ymm2 into 4 packed unsigned word integers in xmm1/m64 using unsigned saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVUSQW"
      operands {
        name: "xmm1/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.F3.0F38.W0 14 /r"
    instruction_group_index: 62
  }
  instructions {
    description: "Converts 8 packed quad-word integers from zmm2 into 8 packed word integers in xmm1/m128 with truncation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVQW"
      operands {
        name: "xmm1/m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.F3.0F38.W0 34 /r"
    instruction_group_index: 62
  }
  instructions {
    description: "Converts 8 packed signed quad-word integers from zmm2 into 8 packed signed word integers in xmm1/m128 using signed saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVSQW"
      operands {
        name: "xmm1/m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.F3.0F38.W0 24 /r"
    instruction_group_index: 62
  }
  instructions {
    description: "Converts 8 packed unsigned quad-word integers from zmm2 into 8 packed unsigned word integers in xmm1/m128 using unsigned saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVUSQW"
      operands {
        name: "xmm1/m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.F3.0F38.W0 14 /r"
    instruction_group_index: 62
  }
  instructions {
    description: "Detect duplicate double-word values in xmm2/m128/m32bcst using writemask k1."
    vendor_syntax {
      mnemonic: "VPCONFLICTD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512CD"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 C4 /r"
    instruction_group_index: 63
  }
  instructions {
    description: "Detect duplicate double-word values in ymm2/m256/m32bcst using writemask k1."
    vendor_syntax {
      mnemonic: "VPCONFLICTD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512CD"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 C4 /r"
    instruction_group_index: 63
  }
  instructions {
    description: "Detect duplicate double-word values in zmm2/m512/m32bcst using writemask k1."
    vendor_syntax {
      mnemonic: "VPCONFLICTD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512CD"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 C4 /r"
    instruction_group_index: 63
  }
  instructions {
    description: "Detect duplicate quad-word values in xmm2/m128/m64bcst using writemask k1."
    vendor_syntax {
      mnemonic: "VPCONFLICTQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512CD"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 C4 /r"
    instruction_group_index: 63
  }
  instructions {
    description: "Detect duplicate quad-word values in ymm2/m256/m64bcst using writemask k1."
    vendor_syntax {
      mnemonic: "VPCONFLICTQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512CD"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 C4 /r"
    instruction_group_index: 63
  }
  instructions {
    description: "Detect duplicate quad-word values in zmm2/m512/m64bcst using writemask k1."
    vendor_syntax {
      mnemonic: "VPCONFLICTQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512CD"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 C4 /r"
    instruction_group_index: 63
  }
  instructions {
    description: "Return the minimum scalar double-precision floatingpoint value between xmm2/m64 and xmm1."
    vendor_syntax {
      mnemonic: "MINSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F2 0F 5D /r"
    instruction_group_index: 64
  }
  instructions {
    description: "Return the minimum scalar double-precision floatingpoint value between xmm3/m64 and xmm2."
    vendor_syntax {
      mnemonic: "VMINSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.LIG.F2.0F.WIG 5D /r"
    instruction_group_index: 64
  }
  instructions {
    description: "Return the minimum scalar double-precision floatingpoint value between xmm3/m64 and xmm2."
    vendor_syntax {
      mnemonic: "VMINSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.LIG.F2.0F.W1 5D /r"
    instruction_group_index: 64
  }
  instructions {
    description: "Permute double-precision floating-point elements in ymm2/m256 using indices in imm8 and store the result in ymm1."
    vendor_syntax {
      mnemonic: "VPERMPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F3A.W1 01 /r ib"
    instruction_group_index: 65
  }
  instructions {
    description: "Permute double-precision floating-point elements in ymm2/m256/m64bcst using indexes in imm8 and store the result in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPERMPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F3A.W1 01 /r ib"
    instruction_group_index: 65
  }
  instructions {
    description: "Permute double-precision floating-point elements in zmm2/m512/m64bcst using indices in imm8 and store the result in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPERMPD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F3A.W1 01 /r ib"
    instruction_group_index: 65
  }
  instructions {
    description: "Permute double-precision floating-point elements in ymm3/m256/m64bcst using indexes in ymm2 and store the result in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPERMPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 16 /r"
    instruction_group_index: 65
  }
  instructions {
    description: "Permute double-precision floating-point elements in zmm3/m512/m64bcst using indices in zmm2 and store the result in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPERMPD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 16 /r"
    instruction_group_index: 65
  }
  instructions {
    description: "Converts 8 packed word integers from xmm2 into 8 packed bytes in xmm1/m64 with truncation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVWB"
      operands {
        name: "xmm1/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.F3.0F38.W0 30 /r"
    instruction_group_index: 66
  }
  instructions {
    description: "Converts 8 packed signed word integers from xmm2 into 8 packed signed bytes in xmm1/m64 using signed saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVSWB"
      operands {
        name: "xmm1/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.F3.0F38.W0 20 /r"
    instruction_group_index: 66
  }
  instructions {
    description: "Converts 8 packed unsigned word integers from xmm2 into 8 packed unsigned bytes in 8mm1/m64 using unsigned saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVUSWB"
      operands {
        name: "xmm1/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.F3.0F38.W0 10 /r"
    instruction_group_index: 66
  }
  instructions {
    description: "Converts 16 packed word integers from ymm2 into 16 packed bytes in xmm1/m128 with truncation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVWB"
      operands {
        name: "xmm1/m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.F3.0F38.W0 30 /r"
    instruction_group_index: 66
  }
  instructions {
    description: "Converts 16 packed signed word integers from ymm2 into 16 packed signed bytes in xmm1/m128 using signed saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVSWB"
      operands {
        name: "xmm1/m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.F3.0F38.W0 20 /r"
    instruction_group_index: 66
  }
  instructions {
    description: "Converts 16 packed unsigned word integers from ymm2 into 16 packed unsigned bytes in xmm1/m128 using unsigned saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVUSWB"
      operands {
        name: "xmm1/m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.F3.0F38.W0 10 /r"
    instruction_group_index: 66
  }
  instructions {
    description: "Converts 32 packed word integers from zmm2 into 32 packed bytes in ymm1/m256 with truncation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVWB"
      operands {
        name: "ymm1/m256"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.F3.0F38.W0 30 /r"
    instruction_group_index: 66
  }
  instructions {
    description: "Converts 32 packed signed word integers from zmm2 into 32 packed signed bytes in ymm1/m256 using signed saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVSWB"
      operands {
        name: "ymm1/m256"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.F3.0F38.W0 20 /r"
    instruction_group_index: 66
  }
  instructions {
    description: "Converts 32 packed unsigned word integers from zmm2 into 32 packed unsigned bytes in ymm1/m256 using unsigned saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVUSWB"
      operands {
        name: "ymm1/m256"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.F3.0F38.W0 10 /r"
    instruction_group_index: 66
  }
  instructions {
    description: "Return the bitwise logical AND NOT of packed doubleprecision floating-point values in xmm1 and xmm2/mem."
    vendor_syntax {
      mnemonic: "ANDNPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 55 /r"
    instruction_group_index: 68
  }
  instructions {
    description: "Return the bitwise logical AND NOT of packed doubleprecision floating-point values in xmm2 and xmm3/mem."
    vendor_syntax {
      mnemonic: "VANDNPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F 55 /r"
    instruction_group_index: 68
  }
  instructions {
    description: "Return the bitwise logical AND NOT of packed doubleprecision floating-point values in ymm2 and ymm3/mem."
    vendor_syntax {
      mnemonic: "VANDNPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F 55/r"
    instruction_group_index: 68
  }
  instructions {
    description: "Return the bitwise logical AND NOT of packed doubleprecision floating-point values in xmm2 and xmm3/m128/m64bcst subject to writemask k1."
    vendor_syntax {
      mnemonic: "VANDNPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.W1 55 /r"
    instruction_group_index: 68
  }
  instructions {
    description: "Return the bitwise logical AND NOT of packed doubleprecision floating-point values in ymm2 and ymm3/m256/m64bcst subject to writemask k1."
    vendor_syntax {
      mnemonic: "VANDNPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.W1 55 /r"
    instruction_group_index: 68
  }
  instructions {
    description: "Return the bitwise logical AND NOT of packed doubleprecision floating-point values in zmm2 and zmm3/m512/m64bcst subject to writemask k1."
    vendor_syntax {
      mnemonic: "VANDNPD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.W1 55 /r"
    instruction_group_index: 68
  }
  instructions {
    description: "Return the bitwise logical XOR of packed doubleprecision floating-point values in xmm1 and xmm2/mem."
    vendor_syntax {
      mnemonic: "XORPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 57/r"
    instruction_group_index: 69
  }
  instructions {
    description: "Return the bitwise logical XOR of packed doubleprecision floating-point values in xmm2 and xmm3/mem."
    vendor_syntax {
      mnemonic: "VXORPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG 57 /r"
    instruction_group_index: 69
  }
  instructions {
    description: "Return the bitwise logical XOR of packed doubleprecision floating-point values in ymm2 and ymm3/mem."
    vendor_syntax {
      mnemonic: "VXORPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG 57 /r"
    instruction_group_index: 69
  }
  instructions {
    description: "Return the bitwise logical XOR of packed doubleprecision floating-point values in xmm2 and xmm3/m128/m64bcst subject to writemask k1."
    vendor_syntax {
      mnemonic: "VXORPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.W1 57 /r"
    instruction_group_index: 69
  }
  instructions {
    description: "Return the bitwise logical XOR of packed doubleprecision floating-point values in ymm2 and ymm3/m256/m64bcst subject to writemask k1."
    vendor_syntax {
      mnemonic: "VXORPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.W1 57 /r"
    instruction_group_index: 69
  }
  instructions {
    description: "Return the bitwise logical XOR of packed doubleprecision floating-point values in zmm2 and zmm3/m512/m64bcst subject to writemask k1."
    vendor_syntax {
      mnemonic: "VXORPD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.W1 57 /r"
    instruction_group_index: 69
  }
  instructions {
    description: "Store ST(0) in m16int with truncation."
    vendor_syntax {
      mnemonic: "FISTTP"
      operands {
        name: "m16int"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DF /1"
    instruction_group_index: 70
  }
  instructions {
    description: "Store ST(0) in m32int with truncation."
    vendor_syntax {
      mnemonic: "FISTTP"
      operands {
        name: "m32int"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DB /1"
    instruction_group_index: 70
  }
  instructions {
    description: "Store ST(0) in m64int with truncation."
    vendor_syntax {
      mnemonic: "FISTTP"
      operands {
        name: "m64int"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DD /1"
    instruction_group_index: 70
  }
  instructions {
    description: "AX := sign-extend of AL."
    vendor_syntax {
      mnemonic: "CBW"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "98"
    instruction_group_index: 71
  }
  instructions {
    description: "EAX := sign-extend of AX."
    vendor_syntax {
      mnemonic: "CWDE"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "98"
    instruction_group_index: 71
  }
  instructions {
    description: "RAX := sign-extend of EAX."
    vendor_syntax {
      mnemonic: "CDQE"
    }
    available_in_64_bit: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "REX.W + 98"
    instruction_group_index: 71
  }
  instructions {
    description: "Selectively write bytes from mm1 to memory location using the byte mask in mm2. The default memory location is specified by DS:DI/EDI/RDI."
    vendor_syntax {
      mnemonic: "MASKMOVQ"
      operands {
        name: "mm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "mm2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "NP 0F F7 /r"
    instruction_group_index: 72
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from xmm1 and xmm3/mem, add/subtract elements in xmm2 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMADDSUB132PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W1 96 /r"
    instruction_group_index: 73
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from xmm1 and xmm2, add/subtract elements in xmm3/mem and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMADDSUB213PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W1 A6 /r"
    instruction_group_index: 73
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from xmm2 and xmm3/mem, add/subtract elements in xmm1 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMADDSUB231PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W1 B6 /r"
    instruction_group_index: 73
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from ymm1 and ymm3/mem, add/subtract elements in ymm2 and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFMADDSUB132PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W1 96 /r"
    instruction_group_index: 73
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from ymm1 and ymm2, add/subtract elements in ymm3/mem and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFMADDSUB213PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W1 A6 /r"
    instruction_group_index: 73
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from ymm2 and ymm3/mem, add/subtract elements in ymm1 and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFMADDSUB231PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W1 B6 /r"
    instruction_group_index: 73
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from xmm1 and xmm2, add/subtract elements in xmm3/m128/m64bcst and put result in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMADDSUB213PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 A6 /r"
    instruction_group_index: 73
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from xmm2 and xmm3/m128/m64bcst, add/subtract elements in xmm1 and put result in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMADDSUB231PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 B6 /r"
    instruction_group_index: 73
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from xmm1 and xmm3/m128/m64bcst, add/subtract elements in xmm2 and put result in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMADDSUB132PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 96 /r"
    instruction_group_index: 73
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from ymm1 and ymm2, add/subtract elements in ymm3/m256/m64bcst and put result in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMADDSUB213PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 A6 /r"
    instruction_group_index: 73
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from ymm2 and ymm3/m256/m64bcst, add/subtract elements in ymm1 and put result in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMADDSUB231PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 B6 /r"
    instruction_group_index: 73
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from ymm1 and ymm3/m256/m64bcst, add/subtract elements in ymm2 and put result in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMADDSUB132PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 96 /r"
    instruction_group_index: 73
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from zmm1and zmm2, add/subtract elements in zmm3/m512/m64bcst and put result in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMADDSUB213PD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 A6 /r"
    instruction_group_index: 73
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from zmm2 and zmm3/m512/m64bcst, add/subtract elements in zmm1 and put result in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMADDSUB231PD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 B6 /r"
    instruction_group_index: 73
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from zmm1 and zmm3/m512/m64bcst, add/subtract elements in zmm2 and put result in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMADDSUB132PD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 96 /r"
    instruction_group_index: 73
  }
  instructions {
    description: "Load unaligned data from mem and return double quadword in xmm1."
    vendor_syntax {
      mnemonic: "LDDQU"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "mem"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "F2 0F F0 /r"
    instruction_group_index: 74
  }
  instructions {
    description: "Load unaligned packed integer values from mem to xmm1."
    vendor_syntax {
      mnemonic: "VLDDQU"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "VEX.128.F2.0F.WIG F0 /r"
    instruction_group_index: 74
  }
  instructions {
    description: "Load unaligned packed integer values from mem to ymm1."
    vendor_syntax {
      mnemonic: "VLDDQU"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "VEX.256.F2.0F.WIG F0 /r"
    instruction_group_index: 74
  }
  instructions {
    description: "Concatenate xmm1 and xmm2, extract result shifted to the right by value in xmm3/m128 into xmm1."
    vendor_syntax {
      mnemonic: "VPSHRDVW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2 && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 72 /r"
    instruction_group_index: 75
  }
  instructions {
    description: "Concatenate ymm1 and ymm2, extract result shifted to the right by value in xmm3/m256 into ymm1."
    vendor_syntax {
      mnemonic: "VPSHRDVW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2 && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 72 /r"
    instruction_group_index: 75
  }
  instructions {
    description: "Concatenate zmm1 and zmm2, extract result shifted to the right by value in zmm3/m512 into zmm1."
    vendor_syntax {
      mnemonic: "VPSHRDVW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 72 /r"
    instruction_group_index: 75
  }
  instructions {
    description: "Concatenate xmm1 and xmm2, extract result shifted to the right by value in xmm3/m128 into xmm1."
    vendor_syntax {
      mnemonic: "VPSHRDVD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2 && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 73 /r"
    instruction_group_index: 75
  }
  instructions {
    description: "Concatenate ymm1 and ymm2, extract result shifted to the right by value in xmm3/m256 into ymm1."
    vendor_syntax {
      mnemonic: "VPSHRDVD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2 && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 73 /r"
    instruction_group_index: 75
  }
  instructions {
    description: "Concatenate zmm1 and zmm2, extract result shifted to the right by value in zmm3/m512 into zmm1."
    vendor_syntax {
      mnemonic: "VPSHRDVD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 73 /r"
    instruction_group_index: 75
  }
  instructions {
    description: "Concatenate xmm1 and xmm2, extract result shifted to the right by value in xmm3/m128 into xmm1."
    vendor_syntax {
      mnemonic: "VPSHRDVQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2 && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 73 /r"
    instruction_group_index: 75
  }
  instructions {
    description: "Concatenate ymm1 and ymm2, extract result shifted to the right by value in xmm3/m256 into ymm1."
    vendor_syntax {
      mnemonic: "VPSHRDVQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2 && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 73 /r"
    instruction_group_index: 75
  }
  instructions {
    description: "Concatenate zmm1 and zmm2, extract result shifted to the right by value in zmm3/m512 into zmm1."
    vendor_syntax {
      mnemonic: "VPSHRDVQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 73 /r"
    instruction_group_index: 75
  }
  instructions {
    description: "Move doubleword from r32 to m32 using non-temporal hint."
    vendor_syntax {
      mnemonic: "MOVNTI"
      operands {
        name: "m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "NP 0F C3 /r"
    instruction_group_index: 76
  }
  instructions {
    description: "Move quadword from r64 to m64 using non-temporal hint."
    vendor_syntax {
      mnemonic: "MOVNTI"
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    encoding_scheme: "MR"
    raw_encoding_specification: "NP REX.W + 0F C3 /r"
    instruction_group_index: 76
  }
  instructions {
    description: "Convert one unsigned doubleword integer from r/m32 to one double-precision floating-point value in xmm1."
    vendor_syntax {
      mnemonic: "VCVTUSI2SD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.LIG.F2.0F.W0 7B /r"
    instruction_group_index: 77
  }
  instructions {
    description: "Convert one unsigned quadword integer from r/m64 to one double-precision floating-point value in xmm1."
    vendor_syntax {
      mnemonic: "VCVTUSI2SD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.LIG.F2.0F.W1 7B /r"
    instruction_group_index: 77
  }
  instructions {
    description: "Clear floating-point exception flags after checking for pending unmasked floating-point exceptions."
    vendor_syntax {
      mnemonic: "FCLEX"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "9B DB E2"
    instruction_group_index: 78
  }
  instructions {
    description: "Clear floating-point exception flags without checking for pending unmasked floating-point exceptions."
    vendor_syntax {
      mnemonic: "FNCLEX"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DB E2"
    instruction_group_index: 78
  }
  instructions {
    description: "Computes the approximate reciprocals of the packed single-precision floating-point values in xmm2/m128 and stores the results in xmm1."
    vendor_syntax {
      mnemonic: "RCPPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "NP 0F 53 /r"
    instruction_group_index: 79
  }
  instructions {
    description: "Computes the approximate reciprocals of packed single-precision values in xmm2/mem and stores the results in xmm1."
    vendor_syntax {
      mnemonic: "VRCPPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "VEX.128.0F.WIG 53 /r"
    instruction_group_index: 79
  }
  instructions {
    description: "Computes the approximate reciprocals of packed single-precision values in ymm2/mem and stores the results in ymm1."
    vendor_syntax {
      mnemonic: "VRCPPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "VEX.256.0F.WIG 53 /r"
    instruction_group_index: 79
  }
  instructions {
    description: "Multiply the low double-precision floating-point value in xmm2/m64 by low double-precision floating-point value in xmm1."
    vendor_syntax {
      mnemonic: "MULSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F2 0F 59 /r"
    instruction_group_index: 80
  }
  instructions {
    description: "Multiply the low double-precision floating-point value in xmm3/m64 by low double-precision floating-point value in xmm2."
    vendor_syntax {
      mnemonic: "VMULSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.LIG.F2.0F.WIG 59 /r"
    instruction_group_index: 80
  }
  instructions {
    description: "Multiply the low double-precision floating-point value in xmm3/m64 by low double-precision floating-point value in xmm2."
    vendor_syntax {
      mnemonic: "VMULSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.LIG.F2.0F.W1 59 /r"
    instruction_group_index: 80
  }
  instructions {
    description: "Convert two packed unsigned quadword integers from xmm2/m128/m64bcst to two packed double-precision floating-point values in xmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTUQQ2PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.F3.0F.W1 7A /r"
    instruction_group_index: 81
  }
  instructions {
    description: "Convert four packed unsigned quadword integers from ymm2/m256/m64bcst to packed double-precision floatingpoint values in ymm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTUQQ2PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.F3.0F.W1 7A /r"
    instruction_group_index: 81
  }
  instructions {
    description: "Convert eight packed unsigned quadword integers from zmm2/m512/m64bcst to eight packed double-precision floating-point values in zmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTUQQ2PD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.F3.0F.W1 7A /r"
    instruction_group_index: 81
  }
  instructions {
    description: "Load: AH := EFLAGS(SF:ZF:0:AF:0:PF:1:CF)."
    vendor_syntax {
      mnemonic: "LAHF"
    }
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "9F"
    instruction_group_index: 82
  }
  instructions {
    description: "Perform a reduction transformation on a scalar single-precision floating point value in xmm3/m32 by subtracting a number of fraction bits specified by the imm8 field. Also, upper single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32]. Stores the result in xmm1 register."
    vendor_syntax {
      mnemonic: "VREDUCESS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.NDS.LIG.66.0F3A.W0 57 /r ib"
    instruction_group_index: 83
  }
  instructions {
    description: "Launch virtual machine managed by current VMCS."
    vendor_syntax {
      mnemonic: "VMLAUNCH"
    }
    feature_name: "VMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "0F 01 C2"
    instruction_group_index: 84
  }
  instructions {
    description: "Resume virtual machine managed by current VMCS."
    vendor_syntax {
      mnemonic: "VMRESUME"
    }
    feature_name: "VMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "0F 01 C3"
    instruction_group_index: 84
  }
  instructions {
    description: "Rotate doublewords in xmm2 right by count in the corresponding element of xmm3/m128/m32bcst, store result using writemask k1."
    vendor_syntax {
      mnemonic: "VPRORVD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 14 /r"
    instruction_group_index: 85
  }
  instructions {
    description: "Rotate doublewords in xmm2/m128/m32bcst right by imm8, store result using writemask k1."
    vendor_syntax {
      mnemonic: "VPRORD"
      operands {
        name: "xmm1"
        encoding: VEX_V_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F.W0 72 /0 ib"
    instruction_group_index: 85
  }
  instructions {
    description: "Rotate quadwords in xmm2 right by count in the corresponding element of xmm3/m128/m64bcst, store result using writemask k1."
    vendor_syntax {
      mnemonic: "VPRORVQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 14 /r"
    instruction_group_index: 85
  }
  instructions {
    description: "Rotate quadwords in xmm2/m128/m64bcst right by imm8, store result using writemask k1."
    vendor_syntax {
      mnemonic: "VPRORQ"
      operands {
        name: "xmm1"
        encoding: VEX_V_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F.W1 72 /0 ib"
    instruction_group_index: 85
  }
  instructions {
    description: "Rotate doublewords in ymm2 right by count in the corresponding element of ymm3/m256/m32bcst, store using result writemask k1."
    vendor_syntax {
      mnemonic: "VPRORVD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 14 /r"
    instruction_group_index: 85
  }
  instructions {
    description: "Rotate doublewords in ymm2/m256/m32bcst right by imm8, store result using writemask k1."
    vendor_syntax {
      mnemonic: "VPRORD"
      operands {
        name: "ymm1"
        encoding: VEX_V_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F.W0 72 /0 ib"
    instruction_group_index: 85
  }
  instructions {
    description: "Rotate quadwords in ymm2 right by count in the corresponding element of ymm3/m256/m64bcst, store result using writemask k1."
    vendor_syntax {
      mnemonic: "VPRORVQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 14 /r"
    instruction_group_index: 85
  }
  instructions {
    description: "Rotate quadwords in ymm2/m256/m64bcst right by imm8, store result using writemask k1."
    vendor_syntax {
      mnemonic: "VPRORQ"
      operands {
        name: "ymm1"
        encoding: VEX_V_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F.W1 72 /0 ib"
    instruction_group_index: 85
  }
  instructions {
    description: "Rotate doublewords in zmm2 right by count in the corresponding element of zmm3/m512/m32bcst, store result using writemask k1."
    vendor_syntax {
      mnemonic: "VPRORVD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 14 /r"
    instruction_group_index: 85
  }
  instructions {
    description: "Rotate doublewords in zmm2/m512/m32bcst right by imm8, store result using writemask k1."
    vendor_syntax {
      mnemonic: "VPRORD"
      operands {
        name: "zmm1"
        encoding: VEX_V_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F.W0 72 /0 ib"
    instruction_group_index: 85
  }
  instructions {
    description: "Rotate quadwords in zmm2 right by count in the corresponding element of zmm3/m512/m64bcst, store result using writemask k1."
    vendor_syntax {
      mnemonic: "VPRORVQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 14 /r"
    instruction_group_index: 85
  }
  instructions {
    description: "Rotate quadwords in zmm2/m512/m64bcst right by imm8, store result using writemask k1."
    vendor_syntax {
      mnemonic: "VPRORQ"
      operands {
        name: "zmm1"
        encoding: VEX_V_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F.W1 72 /0 ib"
    instruction_group_index: 85
  }
  instructions {
    description: "Store ST(0) in m80bcd and pop ST(0)."
    vendor_syntax {
      mnemonic: "FBSTP"
      operands {
        name: "m80bcd"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DF /6"
    instruction_group_index: 86
  }
  instructions {
    description: "One byte no-operation instruction."
    vendor_syntax {
      mnemonic: "NOP"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "NP 90"
    instruction_group_index: 87
  }
  instructions {
    description: "Multi-byte no-operation instruction."
    vendor_syntax {
      mnemonic: "NOP"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "NP 0F 1F /0"
    instruction_group_index: 87
  }
  instructions {
    description: "Multi-byte no-operation instruction."
    vendor_syntax {
      mnemonic: "NOP"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "NP 0F 1F /0"
    instruction_group_index: 87
  }
  instructions {
    description: "Insert the low word from r32 or from m16 into mm at the word position specified by imm8."
    vendor_syntax {
      mnemonic: "PINSRW"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r32/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F C4 /r ib"
    instruction_group_index: 88
  }
  instructions {
    description: "Move the low word of r32 or from m16 into xmm at the word position specified by imm8."
    vendor_syntax {
      mnemonic: "PINSRW"
      operands {
        name: "xmm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r32/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F C4 /r ib"
    instruction_group_index: 88
  }
  instructions {
    description: "Insert a word integer value from r32/m16 and rest from xmm2 into xmm1 at the word offset in imm8."
    vendor_syntax {
      mnemonic: "VPINSRW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r32/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.W0 C4 /r ib"
    instruction_group_index: 88
  }
  instructions {
    description: "Insert a word integer value from r32/m16 and rest from xmm2 into xmm1 at the word offset in imm8."
    vendor_syntax {
      mnemonic: "VPINSRW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r32/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.WIG C4 /r ib"
    instruction_group_index: 88
  }
  instructions {
    description: "Set the AC flag in the EFLAGS register."
    vendor_syntax {
      mnemonic: "STAC"
    }
    feature_name: "SMAP"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "NP 0F 01 CB"
    instruction_group_index: 89
  }
  instructions {
    description: "Restore SSP."
    vendor_syntax {
      mnemonic: "RSTORSSP"
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    feature_name: "CET_SS"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "F3 0F 01 /5 (mod!=11 /5 memory only)"
    instruction_group_index: 91
  }
  instructions {
    description: "Extract 2-bit sign mask from xmm and store in reg. The upper bits of r32 or r64 are filled with zeros."
    vendor_syntax {
      mnemonic: "MOVMSKPD"
      operands {
        name: "reg"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "66 0F 50 /r"
    instruction_group_index: 92
  }
  instructions {
    description: "Extract 2-bit sign mask from xmm2 and store in reg.\nThe upper bits of r32 or r64 are zeroed."
    vendor_syntax {
      mnemonic: "VMOVMSKPD"
      operands {
        name: "reg"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "VEX.128.66.0F.WIG 50 /r"
    instruction_group_index: 92
  }
  instructions {
    description: "Extract 4-bit sign mask from ymm2 and store in reg.\nThe upper bits of r32 or r64 are zeroed."
    vendor_syntax {
      mnemonic: "VMOVMSKPD"
      operands {
        name: "reg"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "VEX.256.66.0F.WIG 50 /r"
    instruction_group_index: 92
  }
  instructions {
    description: "Multiply scalar single-precision floating-point values from source register block indicated by xmm2 by values from m128 and accumulate the result in xmm1."
    vendor_syntax {
      mnemonic: "V4FMADDSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2+3"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_4FMAPS"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.DDS.LIG.F2.0F38.W0 9B /r"
    instruction_group_index: 93
  }
  instructions {
    description: "Multiply and negate scalar single-precision floating-point values from source register block indicated by xmm2 by values from m128 and accumulate the result in xmm1."
    vendor_syntax {
      mnemonic: "V4FNMADDSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2+3"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_4FMAPS"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.DDS.LIG.F2.0F38.W0 AB /r"
    instruction_group_index: 93
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from xmm1 and xmm3/mem, subtract/add elements in xmm2 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMSUBADD132PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W0 97 /r"
    instruction_group_index: 94
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from xmm1 and xmm2, subtract/add elements in xmm3/mem and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMSUBADD213PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W0 A7 /r"
    instruction_group_index: 94
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from xmm2 and xmm3/mem, subtract/add elements in xmm1 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMSUBADD231PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W0 B7 /r"
    instruction_group_index: 94
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from ymm1 and ymm3/mem, subtract/add elements in ymm2 and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFMSUBADD132PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W0 97 /r"
    instruction_group_index: 94
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from ymm1 and ymm2, subtract/add elements in ymm3/mem and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFMSUBADD213PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W0 A7 /r"
    instruction_group_index: 94
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from ymm2 and ymm3/mem, subtract/add elements in ymm1 and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFMSUBADD231PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W0 B7 /r"
    instruction_group_index: 94
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from xmm1 and xmm3/m128/m32bcst, subtract/add elements in xmm2 and put result in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMSUBADD132PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 97 /r"
    instruction_group_index: 94
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from xmm1 and xmm2, subtract/add elements in xmm3/m128/m32bcst and put result in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMSUBADD213PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 A7 /r"
    instruction_group_index: 94
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from xmm2 and xmm3/m128/m32bcst, subtract/add elements in xmm1 and put result in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMSUBADD231PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 B7 /r"
    instruction_group_index: 94
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from ymm1 and ymm3/m256/m32bcst, subtract/add elements in ymm2 and put result in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMSUBADD132PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 97 /r"
    instruction_group_index: 94
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from ymm1 and ymm2, subtract/add elements in ymm3/m256/m32bcst and put result in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMSUBADD213PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 A7 /r"
    instruction_group_index: 94
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from ymm2 and ymm3/m256/m32bcst, subtract/add elements in ymm1 and put result in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMSUBADD231PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 B7 /r"
    instruction_group_index: 94
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from zmm1 and zmm3/m512/m32bcst, subtract/add elements in zmm2 and put result in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMSUBADD132PS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 97 /r"
    instruction_group_index: 94
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from zmm1 and zmm2, subtract/add elements in zmm3/m512/m32bcst and put result in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMSUBADD213PS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 A7 /r"
    instruction_group_index: 94
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from zmm2 and zmm3/m512/m32bcst, subtract/add elements in zmm1 and put result in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMSUBADD231PS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 B7 /r"
    instruction_group_index: 94
  }
  instructions {
    description: "Sets up a linear address range to be monitored by hardware and activates the monitor. The address range should be a writeback memory caching type. The address is DS:RAX/EAX/AX."
    vendor_syntax {
      mnemonic: "MONITOR"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "0F 01 C8"
    instruction_group_index: 95
  }
  instructions {
    description: "Move data from m8 closer to the processor using T0 hint."
    vendor_syntax {
      mnemonic: "PREFETCHT0"
      operands {
        name: "m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 18 /1"
    instruction_group_index: 96
  }
  instructions {
    description: "Move data from m8 closer to the processor using T1 hint."
    vendor_syntax {
      mnemonic: "PREFETCHT1"
      operands {
        name: "m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 18 /2"
    instruction_group_index: 96
  }
  instructions {
    description: "Move data from m8 closer to the processor using T2 hint."
    vendor_syntax {
      mnemonic: "PREFETCHT2"
      operands {
        name: "m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 18 /3"
    instruction_group_index: 96
  }
  instructions {
    description: "Move data from m8 closer to the processor using NTA hint."
    vendor_syntax {
      mnemonic: "PREFETCHNTA"
      operands {
        name: "m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 18 /0"
    instruction_group_index: 96
  }
  instructions {
    description: "Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to mm1."
    vendor_syntax {
      mnemonic: "PMULHRSW"
      operands {
        name: "mm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 38 0B /r"
    instruction_group_index: 97
  }
  instructions {
    description: "Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to xmm1."
    vendor_syntax {
      mnemonic: "PMULHRSW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 38 0B /r"
    instruction_group_index: 97
  }
  instructions {
    description: "Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to xmm1."
    vendor_syntax {
      mnemonic: "VPMULHRSW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F38.WIG 0B /r"
    instruction_group_index: 97
  }
  instructions {
    description: "Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to ymm1."
    vendor_syntax {
      mnemonic: "VPMULHRSW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F38.WIG 0B /r"
    instruction_group_index: 97
  }
  instructions {
    description: "Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to xmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMULHRSW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F38.WIG 0B /r"
    instruction_group_index: 97
  }
  instructions {
    description: "Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to ymm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMULHRSW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38.WIG 0B /r"
    instruction_group_index: 97
  }
  instructions {
    description: "Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to zmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMULHRSW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38.WIG 0B /r"
    instruction_group_index: 97
  }
  instructions {
    description: "AND imm8 with AL; set SF, ZF, PF according to result."
    vendor_syntax {
      mnemonic: "TEST"
      operands {
        name: "AL"
        encoding: IMPLICIT_ENCODING
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "I"
    raw_encoding_specification: "A8 ib"
    instruction_group_index: 98
  }
  instructions {
    description: "AND imm16 with AX; set SF, ZF, PF according to result."
    vendor_syntax {
      mnemonic: "TEST"
      operands {
        name: "AX"
        encoding: IMPLICIT_ENCODING
      }
      operands {
        name: "imm16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "I"
    raw_encoding_specification: "A9 iw"
    instruction_group_index: 98
  }
  instructions {
    description: "AND imm32 with EAX; set SF, ZF, PF according to result."
    vendor_syntax {
      mnemonic: "TEST"
      operands {
        name: "EAX"
        encoding: IMPLICIT_ENCODING
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "I"
    raw_encoding_specification: "A9 id"
    instruction_group_index: 98
  }
  instructions {
    description: "AND imm32 sign-extended to 64-bits with RAX; set SF, ZF, PF according to result."
    vendor_syntax {
      mnemonic: "TEST"
      operands {
        name: "RAX"
        encoding: IMPLICIT_ENCODING
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "I"
    raw_encoding_specification: "REX.W + A9 id"
    instruction_group_index: 98
  }
  instructions {
    description: "AND imm8 with r/m8; set SF, ZF, PF according to result."
    vendor_syntax {
      mnemonic: "TEST"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "F6 /0 ib"
    instruction_group_index: 98
  }
  instructions {
    description: "AND imm8 with r/m8; set SF, ZF, PF according to result."
    vendor_syntax {
      mnemonic: "TEST"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX + F6 /0 ib"
    instruction_group_index: 98
  }
  instructions {
    description: "AND imm16 with r/m16; set SF, ZF, PF according to result."
    vendor_syntax {
      mnemonic: "TEST"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "F7 /0 iw"
    instruction_group_index: 98
  }
  instructions {
    description: "AND imm32 with r/m32; set SF, ZF, PF according to result."
    vendor_syntax {
      mnemonic: "TEST"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "F7 /0 id"
    instruction_group_index: 98
  }
  instructions {
    description: "AND imm32 sign-extended to 64-bits with r/m64; set SF, ZF, PF according to result."
    vendor_syntax {
      mnemonic: "TEST"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX.W + F7 /0 id"
    instruction_group_index: 98
  }
  instructions {
    description: "AND r8 with r/m8; set SF, ZF, PF according to result."
    vendor_syntax {
      mnemonic: "TEST"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "84 /r"
    instruction_group_index: 98
  }
  instructions {
    description: "AND r8 with r/m8; set SF, ZF, PF according to result."
    vendor_syntax {
      mnemonic: "TEST"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MR"
    raw_encoding_specification: "REX + 84 /r"
    instruction_group_index: 98
  }
  instructions {
    description: "AND r16 with r/m16; set SF, ZF, PF according to result."
    vendor_syntax {
      mnemonic: "TEST"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "85 /r"
    instruction_group_index: 98
  }
  instructions {
    description: "AND r32 with r/m32; set SF, ZF, PF according to result."
    vendor_syntax {
      mnemonic: "TEST"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "85 /r"
    instruction_group_index: 98
  }
  instructions {
    description: "AND r64 with r/m64; set SF, ZF, PF according to result."
    vendor_syntax {
      mnemonic: "TEST"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MR"
    raw_encoding_specification: "REX.W + 85 /r"
    instruction_group_index: 98
  }
  instructions {
    description: "Bitwise AND of packed byte integers in xmm2 and xmm3/m128 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
    vendor_syntax {
      mnemonic: "VPTESTMB"
      operands {
        name: "k2"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 26 /r"
    instruction_group_index: 99
  }
  instructions {
    description: "Bitwise AND of packed byte integers in ymm2 and ymm3/m256 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
    vendor_syntax {
      mnemonic: "VPTESTMB"
      operands {
        name: "k2"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 26 /r"
    instruction_group_index: 99
  }
  instructions {
    description: "Bitwise AND of packed byte integers in zmm2 and zmm3/m512 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
    vendor_syntax {
      mnemonic: "VPTESTMB"
      operands {
        name: "k2"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 26 /r"
    instruction_group_index: 99
  }
  instructions {
    description: "Bitwise AND of packed word integers in xmm2 and xmm3/m128 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
    vendor_syntax {
      mnemonic: "VPTESTMW"
      operands {
        name: "k2"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 26 /r"
    instruction_group_index: 99
  }
  instructions {
    description: "Bitwise AND of packed word integers in ymm2 and ymm3/m256 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
    vendor_syntax {
      mnemonic: "VPTESTMW"
      operands {
        name: "k2"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 26 /r"
    instruction_group_index: 99
  }
  instructions {
    description: "Bitwise AND of packed word integers in zmm2 and zmm3/m512 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
    vendor_syntax {
      mnemonic: "VPTESTMW"
      operands {
        name: "k2"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 26 /r"
    instruction_group_index: 99
  }
  instructions {
    description: "Bitwise AND of packed doubleword integers in xmm2 and xmm3/m128/m32bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
    vendor_syntax {
      mnemonic: "VPTESTMD"
      operands {
        name: "k2"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 27 /r"
    instruction_group_index: 99
  }
  instructions {
    description: "Bitwise AND of packed doubleword integers in ymm2 and ymm3/m256/m32bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
    vendor_syntax {
      mnemonic: "VPTESTMD"
      operands {
        name: "k2"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 27 /r"
    instruction_group_index: 99
  }
  instructions {
    description: "Bitwise AND of packed doubleword integers in zmm2 and zmm3/m512/m32bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
    vendor_syntax {
      mnemonic: "VPTESTMD"
      operands {
        name: "k2"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 27 /r"
    instruction_group_index: 99
  }
  instructions {
    description: "Bitwise AND of packed quadword integers in xmm2 and xmm3/m128/m64bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
    vendor_syntax {
      mnemonic: "VPTESTMQ"
      operands {
        name: "k2"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 27 /r"
    instruction_group_index: 99
  }
  instructions {
    description: "Bitwise AND of packed quadword integers in ymm2 and ymm3/m256/m64bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
    vendor_syntax {
      mnemonic: "VPTESTMQ"
      operands {
        name: "k2"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 27 /r"
    instruction_group_index: 99
  }
  instructions {
    description: "Bitwise AND of packed quadword integers in zmm2 and zmm3/m512/m64bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
    vendor_syntax {
      mnemonic: "VPTESTMQ"
      operands {
        name: "k2"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 27 /r"
    instruction_group_index: 99
  }
  instructions {
    description: "Multiply scalar single-precision floating-point value from xmm1 and xmm3/m32, subtract xmm2 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMSUB132SS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.LIG.66.0F38.W0 9B /r"
    instruction_group_index: 100
  }
  instructions {
    description: "Multiply scalar single-precision floating-point value from xmm1 and xmm2, subtract xmm3/m32 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMSUB213SS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.LIG.66.0F38.W0 AB /r"
    instruction_group_index: 100
  }
  instructions {
    description: "Multiply scalar single-precision floating-point value from xmm2 and xmm3/m32, subtract xmm1 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMSUB231SS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.LIG.66.0F38.W0 BB /r"
    instruction_group_index: 100
  }
  instructions {
    description: "Multiply scalar single-precision floating-point value from xmm1 and xmm3/m32, subtract xmm2 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMSUB132SS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.LIG.66.0F38.W0 9B /r"
    instruction_group_index: 100
  }
  instructions {
    description: "Multiply scalar single-precision floating-point value from xmm1 and xmm2, subtract xmm3/m32 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMSUB213SS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.LIG.66.0F38.W0 AB /r"
    instruction_group_index: 100
  }
  instructions {
    description: "Multiply scalar single-precision floating-point value from xmm2 and xmm3/m32, subtract xmm1 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMSUB231SS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.LIG.66.0F38.W0 BB /r"
    instruction_group_index: 100
  }
  instructions {
    description: "Halt"
    vendor_syntax {
      mnemonic: "HLT"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F4"
    instruction_group_index: 101
  }
  instructions {
    description: "Unpacks and Interleaves double-precision floating-point values from high quadwords of xmm1 and xmm2/m128."
    vendor_syntax {
      mnemonic: "UNPCKHPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 15 /r"
    instruction_group_index: 102
  }
  instructions {
    description: "Unpacks and Interleaves double-precision floating-point values from high quadwords of xmm2 and xmm3/m128."
    vendor_syntax {
      mnemonic: "VUNPCKHPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG 15 /r"
    instruction_group_index: 102
  }
  instructions {
    description: "Unpacks and Interleaves double-precision floating-point values from high quadwords of ymm2 and ymm3/m256."
    vendor_syntax {
      mnemonic: "VUNPCKHPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG 15 /r"
    instruction_group_index: 102
  }
  instructions {
    description: "Unpacks and Interleaves double precision floating-point values from high quadwords of xmm2 and xmm3/m128/m64bcst subject to writemask k1."
    vendor_syntax {
      mnemonic: "VUNPCKHPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.W1 15 /r"
    instruction_group_index: 102
  }
  instructions {
    description: "Unpacks and Interleaves double precision floating-point values from high quadwords of ymm2 and ymm3/m256/m64bcst subject to writemask k1."
    vendor_syntax {
      mnemonic: "VUNPCKHPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.W1 15 /r"
    instruction_group_index: 102
  }
  instructions {
    description: "Unpacks and Interleaves double-precision floating-point values from high quadwords of zmm2 and zmm3/m512/m64bcst subject to writemask k1."
    vendor_syntax {
      mnemonic: "VUNPCKHPD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.W1 15 /r"
    instruction_group_index: 102
  }
  instructions {
    description: "Assist in AES round key generation using an 8 bits Round Constant (RCON) specified in the immediate byte, operating on 128 bits of data specified in xmm2/m128 and stores the result in xmm1."
    vendor_syntax {
      mnemonic: "AESKEYGENASSIST"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AES"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMI"
    raw_encoding_specification: "66 0F 3A DF /r ib"
    instruction_group_index: 103
  }
  instructions {
    description: "Assist in AES round key generation using 8 bits Round Constant (RCON) specified in the immediate byte, operating on 128 bits of data specified in xmm2/m128 and stores the result in xmm1."
    vendor_syntax {
      mnemonic: "VAESKEYGENASSIST"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AES && AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMI"
    raw_encoding_specification: "VEX.128.66.0F3A.WIG DF /r ib"
    instruction_group_index: 103
  }
  instructions {
    description: "Bitwise AND mm/m64 and mm."
    vendor_syntax {
      mnemonic: "PAND"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F DB /r"
    instruction_group_index: 104
  }
  instructions {
    description: "Bitwise AND of xmm2/m128 and xmm1."
    vendor_syntax {
      mnemonic: "PAND"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F DB /r"
    instruction_group_index: 104
  }
  instructions {
    description: "Bitwise AND of xmm3/m128 and xmm."
    vendor_syntax {
      mnemonic: "VPAND"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG DB /r"
    instruction_group_index: 104
  }
  instructions {
    description: "Bitwise AND of ymm2, and ymm3/m256 and store result in ymm1."
    vendor_syntax {
      mnemonic: "VPAND"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG DB /r"
    instruction_group_index: 104
  }
  instructions {
    description: "Bitwise AND of packed doubleword integers in xmm2 and xmm3/m128/m32bcst and store result in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPANDD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.W0 DB /r"
    instruction_group_index: 104
  }
  instructions {
    description: "Bitwise AND of packed doubleword integers in ymm2 and ymm3/m256/m32bcst and store result in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPANDD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.W0 DB /r"
    instruction_group_index: 104
  }
  instructions {
    description: "Bitwise AND of packed doubleword integers in zmm2 and zmm3/m512/m32bcst and store result in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPANDD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.W0 DB /r"
    instruction_group_index: 104
  }
  instructions {
    description: "Bitwise AND of packed quadword integers in xmm2 and xmm3/m128/m64bcst and store result in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPANDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.W1 DB /r"
    instruction_group_index: 104
  }
  instructions {
    description: "Bitwise AND of packed quadword integers in ymm2 and ymm3/m256/m64bcst and store result in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPANDQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.W1 DB /r"
    instruction_group_index: 104
  }
  instructions {
    description: "Bitwise AND of packed quadword integers in zmm2 and zmm3/m512/m64bcst and store result in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPANDQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.W1 DB /r"
    instruction_group_index: 104
  }
  instructions {
    description: "Get Normalized Mantissa from float64 vector xmm2/m128/m64bcst and store the result in xmm1, using imm8 for sign control and mantissa interval normalization, under writemask."
    vendor_syntax {
      mnemonic: "VGETMANTPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F3A.W1 26 /r ib"
    instruction_group_index: 105
  }
  instructions {
    description: "Get Normalized Mantissa from float64 vector ymm2/m256/m64bcst and store the result in ymm1, using imm8 for sign control and mantissa interval normalization, under writemask."
    vendor_syntax {
      mnemonic: "VGETMANTPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F3A.W1 26 /r ib"
    instruction_group_index: 105
  }
  instructions {
    description: "Get Normalized Mantissa from float64 vector zmm2/m512/m64bcst and store the result in zmm1, using imm8 for sign control and mantissa interval normalization, under writemask."
    vendor_syntax {
      mnemonic: "VGETMANTPD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F3A.W1 26 /r ib"
    instruction_group_index: 105
  }
  instructions {
    description: "Move quadword from mm to m64 using nontemporal hint."
    vendor_syntax {
      mnemonic: "MOVNTQ"
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "NP 0F E7 /r"
    instruction_group_index: 106
  }
  instructions {
    description: "Load segment selector r/m16 into LDTR."
    vendor_syntax {
      mnemonic: "LLDT"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 00 /2"
    instruction_group_index: 107
  }
  instructions {
    description: "Bitwise AND NOT of mm/m64 and mm."
    vendor_syntax {
      mnemonic: "PANDN"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F DF /r"
    instruction_group_index: 108
  }
  instructions {
    description: "Bitwise AND NOT of xmm2/m128 and xmm1."
    vendor_syntax {
      mnemonic: "PANDN"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F DF /r"
    instruction_group_index: 108
  }
  instructions {
    description: "Bitwise AND NOT of xmm3/m128 and xmm2."
    vendor_syntax {
      mnemonic: "VPANDN"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG DF /r"
    instruction_group_index: 108
  }
  instructions {
    description: "Bitwise AND NOT of ymm2, and ymm3/m256 and store result in ymm1."
    vendor_syntax {
      mnemonic: "VPANDN"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG DF /r"
    instruction_group_index: 108
  }
  instructions {
    description: "Bitwise AND NOT of packed doubleword integers in xmm2 and xmm3/m128/m32bcst and store result in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPANDND"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.W0 DF /r"
    instruction_group_index: 108
  }
  instructions {
    description: "Bitwise AND NOT of packed doubleword integers in ymm2 and ymm3/m256/m32bcst and store result in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPANDND"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.W0 DF /r"
    instruction_group_index: 108
  }
  instructions {
    description: "Bitwise AND NOT of packed doubleword integers in zmm2 and zmm3/m512/m32bcst and store result in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPANDND"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.W0 DF /r"
    instruction_group_index: 108
  }
  instructions {
    description: "Bitwise AND NOT of packed quadword integers in xmm2 and xmm3/m128/m64bcst and store result in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPANDNQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.W1 DF /r"
    instruction_group_index: 108
  }
  instructions {
    description: "Bitwise AND NOT of packed quadword integers in ymm2 and ymm3/m256/m64bcst and store result in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPANDNQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.W1 DF /r"
    instruction_group_index: 108
  }
  instructions {
    description: "Bitwise AND NOT of packed quadword integers in zmm2 and zmm3/m512/m64bcst and store result in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPANDNQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.W1 DF /r"
    instruction_group_index: 108
  }
  instructions {
    description: "Computes the absolute differences of the packed unsigned byte integers from mm2 /m64 and mm1; differences are then summed to produce an unsigned word integer result."
    vendor_syntax {
      mnemonic: "PSADBW"
      operands {
        name: "mm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F F6 /r"
    instruction_group_index: 109
  }
  instructions {
    description: "Computes the absolute differences of the packed unsigned byte integers from xmm2 /m128 and xmm1; the 8 low differences and 8 high differences are then summed separately to produce two unsigned word integer results."
    vendor_syntax {
      mnemonic: "PSADBW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F F6 /r"
    instruction_group_index: 109
  }
  instructions {
    description: "Computes the absolute differences of the packed unsigned byte integers from xmm3 /m128 and xmm2; the 8 low differences and 8 high differences are then summed separately to produce two unsigned word integer results."
    vendor_syntax {
      mnemonic: "VPSADBW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG F6 /r"
    instruction_group_index: 109
  }
  instructions {
    description: "Computes the absolute differences of the packed unsigned byte integers from ymm3 /m256 and ymm2; then each consecutive 8 differences are summed separately to produce four unsigned word integer results."
    vendor_syntax {
      mnemonic: "VPSADBW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG F6 /r"
    instruction_group_index: 109
  }
  instructions {
    description: "Computes the absolute differences of the packed unsigned byte integers from xmm3 /m128 and xmm2; then each consecutive 8 differences are summed separately to produce two unsigned word integer results."
    vendor_syntax {
      mnemonic: "VPSADBW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.WIG F6 /r"
    instruction_group_index: 109
  }
  instructions {
    description: "Computes the absolute differences of the packed unsigned byte integers from ymm3 /m256 and ymm2; then each consecutive 8 differences are summed separately to produce four unsigned word integer results."
    vendor_syntax {
      mnemonic: "VPSADBW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.WIG F6 /r"
    instruction_group_index: 109
  }
  instructions {
    description: "Computes the absolute differences of the packed unsigned byte integers from zmm3 /m512 and zmm2; then each consecutive 8 differences are summed separately to produce eight unsigned word integer results."
    vendor_syntax {
      mnemonic: "VPSADBW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.WIG F6 /r"
    instruction_group_index: 109
  }
  instructions {
    description: "Store selected bit in CF flag."
    vendor_syntax {
      mnemonic: "BT"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "0F A3 /r"
    instruction_group_index: 110
  }
  instructions {
    description: "Store selected bit in CF flag."
    vendor_syntax {
      mnemonic: "BT"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "0F A3 /r"
    instruction_group_index: 110
  }
  instructions {
    description: "Store selected bit in CF flag."
    vendor_syntax {
      mnemonic: "BT"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MR"
    raw_encoding_specification: "REX.W + 0F A3 /r"
    instruction_group_index: 110
  }
  instructions {
    description: "Store selected bit in CF flag."
    vendor_syntax {
      mnemonic: "BT"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "0F BA /4 ib"
    instruction_group_index: 110
  }
  instructions {
    description: "Store selected bit in CF flag."
    vendor_syntax {
      mnemonic: "BT"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "0F BA /4 ib"
    instruction_group_index: 110
  }
  instructions {
    description: "Store selected bit in CF flag."
    vendor_syntax {
      mnemonic: "BT"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX.W + 0F BA /4 ib"
    instruction_group_index: 110
  }
  instructions {
    description: "Add packed single-precision floating-point values from xmm2/m128 to xmm1 and store result in xmm1."
    vendor_syntax {
      mnemonic: "ADDPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 58 /r"
    instruction_group_index: 111
  }
  instructions {
    description: "Add packed single-precision floating-point values from xmm3/m128 to xmm2 and store result in xmm1."
    vendor_syntax {
      mnemonic: "VADDPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.0F.WIG 58 /r"
    instruction_group_index: 111
  }
  instructions {
    description: "Add packed single-precision floating-point values from ymm3/m256 to ymm2 and store result in ymm1."
    vendor_syntax {
      mnemonic: "VADDPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.0F.WIG 58 /r"
    instruction_group_index: 111
  }
  instructions {
    description: "Add packed single-precision floating-point values from xmm3/m128/m32bcst to xmm2 and store result in xmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VADDPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.0F.W0 58 /r"
    instruction_group_index: 111
  }
  instructions {
    description: "Add packed single-precision floating-point values from ymm3/m256/m32bcst to ymm2 and store result in ymm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VADDPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.0F.W0 58 /r"
    instruction_group_index: 111
  }
  instructions {
    description: "Add packed single-precision floating-point values from zmm3/m512/m32bcst to zmm2 and store result in zmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VADDPS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.0F.W0 58 /r"
    instruction_group_index: 111
  }
  instructions {
    description: "Shift words in mm right by mm/m64 while shifting in sign bits."
    vendor_syntax {
      mnemonic: "PSRAW"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F E1 /r"
    instruction_group_index: 112
  }
  instructions {
    description: "Shift words in xmm1 right by xmm2/m128 while shifting in sign bits."
    vendor_syntax {
      mnemonic: "PSRAW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F E1 /r"
    instruction_group_index: 112
  }
  instructions {
    description: "Shift words in mm right by imm8 while shifting in sign bits"
    vendor_syntax {
      mnemonic: "PSRAW"
      operands {
        name: "mm"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "NP 0F 71 /4 ib"
    instruction_group_index: 112
  }
  instructions {
    description: "Shift words in xmm1 right by imm8 while shifting in sign bits"
    vendor_syntax {
      mnemonic: "PSRAW"
      operands {
        name: "xmm1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "66 0F 71 /4 ib"
    instruction_group_index: 112
  }
  instructions {
    description: "Shift doublewords in mm right by mm/m64 while shifting in sign bits."
    vendor_syntax {
      mnemonic: "PSRAD"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F E2 /r"
    instruction_group_index: 112
  }
  instructions {
    description: "Shift doubleword in xmm1 right by xmm2 /m128 while shifting in sign bits."
    vendor_syntax {
      mnemonic: "PSRAD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F E2 /r"
    instruction_group_index: 112
  }
  instructions {
    description: "Shift doublewords in mm right by imm8 while shifting in sign bits."
    vendor_syntax {
      mnemonic: "PSRAD"
      operands {
        name: "mm"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "NP 0F 72 /4 ib"
    instruction_group_index: 112
  }
  instructions {
    description: "Shift doublewords in xmm1 right by imm8 while shifting in sign bits."
    vendor_syntax {
      mnemonic: "PSRAD"
      operands {
        name: "xmm1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "66 0F 72 /4 ib"
    instruction_group_index: 112
  }
  instructions {
    description: "Shift words in xmm2 right by amount specified in xmm3/m128 while shifting in sign bits."
    vendor_syntax {
      mnemonic: "VPSRAW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "VEX.128.66.0F.WIG E1 /r"
    instruction_group_index: 112
  }
  instructions {
    description: "Shift words in xmm2 right by imm8 while shifting in sign bits."
    vendor_syntax {
      mnemonic: "VPSRAW"
      operands {
        name: "xmm1"
        encoding: VEX_V_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "VEX.128.66.0F.WIG 71 /4 ib"
    instruction_group_index: 112
  }
  instructions {
    description: "Shift doublewords in xmm2 right by amount specified in xmm3/m128 while shifting in sign bits."
    vendor_syntax {
      mnemonic: "VPSRAD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "VEX.128.66.0F.WIG E2 /r"
    instruction_group_index: 112
  }
  instructions {
    description: "Shift doublewords in xmm2 right by imm8 while shifting in sign bits."
    vendor_syntax {
      mnemonic: "VPSRAD"
      operands {
        name: "xmm1"
        encoding: VEX_V_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "VEX.128.66.0F.WIG 72 /4 ib"
    instruction_group_index: 112
  }
  instructions {
    description: "Shift words in ymm2 right by amount specified in xmm3/m128 while shifting in sign bits."
    vendor_syntax {
      mnemonic: "VPSRAW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "VEX.256.66.0F.WIG E1 /r"
    instruction_group_index: 112
  }
  instructions {
    description: "Shift words in ymm2 right by imm8 while shifting in sign bits."
    vendor_syntax {
      mnemonic: "VPSRAW"
      operands {
        name: "ymm1"
        encoding: VEX_V_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "VEX.256.66.0F.WIG 71 /4 ib"
    instruction_group_index: 112
  }
  instructions {
    description: "Shift doublewords in ymm2 right by amount specified in xmm3/m128 while shifting in sign bits."
    vendor_syntax {
      mnemonic: "VPSRAD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "VEX.256.66.0F.WIG E2 /r"
    instruction_group_index: 112
  }
  instructions {
    description: "Shift doublewords in ymm2 right by imm8 while shifting in sign bits."
    vendor_syntax {
      mnemonic: "VPSRAD"
      operands {
        name: "ymm1"
        encoding: VEX_V_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "VEX.256.66.0F.WIG 72 /4 ib"
    instruction_group_index: 112
  }
  instructions {
    description: "Shift words in xmm2 right by amount specified in xmm3/m128 while shifting in sign bits using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRAW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "G"
    raw_encoding_specification: "EVEX.128.66.0F.WIG E1 /r"
    instruction_group_index: 112
  }
  instructions {
    description: "Shift words in ymm2 right by amount specified in xmm3/m128 while shifting in sign bits using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRAW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "G"
    raw_encoding_specification: "EVEX.256.66.0F.WIG E1 /r"
    instruction_group_index: 112
  }
  instructions {
    description: "Shift words in zmm2 right by amount specified in xmm3/m128 while shifting in sign bits using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRAW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "G"
    raw_encoding_specification: "EVEX.512.66.0F.WIG E1 /r"
    instruction_group_index: 112
  }
  instructions {
    description: "Shift words in xmm2/m128 right by imm8 while shifting in sign bits using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRAW"
      operands {
        name: "xmm1"
        encoding: VEX_V_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "E"
    raw_encoding_specification: "EVEX.128.66.0F.WIG 71 /4 ib"
    instruction_group_index: 112
  }
  instructions {
    description: "Shift words in ymm2/m256 right by imm8 while shifting in sign bits using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRAW"
      operands {
        name: "ymm1"
        encoding: VEX_V_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "E"
    raw_encoding_specification: "EVEX.256.66.0F.WIG 71 /4 ib"
    instruction_group_index: 112
  }
  instructions {
    description: "Shift words in zmm2/m512 right by imm8 while shifting in sign bits using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRAW"
      operands {
        name: "zmm1"
        encoding: VEX_V_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "E"
    raw_encoding_specification: "EVEX.512.66.0F.WIG 71 /4 ib"
    instruction_group_index: 112
  }
  instructions {
    description: "Shift doublewords in xmm2 right by amount specified in xmm3/m128 while shifting in sign bits using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRAD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "G"
    raw_encoding_specification: "EVEX.128.66.0F.W0 E2 /r"
    instruction_group_index: 112
  }
  instructions {
    description: "Shift doublewords in ymm2 right by amount specified in xmm3/m128 while shifting in sign bits using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRAD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "G"
    raw_encoding_specification: "EVEX.256.66.0F.W0 E2 /r"
    instruction_group_index: 112
  }
  instructions {
    description: "Shift doublewords in zmm2 right by amount specified in xmm3/m128 while shifting in sign bits using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRAD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "G"
    raw_encoding_specification: "EVEX.512.66.0F.W0 E2 /r"
    instruction_group_index: 112
  }
  instructions {
    description: "Shift doublewords in xmm2/m128/m32bcst right by imm8 while shifting in sign bits using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRAD"
      operands {
        name: "xmm1"
        encoding: VEX_V_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "F"
    raw_encoding_specification: "EVEX.128.66.0F.W0 72 /4 ib"
    instruction_group_index: 112
  }
  instructions {
    description: "Shift doublewords in ymm2/m256/m32bcst right by imm8 while shifting in sign bits using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRAD"
      operands {
        name: "ymm1"
        encoding: VEX_V_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "F"
    raw_encoding_specification: "EVEX.256.66.0F.W0 72 /4 ib"
    instruction_group_index: 112
  }
  instructions {
    description: "Shift doublewords in zmm2/m512/m32bcst right by imm8 while shifting in sign bits using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRAD"
      operands {
        name: "zmm1"
        encoding: VEX_V_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "F"
    raw_encoding_specification: "EVEX.512.66.0F.W0 72 /4 ib"
    instruction_group_index: 112
  }
  instructions {
    description: "Shift quadwords in xmm2 right by amount specified in xmm3/m128 while shifting in sign bits using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRAQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "G"
    raw_encoding_specification: "EVEX.128.66.0F.W1 E2 /r"
    instruction_group_index: 112
  }
  instructions {
    description: "Shift quadwords in ymm2 right by amount specified in xmm3/m128 while shifting in sign bits using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRAQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "G"
    raw_encoding_specification: "EVEX.256.66.0F.W1 E2 /r"
    instruction_group_index: 112
  }
  instructions {
    description: "Shift quadwords in zmm2 right by amount specified in xmm3/m128 while shifting in sign bits using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRAQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "G"
    raw_encoding_specification: "EVEX.512.66.0F.W1 E2 /r"
    instruction_group_index: 112
  }
  instructions {
    description: "Shift quadwords in xmm2/m128/m64bcst right by imm8 while shifting in sign bits using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRAQ"
      operands {
        name: "xmm1"
        encoding: VEX_V_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "F"
    raw_encoding_specification: "EVEX.128.66.0F.W1 72 /4 ib"
    instruction_group_index: 112
  }
  instructions {
    description: "Shift quadwords in ymm2/m256/m64bcst right by imm8 while shifting in sign bits using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRAQ"
      operands {
        name: "ymm1"
        encoding: VEX_V_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "F"
    raw_encoding_specification: "EVEX.256.66.0F.W1 72 /4 ib"
    instruction_group_index: 112
  }
  instructions {
    description: "Shift quadwords in zmm2/m512/m64bcst right by imm8 while shifting in sign bits using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRAQ"
      operands {
        name: "zmm1"
        encoding: VEX_V_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "F"
    raw_encoding_specification: "EVEX.512.66.0F.W1 72 /4 ib"
    instruction_group_index: 112
  }
  instructions {
    description: "Check if r16 (array index) is within bounds specified by m16&16."
    vendor_syntax {
      mnemonic: "BOUND"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "m16&16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "62 /r"
    instruction_group_index: 113
  }
  instructions {
    description: "Check if r32 (array index) is within bounds specified by m32&32."
    vendor_syntax {
      mnemonic: "BOUND"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "m32&32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "62 /r"
    instruction_group_index: 113
  }
  instructions {
    description: "Pop DI, SI, BP, BX, DX, CX, and AX."
    vendor_syntax {
      mnemonic: "POPA"
    }
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "61"
    instruction_group_index: 114
  }
  instructions {
    description: "Pop EDI, ESI, EBP, EBX, EDX, ECX, and EAX."
    vendor_syntax {
      mnemonic: "POPAD"
    }
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "61"
    instruction_group_index: 114
  }
  instructions {
    description: "Subtract the low double-precision floating-point value in xmm2/m64 from xmm1 and store the result in xmm1."
    vendor_syntax {
      mnemonic: "SUBSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F2 0F 5C /r"
    instruction_group_index: 115
  }
  instructions {
    description: "Subtract the low double-precision floating-point value in xmm3/m64 from xmm2 and store the result in xmm1."
    vendor_syntax {
      mnemonic: "VSUBSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.LIG.F2.0F.WIG 5C /r"
    instruction_group_index: 115
  }
  instructions {
    description: "Subtract the low double-precision floating-point value in xmm3/m64 from xmm2 and store the result in xmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VSUBSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.LIG.F2.0F.W1 5C /r"
    instruction_group_index: 115
  }
  instructions {
    description: "Return the maximum single-precision floating-point values between xmm1 and xmm2/mem."
    vendor_syntax {
      mnemonic: "MAXPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 5F /r"
    instruction_group_index: 116
  }
  instructions {
    description: "Return the maximum single-precision floating-point values between xmm2 and xmm3/mem."
    vendor_syntax {
      mnemonic: "VMAXPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.0F.WIG 5F /r"
    instruction_group_index: 116
  }
  instructions {
    description: "Return the maximum single-precision floating-point values between ymm2 and ymm3/mem."
    vendor_syntax {
      mnemonic: "VMAXPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.0F.WIG 5F /r"
    instruction_group_index: 116
  }
  instructions {
    description: "Return the maximum packed single-precision floating-point values between xmm2 and xmm3/m128/m32bcst and store result in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VMAXPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.0F.W0 5F /r"
    instruction_group_index: 116
  }
  instructions {
    description: "Return the maximum packed single-precision floating-point values between ymm2 and ymm3/m256/m32bcst and store result in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VMAXPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.0F.W0 5F /r"
    instruction_group_index: 116
  }
  instructions {
    description: "Return the maximum packed single-precision floating-point values between zmm2 and zmm3/m512/m32bcst and store result in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VMAXPS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.0F.W0 5F /r"
    instruction_group_index: 116
  }
  instructions {
    description: "Shuffle the words in mm2/m64 based on the encoding in imm8 and store the result in mm1."
    vendor_syntax {
      mnemonic: "PSHUFW"
      operands {
        name: "mm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "mm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMI"
    raw_encoding_specification: "NP 0F 70 /r ib"
    instruction_group_index: 117
  }
  instructions {
    description: "Fast return to privilege level 3 user code."
    vendor_syntax {
      mnemonic: "SYSEXIT"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "0F 35"
    instruction_group_index: 118
  }
  instructions {
    description: "Fast return to 64-bit mode privilege level 3 user code."
    vendor_syntax {
      mnemonic: "SYSEXIT"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "REX.W + 0F 35"
    instruction_group_index: 118
  }
  instructions {
    description: "Horizontal subtract packed double-precision floating-point values from xmm2/m128 to xmm1."
    vendor_syntax {
      mnemonic: "HSUBPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "66 0F 7D /r"
    instruction_group_index: 119
  }
  instructions {
    description: "Horizontal subtract packed double-precision floating-point values from xmm2 and xmm3/mem."
    vendor_syntax {
      mnemonic: "VHSUBPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.128.66.0F.WIG 7D /r"
    instruction_group_index: 119
  }
  instructions {
    description: "Horizontal subtract packed double-precision floating-point values from ymm2 and ymm3/mem."
    vendor_syntax {
      mnemonic: "VHSUBPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.256.66.0F.WIG 7D /r"
    instruction_group_index: 119
  }
  instructions {
    description: "Divide low double-precision floating-point value in xmm1 by low double-precision floating-point value in xmm2/m64."
    vendor_syntax {
      mnemonic: "DIVSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F2 0F 5E /r"
    instruction_group_index: 120
  }
  instructions {
    description: "Divide low double-precision floating-point value in xmm2 by low double-precision floating-point value in xmm3/m64."
    vendor_syntax {
      mnemonic: "VDIVSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.LIG.F2.0F.WIG 5E /r"
    instruction_group_index: 120
  }
  instructions {
    description: "Divide low double-precision floating-point value in xmm2 by low double-precision floating-point value in xmm3/m64."
    vendor_syntax {
      mnemonic: "VDIVSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.LIG.F2.0F.W1 5E /r"
    instruction_group_index: 120
  }
  instructions {
    description: "Multiply groups of 2 pairs of signed words in xmm3/m128/m32bcst with corresponding signed words of xmm2, summing those products and adding them to doubleword result in xmm1, with signed saturation, under writemask k1."
    vendor_syntax {
      mnemonic: "VPDPWSSDS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VNNI && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 53 /r"
    instruction_group_index: 121
  }
  instructions {
    description: "Multiply groups of 2 pairs of signed words in ymm3/m256/m32bcst with corresponding signed words of ymm2, summing those products and adding them to doubleword result in ymm1, with signed saturation, under writemask k1."
    vendor_syntax {
      mnemonic: "VPDPWSSDS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VNNI && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 53 /r"
    instruction_group_index: 121
  }
  instructions {
    description: "Multiply groups of 2 pairs of signed words in zmm3/m512/m32bcst with corresponding signed words of zmm2, summing those products and adding them to doubleword result in zmm1, with signed saturation, under writemask k1."
    vendor_syntax {
      mnemonic: "VPDPWSSDS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VNNI"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 53 /r"
    instruction_group_index: 121
  }
  instructions {
    description: "Shuffle the high words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1."
    vendor_syntax {
      mnemonic: "PSHUFHW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F3 0F 70 /r ib"
    instruction_group_index: 122
  }
  instructions {
    description: "Shuffle the high words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1."
    vendor_syntax {
      mnemonic: "VPSHUFHW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.F3.0F.WIG 70 /r ib"
    instruction_group_index: 122
  }
  instructions {
    description: "Shuffle the high words in ymm2/m256 based on the encoding in imm8 and store the result in ymm1."
    vendor_syntax {
      mnemonic: "VPSHUFHW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.F3.0F.WIG 70 /r ib"
    instruction_group_index: 122
  }
  instructions {
    description: "Shuffle the high words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1 under write mask k1."
    vendor_syntax {
      mnemonic: "VPSHUFHW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.F3.0F.WIG 70 /r ib"
    instruction_group_index: 122
  }
  instructions {
    description: "Shuffle the high words in ymm2/m256 based on the encoding in imm8 and store the result in ymm1 under write mask k1."
    vendor_syntax {
      mnemonic: "VPSHUFHW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.F3.0F.WIG 70 /r ib"
    instruction_group_index: 122
  }
  instructions {
    description: "Shuffle the high words in zmm2/m512 based on the encoding in imm8 and store the result in zmm1 under write mask k1."
    vendor_syntax {
      mnemonic: "VPSHUFHW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.F3.0F.WIG 70 /r ib"
    instruction_group_index: 122
  }
  instructions {
    description: "Interrupt return (16-bit operand size)."
    vendor_syntax {
      mnemonic: "IRET"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "CF"
    instruction_group_index: 123
  }
  instructions {
    description: "Interrupt return (32-bit operand size)."
    vendor_syntax {
      mnemonic: "IRETD"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "CF"
    instruction_group_index: 123
  }
  instructions {
    description: "Interrupt return (64-bit operand size)."
    vendor_syntax {
      mnemonic: "IRETQ"
    }
    available_in_64_bit: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "REX.W + CF"
    instruction_group_index: 123
  }
  instructions {
    description: "Selectively multiply packed SP floating-point values from xmm1 with packed SP floatingpoint values from xmm2, add and selectively store the packed SP floating-point values or zero values to xmm1."
    vendor_syntax {
      mnemonic: "DPPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMI"
    raw_encoding_specification: "66 0F 3A 40 /r ib"
    instruction_group_index: 124
  }
  instructions {
    description: "Multiply packed SP floating point values from xmm1 with packed SP floating point values from xmm2/mem selectively add and store to xmm1."
    vendor_syntax {
      mnemonic: "VDPPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVMI"
    raw_encoding_specification: "VEX.128.66.0F3A.WIG 40 /r ib"
    instruction_group_index: 124
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from ymm2 with packed SP floating point values from ymm3/mem, selectively add pairs of elements and store to ymm1."
    vendor_syntax {
      mnemonic: "VDPPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVMI"
    raw_encoding_specification: "VEX.256.66.0F3A.WIG 40 /r ib"
    instruction_group_index: 124
  }
  instructions {
    description: "Compare packed signed byte integers in mm and mm/m64 for greater than."
    vendor_syntax {
      mnemonic: "PCMPGTB"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 64 /r"
    instruction_group_index: 125
  }
  instructions {
    description: "Compare packed signed byte integers in xmm1 and xmm2/m128 for greater than."
    vendor_syntax {
      mnemonic: "PCMPGTB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 64 /r"
    instruction_group_index: 125
  }
  instructions {
    description: "Compare packed signed word integers in mm and mm/m64 for greater than."
    vendor_syntax {
      mnemonic: "PCMPGTW"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 65 /r"
    instruction_group_index: 125
  }
  instructions {
    description: "Compare packed signed word integers in xmm1 and xmm2/m128 for greater than."
    vendor_syntax {
      mnemonic: "PCMPGTW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 65 /r"
    instruction_group_index: 125
  }
  instructions {
    description: "Compare packed signed doubleword integers in mm and mm/m64 for greater than."
    vendor_syntax {
      mnemonic: "PCMPGTD"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 66 /r"
    instruction_group_index: 125
  }
  instructions {
    description: "Compare packed signed doubleword integers in xmm1 and xmm2/m128 for greater than."
    vendor_syntax {
      mnemonic: "PCMPGTD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 66 /r"
    instruction_group_index: 125
  }
  instructions {
    description: "Compare packed signed byte integers in xmm2 and xmm3/m128 for greater than."
    vendor_syntax {
      mnemonic: "VPCMPGTB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG 64 /r"
    instruction_group_index: 125
  }
  instructions {
    description: "Compare packed signed word integers in xmm2 and xmm3/m128 for greater than."
    vendor_syntax {
      mnemonic: "VPCMPGTW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG 65 /r"
    instruction_group_index: 125
  }
  instructions {
    description: "Compare packed signed doubleword integers in xmm2 and xmm3/m128 for greater than."
    vendor_syntax {
      mnemonic: "VPCMPGTD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG 66 /r"
    instruction_group_index: 125
  }
  instructions {
    description: "Compare packed signed byte integers in ymm2 and ymm3/m256 for greater than."
    vendor_syntax {
      mnemonic: "VPCMPGTB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG 64 /r"
    instruction_group_index: 125
  }
  instructions {
    description: "Compare packed signed word integers in ymm2 and ymm3/m256 for greater than."
    vendor_syntax {
      mnemonic: "VPCMPGTW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG 65 /r"
    instruction_group_index: 125
  }
  instructions {
    description: "Compare packed signed doubleword integers in ymm2 and ymm3/m256 for greater than."
    vendor_syntax {
      mnemonic: "VPCMPGTD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG 66 /r"
    instruction_group_index: 125
  }
  instructions {
    description: "Compare Greater between int32 vector xmm2 and int32 vector xmm3/m128/m32bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
    vendor_syntax {
      mnemonic: "VPCMPGTD"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.W0 66 /r"
    instruction_group_index: 125
  }
  instructions {
    description: "Compare Greater between int32 vector ymm2 and int32 vector ymm3/m256/m32bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
    vendor_syntax {
      mnemonic: "VPCMPGTD"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.W0 66 /r"
    instruction_group_index: 125
  }
  instructions {
    description: "Compare Greater between int32 elements in zmm2 and zmm3/m512/m32bcst, and set destination k1 according to the comparison results under writemask. k2."
    vendor_syntax {
      mnemonic: "VPCMPGTD"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.W0 66 /r"
    instruction_group_index: 125
  }
  instructions {
    description: "Compare packed signed byte integers in xmm2 and xmm3/m128 for greater than, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
    vendor_syntax {
      mnemonic: "VPCMPGTB"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.128.66.0F.WIG 64 /r"
    instruction_group_index: 125
  }
  instructions {
    description: "Compare packed signed byte integers in ymm2 and ymm3/m256 for greater than, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
    vendor_syntax {
      mnemonic: "VPCMPGTB"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.256.66.0F.WIG 64 /r"
    instruction_group_index: 125
  }
  instructions {
    description: "Compare packed signed byte integers in zmm2 and zmm3/m512 for greater than, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
    vendor_syntax {
      mnemonic: "VPCMPGTB"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.66.0F.WIG 64 /r"
    instruction_group_index: 125
  }
  instructions {
    description: "Compare packed signed word integers in xmm2 and xmm3/m128 for greater than, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
    vendor_syntax {
      mnemonic: "VPCMPGTW"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.128.66.0F.WIG 65 /r"
    instruction_group_index: 125
  }
  instructions {
    description: "Compare packed signed word integers in ymm2 and ymm3/m256 for greater than, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
    vendor_syntax {
      mnemonic: "VPCMPGTW"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.256.66.0F.WIG 65 /r"
    instruction_group_index: 125
  }
  instructions {
    description: "Compare packed signed word integers in zmm2 and zmm3/m512 for greater than, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
    vendor_syntax {
      mnemonic: "VPCMPGTW"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.66.0F.WIG 65 /r"
    instruction_group_index: 125
  }
  instructions {
    description: "Generate a #BR if the address in r/m32 is lower than the lower bound in bnd.LB."
    vendor_syntax {
      mnemonic: "BNDCL"
      operands {
        name: "bnd"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MPX"
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "F3 0F 1A /r"
    instruction_group_index: 126
  }
  instructions {
    description: "Generate a #BR if the address in r/m64 is lower than the lower bound in bnd.LB."
    vendor_syntax {
      mnemonic: "BNDCL"
      operands {
        name: "bnd"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MPX"
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "F3 0F 1A /r"
    instruction_group_index: 126
  }
  instructions {
    description: "Parallel deposit of bits from r32b using mask in r/m32, result is written to r32a."
    vendor_syntax {
      mnemonic: "PDEP"
      operands {
        name: "r32a"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r32b"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "BMI2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.LZ.F2.0F38.W0 F5 /r"
    instruction_group_index: 127
  }
  instructions {
    description: "Parallel deposit of bits from r64b using mask in r/m64, result is written to r64a."
    vendor_syntax {
      mnemonic: "PDEP"
      operands {
        name: "r64a"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r64b"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "BMI2"
    available_in_64_bit: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.LZ.F2.0F38.W1 F5 /r"
    instruction_group_index: 127
  }
  instructions {
    description: "Multiplies elements in the finite field GF(2^8)."
    vendor_syntax {
      mnemonic: "GF2P8MULB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "GFNI"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F38 CF /r"
    instruction_group_index: 128
  }
  instructions {
    description: "Multiplies elements in the finite field GF(2^8)."
    vendor_syntax {
      mnemonic: "VGF2P8MULB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX && GFNI"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F38.W0 CF /r"
    instruction_group_index: 128
  }
  instructions {
    description: "Multiplies elements in the finite field GF(2^8)."
    vendor_syntax {
      mnemonic: "VGF2P8MULB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX && GFNI"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F38.W0 CF /r"
    instruction_group_index: 128
  }
  instructions {
    description: "Multiplies elements in the finite field GF(2^8)."
    vendor_syntax {
      mnemonic: "VGF2P8MULB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && GFNI"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 CF /r"
    instruction_group_index: 128
  }
  instructions {
    description: "Multiplies elements in the finite field GF(2^8)."
    vendor_syntax {
      mnemonic: "VGF2P8MULB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && GFNI"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 CF /r"
    instruction_group_index: 128
  }
  instructions {
    description: "Multiplies elements in the finite field GF(2^8)."
    vendor_syntax {
      mnemonic: "VGF2P8MULB"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F && GFNI"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 CF /r"
    instruction_group_index: 128
  }
  instructions {
    description: "Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128."
    vendor_syntax {
      mnemonic: "AESDECLAST"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AES"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 38 DF /r"
    instruction_group_index: 129
  }
  instructions {
    description: "Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm2 with a 128-bit round key from xmm3/m128; store the result in xmm1."
    vendor_syntax {
      mnemonic: "VAESDECLAST"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AES && AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F38.WIG DF /r"
    instruction_group_index: 129
  }
  instructions {
    description: "Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from ymm2 with a 128-bit round key from ymm3/m256; store the result in ymm1."
    vendor_syntax {
      mnemonic: "VAESDECLAST"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "VAES"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "VEX.256.66.0F38.WIG DF /r"
    instruction_group_index: 129
  }
  instructions {
    description: "Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm2 with a 128-bit round key from xmm3/m128; store the result in xmm1."
    vendor_syntax {
      mnemonic: "VAESDECLAST"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "VAES && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.128.66.0F38.WIG DF /r"
    instruction_group_index: 129
  }
  instructions {
    description: "Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from ymm2 with a 128-bit round key from ymm3/m256; store the result in ymm1."
    vendor_syntax {
      mnemonic: "VAESDECLAST"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "VAES && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.256.66.0F38.WIG DF /r"
    instruction_group_index: 129
  }
  instructions {
    description: "Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from zmm2 with a 128-bit round key from zmm3/m512; store the result in zmm1."
    vendor_syntax {
      mnemonic: "VAESDECLAST"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "VAES && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.66.0F38.WIG DF /r"
    instruction_group_index: 129
  }
  instructions {
    description: "Near return to calling procedure."
    vendor_syntax {
      mnemonic: "RET"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "C3"
    instruction_group_index: 130
  }
  instructions {
    description: "Far return to calling procedure."
    vendor_syntax {
      mnemonic: "RET"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "CB"
    instruction_group_index: 130
  }
  instructions {
    description: "Near return to calling procedure and pop imm16 bytes from stack."
    vendor_syntax {
      mnemonic: "RET"
      operands {
        name: "imm16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "I"
    raw_encoding_specification: "C2 iw"
    instruction_group_index: 130
  }
  instructions {
    description: "Far return to calling procedure and pop imm16 bytes from stack."
    vendor_syntax {
      mnemonic: "RET"
      operands {
        name: "imm16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "I"
    raw_encoding_specification: "CA iw"
    instruction_group_index: 130
  }
  instructions {
    description: "Move quadword from mmx to low quadword of xmm."
    vendor_syntax {
      mnemonic: "MOVQ2DQ"
      operands {
        name: "xmm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "mm"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "F3 0F D6 /r"
    instruction_group_index: 131
  }
  instructions {
    description: "Broadcast single-precision floating-point element in mem to four locations in xmm1."
    vendor_syntax {
      mnemonic: "VBROADCASTSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W0 18 /r"
    instruction_group_index: 132
  }
  instructions {
    description: "Broadcast single-precision floating-point element in mem to eight locations in ymm1."
    vendor_syntax {
      mnemonic: "VBROADCASTSS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W0 18 /r"
    instruction_group_index: 132
  }
  instructions {
    description: "Broadcast double-precision floating-point element in mem to four locations in ymm1."
    vendor_syntax {
      mnemonic: "VBROADCASTSD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W0 19 /r"
    instruction_group_index: 132
  }
  instructions {
    description: "Broadcast 128 bits of floating-point data in mem to low and high 128-bits in ymm1."
    vendor_syntax {
      mnemonic: "VBROADCASTF128"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W0 1A /r"
    instruction_group_index: 132
  }
  instructions {
    description: "Broadcast the low single-precision floating-point element in the source operand to four locations in xmm1."
    vendor_syntax {
      mnemonic: "VBROADCASTSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W0 18/r"
    instruction_group_index: 132
  }
  instructions {
    description: "Broadcast low single-precision floating-point element in the source operand to eight locations in ymm1."
    vendor_syntax {
      mnemonic: "VBROADCASTSS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W0 18 /r"
    instruction_group_index: 132
  }
  instructions {
    description: "Broadcast low double-precision floating-point element in the source operand to four locations in ymm1."
    vendor_syntax {
      mnemonic: "VBROADCASTSD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W0 19 /r"
    instruction_group_index: 132
  }
  instructions {
    description: "Broadcast low double-precision floating-point element in xmm2/m64 to four locations in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VBROADCASTSD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 19 /r"
    instruction_group_index: 132
  }
  instructions {
    description: "Broadcast low double-precision floating-point element in xmm2/m64 to eight locations in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VBROADCASTSD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 19 /r"
    instruction_group_index: 132
  }
  instructions {
    description: "Broadcast two single-precision floating-point elements in xmm2/m64 to locations in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VBROADCASTF32X2"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 19 /r"
    instruction_group_index: 132
  }
  instructions {
    description: "Broadcast two single-precision floating-point elements in xmm2/m64 to locations in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VBROADCASTF32X2"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 19 /r"
    instruction_group_index: 132
  }
  instructions {
    description: "Broadcast low single-precision floating-point element in xmm2/m32 to all locations in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VBROADCASTSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 18 /r"
    instruction_group_index: 132
  }
  instructions {
    description: "Broadcast low single-precision floating-point element in xmm2/m32 to all locations in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VBROADCASTSS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 18 /r"
    instruction_group_index: 132
  }
  instructions {
    description: "Broadcast low single-precision floating-point element in xmm2/m32 to all locations in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VBROADCASTSS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 18 /r"
    instruction_group_index: 132
  }
  instructions {
    description: "Broadcast 128 bits of 4 single-precision floating-point data in mem to locations in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VBROADCASTF32X4"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 1A /r"
    instruction_group_index: 132
  }
  instructions {
    description: "Broadcast 128 bits of 4 single-precision floating-point data in mem to locations in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VBROADCASTF32X4"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 1A /r"
    instruction_group_index: 132
  }
  instructions {
    description: "Broadcast 128 bits of 2 double-precision floating-point data in mem to locations in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VBROADCASTF64X2"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 1A /r"
    instruction_group_index: 132
  }
  instructions {
    description: "Broadcast 128 bits of 2 double-precision floating-point data in mem to locations in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VBROADCASTF64X2"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 1A /r"
    instruction_group_index: 132
  }
  instructions {
    description: "Broadcast 256 bits of 8 single-precision floating-point data in mem to locations in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VBROADCASTF32X8"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "E"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 1B /r"
    instruction_group_index: 132
  }
  instructions {
    description: "Broadcast 256 bits of 4 double-precision floating-point data in mem to locations in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VBROADCASTF64X4"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 1B /r"
    instruction_group_index: 132
  }
  instructions {
    description: "Blend byte integer vector xmm2 and byte vector xmm3/m128 and store the result in xmm1, under control mask."
    vendor_syntax {
      mnemonic: "VPBLENDMB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 66 /r"
    instruction_group_index: 133
  }
  instructions {
    description: "Blend byte integer vector ymm2 and byte vector ymm3/m256 and store the result in ymm1, under control mask."
    vendor_syntax {
      mnemonic: "VPBLENDMB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 66 /r"
    instruction_group_index: 133
  }
  instructions {
    description: "Blend byte integer vector zmm2 and byte vector zmm3/m512 and store the result in zmm1, under control mask."
    vendor_syntax {
      mnemonic: "VPBLENDMB"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 66 /r"
    instruction_group_index: 133
  }
  instructions {
    description: "Blend word integer vector xmm2 and word vector xmm3/m128 and store the result in xmm1, under control mask."
    vendor_syntax {
      mnemonic: "VPBLENDMW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 66 /r"
    instruction_group_index: 133
  }
  instructions {
    description: "Blend word integer vector ymm2 and word vector ymm3/m256 and store the result in ymm1, under control mask."
    vendor_syntax {
      mnemonic: "VPBLENDMW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 66 /r"
    instruction_group_index: 133
  }
  instructions {
    description: "Blend word integer vector zmm2 and word vector zmm3/m512 and store the result in zmm1, under control mask."
    vendor_syntax {
      mnemonic: "VPBLENDMW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 66 /r"
    instruction_group_index: 133
  }
  instructions {
    description: "Read MSR specified by ECX into EDX:EAX."
    vendor_syntax {
      mnemonic: "RDMSR"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "0F 32"
    instruction_group_index: 134
  }
  instructions {
    description: "Using signed dword indices, prefetch sparse byte memory locations containing single-precision data using opmask k1 and T1 hint."
    vendor_syntax {
      mnemonic: "VGATHERPF1DPS"
      operands {
        name: "vm32z"
        encoding: VSIB_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512PF"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 C6 /2 /vsib"
    instruction_group_index: 135
  }
  instructions {
    description: "Using signed qword indices, prefetch sparse byte memory locations containing single-precision data using opmask k1 and T1 hint."
    vendor_syntax {
      mnemonic: "VGATHERPF1QPS"
      operands {
        name: "vm64z"
        encoding: VSIB_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512PF"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 C7 /2 /vsib"
    instruction_group_index: 135
  }
  instructions {
    description: "Using signed dword indices, prefetch sparse byte memory locations containing double-precision data using opmask k1 and T1 hint."
    vendor_syntax {
      mnemonic: "VGATHERPF1DPD"
      operands {
        name: "vm32y"
        encoding: VSIB_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512PF"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 C6 /2 /vsib"
    instruction_group_index: 135
  }
  instructions {
    description: "Using signed qword indices, prefetch sparse byte memory locations containing double-precision data using opmask k1 and T1 hint."
    vendor_syntax {
      mnemonic: "VGATHERPF1QPD"
      operands {
        name: "vm64z"
        encoding: VSIB_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512PF"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 C7 /2 /vsib"
    instruction_group_index: 135
  }
  instructions {
    description: "This instruction is used to execute non-privileged Intel SGX leaf functions."
    vendor_syntax {
      mnemonic: "ENCLU"
    }
    feature_name: "<UNKNOWN>"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "NP 0F 01 D7"
    instruction_group_index: 136
    leaf_instructions {
      description: "This leaf function retrieves a cryptographic key."
      llvm_mnemonic: "EGETKEY"
      vendor_syntax {
        mnemonic: "EGETKEY"
        operands {
          name: "EAX"
          description: "EGETKEY (In); Return error code (Out)"
          value: "\001"
          encoding: X86_REGISTER_EAX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RBX"
          description: "Address to a KEYREQUEST (In)"
          encoding: X86_REGISTER_RBX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RCX"
          description: "Address of the OUTPUTDATA (In)"
          encoding: X86_REGISTER_RCX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
      }
      feature_name: "SGX1"
      available_in_64_bit: true
      legacy_instruction: true
      encoding_scheme: "IR"
      instruction_group_index: 0
    }
    leaf_instructions {
      description: "This leaf function is used to re-enter an enclave after an interrupt."
      llvm_mnemonic: "ERESUME"
      vendor_syntax {
        mnemonic: "ERESUME"
        operands {
          name: "EAX"
          description: "ERESUME (In)"
          value: "\003"
          encoding: X86_REGISTER_EAX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RBX"
          description: "Address of a TCS (In)"
          encoding: X86_REGISTER_RBX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RCX"
          description: "Address of AEP (In)"
          encoding: X86_REGISTER_RCX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
      }
      feature_name: "SGX1"
      available_in_64_bit: true
      legacy_instruction: true
      encoding_scheme: "IR"
      instruction_group_index: 0
    }
    leaf_instructions {
      description: "This leaf function extends the access rights of an existing EPC page."
      llvm_mnemonic: "EMODPE"
      vendor_syntax {
        mnemonic: "EMODPE"
        operands {
          name: "EAX"
          description: "EMODPE (In)"
          value: "\006"
          encoding: X86_REGISTER_EAX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RBX"
          description: "Address of a SECINFO (In)"
          encoding: X86_REGISTER_RBX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RCX"
          description: "Address of the destination EPC page (In)"
          encoding: X86_REGISTER_RCX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
      }
      feature_name: "SGX2"
      available_in_64_bit: true
      legacy_instruction: true
      encoding_scheme: "IR"
      instruction_group_index: 0
    }
    leaf_instructions {
      description: "This leaf function is used to exit an enclave."
      llvm_mnemonic: "EEXIT"
      vendor_syntax {
        mnemonic: "EEXIT"
        operands {
          name: "EAX"
          description: "EEXIT (In)"
          value: "\004"
          encoding: X86_REGISTER_EAX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RBX"
          description: "Target address outside the enclave (In)"
          encoding: X86_REGISTER_RBX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RCX"
          description: "Address of the current AEP (Out)"
          encoding: X86_REGISTER_RCX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
      }
      feature_name: "SGX1"
      available_in_64_bit: true
      legacy_instruction: true
      encoding_scheme: "IR"
      instruction_group_index: 0
    }
    leaf_instructions {
      description: "This leaf function initializes a dynamically allocated EPC page from another page in the EPC."
      llvm_mnemonic: "EACCEPTCOPY"
      vendor_syntax {
        mnemonic: "EACCEPTCOPY"
        operands {
          name: "EAX"
          description: "EACCEPTCOPY (In); Return Error Code \n(Out)"
          value: "\007"
          encoding: X86_REGISTER_EAX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RBX"
          description: "Address of a SECINFO (In)"
          encoding: X86_REGISTER_RBX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RCX"
          description: "Address of the destina-\ntion EPC page (In)"
          encoding: X86_REGISTER_RCX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RDX"
          description: "Address of the \nsource EPC page (In)"
          encoding: X86_REGISTER_RDX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
      }
      feature_name: "SGX2"
      available_in_64_bit: true
      legacy_instruction: true
      encoding_scheme: "IR"
      instruction_group_index: 0
    }
    leaf_instructions {
      description: "This leaf function is used to enter an enclave."
      llvm_mnemonic: "EENTER"
      vendor_syntax {
        mnemonic: "EENTER"
        operands {
          name: "EAX"
          description: "EENTER (In); Content of RBX.CSSA \n(Out)"
          value: "\002"
          encoding: X86_REGISTER_EAX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RBX"
          description: "Address of a TCS (In)"
          encoding: X86_REGISTER_RBX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RCX"
          description: "Address of AEP (In); Address of IP following EENTER (Out)"
          encoding: X86_REGISTER_RCX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
      }
      feature_name: "SGX1"
      available_in_64_bit: true
      legacy_instruction: true
      encoding_scheme: "IR"
      instruction_group_index: 0
    }
    leaf_instructions {
      description: "This leaf function accepts changes made by system software to an EPC page in the running enclave."
      llvm_mnemonic: "EACCEPT"
      vendor_syntax {
        mnemonic: "EACCEPT"
        operands {
          name: "EAX"
          description: "EACCEPT (In); Return Error Code (Out)"
          value: "\005"
          encoding: X86_REGISTER_EAX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RBX"
          description: "Address of a SECINFO (In)"
          encoding: X86_REGISTER_RBX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RCX"
          description: "Address of the destination EPC page (In)"
          encoding: X86_REGISTER_RCX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
      }
      feature_name: "SGX2"
      available_in_64_bit: true
      legacy_instruction: true
      encoding_scheme: "IR"
      instruction_group_index: 0
    }
    leaf_instructions {
      description: "This leaf function creates a cryptographic report of the enclave."
      llvm_mnemonic: "EREPORT"
      vendor_syntax {
        mnemonic: "EREPORT"
        operands {
          name: "EAX"
          description: "EREPORT (In)"
          value: "\000"
          encoding: X86_REGISTER_EAX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RBX"
          description: "Address of TARGETINFO \n(In)"
          encoding: X86_REGISTER_RBX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RCX"
          description: "Address of REPORTDATA \n(In)"
          encoding: X86_REGISTER_RCX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RDX"
          description: "Address where the REPORT is \nwritten to in an OUTPUTDATA (In)"
          encoding: X86_REGISTER_RDX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
      }
      feature_name: "SGX1"
      available_in_64_bit: true
      legacy_instruction: true
      encoding_scheme: "IR"
      instruction_group_index: 0
    }
  }
  instructions {
    description: "Converts 2 packed quad-word integers from xmm2 into 2 packed double-word integers in xmm1/m128 with truncation subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVQD"
      operands {
        name: "xmm1/m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.F3.0F38.W0 35 /r"
    instruction_group_index: 137
  }
  instructions {
    description: "Converts 2 packed signed quad-word integers from xmm2 into 2 packed signed double-word integers in xmm1/m64 using signed saturation subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVSQD"
      operands {
        name: "xmm1/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.F3.0F38.W0 25 /r"
    instruction_group_index: 137
  }
  instructions {
    description: "Converts 2 packed unsigned quad-word integers from xmm2 into 2 packed unsigned double-word integers in xmm1/m64 using unsigned saturation subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVUSQD"
      operands {
        name: "xmm1/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.F3.0F38.W0 15 /r"
    instruction_group_index: 137
  }
  instructions {
    description: "Converts 4 packed quad-word integers from ymm2 into 4 packed double-word integers in xmm1/m128 with truncation subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVQD"
      operands {
        name: "xmm1/m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.F3.0F38.W0 35 /r"
    instruction_group_index: 137
  }
  instructions {
    description: "Converts 4 packed signed quad-word integers from ymm2 into 4 packed signed double-word integers in xmm1/m128 using signed saturation subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVSQD"
      operands {
        name: "xmm1/m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.F3.0F38.W0 25 /r"
    instruction_group_index: 137
  }
  instructions {
    description: "Converts 4 packed unsigned quad-word integers from ymm2 into 4 packed unsigned double-word integers in xmm1/m128 using unsigned saturation subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVUSQD"
      operands {
        name: "xmm1/m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.F3.0F38.W0 15 /r"
    instruction_group_index: 137
  }
  instructions {
    description: "Converts 8 packed quad-word integers from zmm2 into 8 packed double-word integers in ymm1/m256 with truncation subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVQD"
      operands {
        name: "ymm1/m256"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.F3.0F38.W0 35 /r"
    instruction_group_index: 137
  }
  instructions {
    description: "Converts 8 packed signed quad-word integers from zmm2 into 8 packed signed double-word integers in ymm1/m256 using signed saturation subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVSQD"
      operands {
        name: "ymm1/m256"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.F3.0F38.W0 25 /r"
    instruction_group_index: 137
  }
  instructions {
    description: "Converts 8 packed unsigned quad-word integers from zmm2 into 8 packed unsigned double-word integers in ymm1/m256 using unsigned saturation subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVUSQD"
      operands {
        name: "ymm1/m256"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.F3.0F38.W0 15 /r"
    instruction_group_index: 137
  }
  instructions {
    description: "Convert one single-precision floating-point value in xmm2/m32 to one double-precision floating-point value in xmm1."
    vendor_syntax {
      mnemonic: "CVTSS2SD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F3 0F 5A /r"
    instruction_group_index: 138
  }
  instructions {
    description: "Convert one single-precision floating-point value in xmm3/m32 to one double-precision floating-point value and merge with high bits of xmm2."
    vendor_syntax {
      mnemonic: "VCVTSS2SD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.LIG.F3.0F.WIG 5A /r"
    instruction_group_index: 138
  }
  instructions {
    description: "Convert one single-precision floating-point value in xmm3/m32 to one double-precision floating-point value and merge with high bits of xmm2 under writemask k1."
    vendor_syntax {
      mnemonic: "VCVTSS2SD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.LIG.F3.0F.W0 5A /r"
    instruction_group_index: 138
  }
  instructions {
    description: "Move aligned packed integer values from xmm2/mem to xmm1."
    vendor_syntax {
      mnemonic: "MOVDQA"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 6F /r"
    instruction_group_index: 139
  }
  instructions {
    description: "Move aligned packed integer values from xmm1 to xmm2/mem."
    vendor_syntax {
      mnemonic: "MOVDQA"
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "66 0F 7F /r"
    instruction_group_index: 139
  }
  instructions {
    description: "Move aligned packed integer values from xmm2/mem to xmm1."
    vendor_syntax {
      mnemonic: "VMOVDQA"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F.WIG 6F /r"
    instruction_group_index: 139
  }
  instructions {
    description: "Move aligned packed integer values from xmm1 to xmm2/mem."
    vendor_syntax {
      mnemonic: "VMOVDQA"
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG 7F /r"
    instruction_group_index: 139
  }
  instructions {
    description: "Move aligned packed integer values from ymm2/mem to ymm1."
    vendor_syntax {
      mnemonic: "VMOVDQA"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F.WIG 6F /r"
    instruction_group_index: 139
  }
  instructions {
    description: "Move aligned packed integer values from ymm1 to ymm2/mem."
    vendor_syntax {
      mnemonic: "VMOVDQA"
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG 7F /r"
    instruction_group_index: 139
  }
  instructions {
    description: "Move aligned packed doubleword integer values from xmm2/m128 to xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVDQA32"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.W0 6F /r"
    instruction_group_index: 139
  }
  instructions {
    description: "Move aligned packed doubleword integer values from ymm2/m256 to ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVDQA32"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.W0 6F /r"
    instruction_group_index: 139
  }
  instructions {
    description: "Move aligned packed doubleword integer values from zmm2/m512 to zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVDQA32"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.W0 6F /r"
    instruction_group_index: 139
  }
  instructions {
    description: "Move aligned packed doubleword integer values from xmm1 to xmm2/m128 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVDQA32"
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.128.66.0F.W0 7F /r"
    instruction_group_index: 139
  }
  instructions {
    description: "Move aligned packed doubleword integer values from ymm1 to ymm2/m256 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVDQA32"
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.256.66.0F.W0 7F /r"
    instruction_group_index: 139
  }
  instructions {
    description: "Move aligned packed doubleword integer values from zmm1 to zmm2/m512 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVDQA32"
      operands {
        name: "zmm2/m512"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.66.0F.W0 7F /r"
    instruction_group_index: 139
  }
  instructions {
    description: "Move aligned packed quadword integer values from xmm2/m128 to xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVDQA64"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.W1 6F /r"
    instruction_group_index: 139
  }
  instructions {
    description: "Move aligned packed quadword integer values from ymm2/m256 to ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVDQA64"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.W1 6F /r"
    instruction_group_index: 139
  }
  instructions {
    description: "Move aligned packed quadword integer values from zmm2/m512 to zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVDQA64"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.W1 6F /r"
    instruction_group_index: 139
  }
  instructions {
    description: "Move aligned packed quadword integer values from xmm1 to xmm2/m128 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVDQA64"
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.128.66.0F.W1 7F /r"
    instruction_group_index: 139
  }
  instructions {
    description: "Move aligned packed quadword integer values from ymm1 to ymm2/m256 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVDQA64"
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.256.66.0F.W1 7F /r"
    instruction_group_index: 139
  }
  instructions {
    description: "Move aligned packed quadword integer values from zmm1 to zmm2/m512 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVDQA64"
      operands {
        name: "zmm2/m512"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.66.0F.W1 7F /r"
    instruction_group_index: 139
  }
  instructions {
    description: "Move two packed single-precision floating-point values from low quadword of xmm2 to high quadword of xmm1."
    vendor_syntax {
      mnemonic: "MOVLHPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "NP 0F 16 /r"
    instruction_group_index: 140
  }
  instructions {
    description: "Merge two packed single-precision floating-point values from low quadword of xmm3 and low quadword of xmm2."
    vendor_syntax {
      mnemonic: "VMOVLHPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.128.0F.WIG 16 /r"
    instruction_group_index: 140
  }
  instructions {
    description: "Merge two packed single-precision floating-point values from low quadword of xmm3 and low quadword of xmm2."
    vendor_syntax {
      mnemonic: "VMOVLHPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "EVEX.128.0F.W0 16 /r"
    instruction_group_index: 140
  }
  instructions {
    description: "Scale the packed double-precision floating-point values in xmm2 using values from xmm3/m128/m64bcst. Under writemask k1."
    vendor_syntax {
      mnemonic: "VSCALEFPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 2C /r"
    instruction_group_index: 141
  }
  instructions {
    description: "Scale the packed double-precision floating-point values in ymm2 using values from ymm3/m256/m64bcst. Under writemask k1."
    vendor_syntax {
      mnemonic: "VSCALEFPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 2C /r"
    instruction_group_index: 141
  }
  instructions {
    description: "Scale the packed double-precision floating-point values in zmm2 using values from zmm3/m512/m64bcst. Under writemask k1."
    vendor_syntax {
      mnemonic: "VSCALEFPD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 2C /r"
    instruction_group_index: 141
  }
  instructions {
    description: "Scale the scalar single-precision floating-point value in xmm2 using floating-point value from xmm3/m32. Under writemask k1."
    vendor_syntax {
      mnemonic: "VSCALEFSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.LIG.66.0F38.W0 2D /r"
    instruction_group_index: 142
  }
  instructions {
    description: "Reads a specified VMCS field (in 64-bit mode)."
    vendor_syntax {
      mnemonic: "VMREAD"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "VMX"
    available_in_64_bit: true
    encoding_scheme: "MR"
    raw_encoding_specification: "NP 0F 78"
    instruction_group_index: 143
  }
  instructions {
    description: "Reads a specified VMCS field (outside 64-bit mode)."
    vendor_syntax {
      mnemonic: "VMREAD"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "VMX"
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "NP 0F 78"
    instruction_group_index: 143
  }
  instructions {
    description: "Add imm8 to AL."
    vendor_syntax {
      mnemonic: "ADD"
      operands {
        name: "AL"
        encoding: IMPLICIT_ENCODING
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "I"
    raw_encoding_specification: "04 ib"
    instruction_group_index: 144
  }
  instructions {
    description: "Add imm16 to AX."
    vendor_syntax {
      mnemonic: "ADD"
      operands {
        name: "AX"
        encoding: IMPLICIT_ENCODING
      }
      operands {
        name: "imm16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "I"
    raw_encoding_specification: "05 iw"
    instruction_group_index: 144
  }
  instructions {
    description: "Add imm32 to EAX."
    vendor_syntax {
      mnemonic: "ADD"
      operands {
        name: "EAX"
        encoding: IMPLICIT_ENCODING
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "I"
    raw_encoding_specification: "05 id"
    instruction_group_index: 144
  }
  instructions {
    description: "Add imm32 sign-extended to 64-bits to RAX."
    vendor_syntax {
      mnemonic: "ADD"
      operands {
        name: "RAX"
        encoding: IMPLICIT_ENCODING
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "I"
    raw_encoding_specification: "REX.W + 05 id"
    instruction_group_index: 144
  }
  instructions {
    description: "Add imm8 to r/m8."
    vendor_syntax {
      mnemonic: "ADD"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "80 /0 ib"
    instruction_group_index: 144
  }
  instructions {
    description: "Add sign-extended imm8 to r/m8."
    vendor_syntax {
      mnemonic: "ADD"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX + 80 /0 ib"
    instruction_group_index: 144
  }
  instructions {
    description: "Add imm16 to r/m16."
    vendor_syntax {
      mnemonic: "ADD"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "81 /0 iw"
    instruction_group_index: 144
  }
  instructions {
    description: "Add imm32 to r/m32."
    vendor_syntax {
      mnemonic: "ADD"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "81 /0 id"
    instruction_group_index: 144
  }
  instructions {
    description: "Add imm32 sign-extended to 64-bits to r/m64."
    vendor_syntax {
      mnemonic: "ADD"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX.W + 81 /0 id"
    instruction_group_index: 144
  }
  instructions {
    description: "Add sign-extended imm8 to r/m16."
    vendor_syntax {
      mnemonic: "ADD"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "83 /0 ib"
    instruction_group_index: 144
  }
  instructions {
    description: "Add sign-extended imm8 to r/m32."
    vendor_syntax {
      mnemonic: "ADD"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "83 /0 ib"
    instruction_group_index: 144
  }
  instructions {
    description: "Add sign-extended imm8 to r/m64."
    vendor_syntax {
      mnemonic: "ADD"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX.W + 83 /0 ib"
    instruction_group_index: 144
  }
  instructions {
    description: "Add r8 to r/m8."
    vendor_syntax {
      mnemonic: "ADD"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "00 /r"
    instruction_group_index: 144
  }
  instructions {
    description: "Add r8 to r/m8."
    vendor_syntax {
      mnemonic: "ADD"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MR"
    raw_encoding_specification: "REX + 00 /r"
    instruction_group_index: 144
  }
  instructions {
    description: "Add r16 to r/m16."
    vendor_syntax {
      mnemonic: "ADD"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "01 /r"
    instruction_group_index: 144
  }
  instructions {
    description: "Add r32 to r/m32."
    vendor_syntax {
      mnemonic: "ADD"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "01 /r"
    instruction_group_index: 144
  }
  instructions {
    description: "Add r64 to r/m64."
    vendor_syntax {
      mnemonic: "ADD"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MR"
    raw_encoding_specification: "REX.W + 01 /r"
    instruction_group_index: 144
  }
  instructions {
    description: "Add r/m8 to r8."
    vendor_syntax {
      mnemonic: "ADD"
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "02 /r"
    instruction_group_index: 144
  }
  instructions {
    description: "Add r/m8 to r8."
    vendor_syntax {
      mnemonic: "ADD"
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX + 02 /r"
    instruction_group_index: 144
  }
  instructions {
    description: "Add r/m16 to r16."
    vendor_syntax {
      mnemonic: "ADD"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "03 /r"
    instruction_group_index: 144
  }
  instructions {
    description: "Add r/m32 to r32."
    vendor_syntax {
      mnemonic: "ADD"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "03 /r"
    instruction_group_index: 144
  }
  instructions {
    description: "Add r/m64 to r64."
    vendor_syntax {
      mnemonic: "ADD"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 03 /r"
    instruction_group_index: 144
  }
  instructions {
    description: "Hint to hardware to move the cache line containing m8 to a more distant level of the cache without writing back to memory."
    vendor_syntax {
      mnemonic: "CLDEMOTE"
      operands {
        name: "m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    feature_name: "CLDEMOTE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 1C /0"
    instruction_group_index: 145
  }
  instructions {
    description: "Compare packed signed qwords in xmm2/m128 and xmm1 for greater than."
    vendor_syntax {
      mnemonic: "PCMPGTQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 38 37 /r"
    instruction_group_index: 146
  }
  instructions {
    description: "Compare packed signed qwords in xmm2 and xmm3/m128 for greater than."
    vendor_syntax {
      mnemonic: "VPCMPGTQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F38.WIG 37 /r"
    instruction_group_index: 146
  }
  instructions {
    description: "Compare packed signed qwords in ymm2 and ymm3/m256 for greater than."
    vendor_syntax {
      mnemonic: "VPCMPGTQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F38.WIG 37 /r"
    instruction_group_index: 146
  }
  instructions {
    description: "Compare Greater between int64 vector xmm2 and int64 vector xmm3/m128/m64bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
    vendor_syntax {
      mnemonic: "VPCMPGTQ"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 37 /r"
    instruction_group_index: 146
  }
  instructions {
    description: "Compare Greater between int64 vector ymm2 and int64 vector ymm3/m256/m64bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
    vendor_syntax {
      mnemonic: "VPCMPGTQ"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 37 /r"
    instruction_group_index: 146
  }
  instructions {
    description: "Compare Greater between int64 vector zmm2 and int64 vector zmm3/m512/m64bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
    vendor_syntax {
      mnemonic: "VPCMPGTQ"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 37 /r"
    instruction_group_index: 146
  }
  instructions {
    description: "Perform a packed comparison of string data with explicit lengths, generating a mask, and storing the result in XMM0."
    vendor_syntax {
      mnemonic: "PCMPESTRM"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMI"
    raw_encoding_specification: "66 0F 3A 60 /r imm8"
    instruction_group_index: 147
  }
  instructions {
    description: "Perform a packed comparison of string data with explicit lengths, generating a mask, and storing the result in XMM0."
    vendor_syntax {
      mnemonic: "VPCMPESTRM"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMI"
    raw_encoding_specification: "VEX.128.66.0F3A 60 /r ib"
    instruction_group_index: 147
  }
  instructions {
    description: "Convert one signed doubleword integer from r32/m32 to one double-precision floating-point value in xmm1."
    vendor_syntax {
      mnemonic: "CVTSI2SD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F2 0F 2A /r"
    instruction_group_index: 149
  }
  instructions {
    description: "Convert one signed quadword integer from r/m64 to one double-precision floating-point value in xmm1."
    vendor_syntax {
      mnemonic: "CVTSI2SD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    encoding_scheme: "A"
    raw_encoding_specification: "F2 REX.W 0F 2A /r"
    instruction_group_index: 149
  }
  instructions {
    description: "Convert one signed doubleword integer from r/m32 to one double-precision floating-point value in xmm1."
    vendor_syntax {
      mnemonic: "VCVTSI2SD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.LIG.F2.0F.W0 2A /r"
    instruction_group_index: 149
  }
  instructions {
    description: "Convert one signed quadword integer from r/m64 to one double-precision floating-point value in xmm1."
    vendor_syntax {
      mnemonic: "VCVTSI2SD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.LIG.F2.0F.W1 2A /r"
    instruction_group_index: 149
  }
  instructions {
    description: "Convert one signed doubleword integer from r/m32 to one double-precision floating-point value in xmm1."
    vendor_syntax {
      mnemonic: "VCVTSI2SD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.LIG.F2.0F.W0 2A /r"
    instruction_group_index: 149
  }
  instructions {
    description: "Convert one signed quadword integer from r/m64 to one double-precision floating-point value in xmm1."
    vendor_syntax {
      mnemonic: "VCVTSI2SD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.LIG.F2.0F.W1 2A /r"
    instruction_group_index: 149
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from xmm1 and xmm3/mem, negate the multiplication result andadd to xmm2 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMADD132PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W0 9C /r"
    instruction_group_index: 150
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from xmm1 and xmm2, negate the multiplication result and add to xmm3/mem and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMADD213PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W0 AC /r"
    instruction_group_index: 150
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from xmm2 and xmm3/mem, negate the multiplication result andadd to xmm1 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMADD231PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W0 BC /r"
    instruction_group_index: 150
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from ymm1 and ymm3/mem, negate the multiplication result andadd to ymm2 and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFNMADD132PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W0 9C /r"
    instruction_group_index: 150
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from ymm1 and ymm2, negate the multiplication result and add to ymm3/mem and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFNMADD213PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W0 AC /r"
    instruction_group_index: 150
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from ymm2 and ymm3/mem, negate the multiplication result and add to ymm1 and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFNMADD231PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.0 BC /r"
    instruction_group_index: 150
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from xmm1 and xmm3/m128/m32bcst, negate the multiplication result and add to xmm2 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMADD132PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 9C /r"
    instruction_group_index: 150
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from xmm1 and xmm2, negate the multiplication result and add to xmm3/m128/m32bcst and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMADD213PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 AC /r"
    instruction_group_index: 150
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from xmm2 and xmm3/m128/m32bcst, negate the multiplication result and add to xmm1 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMADD231PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 BC /r"
    instruction_group_index: 150
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from ymm1 and ymm3/m256/m32bcst, negate the multiplication result and add to ymm2 and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFNMADD132PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 9C /r"
    instruction_group_index: 150
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from ymm1 and ymm2, negate the multiplication result and add to ymm3/m256/m32bcst and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFNMADD213PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 AC /r"
    instruction_group_index: 150
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from ymm2 and ymm3/m256/m32bcst, negate the multiplication result and add to ymm1 and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFNMADD231PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 BC /r"
    instruction_group_index: 150
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from zmm1 and zmm3/m512/m32bcst, negate the multiplication result and add to zmm2 and put result in zmm1."
    vendor_syntax {
      mnemonic: "VFNMADD132PS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 9C /r"
    instruction_group_index: 150
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from zmm1 and zmm2, negate the multiplication result and add to zmm3/m512/m32bcst and put result in zmm1."
    vendor_syntax {
      mnemonic: "VFNMADD213PS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 AC /r"
    instruction_group_index: 150
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from zmm2 and zmm3/m512/m32bcst, negate the multiplication result and add to zmm1 and put result in zmm1."
    vendor_syntax {
      mnemonic: "VFNMADD231PS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 BC /r"
    instruction_group_index: 150
  }
  instructions {
    description: "Replace ST(0) with (2ST(0) - 1)."
    vendor_syntax {
      mnemonic: "F2XM1"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D9 F0"
    instruction_group_index: 151
  }
  instructions {
    description: "Return the bitwise logical XOR of packed singleprecision floating-point values in xmm1 and xmm2/mem."
    vendor_syntax {
      mnemonic: "XORPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 57 /r"
    instruction_group_index: 152
  }
  instructions {
    description: "Return the bitwise logical XOR of packed singleprecision floating-point values in xmm2 and xmm3/mem."
    vendor_syntax {
      mnemonic: "VXORPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.0F.WIG 57 /r"
    instruction_group_index: 152
  }
  instructions {
    description: "Return the bitwise logical XOR of packed singleprecision floating-point values in ymm2 and ymm3/mem."
    vendor_syntax {
      mnemonic: "VXORPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.0F.WIG 57 /r"
    instruction_group_index: 152
  }
  instructions {
    description: "Return the bitwise logical XOR of packed singleprecision floating-point values in xmm2 and xmm3/m128/m32bcst subject to writemask k1."
    vendor_syntax {
      mnemonic: "VXORPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.0F.W0 57 /r"
    instruction_group_index: 152
  }
  instructions {
    description: "Return the bitwise logical XOR of packed singleprecision floating-point values in ymm2 and ymm3/m256/m32bcst subject to writemask k1."
    vendor_syntax {
      mnemonic: "VXORPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.0F.W0 57 /r"
    instruction_group_index: 152
  }
  instructions {
    description: "Return the bitwise logical XOR of packed singleprecision floating-point values in zmm2 and zmm3/m512/m32bcst subject to writemask k1."
    vendor_syntax {
      mnemonic: "VXORPS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.0F.W0 57 /r"
    instruction_group_index: 152
  }
  instructions {
    description: "Convert four packed single-precision floating-point values from xmm2/mem to four packed signed doubleword values in xmm1 using truncation."
    vendor_syntax {
      mnemonic: "CVTTPS2DQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F3 0F 5B /r"
    instruction_group_index: 153
  }
  instructions {
    description: "Convert four packed single-precision floating-point values from xmm2/mem to four packed signed doubleword values in xmm1 using truncation."
    vendor_syntax {
      mnemonic: "VCVTTPS2DQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.F3.0F.WIG 5B /r"
    instruction_group_index: 153
  }
  instructions {
    description: "Convert eight packed single-precision floating-point values from ymm2/mem to eight packed signed doubleword values in ymm1 using truncation."
    vendor_syntax {
      mnemonic: "VCVTTPS2DQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.F3.0F.WIG 5B /r"
    instruction_group_index: 153
  }
  instructions {
    description: "Convert four packed single precision floating-point values from xmm2/m128/m32bcst to four packed signed doubleword values in xmm1 using truncation subject to writemask k1."
    vendor_syntax {
      mnemonic: "VCVTTPS2DQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.F3.0F.W0 5B /r"
    instruction_group_index: 153
  }
  instructions {
    description: "Convert eight packed single precision floating-point values from ymm2/m256/m32bcst to eight packed signed doubleword values in ymm1 using truncation subject to writemask k1."
    vendor_syntax {
      mnemonic: "VCVTTPS2DQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.F3.0F.W0 5B /r"
    instruction_group_index: 153
  }
  instructions {
    description: "Convert sixteen packed single-precision floating-point values from zmm2/m512/m32bcst to sixteen packed signed doubleword values in zmm1 using truncation subject to writemask k1."
    vendor_syntax {
      mnemonic: "VCVTTPS2DQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.F3.0F.W0 5B /r"
    instruction_group_index: 153
  }
  instructions {
    description: "Permute word integers from two tables in xmm3/m128 and xmm2 using indexes in xmm1 and store the result in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMI2W"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 75 /r"
    instruction_group_index: 154
  }
  instructions {
    description: "Permute word integers from two tables in ymm3/m256 and ymm2 using indexes in ymm1 and store the result in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMI2W"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 75 /r"
    instruction_group_index: 154
  }
  instructions {
    description: "Permute word integers from two tables in zmm3/m512 and zmm2 using indexes in zmm1 and store the result in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMI2W"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 75 /r"
    instruction_group_index: 154
  }
  instructions {
    description: "Permute double-words from two tables in xmm3/m128/m32bcst and xmm2 using indexes in xmm1 and store the result in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMI2D"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 76 /r"
    instruction_group_index: 154
  }
  instructions {
    description: "Permute double-words from two tables in ymm3/m256/m32bcst and ymm2 using indexes in ymm1 and store the result in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMI2D"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 76 /r"
    instruction_group_index: 154
  }
  instructions {
    description: "Permute double-words from two tables in zmm3/m512/m32bcst and zmm2 using indices in zmm1 and store the result in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMI2D"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 76 /r"
    instruction_group_index: 154
  }
  instructions {
    description: "Permute quad-words from two tables in xmm3/m128/m64bcst and xmm2 using indexes in xmm1 and store the result in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMI2Q"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 76 /r"
    instruction_group_index: 154
  }
  instructions {
    description: "Permute quad-words from two tables in ymm3/m256/m64bcst and ymm2 using indexes in ymm1 and store the result in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMI2Q"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 76 /r"
    instruction_group_index: 154
  }
  instructions {
    description: "Permute quad-words from two tables in zmm3/m512/m64bcst and zmm2 using indices in zmm1 and store the result in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMI2Q"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 76 /r"
    instruction_group_index: 154
  }
  instructions {
    description: "Permute single-precision FP values from two tables in xmm3/m128/m32bcst and xmm2 using indexes in xmm1 and store the result in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMI2PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 77 /r"
    instruction_group_index: 154
  }
  instructions {
    description: "Permute single-precision FP values from two tables in ymm3/m256/m32bcst and ymm2 using indexes in ymm1 and store the result in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMI2PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 77 /r"
    instruction_group_index: 154
  }
  instructions {
    description: "Permute single-precision FP values from two tables in zmm3/m512/m32bcst and zmm2 using indices in zmm1 and store the result in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMI2PS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 77 /r"
    instruction_group_index: 154
  }
  instructions {
    description: "Permute double-precision FP values from two tables in xmm3/m128/m64bcst and xmm2 using indexes in xmm1 and store the result in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMI2PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 77 /r"
    instruction_group_index: 154
  }
  instructions {
    description: "Permute double-precision FP values from two tables in ymm3/m256/m64bcst and ymm2 using indexes in ymm1 and store the result in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMI2PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 77 /r"
    instruction_group_index: 154
  }
  instructions {
    description: "Permute double-precision FP values from two tables in zmm3/m512/m64bcst and zmm2 using indices in zmm1 and store the result in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMI2PD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 77 /r"
    instruction_group_index: 154
  }
  instructions {
    description: "Convert one single-precision floating-point value from xmm1/m32 to one signed doubleword integer in r32 using truncation."
    vendor_syntax {
      mnemonic: "CVTTSS2SI"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F3 0F 2C /r"
    instruction_group_index: 155
  }
  instructions {
    description: "Convert one single-precision floating-point value from xmm1/m32 to one signed quadword integer in r64 using truncation."
    vendor_syntax {
      mnemonic: "CVTTSS2SI"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    encoding_scheme: "A"
    raw_encoding_specification: "F3 REX.W 0F 2C /r"
    instruction_group_index: 155
  }
  instructions {
    description: "Convert one single-precision floating-point value from xmm1/m32 to one signed doubleword integer in r32 using truncation."
    vendor_syntax {
      mnemonic: "VCVTTSS2SI"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.LIG.F3.0F.W0 2C /r"
    instruction_group_index: 155
  }
  instructions {
    description: "Convert one single-precision floating-point value from xmm1/m32 to one signed quadword integer in r64 using truncation."
    vendor_syntax {
      mnemonic: "VCVTTSS2SI"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.LIG.F3.0F.W1 2C /r"
    instruction_group_index: 155
  }
  instructions {
    description: "Convert one single-precision floating-point value from xmm1/m32 to one signed doubleword integer in r32 using truncation."
    vendor_syntax {
      mnemonic: "VCVTTSS2SI"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.LIG.F3.0F.W0 2C /r"
    instruction_group_index: 155
  }
  instructions {
    description: "Convert one single-precision floating-point value from xmm1/m32 to one signed quadword integer in r64 using truncation."
    vendor_syntax {
      mnemonic: "VCVTTSS2SI"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.LIG.F3.0F.W1 2C /r"
    instruction_group_index: 155
  }
  instructions {
    description: "Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to mm1."
    vendor_syntax {
      mnemonic: "PMADDUBSW"
      operands {
        name: "mm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 38 04 /r"
    instruction_group_index: 156
  }
  instructions {
    description: "Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to xmm1."
    vendor_syntax {
      mnemonic: "PMADDUBSW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 38 04 /r"
    instruction_group_index: 156
  }
  instructions {
    description: "Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to xmm1."
    vendor_syntax {
      mnemonic: "VPMADDUBSW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F38.WIG 04 /r"
    instruction_group_index: 156
  }
  instructions {
    description: "Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to ymm1."
    vendor_syntax {
      mnemonic: "VPMADDUBSW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F38.WIG 04 /r"
    instruction_group_index: 156
  }
  instructions {
    description: "Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to xmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMADDUBSW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F38.WIG 04 /r"
    instruction_group_index: 156
  }
  instructions {
    description: "Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to ymm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMADDUBSW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38.WIG 04 /r"
    instruction_group_index: 156
  }
  instructions {
    description: "Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to zmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMADDUBSW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38.WIG 04 /r"
    instruction_group_index: 156
  }
  instructions {
    description: "Return the bitwise logical AND of packed single-precision floating-point values in xmm1 and xmm2/mem."
    vendor_syntax {
      mnemonic: "ANDPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 54 /r"
    instruction_group_index: 157
  }
  instructions {
    description: "Return the bitwise logical AND of packed single-precision floating-point values in xmm2 and xmm3/mem."
    vendor_syntax {
      mnemonic: "VANDPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.0F 54 /r"
    instruction_group_index: 157
  }
  instructions {
    description: "Return the bitwise logical AND of packed single-precision floating-point values in ymm2 and ymm3/mem."
    vendor_syntax {
      mnemonic: "VANDPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.0F 54 /r"
    instruction_group_index: 157
  }
  instructions {
    description: "Return the bitwise logical AND of packed single-precision floating-point values in xmm2 and xmm3/m128/m32bcst subject to writemask k1."
    vendor_syntax {
      mnemonic: "VANDPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.0F.W0 54 /r"
    instruction_group_index: 157
  }
  instructions {
    description: "Return the bitwise logical AND of packed single-precision floating-point values in ymm2 and ymm3/m256/m32bcst subject to writemask k1."
    vendor_syntax {
      mnemonic: "VANDPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.0F.W0 54 /r"
    instruction_group_index: 157
  }
  instructions {
    description: "Return the bitwise logical AND of packed single-precision floating-point values in zmm2 and zmm3/m512/m32bcst subject to writemask k1."
    vendor_syntax {
      mnemonic: "VANDPS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.0F.W0 54 /r"
    instruction_group_index: 157
  }
  instructions {
    description: "Multiply the packed signed word integers in mm1 register and mm2/m64, and store the low 16 bits of the results in mm1."
    vendor_syntax {
      mnemonic: "PMULLW"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F D5 /r"
    instruction_group_index: 158
  }
  instructions {
    description: "Multiply the packed signed word integers in xmm1 and xmm2/m128, and store the low 16 bits of the results in xmm1."
    vendor_syntax {
      mnemonic: "PMULLW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F D5 /r"
    instruction_group_index: 158
  }
  instructions {
    description: "Multiply the packed dword signed integers in xmm2 and xmm3/m128 and store the low 32 bits of each product in xmm1."
    vendor_syntax {
      mnemonic: "VPMULLW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG D5 /r"
    instruction_group_index: 158
  }
  instructions {
    description: "Multiply the packed signed word integers in ymm2 and ymm3/m256, and store the low 16 bits of the results in ymm1."
    vendor_syntax {
      mnemonic: "VPMULLW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG D5 /r"
    instruction_group_index: 158
  }
  instructions {
    description: "Multiply the packed signed word integers in xmm2 and xmm3/m128, and store the low 16 bits of the results in xmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMULLW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.WIG D5 /r"
    instruction_group_index: 158
  }
  instructions {
    description: "Multiply the packed signed word integers in ymm2 and ymm3/m256, and store the low 16 bits of the results in ymm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMULLW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.WIG D5 /r"
    instruction_group_index: 158
  }
  instructions {
    description: "Multiply the packed signed word integers in zmm2 and zmm3/m512, and store the low 16 bits of the results in zmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMULLW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.WIG D5 /r"
    instruction_group_index: 158
  }
  instructions {
    description: "Return the maximum double-precision floating-point values between xmm1 and xmm2/m128."
    vendor_syntax {
      mnemonic: "MAXPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 5F /r"
    instruction_group_index: 159
  }
  instructions {
    description: "Return the maximum double-precision floating-point values between xmm2 and xmm3/m128."
    vendor_syntax {
      mnemonic: "VMAXPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG 5F /r"
    instruction_group_index: 159
  }
  instructions {
    description: "Return the maximum packed double-precision floating-point values between ymm2 and ymm3/m256."
    vendor_syntax {
      mnemonic: "VMAXPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG 5F /r"
    instruction_group_index: 159
  }
  instructions {
    description: "Return the maximum packed double-precision floating-point values between xmm2 and xmm3/m128/m64bcst and store result in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VMAXPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.W1 5F /r"
    instruction_group_index: 159
  }
  instructions {
    description: "Return the maximum packed double-precision floating-point values between ymm2 and ymm3/m256/m64bcst and store result in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VMAXPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.W1 5F /r"
    instruction_group_index: 159
  }
  instructions {
    description: "Return the maximum packed double-precision floating-point values between zmm2 and zmm3/m512/m64bcst and store result in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VMAXPD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.W1 5F /r"
    instruction_group_index: 159
  }
  instructions {
    description: "Stores segment selector from TR in r/m16."
    vendor_syntax {
      mnemonic: "STR"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 00 /1"
    instruction_group_index: 160
  }
  instructions {
    description: "Scale the packed single-precision floating-point values in xmm2 using values from xmm3/m128/m32bcst. Under writemask k1."
    vendor_syntax {
      mnemonic: "VSCALEFPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 2C /r"
    instruction_group_index: 161
  }
  instructions {
    description: "Scale the packed single-precision values in ymm2 using floating point values from ymm3/m256/m32bcst. Under writemask k1."
    vendor_syntax {
      mnemonic: "VSCALEFPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 2C /r"
    instruction_group_index: 161
  }
  instructions {
    description: "Scale the packed single-precision floating-point values in zmm2 using floating-point values from zmm3/m512/m32bcst. Under writemask k1."
    vendor_syntax {
      mnemonic: "VSCALEFPS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 2C /r"
    instruction_group_index: 161
  }
  instructions {
    description: "Move control register to r32."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "r32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "CR0-CR7"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "0F 20/r"
    instruction_group_index: 162
  }
  instructions {
    description: "Move extended control register to r64."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "r64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "CR0-CR7"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MR"
    raw_encoding_specification: "0F 20/r"
    instruction_group_index: 162
  }
  instructions {
    description: "Move extended CR8 to r64."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "r64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "CR8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MR"
    raw_encoding_specification: "REX.R + 0F 20 /0"
    instruction_group_index: 162
  }
  instructions {
    description: "Move r32 to control register."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "CR0-CR7"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 22 /r"
    instruction_group_index: 162
  }
  instructions {
    description: "Move r64 to extended control register."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "CR0-CR7"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 22 /r"
    instruction_group_index: 162
  }
  instructions {
    description: "Move r64 to extended CR8."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "CR8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.R + 0F 22 /0"
    instruction_group_index: 162
  }
  instructions {
    description: "Expand packed double-precision floating-point values from xmm2/m128 to xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VEXPANDPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 88 /r"
    instruction_group_index: 163
  }
  instructions {
    description: "Expand packed double-precision floating-point values from ymm2/m256 to ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VEXPANDPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 88 /r"
    instruction_group_index: 163
  }
  instructions {
    description: "Expand packed double-precision floating-point values from zmm2/m512 to zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VEXPANDPD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 88 /r"
    instruction_group_index: 163
  }
  instructions {
    description: "Computes approximations to the Reciprocal square root (<2^- 28 relative error) of the packed double-precision floating-point values from zmm2/m512/m64bcst and stores result in zmm1with writemask k1."
    vendor_syntax {
      mnemonic: "VRSQRT28PD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512ER"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 CC /r"
    instruction_group_index: 164
  }
  instructions {
    description: "Shift doublewords in xmm2 right by amount specified in the corresponding element of xmm3/m128 while shifting in sign bits."
    vendor_syntax {
      mnemonic: "VPSRAVD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W0 46 /r"
    instruction_group_index: 166
  }
  instructions {
    description: "Shift doublewords in ymm2 right by amount specified in the corresponding element of ymm3/m256 while shifting in sign bits."
    vendor_syntax {
      mnemonic: "VPSRAVD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W0 46 /r"
    instruction_group_index: 166
  }
  instructions {
    description: "Shift words in xmm2 right by amount specified in the corresponding element of xmm3/m128 while shifting in sign bits using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRAVW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 11 /r"
    instruction_group_index: 166
  }
  instructions {
    description: "Shift words in ymm2 right by amount specified in the corresponding element of ymm3/m256 while shifting in sign bits using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRAVW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 11 /r"
    instruction_group_index: 166
  }
  instructions {
    description: "Shift words in zmm2 right by amount specified in the corresponding element of zmm3/m512 while shifting in sign bits using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRAVW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 11 /r"
    instruction_group_index: 166
  }
  instructions {
    description: "Shift doublewords in xmm2 right by amount specified in the corresponding element of xmm3/m128/m32bcst while shifting in sign bits using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRAVD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 46 /r"
    instruction_group_index: 166
  }
  instructions {
    description: "Shift doublewords in ymm2 right by amount specified in the corresponding element of ymm3/m256/m32bcst while shifting in sign bits using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRAVD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 46 /r"
    instruction_group_index: 166
  }
  instructions {
    description: "Shift doublewords in zmm2 right by amount specified in the corresponding element of zmm3/m512/m32bcst while shifting in sign bits using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRAVD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 46 /r"
    instruction_group_index: 166
  }
  instructions {
    description: "Shift quadwords in xmm2 right by amount specified in the corresponding element of xmm3/m128/m64bcst while shifting in sign bits using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRAVQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 46 /r"
    instruction_group_index: 166
  }
  instructions {
    description: "Shift quadwords in ymm2 right by amount specified in the corresponding element of ymm3/m256/m64bcst while shifting in sign bits using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRAVQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 46 /r"
    instruction_group_index: 166
  }
  instructions {
    description: "Shift quadwords in zmm2 right by amount specified in the corresponding element of zmm3/m512/m64bcst while shifting in sign bits using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRAVQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 46 /r"
    instruction_group_index: 166
  }
  instructions {
    description: "Subtract packed byte integers in mm/m64 from packed byte integers in mm."
    vendor_syntax {
      mnemonic: "PSUBB"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F F8 /r"
    instruction_group_index: 167
  }
  instructions {
    description: "Subtract packed byte integers in xmm2/m128 from packed byte integers in xmm1."
    vendor_syntax {
      mnemonic: "PSUBB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F F8 /r"
    instruction_group_index: 167
  }
  instructions {
    description: "Subtract packed word integers in mm/m64 from packed word integers in mm."
    vendor_syntax {
      mnemonic: "PSUBW"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F F9 /r"
    instruction_group_index: 167
  }
  instructions {
    description: "Subtract packed word integers in xmm2/m128 from packed word integers in xmm1."
    vendor_syntax {
      mnemonic: "PSUBW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F F9 /r"
    instruction_group_index: 167
  }
  instructions {
    description: "Subtract packed doubleword integers in mm/m64 from packed doubleword integers in mm."
    vendor_syntax {
      mnemonic: "PSUBD"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F FA /r"
    instruction_group_index: 167
  }
  instructions {
    description: "Subtract packed doubleword integers in xmm2/mem128 from packed doubleword integers in xmm1."
    vendor_syntax {
      mnemonic: "PSUBD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F FA /r"
    instruction_group_index: 167
  }
  instructions {
    description: "Subtract packed byte integers in xmm3/m128 from xmm2."
    vendor_syntax {
      mnemonic: "VPSUBB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG F8 /r"
    instruction_group_index: 167
  }
  instructions {
    description: "Subtract packed word integers in xmm3/m128 from xmm2."
    vendor_syntax {
      mnemonic: "VPSUBW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG F9 /r"
    instruction_group_index: 167
  }
  instructions {
    description: "Subtract packed doubleword integers in xmm3/m128 from xmm2."
    vendor_syntax {
      mnemonic: "VPSUBD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG FA /r"
    instruction_group_index: 167
  }
  instructions {
    description: "Subtract packed byte integers in ymm3/m256 from ymm2."
    vendor_syntax {
      mnemonic: "VPSUBB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG F8 /r"
    instruction_group_index: 167
  }
  instructions {
    description: "Subtract packed word integers in ymm3/m256 from ymm2."
    vendor_syntax {
      mnemonic: "VPSUBW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG F9 /r"
    instruction_group_index: 167
  }
  instructions {
    description: "Subtract packed doubleword integers in ymm3/m256 from ymm2."
    vendor_syntax {
      mnemonic: "VPSUBD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG FA /r"
    instruction_group_index: 167
  }
  instructions {
    description: "Subtract packed byte integers in xmm3/m128 from xmm2 and store in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPSUBB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.WIG F8 /r"
    instruction_group_index: 167
  }
  instructions {
    description: "Subtract packed byte integers in ymm3/m256 from ymm2 and store in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPSUBB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.WIG F8 /r"
    instruction_group_index: 167
  }
  instructions {
    description: "Subtract packed byte integers in zmm3/m512 from zmm2 and store in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPSUBB"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.WIG F8 /r"
    instruction_group_index: 167
  }
  instructions {
    description: "Subtract packed word integers in xmm3/m128 from xmm2 and store in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPSUBW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.WIG F9 /r"
    instruction_group_index: 167
  }
  instructions {
    description: "Subtract packed word integers in ymm3/m256 from ymm2 and store in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPSUBW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.WIG F9 /r"
    instruction_group_index: 167
  }
  instructions {
    description: "Subtract packed word integers in zmm3/m512 from zmm2 and store in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPSUBW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.WIG F9 /r"
    instruction_group_index: 167
  }
  instructions {
    description: "Subtract packed doubleword integers in xmm3/m128/m32bcst from xmm2 and store in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPSUBD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.128.66.0F.W0 FA /r"
    instruction_group_index: 167
  }
  instructions {
    description: "Subtract packed doubleword integers in ymm3/m256/m32bcst from ymm2 and store in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPSUBD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.256.66.0F.W0 FA /r"
    instruction_group_index: 167
  }
  instructions {
    description: "Subtract packed doubleword integers in zmm3/m512/m32bcst from zmm2 and store in zmm1 using writemask k1"
    vendor_syntax {
      mnemonic: "VPSUBD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.66.0F.W0 FA /r"
    instruction_group_index: 167
  }
  instructions {
    description: "Store selected bit in CF flag and set."
    vendor_syntax {
      mnemonic: "BTS"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "0F AB /r"
    instruction_group_index: 168
  }
  instructions {
    description: "Store selected bit in CF flag and set."
    vendor_syntax {
      mnemonic: "BTS"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "0F AB /r"
    instruction_group_index: 168
  }
  instructions {
    description: "Store selected bit in CF flag and set."
    vendor_syntax {
      mnemonic: "BTS"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MR"
    raw_encoding_specification: "REX.W + 0F AB /r"
    instruction_group_index: 168
  }
  instructions {
    description: "Store selected bit in CF flag and set."
    vendor_syntax {
      mnemonic: "BTS"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "0F BA /5 ib"
    instruction_group_index: 168
  }
  instructions {
    description: "Store selected bit in CF flag and set."
    vendor_syntax {
      mnemonic: "BTS"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "0F BA /5 ib"
    instruction_group_index: 168
  }
  instructions {
    description: "Store selected bit in CF flag and set."
    vendor_syntax {
      mnemonic: "BTS"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX.W + 0F BA /5 ib"
    instruction_group_index: 168
  }
  instructions {
    description: "Select packed DP-FP values from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1."
    vendor_syntax {
      mnemonic: "BLENDPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMI"
    raw_encoding_specification: "66 0F 3A 0D /r ib"
    instruction_group_index: 169
  }
  instructions {
    description: "Select packed double-precision floating-point Values from xmm2 and xmm3/m128 from mask in imm8 and store the values in xmm1."
    vendor_syntax {
      mnemonic: "VBLENDPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVMI"
    raw_encoding_specification: "VEX.128.66.0F3A.WIG 0D /r ib"
    instruction_group_index: 169
  }
  instructions {
    description: "Select packed double-precision floating-point Values from ymm2 and ymm3/m256 from mask in imm8 and store the values in ymm1."
    vendor_syntax {
      mnemonic: "VBLENDPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVMI"
    raw_encoding_specification: "VEX.256.66.0F3A.WIG 0D /r ib"
    instruction_group_index: 169
  }
  instructions {
    description: "Generate breakpoint trap."
    vendor_syntax {
      mnemonic: "INT3"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "CC"
    instruction_group_index: 170
  }
  instructions {
    description: "Generate software interrupt with vector specified by immediate byte."
    vendor_syntax {
      mnemonic: "INT"
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "I"
    raw_encoding_specification: "CD ib"
    instruction_group_index: 170
  }
  instructions {
    description: "Generate overflow trap if overflow flag is 1."
    vendor_syntax {
      mnemonic: "INTO"
    }
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "CE"
    instruction_group_index: 170
  }
  instructions {
    description: "Generate debug trap."
    vendor_syntax {
      mnemonic: "INT1"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F1"
    instruction_group_index: 170
  }
  instructions {
    description: "Multiply unsigned doubleword integer in mm1 by unsigned doubleword integer in mm2/m64, and store the quadword result in mm1."
    vendor_syntax {
      mnemonic: "PMULUDQ"
      operands {
        name: "mm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F F4 /r"
    instruction_group_index: 171
  }
  instructions {
    description: "Multiply packed unsigned doubleword integers in xmm1 by packed unsigned doubleword integers in xmm2/m128, and store the quadword results in xmm1."
    vendor_syntax {
      mnemonic: "PMULUDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F F4 /r"
    instruction_group_index: 171
  }
  instructions {
    description: "Multiply packed unsigned doubleword integers in xmm2 by packed unsigned doubleword integers in xmm3/m128, and store the quadword results in xmm1."
    vendor_syntax {
      mnemonic: "VPMULUDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG F4 /r"
    instruction_group_index: 171
  }
  instructions {
    description: "Multiply packed unsigned doubleword integers in ymm2 by packed unsigned doubleword integers in ymm3/m256, and store the quadword results in ymm1."
    vendor_syntax {
      mnemonic: "VPMULUDQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG F4 /r"
    instruction_group_index: 171
  }
  instructions {
    description: "Multiply packed unsigned doubleword integers in xmm2 by packed unsigned doubleword integers in xmm3/m128/m64bcst, and store the quadword results in xmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMULUDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.W1 F4 /r"
    instruction_group_index: 171
  }
  instructions {
    description: "Multiply packed unsigned doubleword integers in ymm2 by packed unsigned doubleword integers in ymm3/m256/m64bcst, and store the quadword results in ymm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMULUDQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.W1 F4 /r"
    instruction_group_index: 171
  }
  instructions {
    description: "Multiply packed unsigned doubleword integers in zmm2 by packed unsigned doubleword integers in zmm3/m512/m64bcst, and store the quadword results in zmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMULUDQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.W1 F4 /r"
    instruction_group_index: 171
  }
  instructions {
    description: "Save a restore-shadow-stack token on previous shadow stack."
    vendor_syntax {
      mnemonic: "SAVEPREVSSP"
    }
    feature_name: "CET_SS"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F3 0F 01 EA"
    instruction_group_index: 172
  }
  instructions {
    description: "Compare low double-precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly."
    vendor_syntax {
      mnemonic: "UCOMISD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 2E /r"
    instruction_group_index: 173
  }
  instructions {
    description: "Compare low double-precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly."
    vendor_syntax {
      mnemonic: "VUCOMISD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.LIG.66.0F.WIG 2E /r"
    instruction_group_index: 173
  }
  instructions {
    description: "Compare low double-precision floating-point values in xmm1 and xmm2/m64 and set the EFLAGS flags accordingly."
    vendor_syntax {
      mnemonic: "VUCOMISD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.LIG.66.0F.W1 2E /r"
    instruction_group_index: 173
  }
  instructions {
    description: "Move unaligned packed single-precision floating-point from xmm2/mem to xmm1."
    vendor_syntax {
      mnemonic: "MOVUPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 10 /r"
    instruction_group_index: 174
  }
  instructions {
    description: "Move unaligned packed single-precision floating-point from xmm1 to xmm2/mem."
    vendor_syntax {
      mnemonic: "MOVUPS"
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "NP 0F 11 /r"
    instruction_group_index: 174
  }
  instructions {
    description: "Move unaligned packed single-precision floating-point from xmm2/mem to xmm1."
    vendor_syntax {
      mnemonic: "VMOVUPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.0F.WIG 10 /r"
    instruction_group_index: 174
  }
  instructions {
    description: "Move unaligned packed single-precision floating-point from xmm1 to xmm2/mem."
    vendor_syntax {
      mnemonic: "VMOVUPS"
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.0F.WIG 11 /r"
    instruction_group_index: 174
  }
  instructions {
    description: "Move unaligned packed single-precision floating-point from ymm2/mem to ymm1."
    vendor_syntax {
      mnemonic: "VMOVUPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.0F.WIG 10 /r"
    instruction_group_index: 174
  }
  instructions {
    description: "Move unaligned packed single-precision floating-point from ymm1 to ymm2/mem."
    vendor_syntax {
      mnemonic: "VMOVUPS"
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.0F.WIG 11 /r"
    instruction_group_index: 174
  }
  instructions {
    description: "Move unaligned packed single-precision floating-point values from xmm2/m128 to xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVUPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.0F.W0 10 /r"
    instruction_group_index: 174
  }
  instructions {
    description: "Move unaligned packed single-precision floating-point values from ymm2/m256 to ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVUPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.0F.W0 10 /r"
    instruction_group_index: 174
  }
  instructions {
    description: "Move unaligned packed single-precision floating-point values from zmm2/m512 to zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVUPS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.0F.W0 10 /r"
    instruction_group_index: 174
  }
  instructions {
    description: "Move unaligned packed single-precision floating-point values from xmm1 to xmm2/m128 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVUPS"
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.128.0F.W0 11 /r"
    instruction_group_index: 174
  }
  instructions {
    description: "Move unaligned packed single-precision floating-point values from ymm1 to ymm2/m256 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVUPS"
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.256.0F.W0 11 /r"
    instruction_group_index: 174
  }
  instructions {
    description: "Move unaligned packed single-precision floating-point values from zmm1 to zmm2/m512 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVUPS"
      operands {
        name: "zmm2/m512"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.0F.W0 11 /r"
    instruction_group_index: 174
  }
  instructions {
    description: "Copy VMCS data to VMCS region in memory."
    vendor_syntax {
      mnemonic: "VMCLEAR"
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "VMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "66 0F C7 /6"
    instruction_group_index: 175
  }
  instructions {
    description: "Convert two packed single precision floating-point values from xmm2/m64/m32bcst to two packed signed quadword values in xmm1 using truncation subject to writemask k1."
    vendor_syntax {
      mnemonic: "VCVTTPS2QQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F.W0 7A /r"
    instruction_group_index: 177
  }
  instructions {
    description: "Convert four packed single precision floating-point values from xmm2/m128/m32bcst to four packed signed quadword values in ymm1 using truncation subject to writemask k1."
    vendor_syntax {
      mnemonic: "VCVTTPS2QQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F.W0 7A /r"
    instruction_group_index: 177
  }
  instructions {
    description: "Convert eight packed single precision floating-point values from ymm2/m256/m32bcst to eight packed signed quadword values in zmm1 using truncation subject to writemask k1."
    vendor_syntax {
      mnemonic: "VCVTTPS2QQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F.W0 7A /r"
    instruction_group_index: 177
  }
  instructions {
    description: "Exchanges the current GS base register value with the value contained in MSR address C0000102H."
    vendor_syntax {
      mnemonic: "SWAPGS"
    }
    available_in_64_bit: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "0F 01 F8"
    instruction_group_index: 178
  }
  instructions {
    description: "Restore state components specified by EDX:EAX from mem."
    vendor_syntax {
      mnemonic: "XRSTOR"
      operands {
        name: "mem"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "XSAVE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "NP 0F AE /5"
    instruction_group_index: 179
  }
  instructions {
    description: "Restore state components specified by EDX:EAX from mem."
    vendor_syntax {
      mnemonic: "XRSTOR64"
      operands {
        name: "mem"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "XSAVE"
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "NP REX.W + 0F AE /5"
    instruction_group_index: 179
  }
  instructions {
    description: "Multiply the packed words in mm by the packed words in mm/m64, add adjacent doubleword results, and store in mm."
    vendor_syntax {
      mnemonic: "PMADDWD"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F F5 /r"
    instruction_group_index: 180
  }
  instructions {
    description: "Multiply the packed word integers in xmm1 by the packed word integers in xmm2/m128, add adjacent doubleword results, and store in xmm1."
    vendor_syntax {
      mnemonic: "PMADDWD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F F5 /r"
    instruction_group_index: 180
  }
  instructions {
    description: "Multiply the packed word integers in xmm2 by the packed word integers in xmm3/m128, add adjacent doubleword results, and store in xmm1."
    vendor_syntax {
      mnemonic: "VPMADDWD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG F5 /r"
    instruction_group_index: 180
  }
  instructions {
    description: "Multiply the packed word integers in ymm2 by the packed word integers in ymm3/m256, add adjacent doubleword results, and store in ymm1."
    vendor_syntax {
      mnemonic: "VPMADDWD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG F5 /r"
    instruction_group_index: 180
  }
  instructions {
    description: "Multiply the packed word integers in xmm2 by the packed word integers in xmm3/m128, add adjacent doubleword results, and store in xmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMADDWD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.WIG F5 /r"
    instruction_group_index: 180
  }
  instructions {
    description: "Multiply the packed word integers in ymm2 by the packed word integers in ymm3/m256, add adjacent doubleword results, and store in ymm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMADDWD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.WIG F5 /r"
    instruction_group_index: 180
  }
  instructions {
    description: "Multiply the packed word integers in zmm2 by the packed word integers in zmm3/m512, add adjacent doubleword results, and store in zmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMADDWD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.WIG F5 /r"
    instruction_group_index: 180
  }
  instructions {
    description: "Pop top of stack into lower 16 bits of EFLAGS."
    vendor_syntax {
      mnemonic: "POPF"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "9D"
    instruction_group_index: 181
  }
  instructions {
    description: "Pop top of stack into EFLAGS."
    vendor_syntax {
      mnemonic: "POPFD"
    }
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "9D"
    instruction_group_index: 181
  }
  instructions {
    description: "Pop top of stack and zero-extend into RFLAGS."
    vendor_syntax {
      mnemonic: "POPFQ"
    }
    available_in_64_bit: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "9D"
    instruction_group_index: 181
  }
  instructions {
    description: "Count the number of leading zero bits in r/m16, return result in r16."
    vendor_syntax {
      mnemonic: "LZCNT"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "LZCNT"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "F3 0F BD /r"
    instruction_group_index: 182
  }
  instructions {
    description: "Count the number of leading zero bits in r/m32, return result in r32."
    vendor_syntax {
      mnemonic: "LZCNT"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "LZCNT"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "F3 0F BD /r"
    instruction_group_index: 182
  }
  instructions {
    description: "Count the number of leading zero bits in r/m64, return result in r64."
    vendor_syntax {
      mnemonic: "LZCNT"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "LZCNT"
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "F3 REX.W 0F BD /r"
    instruction_group_index: 182
  }
  instructions {
    description: "Move 16 bits mask from k2/m16 and store the result in k1."
    vendor_syntax {
      mnemonic: "KMOVW"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "VEX.L0.0F.W0 90 /r"
    instruction_group_index: 183
  }
  instructions {
    description: "Move 8 bits mask from k2/m8 and store the result in k1."
    vendor_syntax {
      mnemonic: "KMOVB"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "VEX.L0.66.0F.W0 90 /r"
    instruction_group_index: 183
  }
  instructions {
    description: "Move 64 bits mask from k2/m64 and store the result in k1."
    vendor_syntax {
      mnemonic: "KMOVQ"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "VEX.L0.0F.W1 90 /r"
    instruction_group_index: 183
  }
  instructions {
    description: "Move 32 bits mask from k2/m32 and store the result in k1."
    vendor_syntax {
      mnemonic: "KMOVD"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "VEX.L0.66.0F.W1 90 /r"
    instruction_group_index: 183
  }
  instructions {
    description: "Move 16 bits mask from k1 and store the result in m16."
    vendor_syntax {
      mnemonic: "KMOVW"
      operands {
        name: "m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "VEX.L0.0F.W0 91 /r"
    instruction_group_index: 183
  }
  instructions {
    description: "Move 8 bits mask from k1 and store the result in m8."
    vendor_syntax {
      mnemonic: "KMOVB"
      operands {
        name: "m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "VEX.L0.66.0F.W0 91 /r"
    instruction_group_index: 183
  }
  instructions {
    description: "Move 64 bits mask from k1 and store the result in m64."
    vendor_syntax {
      mnemonic: "KMOVQ"
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "VEX.L0.0F.W1 91 /r"
    instruction_group_index: 183
  }
  instructions {
    description: "Move 32 bits mask from k1 and store the result in m32."
    vendor_syntax {
      mnemonic: "KMOVD"
      operands {
        name: "m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "VEX.L0.66.0F.W1 91 /r"
    instruction_group_index: 183
  }
  instructions {
    description: "Move 16 bits mask from r32 to k1."
    vendor_syntax {
      mnemonic: "KMOVW"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RR"
    raw_encoding_specification: "VEX.L0.0F.W0 92 /r"
    instruction_group_index: 183
  }
  instructions {
    description: "Move 8 bits mask from r32 to k1."
    vendor_syntax {
      mnemonic: "KMOVB"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RR"
    raw_encoding_specification: "VEX.L0.66.0F.W0 92 /r"
    instruction_group_index: 183
  }
  instructions {
    description: "Move 64 bits mask from r64 to k1."
    vendor_syntax {
      mnemonic: "KMOVQ"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    encoding_scheme: "RR"
    raw_encoding_specification: "VEX.L0.F2.0F.W1 92 /r"
    instruction_group_index: 183
  }
  instructions {
    description: "Move 32 bits mask from r32 to k1."
    vendor_syntax {
      mnemonic: "KMOVD"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RR"
    raw_encoding_specification: "VEX.L0.F2.0F.W0 92 /r"
    instruction_group_index: 183
  }
  instructions {
    description: "Move 16 bits mask from k1 to r32."
    vendor_syntax {
      mnemonic: "KMOVW"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RR"
    raw_encoding_specification: "VEX.L0.0F.W0 93 /r"
    instruction_group_index: 183
  }
  instructions {
    description: "Move 8 bits mask from k1 to r32."
    vendor_syntax {
      mnemonic: "KMOVB"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RR"
    raw_encoding_specification: "VEX.L0.66.0F.W0 93 /r"
    instruction_group_index: 183
  }
  instructions {
    description: "Move 64 bits mask from k1 to r64."
    vendor_syntax {
      mnemonic: "KMOVQ"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    encoding_scheme: "RR"
    raw_encoding_specification: "VEX.L0.F2.0F.W1 93 /r"
    instruction_group_index: 183
  }
  instructions {
    description: "Move 32 bits mask from k1 to r32."
    vendor_syntax {
      mnemonic: "KMOVD"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RR"
    raw_encoding_specification: "VEX.L0.F2.0F.W0 93 /r"
    instruction_group_index: 183
  }
  instructions {
    description: "Sets up a linear address range to be monitored by hardware and activates the monitor. The address range should be a write-back memory caching type. The address is contained in r16/r32/r64."
    vendor_syntax {
      mnemonic: "UMONITOR"
      operands {
        name: "r16/r32/r64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "WAITPKG"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F3 0F AE /6"
    instruction_group_index: 184
  }
  instructions {
    description: "Compress packed single-precision floating-point values from xmm2 to xmm1/m128 using writemask k1."
    vendor_syntax {
      mnemonic: "VCOMPRESSPS"
      operands {
        name: "xmm1/m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 8A /r"
    instruction_group_index: 185
  }
  instructions {
    description: "Compress packed single-precision floating-point values from ymm2 to ymm1/m256 using writemask k1."
    vendor_syntax {
      mnemonic: "VCOMPRESSPS"
      operands {
        name: "ymm1/m256"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 8A /r"
    instruction_group_index: 185
  }
  instructions {
    description: "Compress packed single-precision floating-point values from zmm2 using control mask k1 to zmm1/m512."
    vendor_syntax {
      mnemonic: "VCOMPRESSPS"
      operands {
        name: "zmm1/m512"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 8A /r"
    instruction_group_index: 185
  }
  instructions {
    description: "Using dword indices specified in vm32x, gather qword values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."
    vendor_syntax {
      mnemonic: "VPGATHERDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "vm32x"
        encoding: VSIB_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W1 90 /r"
    instruction_group_index: 186
  }
  instructions {
    description: "Using qword indices specified in vm64x, gather qword values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."
    vendor_syntax {
      mnemonic: "VPGATHERQQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "vm64x"
        encoding: VSIB_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W1 91 /r"
    instruction_group_index: 186
  }
  instructions {
    description: "Using dword indices specified in vm32x, gather qword values from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1."
    vendor_syntax {
      mnemonic: "VPGATHERDQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "vm32x"
        encoding: VSIB_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W1 90 /r"
    instruction_group_index: 186
  }
  instructions {
    description: "Using qword indices specified in vm64y, gather qword values from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1."
    vendor_syntax {
      mnemonic: "VPGATHERQQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "vm64y"
        encoding: VSIB_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W1 91 /r"
    instruction_group_index: 186
  }
  instructions {
    description: "Restore state components specified by EDX:EAX from mem."
    vendor_syntax {
      mnemonic: "XRSTORS"
      operands {
        name: "mem"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "XSS"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "NP 0F C7 /3"
    instruction_group_index: 187
  }
  instructions {
    description: "Restore state components specified by EDX:EAX from mem."
    vendor_syntax {
      mnemonic: "XRSTORS64"
      operands {
        name: "mem"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "XSS"
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "NP REX.W + 0F C7 /3"
    instruction_group_index: 187
  }
  instructions {
    description: "Invalidates entries in the TLBs and paging-structure caches based on invalidation type in r32 and descriptor in m128."
    vendor_syntax {
      mnemonic: "INVPCID"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "INVPCID"
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "66 0F 38 82 /r"
    instruction_group_index: 188
  }
  instructions {
    description: "Invalidates entries in the TLBs and paging-structure caches based on invalidation type in r64 and descriptor in m128."
    vendor_syntax {
      mnemonic: "INVPCID"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "INVPCID"
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "66 0F 38 82 /r"
    instruction_group_index: 188
  }
  instructions {
    description: "Unsigned addition of r32 with CF, r/m32 to r32, writes CF."
    vendor_syntax {
      mnemonic: "ADCX"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "ADX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "66 0F 38 F6 /r"
    instruction_group_index: 189
  }
  instructions {
    description: "Unsigned addition of r64 with CF, r/m64 to r64, writes CF."
    vendor_syntax {
      mnemonic: "ADCX"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "ADX"
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "66 REX.W 0F 38 F6 /r"
    instruction_group_index: 189
  }
  instructions {
    description: "Compare packed signed doubleword integer values in xmm3/m128/m32bcst and xmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
    vendor_syntax {
      mnemonic: "VPCMPD"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F3A.W0 1F /r ib"
    instruction_group_index: 190
  }
  instructions {
    description: "Compare packed signed doubleword integer values in ymm3/m256/m32bcst and ymm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
    vendor_syntax {
      mnemonic: "VPCMPD"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F3A.W0 1F /r ib"
    instruction_group_index: 190
  }
  instructions {
    description: "Compare packed signed doubleword integer values in zmm2 and zmm3/m512/m32bcst using bits 2:0 of imm8 as a comparison predicate. The comparison results are written to the destination k1 under writemask k2."
    vendor_syntax {
      mnemonic: "VPCMPD"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F3A.W0 1F /r ib"
    instruction_group_index: 190
  }
  instructions {
    description: "Compare packed unsigned doubleword integer values in xmm3/m128/m32bcst and xmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
    vendor_syntax {
      mnemonic: "VPCMPUD"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F3A.W0 1E /r ib"
    instruction_group_index: 190
  }
  instructions {
    description: "Compare packed unsigned doubleword integer values in ymm3/m256/m32bcst and ymm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
    vendor_syntax {
      mnemonic: "VPCMPUD"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F3A.W0 1E /r ib"
    instruction_group_index: 190
  }
  instructions {
    description: "Compare packed unsigned doubleword integer values in zmm2 and zmm3/m512/m32bcst using bits 2:0 of imm8 as a comparison predicate. The comparison results are written to the destination k1 under writemask k2."
    vendor_syntax {
      mnemonic: "VPCMPUD"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F3A.W0 1E /r ib"
    instruction_group_index: 190
  }
  instructions {
    description: "Bitwise AND of inverted r32b with r/m32, store result in r32a."
    vendor_syntax {
      mnemonic: "ANDN"
      operands {
        name: "r32a"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r32b"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "BMI1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.LZ.0F38.W0 F2 /r"
    instruction_group_index: 191
  }
  instructions {
    description: "Bitwise AND of inverted r64b with r/m64, store result in r64a."
    vendor_syntax {
      mnemonic: "ANDN"
      operands {
        name: "r64a"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r64b"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "BMI1"
    available_in_64_bit: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.LZ. 0F38.W1 F2 /r"
    instruction_group_index: 191
  }
  instructions {
    description: "Extract the normalized mantissa from the low float32 element of xmm3/m32 using imm8 for sign control and mantissa interval normalization, store the mantissa to xmm1 under the writemask k1 and merge with the other elements of xmm2."
    vendor_syntax {
      mnemonic: "VGETMANTSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.LIG.66.0F3A.W0 27 /r ib"
    instruction_group_index: 192
  }
  instructions {
    description: "Clear interrupt flag; interrupts disabled when interrupt flag cleared."
    vendor_syntax {
      mnemonic: "CLI"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "FA"
    instruction_group_index: 193
  }
  instructions {
    description: "Resume operation of interrupted program."
    vendor_syntax {
      mnemonic: "RSM"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "0F AA"
    instruction_group_index: 194
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from xmm1 and xmm3/mem, add to xmm2 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMADD132PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W0 98 /r"
    instruction_group_index: 195
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from xmm1 and xmm2, add to xmm3/mem and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMADD213PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W0 A8 /r"
    instruction_group_index: 195
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from xmm2 and xmm3/mem, add to xmm1 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMADD231PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W0 B8 /r"
    instruction_group_index: 195
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from ymm1 and ymm3/mem, add to ymm2 and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFMADD132PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W0 98 /r"
    instruction_group_index: 195
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from ymm1 and ymm2, add to ymm3/mem and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFMADD213PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W0 A8 /r"
    instruction_group_index: 195
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from ymm2 and ymm3/mem, add to ymm1 and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFMADD231PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.0 B8 /r"
    instruction_group_index: 195
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from xmm1 and xmm3/m128/m32bcst, add to xmm2 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMADD132PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 98 /r"
    instruction_group_index: 195
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from xmm1 and xmm2, add to xmm3/m128/m32bcst and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMADD213PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 A8 /r"
    instruction_group_index: 195
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from xmm2 and xmm3/m128/m32bcst, add to xmm1 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMADD231PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 B8 /r"
    instruction_group_index: 195
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from ymm1 and ymm3/m256/m32bcst, add to ymm2 and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFMADD132PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 98 /r"
    instruction_group_index: 195
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from ymm1 and ymm2, add to ymm3/m256/m32bcst and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFMADD213PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 A8 /r"
    instruction_group_index: 195
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from ymm2 and ymm3/m256/m32bcst, add to ymm1 and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFMADD231PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 B8 /r"
    instruction_group_index: 195
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from zmm1 and zmm3/m512/m32bcst, add to zmm2 and put result in zmm1."
    vendor_syntax {
      mnemonic: "VFMADD132PS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 98 /r"
    instruction_group_index: 195
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from zmm1 and zmm2, add to zmm3/m512/m32bcst and put result in zmm1."
    vendor_syntax {
      mnemonic: "VFMADD213PS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 A8 /r"
    instruction_group_index: 195
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from zmm2 and zmm3/m512/m32bcst, add to zmm1 and put result in zmm1."
    vendor_syntax {
      mnemonic: "VFMADD231PS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 B8 /r"
    instruction_group_index: 195
  }
  instructions {
    description: "Round the low packed single precision floating-point value in xmm2/m32 and place the result in xmm1.  The rounding mode is determined by imm8."
    vendor_syntax {
      mnemonic: "ROUNDSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMI"
    raw_encoding_specification: "66 0F 3A 0A /r ib"
    instruction_group_index: 197
  }
  instructions {
    description: "Round the low packed single precision floating-point value in xmm3/m32 and place the result in xmm1. The rounding mode is determined by imm8. Also, upper packed single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32]."
    vendor_syntax {
      mnemonic: "VROUNDSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVMI"
    raw_encoding_specification: "VEX.LIG.66.0F3A.WIG 0A /r ib"
    instruction_group_index: 197
  }
  instructions {
    description: "Compare AL with byte at ES:(E)DI or RDI, then set status flags.*"
    vendor_syntax {
      mnemonic: "SCAS"
      operands {
        name: "m8"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "AE"
    instruction_group_index: 199
  }
  instructions {
    description: "Compare AX with word at ES:(E)DI or RDI, then set status flags.*"
    vendor_syntax {
      mnemonic: "SCAS"
      operands {
        name: "m16"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "AF"
    instruction_group_index: 199
  }
  instructions {
    description: "Compare EAX with doubleword at ES(E)DI or RDI then set status flags.*"
    vendor_syntax {
      mnemonic: "SCAS"
      operands {
        name: "m32"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "AF"
    instruction_group_index: 199
  }
  instructions {
    description: "Compare RAX with quadword at RDI or EDI then set status flags."
    vendor_syntax {
      mnemonic: "SCAS"
      operands {
        name: "m64"
      }
    }
    available_in_64_bit: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "REX.W + AF"
    instruction_group_index: 199
  }
  instructions {
    description: "Compare AL with byte at ES:(E)DI or RDI then set status flags.*"
    vendor_syntax {
      mnemonic: "SCASB"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "AE"
    instruction_group_index: 199
  }
  instructions {
    description: "Compare AX with word at ES:(E)DI or RDI then set status flags.*"
    vendor_syntax {
      mnemonic: "SCASW"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "AF"
    instruction_group_index: 199
  }
  instructions {
    description: "Compare EAX with doubleword at ES:(E)DI or RDI then set status flags.*"
    vendor_syntax {
      mnemonic: "SCASD"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "AF"
    instruction_group_index: 199
  }
  instructions {
    description: "Compare RAX with quadword at RDI or EDI then set status flags."
    vendor_syntax {
      mnemonic: "SCASQ"
    }
    available_in_64_bit: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "REX.W + AF"
    instruction_group_index: 199
  }
  instructions {
    description: "Compare packed double-precision floating-point values in xmm2/m128 and xmm1 using bits 2:0 of imm8 as a comparison predicate."
    vendor_syntax {
      mnemonic: "CMPPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F C2 /r ib"
    instruction_group_index: 200
  }
  instructions {
    description: "Compare packed double-precision floating-point values in xmm3/m128 and xmm2 using bits 4:0 of imm8 as a comparison predicate."
    vendor_syntax {
      mnemonic: "VCMPPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG C2 /r ib"
    instruction_group_index: 200
  }
  instructions {
    description: "Compare packed double-precision floating-point values in ymm3/m256 and ymm2 using bits 4:0 of imm8 as a comparison predicate."
    vendor_syntax {
      mnemonic: "VCMPPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG C2 /r ib"
    instruction_group_index: 200
  }
  instructions {
    description: "Compare packed double-precision floating-point values in xmm3/m128/m64bcst and xmm2 using bits 4:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
    vendor_syntax {
      mnemonic: "VCMPPD"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.W1 C2 /r ib"
    instruction_group_index: 200
  }
  instructions {
    description: "Compare packed double-precision floating-point values in ymm3/m256/m64bcst and ymm2 using bits 4:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
    vendor_syntax {
      mnemonic: "VCMPPD"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.W1 C2 /r ib"
    instruction_group_index: 200
  }
  instructions {
    description: "Compare packed double-precision floating-point values in zmm3/m512/m64bcst and zmm2 using bits 4:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
    vendor_syntax {
      mnemonic: "VCMPPD"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.W1 C2 /r ib"
    instruction_group_index: 200
  }
  instructions {
    description: "Reverse byte order in m16 and move to r16."
    vendor_syntax {
      mnemonic: "MOVBE"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "<UNKNOWN>"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 38 F0 /r"
    instruction_group_index: 201
  }
  instructions {
    description: "Reverse byte order in m32 and move to r32."
    vendor_syntax {
      mnemonic: "MOVBE"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "<UNKNOWN>"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 38 F0 /r"
    instruction_group_index: 201
  }
  instructions {
    description: "Reverse byte order in m64 and move to r64."
    vendor_syntax {
      mnemonic: "MOVBE"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "<UNKNOWN>"
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 0F 38 F0 /r"
    instruction_group_index: 201
  }
  instructions {
    description: "Reverse byte order in r16 and move to m16."
    vendor_syntax {
      mnemonic: "MOVBE"
      operands {
        name: "m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "<UNKNOWN>"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "0F 38 F1 /r"
    instruction_group_index: 201
  }
  instructions {
    description: "Reverse byte order in r32 and move to m32."
    vendor_syntax {
      mnemonic: "MOVBE"
      operands {
        name: "m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "<UNKNOWN>"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "0F 38 F1 /r"
    instruction_group_index: 201
  }
  instructions {
    description: "Reverse byte order in r64 and move to m64."
    vendor_syntax {
      mnemonic: "MOVBE"
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "<UNKNOWN>"
    available_in_64_bit: true
    encoding_scheme: "MR"
    raw_encoding_specification: "REX.W + 0F 38 F1 /r"
    instruction_group_index: 201
  }
  instructions {
    description: "Computes approximate reciprocal square root (<2^-28 relative error) of the scalar single-precision floating-point value from xmm3/m32 and stores result in xmm1with writemask k1. Also, upper 3 single-precision floating-point value (bits[127:32]) from xmm2 is copied to xmm1[127:32]."
    vendor_syntax {
      mnemonic: "VRSQRT28SS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512ER"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.LIG.66.0F38.W0 CD /r"
    instruction_group_index: 202
  }
  instructions {
    description: "Compare ST(0) with 0.0."
    vendor_syntax {
      mnemonic: "FTST"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D9 E4"
    instruction_group_index: 203
  }
  instructions {
    description: "Select byte values from xmm1 and xmm2/m128 from mask specified in the high bit of each byte in XMM0 and store the values into xmm1."
    vendor_syntax {
      mnemonic: "PBLENDVB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "<XMM0>"
        encoding: IMPLICIT_ENCODING
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "66 0F 38 10 /r"
    instruction_group_index: 204
  }
  instructions {
    description: "Select byte values from xmm2 and xmm3/m128 using mask bits in the specified mask register, xmm4, and store the values into xmm1."
    vendor_syntax {
      mnemonic: "VPBLENDVB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm4"
        encoding: VEX_SUFFIX_ENCODING
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVMR"
    raw_encoding_specification: "VEX.128.66.0F3A.W0 4C /r /is4"
    instruction_group_index: 204
  }
  instructions {
    description: "Select byte values from ymm2 and ymm3/m256 from mask specified in the high bit of each byte in ymm4 and store the values into ymm1."
    vendor_syntax {
      mnemonic: "VPBLENDVB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm4"
        encoding: VEX_SUFFIX_ENCODING
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVMR"
    raw_encoding_specification: "VEX.256.66.0F3A.W0 4C /r /is4"
    instruction_group_index: 204
  }
  instructions {
    description: "Write back and flush Internal caches; initiate writing-back and flushing of external caches."
    vendor_syntax {
      mnemonic: "WBINVD"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "0F 09"
    instruction_group_index: 205
  }
  instructions {
    description: "For legacy mode, compare byte at address DS:(E)SI with byte at address ES:(E)DI; For 64-bit mode compare byte at address (R|E)SI to byte at address (R|E)DI. The status flags are set accordingly."
    vendor_syntax {
      mnemonic: "CMPS"
      operands {
        name: "m8"
      }
      operands {
        name: "m8"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "A6"
    instruction_group_index: 206
  }
  instructions {
    description: "For legacy mode, compare word at address DS:(E)SI with word at address ES:(E)DI; For 64-bit mode compare word at address (R|E)SI with word at address (R|E)DI. The status flags are set accordingly."
    vendor_syntax {
      mnemonic: "CMPS"
      operands {
        name: "m16"
      }
      operands {
        name: "m16"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "A7"
    instruction_group_index: 206
  }
  instructions {
    description: "For legacy mode, compare dword at address DS:(E)SI at dword at address ES:(E)DI; For 64-bit mode compare dword at address (R|E)SI at dword at address (R|E)DI.\nThe status flags are set accordingly."
    vendor_syntax {
      mnemonic: "CMPS"
      operands {
        name: "m32"
      }
      operands {
        name: "m32"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "A7"
    instruction_group_index: 206
  }
  instructions {
    description: "Compares quadword at address (R|E)SI with quadword at address (R|E)DI and sets the status flags accordingly."
    vendor_syntax {
      mnemonic: "CMPS"
      operands {
        name: "m64"
      }
      operands {
        name: "m64"
      }
    }
    available_in_64_bit: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "REX.W + A7"
    instruction_group_index: 206
  }
  instructions {
    description: "For legacy mode, compare byte at address DS:(E)SI with byte at address ES:(E)DI; For 64-bit mode compare byte at address (R|E)SI with byte at address (R|E)DI. The status flags are set accordingly."
    vendor_syntax {
      mnemonic: "CMPSB"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "A6"
    instruction_group_index: 206
  }
  instructions {
    description: "For legacy mode, compare word at address DS:(E)SI with word at address ES:(E)DI; For 64-bit mode compare word at address (R|E)SI with word at address (R|E)DI. The status flags are set accordingly."
    vendor_syntax {
      mnemonic: "CMPSW"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "A7"
    instruction_group_index: 206
  }
  instructions {
    description: "For legacy mode, compare dword at address DS:(E)SI with dword at address ES:(E)DI; For 64-bit mode compare dword at address (R|E)SI with dword at address (R|E)DI. The status flags are set accordingly."
    vendor_syntax {
      mnemonic: "CMPSD"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "A7"
    instruction_group_index: 206
  }
  instructions {
    description: "Compares quadword at address (R|E)SI with quadword at address (R|E)DI and sets the status flags accordingly."
    vendor_syntax {
      mnemonic: "CMPSQ"
    }
    available_in_64_bit: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "REX.W + A7"
    instruction_group_index: 206
  }
  instructions {
    description: "Push m32fp onto the FPU register stack."
    vendor_syntax {
      mnemonic: "FLD"
      operands {
        name: "m32fp"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D9 /0"
    instruction_group_index: 207
  }
  instructions {
    description: "Push m64fp onto the FPU register stack."
    vendor_syntax {
      mnemonic: "FLD"
      operands {
        name: "m64fp"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DD /0"
    instruction_group_index: 207
  }
  instructions {
    description: "Push m80fp onto the FPU register stack."
    vendor_syntax {
      mnemonic: "FLD"
      operands {
        name: "m80fp"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DB /5"
    instruction_group_index: 207
  }
  instructions {
    description: "Push ST(i) onto the FPU register stack."
    vendor_syntax {
      mnemonic: "FLD"
      operands {
        name: "ST(i)"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D9 C0+i"
    instruction_group_index: 207
  }
  instructions {
    description: "Perform a reduction transformation on a scalar double-precision floating point value in xmm3/m64 by subtracting a number of fraction bits specified by the imm8 field. Also, upper double precision floating-point value (bits[127:64]) from xmm2 are copied to xmm1[127:64]. Stores the result in xmm1 register."
    vendor_syntax {
      mnemonic: "VREDUCESD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.NDS.LIG.66.0F3A.W1 57 /r"
    instruction_group_index: 208
  }
  instructions {
    description: "Return the minimum double-precision floating-point values between xmm1 and xmm2/mem"
    vendor_syntax {
      mnemonic: "MINPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 5D /r"
    instruction_group_index: 209
  }
  instructions {
    description: "Return the minimum double-precision floating-point values between xmm2 and xmm3/mem."
    vendor_syntax {
      mnemonic: "VMINPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG 5D /r"
    instruction_group_index: 209
  }
  instructions {
    description: "Return the minimum packed double-precision floating-point values between ymm2 and ymm3/mem."
    vendor_syntax {
      mnemonic: "VMINPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG 5D /r"
    instruction_group_index: 209
  }
  instructions {
    description: "Return the minimum packed double-precision floating-point values between xmm2 and xmm3/m128/m64bcst and store result in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VMINPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.W1 5D /r"
    instruction_group_index: 209
  }
  instructions {
    description: "Return the minimum packed double-precision floating-point values between ymm2 and ymm3/m256/m64bcst and store result in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VMINPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.W1 5D /r"
    instruction_group_index: 209
  }
  instructions {
    description: "Return the minimum packed double-precision floating-point values between zmm2 and zmm3/m512/m64bcst and store result in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VMINPD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.W1 5D /r"
    instruction_group_index: 209
  }
  instructions {
    description: "Divide packed single-precision floating-point values in xmm1 by packed single-precision floating-point values in xmm2/mem."
    vendor_syntax {
      mnemonic: "DIVPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 5E /r"
    instruction_group_index: 210
  }
  instructions {
    description: "Divide packed single-precision floating-point values in xmm2 by packed single-precision floating-point values in xmm3/mem."
    vendor_syntax {
      mnemonic: "VDIVPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.0F.WIG 5E /r"
    instruction_group_index: 210
  }
  instructions {
    description: "Divide packed single-precision floating-point values in ymm2 by packed single-precision floating-point values in ymm3/mem."
    vendor_syntax {
      mnemonic: "VDIVPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.0F.WIG 5E /r"
    instruction_group_index: 210
  }
  instructions {
    description: "Divide packed single-precision floating-point values in xmm2 by packed single-precision floating-point values in xmm3/m128/m32bcst and write results to xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VDIVPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.0F.W0 5E /r"
    instruction_group_index: 210
  }
  instructions {
    description: "Divide packed single-precision floating-point values in ymm2 by packed single-precision floating-point values in ymm3/m256/m32bcst and write results to ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VDIVPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.0F.W0 5E /r"
    instruction_group_index: 210
  }
  instructions {
    description: "Divide packed single-precision floating-point values in zmm2 by packed single-precision floating-point values in zmm3/m512/m32bcst and write results to zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VDIVPS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.0F.W0 5E /r"
    instruction_group_index: 210
  }
  instructions {
    description: "Write the value in EDX:EAX to the XCR specified by ECX."
    vendor_syntax {
      mnemonic: "XSETBV"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "NP 0F 01 D1"
    instruction_group_index: 211
  }
  instructions {
    description: "Scale the scalar double-precision floating-point values in xmm2 using the value from xmm3/m64. Under writemask k1."
    vendor_syntax {
      mnemonic: "VSCALEFSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.LIG.66.0F38.W1 2D /r"
    instruction_group_index: 212
  }
  instructions {
    description: "Move double-precision floating-point value from xmm2/m64 and duplicate into xmm1."
    vendor_syntax {
      mnemonic: "MOVDDUP"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F2 0F 12 /r"
    instruction_group_index: 213
  }
  instructions {
    description: "Move double-precision floating-point value from xmm2/m64 and duplicate into xmm1."
    vendor_syntax {
      mnemonic: "VMOVDDUP"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.F2.0F.WIG 12 /r"
    instruction_group_index: 213
  }
  instructions {
    description: "Move even index double-precision floating-point values from ymm2/mem and duplicate each element into ymm1."
    vendor_syntax {
      mnemonic: "VMOVDDUP"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.F2.0F.WIG 12 /r"
    instruction_group_index: 213
  }
  instructions {
    description: "Move double-precision floating-point value from xmm2/m64 and duplicate each element into xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VMOVDDUP"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.F2.0F.W1 12 /r"
    instruction_group_index: 213
  }
  instructions {
    description: "Move even index double-precision floating-point values from ymm2/m256 and duplicate each element into ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VMOVDDUP"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.F2.0F.W1 12 /r"
    instruction_group_index: 213
  }
  instructions {
    description: "Move even index double-precision floating-point values from zmm2/m512 and duplicate each element into zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VMOVDDUP"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.F2.0F.W1 12 /r"
    instruction_group_index: 213
  }
  instructions {
    description: "Convert two packed double-precision floating-point values from xmm2/mem to two packed unsigned quadword integers in xmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTPD2UQQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F.W1 79 /r"
    instruction_group_index: 214
  }
  instructions {
    description: "Convert fourth packed double-precision floating-point values from ymm2/mem to four packed unsigned quadword integers in ymm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTPD2UQQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F.W1 79 /r"
    instruction_group_index: 214
  }
  instructions {
    description: "Convert eight packed double-precision floating-point values from zmm2/mem to eight packed unsigned quadword integers in zmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTPD2UQQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F.W1 79 /r"
    instruction_group_index: 214
  }
  instructions {
    description: "Count the number of trailing zero bits in r/m16, return result in r16."
    vendor_syntax {
      mnemonic: "TZCNT"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "BMI1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F3 0F BC /r"
    instruction_group_index: 215
  }
  instructions {
    description: "Count the number of trailing zero bits in r/m32, return result in r32."
    vendor_syntax {
      mnemonic: "TZCNT"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "BMI1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F3 0F BC /r"
    instruction_group_index: 215
  }
  instructions {
    description: "Count the number of trailing zero bits in r/m64, return result in r64."
    vendor_syntax {
      mnemonic: "TZCNT"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "BMI1"
    available_in_64_bit: true
    encoding_scheme: "A"
    raw_encoding_specification: "F3 REX.W 0F BC /r"
    instruction_group_index: 215
  }
  instructions {
    description: "Convert 4 packed signed doubleword integers from xmm1 and 4 packed signed doubleword integers from xmm2/m128 into 8 packed unsigned word integers in xmm1 using unsigned saturation."
    vendor_syntax {
      mnemonic: "PACKUSDW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 38 2B /r"
    instruction_group_index: 216
  }
  instructions {
    description: "Convert 4 packed signed doubleword integers from xmm2 and 4 packed signed doubleword integers from xmm3/m128 into 8 packed unsigned word integers in xmm1 using unsigned saturation."
    vendor_syntax {
      mnemonic: "VPACKUSDW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F38 2B /r"
    instruction_group_index: 216
  }
  instructions {
    description: "Convert 8 packed signed doubleword integers from ymm2 and 8 packed signed doubleword integers from ymm3/m256 into 16 packed unsigned word integers in ymm1 using unsigned saturation."
    vendor_syntax {
      mnemonic: "VPACKUSDW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F38 2B /r"
    instruction_group_index: 216
  }
  instructions {
    description: "Convert packed signed doubleword integers from xmm2 and packed signed doubleword integers from xmm3/m128/m32bcst into packed unsigned word integers in xmm1 using unsigned saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPACKUSDW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 2B /r"
    instruction_group_index: 216
  }
  instructions {
    description: "Convert packed signed doubleword integers from ymm2 and packed signed doubleword integers from ymm3/m256/m32bcst into packed unsigned word integers in ymm1 using unsigned saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPACKUSDW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 2B /r"
    instruction_group_index: 216
  }
  instructions {
    description: "Convert packed signed doubleword integers from zmm2 and packed signed doubleword integers from zmm3/m512/m32bcst into packed unsigned word integers in zmm1 using unsigned saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPACKUSDW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 2B /r"
    instruction_group_index: 216
  }
  instructions {
    description: "Computes the approximate reciprocal ( < 2^-28 relative error) of the scalar single-precision floating-point value in xmm3/m32 and stores the results in xmm1. Under writemask. Also, upper 3 single-precision floating-point values (bits[127:32]) from xmm2 is copied to xmm1[127:32]."
    vendor_syntax {
      mnemonic: "VRCP28SS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512ER"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.LIG.66.0F38.W0 CB /r"
    instruction_group_index: 217
  }
  instructions {
    description: "Return the maximum scalar double-precision floating-point value between xmm2/m64 and xmm1."
    vendor_syntax {
      mnemonic: "MAXSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F2 0F 5F /r"
    instruction_group_index: 219
  }
  instructions {
    description: "Return the maximum scalar double-precision floating-point value between xmm3/m64 and xmm2."
    vendor_syntax {
      mnemonic: "VMAXSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.LIG.F2.0F.WIG 5F /r"
    instruction_group_index: 219
  }
  instructions {
    description: "Return the maximum scalar double-precision floating-point value between xmm3/m64 and xmm2."
    vendor_syntax {
      mnemonic: "VMAXSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.LIG.F2.0F.W1 5F /r"
    instruction_group_index: 219
  }
  instructions {
    description: "Perform reduction transformation on packed single-precision floating point values in xmm2/m128/m32bcst by subtracting a number of fraction bits specified by the imm8 field. Stores the result in xmm1 register under writemask k1."
    vendor_syntax {
      mnemonic: "VREDUCEPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F3A.W0 56 /r ib"
    instruction_group_index: 220
  }
  instructions {
    description: "Perform reduction transformation on packed single-precision floating point values in ymm2/m256/m32bcst by subtracting a number of fraction bits specified by the imm8 field. Stores the result in ymm1 register under writemask k1."
    vendor_syntax {
      mnemonic: "VREDUCEPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F3A.W0 56 /r ib"
    instruction_group_index: 220
  }
  instructions {
    description: "Perform reduction transformation on packed single-precision floating point values in zmm2/m512/m32bcst by subtracting a number of fraction bits specified by the imm8 field. Stores the result in zmm1 register under writemask k1."
    vendor_syntax {
      mnemonic: "VREDUCEPS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F3A.W0 56 /r ib"
    instruction_group_index: 220
  }
  instructions {
    description: "Tests the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result."
    vendor_syntax {
      mnemonic: "VFPCLASSPD"
      operands {
        name: "k2"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F3A.W1 66 /r ib"
    instruction_group_index: 221
  }
  instructions {
    description: "Tests the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result."
    vendor_syntax {
      mnemonic: "VFPCLASSPD"
      operands {
        name: "k2"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F3A.W1 66 /r ib"
    instruction_group_index: 221
  }
  instructions {
    description: "Tests the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result."
    vendor_syntax {
      mnemonic: "VFPCLASSPD"
      operands {
        name: "k2"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F3A.W1 66 /r ib"
    instruction_group_index: 221
  }
  instructions {
    description: "Jump short, RIP = RIP + 8-bit displacement sign extended to 64-bits"
    vendor_syntax {
      mnemonic: "JMP"
      operands {
        name: "rel8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EB cb"
    instruction_group_index: 222
  }
  instructions {
    description: "Jump near, relative, displacement relative to next instruction. Not supported in 64-bit mode."
    vendor_syntax {
      mnemonic: "JMP"
      operands {
        name: "rel16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "E9 cw"
    instruction_group_index: 222
  }
  instructions {
    description: "Jump near, relative, RIP = RIP + 32-bit displacement sign extended to 64-bits"
    vendor_syntax {
      mnemonic: "JMP"
      operands {
        name: "rel32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "E9 cd"
    instruction_group_index: 222
  }
  instructions {
    description: "Jump near, absolute indirect, address = zeroextended r/m16. Not supported in 64-bit mode."
    vendor_syntax {
      mnemonic: "JMP"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "FF /4"
    instruction_group_index: 222
  }
  instructions {
    description: "Jump near, absolute indirect, address given in r/m32. Not supported in 64-bit mode."
    vendor_syntax {
      mnemonic: "JMP"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "FF /4"
    instruction_group_index: 222
  }
  instructions {
    description: "Jump near, absolute indirect, RIP = 64-Bit offset from register or memory"
    vendor_syntax {
      mnemonic: "JMP"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "FF /4"
    instruction_group_index: 222
  }
  instructions {
    description: "Jump far, absolute, address given in operand"
    vendor_syntax {
      mnemonic: "JMP"
      operands {
        name: "ptr16:16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EA cd"
    instruction_group_index: 222
  }
  instructions {
    description: "Jump far, absolute, address given in operand"
    vendor_syntax {
      mnemonic: "JMP"
      operands {
        name: "ptr16:32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EA cp"
    instruction_group_index: 222
  }
  instructions {
    description: "Jump far, absolute indirect, address given in m16:16"
    vendor_syntax {
      mnemonic: "JMP"
      operands {
        name: "m16:16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "FF /5"
    instruction_group_index: 222
  }
  instructions {
    description: "Jump far, absolute indirect, address given in m16:32."
    vendor_syntax {
      mnemonic: "JMP"
      operands {
        name: "m16:32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "FF /5"
    instruction_group_index: 222
  }
  instructions {
    description: "Jump far, absolute indirect, address given in m16:64."
    vendor_syntax {
      mnemonic: "JMP"
      operands {
        name: "m16:64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX.W FF /5"
    instruction_group_index: 222
  }
  instructions {
    description: "Select from quadruplet of single-precision floatingpoint values in xmm1 and xmm2/m128 using imm8, interleaved result pairs are stored in xmm1."
    vendor_syntax {
      mnemonic: "SHUFPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F C6 /r ib"
    instruction_group_index: 223
  }
  instructions {
    description: "Select from quadruplet of single-precision floatingpoint values in xmm1 and xmm2/m128 using imm8, interleaved result pairs are stored in xmm1."
    vendor_syntax {
      mnemonic: "VSHUFPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.0F.WIG C6 /r ib"
    instruction_group_index: 223
  }
  instructions {
    description: "Select from quadruplet of single-precision floatingpoint values in ymm2 and ymm3/m256 using imm8, interleaved result pairs are stored in ymm1."
    vendor_syntax {
      mnemonic: "VSHUFPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.0F.WIG C6 /r ib"
    instruction_group_index: 223
  }
  instructions {
    description: "Select from quadruplet of single-precision floatingpoint values in xmm1 and xmm2/m128 using imm8, interleaved result pairs are stored in xmm1, subject to writemask k1."
    vendor_syntax {
      mnemonic: "VSHUFPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.0F.W0 C6 /r ib"
    instruction_group_index: 223
  }
  instructions {
    description: "Select from quadruplet of single-precision floatingpoint values in ymm2 and ymm3/m256 using imm8, interleaved result pairs are stored in ymm1, subject to writemask k1."
    vendor_syntax {
      mnemonic: "VSHUFPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.0F.W0 C6 /r ib"
    instruction_group_index: 223
  }
  instructions {
    description: "Select from quadruplet of single-precision floatingpoint values in zmm2 and zmm3/m512 using imm8, interleaved result pairs are stored in zmm1, subject to writemask k1."
    vendor_syntax {
      mnemonic: "VSHUFPS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.0F.W0 C6 /r ib"
    instruction_group_index: 223
  }
  instructions {
    description: "Fast call to privilege level 0 system procedures."
    vendor_syntax {
      mnemonic: "SYSENTER"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "0F 34"
    instruction_group_index: 224
  }
  instructions {
    description: "Permute 128-bit integer data in ymm2 and ymm3/mem using controls from imm8 and store result in ymm1."
    vendor_syntax {
      mnemonic: "VPERM2I128"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVMI"
    raw_encoding_specification: "VEX.256.66.0F3A.W0 46 /r ib"
    instruction_group_index: 225
  }
  instructions {
    description: "Add 16-bit signed integers horizontally, pack saturated integers to mm1."
    vendor_syntax {
      mnemonic: "PHADDSW"
      operands {
        name: "mm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "NP 0F 38 03 /r"
    instruction_group_index: 226
  }
  instructions {
    description: "Add 16-bit signed integers horizontally, pack saturated integers to xmm1."
    vendor_syntax {
      mnemonic: "PHADDSW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "66 0F 38 03 /r"
    instruction_group_index: 226
  }
  instructions {
    description: "Add 16-bit signed integers horizontally, pack saturated integers to xmm1."
    vendor_syntax {
      mnemonic: "VPHADDSW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.128.66.0F38.WIG 03 /r"
    instruction_group_index: 226
  }
  instructions {
    description: "Add 16-bit signed integers horizontally, pack saturated integers to ymm1."
    vendor_syntax {
      mnemonic: "VPHADDSW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.256.66.0F38.WIG 03 /r"
    instruction_group_index: 226
  }
  instructions {
    description: "No operation is performed."
    vendor_syntax {
      mnemonic: "FNOP"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D9 D0"
    instruction_group_index: 227
  }
  instructions {
    description: "Subtract quadword integer in mm1 from mm2 /m64."
    vendor_syntax {
      mnemonic: "PSUBQ"
      operands {
        name: "mm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F FB /r"
    instruction_group_index: 228
  }
  instructions {
    description: "Subtract packed quadword integers in xmm1 from xmm2 /m128."
    vendor_syntax {
      mnemonic: "PSUBQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F FB /r"
    instruction_group_index: 228
  }
  instructions {
    description: "Subtract packed quadword integers in xmm3/m128 from xmm2."
    vendor_syntax {
      mnemonic: "VPSUBQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG FB/r"
    instruction_group_index: 228
  }
  instructions {
    description: "Subtract packed quadword integers in ymm3/m256 from ymm2."
    vendor_syntax {
      mnemonic: "VPSUBQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG FB /r"
    instruction_group_index: 228
  }
  instructions {
    description: "Subtract packed quadword integers in xmm3/m128/m64bcst from xmm2 and store in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPSUBQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.W1 FB /r"
    instruction_group_index: 228
  }
  instructions {
    description: "Subtract packed quadword integers in ymm3/m256/m64bcst from ymm2 and store in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPSUBQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.W1 FB /r"
    instruction_group_index: 228
  }
  instructions {
    description: "Subtract packed quadword integers in zmm3/m512/m64bcst from zmm2 and store in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPSUBQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.W1 FB/r"
    instruction_group_index: 228
  }
  instructions {
    description: "Raise invalid opcode exception."
    vendor_syntax {
      mnemonic: "UD01"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F FF /r"
    instruction_group_index: 229
  }
  instructions {
    description: "Raise invalid opcode exception."
    vendor_syntax {
      mnemonic: "UD1"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F B9 /r"
    instruction_group_index: 229
  }
  instructions {
    description: "Raise invalid opcode exception."
    vendor_syntax {
      mnemonic: "UD2"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "0F 0B"
    instruction_group_index: 229
  }
  instructions {
    description: "Blend doubleword integer vector xmm2 and doubleword vector xmm3/m128/m32bcst and store the result in xmm1, under control mask."
    vendor_syntax {
      mnemonic: "VPBLENDMD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 64 /r"
    instruction_group_index: 230
  }
  instructions {
    description: "Blend doubleword integer vector ymm2 and doubleword vector ymm3/m256/m32bcst and store the result in ymm1, under control mask."
    vendor_syntax {
      mnemonic: "VPBLENDMD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 64 /r"
    instruction_group_index: 230
  }
  instructions {
    description: "Blend doubleword integer vector zmm2 and doubleword vector zmm3/m512/m32bcst and store the result in zmm1, under control mask."
    vendor_syntax {
      mnemonic: "VPBLENDMD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 64 /r"
    instruction_group_index: 230
  }
  instructions {
    description: "Blend quadword integer vector xmm2 and quadword vector xmm3/m128/m64bcst and store the result in xmm1, under control mask."
    vendor_syntax {
      mnemonic: "VPBLENDMQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 64 /r"
    instruction_group_index: 230
  }
  instructions {
    description: "Blend quadword integer vector ymm2 and quadword vector ymm3/m256/m64bcst and store the result in ymm1, under control mask."
    vendor_syntax {
      mnemonic: "VPBLENDMQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 64 /r"
    instruction_group_index: 230
  }
  instructions {
    description: "Blend quadword integer vector zmm2 and quadword vector zmm3/m512/m64bcst and store the result in zmm1, under control mask."
    vendor_syntax {
      mnemonic: "VPBLENDMQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 64 /r"
    instruction_group_index: 230
  }
  instructions {
    description: "Computes the approximate reciprocal ( < 2^-28 relative error) of the scalar double-precision floating-point value in xmm3/m64 and stores the results in xmm1. Under writemask. Also, upper double-precision floating-point value (bits[127:64]) from xmm2 is copied to xmm1[127:64]."
    vendor_syntax {
      mnemonic: "VRCP28SD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512ER"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.LIG.66.0F38.W1 CB /r"
    instruction_group_index: 231
  }
  instructions {
    description: "Set SP to BP, then pop BP."
    vendor_syntax {
      mnemonic: "LEAVE"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "C9"
    instruction_group_index: 233
  }
  instructions {
    description: "Set ESP to EBP, then pop EBP."
    vendor_syntax {
      mnemonic: "LEAVE"
    }
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "C9"
    instruction_group_index: 233
  }
  instructions {
    description: "Set RSP to RBP, then pop RBP."
    vendor_syntax {
      mnemonic: "LEAVE"
    }
    available_in_64_bit: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "C9"
    instruction_group_index: 233
  }
  instructions {
    description: "Read time-stamp counter into EDX:EAX."
    vendor_syntax {
      mnemonic: "RDTSC"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "0F 31"
    instruction_group_index: 234
  }
  instructions {
    description: "Serializes store operations."
    vendor_syntax {
      mnemonic: "SFENCE"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "NP 0F AE F8"
    instruction_group_index: 235
  }
  instructions {
    description: "Fix up special numbers in float64 vector xmm1, float64 vector xmm2 and int64 vector xmm3/m128/m64bcst and store the result in xmm1, under writemask."
    vendor_syntax {
      mnemonic: "VFIXUPIMMPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F3A.W1 54 /r ib"
    instruction_group_index: 236
  }
  instructions {
    description: "Fix up special numbers in float64 vector ymm1, float64 vector ymm2 and int64 vector ymm3/m256/m64bcst and store the result in ymm1, under writemask."
    vendor_syntax {
      mnemonic: "VFIXUPIMMPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F3A.W1 54 /r ib"
    instruction_group_index: 236
  }
  instructions {
    description: "Fix up elements of float64 vector in zmm2 using int64 vector table in zmm3/m512/m64bcst, combine with preserved elements from zmm1, and store the result in zmm1."
    vendor_syntax {
      mnemonic: "VFIXUPIMMPD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F3A.W1 54 /r ib"
    instruction_group_index: 236
  }
  instructions {
    description: "Convert BCD value to floating-point and push onto the FPU stack."
    vendor_syntax {
      mnemonic: "FBLD"
      operands {
        name: "m80bcd"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DF /4"
    instruction_group_index: 237
  }
  instructions {
    description: "Push lower 16 bits of EFLAGS."
    vendor_syntax {
      mnemonic: "PUSHF"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "9C"
    instruction_group_index: 238
  }
  instructions {
    description: "Push EFLAGS."
    vendor_syntax {
      mnemonic: "PUSHFD"
    }
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "9C"
    instruction_group_index: 238
  }
  instructions {
    description: "Push RFLAGS."
    vendor_syntax {
      mnemonic: "PUSHFQ"
    }
    available_in_64_bit: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "9C"
    instruction_group_index: 238
  }
  instructions {
    description: "Multiply unsigned 52-bit integers in xmm2 and xmm3/m128 and add the low 52 bits of the 104-bit product to the qword unsigned integers in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPMADD52LUQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_IFMA && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 B4 /r"
    instruction_group_index: 239
  }
  instructions {
    description: "Multiply unsigned 52-bit integers in ymm2 and ymm3/m256 and add the low 52 bits of the 104-bit product to the qword unsigned integers in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPMADD52LUQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_IFMA && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 B4 /r"
    instruction_group_index: 239
  }
  instructions {
    description: "Multiply unsigned 52-bit integers in zmm2 and zmm3/m512 and add the low 52 bits of the 104-bit product to the qword unsigned integers in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPMADD52LUQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_IFMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 B4 /r"
    instruction_group_index: 239
  }
  instructions {
    description: "Subtract signed packed bytes in mm/m64 from signed packed bytes in mm and saturate results."
    vendor_syntax {
      mnemonic: "PSUBSB"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F E8 /r"
    instruction_group_index: 240
  }
  instructions {
    description: "Subtract packed signed byte integers in xmm2/m128 from packed signed byte integers in xmm1 and saturate results."
    vendor_syntax {
      mnemonic: "PSUBSB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F E8 /r"
    instruction_group_index: 240
  }
  instructions {
    description: "Subtract signed packed words in mm/m64 from signed packed words in mm and saturate results."
    vendor_syntax {
      mnemonic: "PSUBSW"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F E9 /r"
    instruction_group_index: 240
  }
  instructions {
    description: "Subtract packed signed word integers in xmm2/m128 from packed signed word integers in xmm1 and saturate results."
    vendor_syntax {
      mnemonic: "PSUBSW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F E9 /r"
    instruction_group_index: 240
  }
  instructions {
    description: "Subtract packed signed byte integers in xmm3/m128 from packed signed byte integers in xmm2 and saturate results."
    vendor_syntax {
      mnemonic: "VPSUBSB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG E8 /r"
    instruction_group_index: 240
  }
  instructions {
    description: "Subtract packed signed word integers in xmm3/m128 from packed signed word integers in xmm2 and saturate results."
    vendor_syntax {
      mnemonic: "VPSUBSW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG E9 /r"
    instruction_group_index: 240
  }
  instructions {
    description: "Subtract packed signed byte integers in ymm3/m256 from packed signed byte integers in ymm2 and saturate results."
    vendor_syntax {
      mnemonic: "VPSUBSB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG E8 /r"
    instruction_group_index: 240
  }
  instructions {
    description: "Subtract packed signed word integers in ymm3/m256 from packed signed word integers in ymm2 and saturate results."
    vendor_syntax {
      mnemonic: "VPSUBSW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG E9 /r"
    instruction_group_index: 240
  }
  instructions {
    description: "Subtract packed signed byte integers in xmm3/m128 from packed signed byte integers in xmm2 and saturate results and store in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPSUBSB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.WIG E8 /r"
    instruction_group_index: 240
  }
  instructions {
    description: "Subtract packed signed byte integers in ymm3/m256 from packed signed byte integers in ymm2 and saturate results and store in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPSUBSB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.WIG E8 /r"
    instruction_group_index: 240
  }
  instructions {
    description: "Subtract packed signed byte integers in zmm3/m512 from packed signed byte integers in zmm2 and saturate results and store in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPSUBSB"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.WIG E8 /r"
    instruction_group_index: 240
  }
  instructions {
    description: "Subtract packed signed word integers in xmm3/m128 from packed signed word integers in xmm2 and saturate results and store in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPSUBSW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.WIG E9 /r"
    instruction_group_index: 240
  }
  instructions {
    description: "Subtract packed signed word integers in ymm3/m256 from packed signed word integers in ymm2 and saturate results and store in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPSUBSW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.WIG E9 /r"
    instruction_group_index: 240
  }
  instructions {
    description: "Subtract packed signed word integers in zmm3/m512 from packed signed word integers in zmm2 and saturate results and store in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPSUBSW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.WIG E9 /r"
    instruction_group_index: 240
  }
  instructions {
    description: "Computes the approximate reciprocal square root of the scalar double-precision floating-point value in xmm3/m64 and stores the result in the low quadword element of xmm1 using writemask k1. Bits[127:64] of xmm2 is copied to xmm1[127:64]."
    vendor_syntax {
      mnemonic: "VRSQRT14SD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.LIG.66.0F38.W1 4F /r"
    instruction_group_index: 241
  }
  instructions {
    description: "Clear DF flag."
    vendor_syntax {
      mnemonic: "CLD"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "FC"
    instruction_group_index: 242
  }
  instructions {
    description: "Blend double-precision vector xmm2 and double-precision vector xmm3/m128/m64bcst and store the result in xmm1, under control mask."
    vendor_syntax {
      mnemonic: "VBLENDMPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 65 /r"
    instruction_group_index: 243
  }
  instructions {
    description: "Blend double-precision vector ymm2 and double-precision vector ymm3/m256/m64bcst and store the result in ymm1, under control mask."
    vendor_syntax {
      mnemonic: "VBLENDMPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 65 /r"
    instruction_group_index: 243
  }
  instructions {
    description: "Blend double-precision vector zmm2 and double-precision vector zmm3/m512/m64bcst and store the result in zmm1, under control mask."
    vendor_syntax {
      mnemonic: "VBLENDMPD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 65 /r"
    instruction_group_index: 243
  }
  instructions {
    description: "Blend single-precision vector xmm2 and single-precision vector xmm3/m128/m32bcst and store the result in xmm1, under control mask."
    vendor_syntax {
      mnemonic: "VBLENDMPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 65 /r"
    instruction_group_index: 243
  }
  instructions {
    description: "Blend single-precision vector ymm2 and single-precision vector ymm3/m256/m32bcst and store the result in ymm1, under control mask."
    vendor_syntax {
      mnemonic: "VBLENDMPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 65 /r"
    instruction_group_index: 243
  }
  instructions {
    description: "Blend single-precision vector zmm2 and single-precision vector zmm3/m512/m32bcst using k1 as select control and store the result in zmm1."
    vendor_syntax {
      mnemonic: "VBLENDMPS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 65 /r"
    instruction_group_index: 243
  }
  instructions {
    description: "Return the bitwise logical AND of packed doubleprecision floating-point values in xmm1 and xmm2/mem."
    vendor_syntax {
      mnemonic: "ANDPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 54 /r"
    instruction_group_index: 244
  }
  instructions {
    description: "Return the bitwise logical AND of packed doubleprecision floating-point values in xmm2 and xmm3/mem."
    vendor_syntax {
      mnemonic: "VANDPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F 54 /r"
    instruction_group_index: 244
  }
  instructions {
    description: "Return the bitwise logical AND of packed doubleprecision floating-point values in ymm2 and ymm3/mem."
    vendor_syntax {
      mnemonic: "VANDPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F 54 /r"
    instruction_group_index: 244
  }
  instructions {
    description: "Return the bitwise logical AND of packed doubleprecision floating-point values in xmm2 and xmm3/m128/m64bcst subject to writemask k1."
    vendor_syntax {
      mnemonic: "VANDPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.W1 54 /r"
    instruction_group_index: 244
  }
  instructions {
    description: "Return the bitwise logical AND of packed doubleprecision floating-point values in ymm2 and ymm3/m256/m64bcst subject to writemask k1."
    vendor_syntax {
      mnemonic: "VANDPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.W1 54 /r"
    instruction_group_index: 244
  }
  instructions {
    description: "Return the bitwise logical AND of packed doubleprecision floating-point values in zmm2 and zmm3/m512/m64bcst subject to writemask k1."
    vendor_syntax {
      mnemonic: "VANDPD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.W1 54 /r"
    instruction_group_index: 244
  }
  instructions {
    description: "Specifies the end of an RTM code region."
    vendor_syntax {
      mnemonic: "XEND"
    }
    feature_name: "RTM"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 01 D5"
    instruction_group_index: 245
  }
  instructions {
    description: "Push +1.0 onto the FPU register stack."
    vendor_syntax {
      mnemonic: "FLD1"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D9 E8"
    instruction_group_index: 246
  }
  instructions {
    description: "Push log210 onto the FPU register stack."
    vendor_syntax {
      mnemonic: "FLDL2T"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D9 E9"
    instruction_group_index: 246
  }
  instructions {
    description: "Push log2e onto the FPU register stack."
    vendor_syntax {
      mnemonic: "FLDL2E"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D9 EA"
    instruction_group_index: 246
  }
  instructions {
    description: "Push \317\200 onto the FPU register stack."
    vendor_syntax {
      mnemonic: "FLDPI"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D9 EB"
    instruction_group_index: 246
  }
  instructions {
    description: "Push log102 onto the FPU register stack."
    vendor_syntax {
      mnemonic: "FLDLG2"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D9 EC"
    instruction_group_index: 246
  }
  instructions {
    description: "Push loge2 onto the FPU register stack."
    vendor_syntax {
      mnemonic: "FLDLN2"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D9 ED"
    instruction_group_index: 246
  }
  instructions {
    description: "Push +0.0 onto the FPU register stack."
    vendor_syntax {
      mnemonic: "FLDZ"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D9 EE"
    instruction_group_index: 246
  }
  instructions {
    description: "Add/subtract single-precision floating-point values from xmm2/m128 to xmm1."
    vendor_syntax {
      mnemonic: "ADDSUBPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "F2 0F D0 /r"
    instruction_group_index: 247
  }
  instructions {
    description: "Add/subtract single-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1."
    vendor_syntax {
      mnemonic: "VADDSUBPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.128.F2.0F.WIG D0 /r"
    instruction_group_index: 247
  }
  instructions {
    description: "Add / subtract single-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1."
    vendor_syntax {
      mnemonic: "VADDSUBPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.256.F2.0F.WIG D0 /r"
    instruction_group_index: 247
  }
  instructions {
    description: "Gives hint to processor that improves performance of spin-wait loops."
    vendor_syntax {
      mnemonic: "PAUSE"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F3 90"
    instruction_group_index: 248
  }
  instructions {
    description: "Complements sign of ST(0)."
    vendor_syntax {
      mnemonic: "FCHS"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D9 E0"
    instruction_group_index: 249
  }
  instructions {
    description: "Output byte from memory location specified in DS:(E)SI or RSI to I/O port specified in DX**."
    vendor_syntax {
      mnemonic: "OUTS"
      operands {
        name: "DX"
      }
      operands {
        name: "m8"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "6E"
    instruction_group_index: 250
  }
  instructions {
    description: "Output word from memory location specified in DS:(E)SI or RSI to I/O port specified in DX**."
    vendor_syntax {
      mnemonic: "OUTS"
      operands {
        name: "DX"
      }
      operands {
        name: "m16"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "6F"
    instruction_group_index: 250
  }
  instructions {
    description: "Output doubleword from memory location specified in DS:(E)SI or RSI to I/O port specified in DX**."
    vendor_syntax {
      mnemonic: "OUTS"
      operands {
        name: "DX"
      }
      operands {
        name: "m32"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "6F"
    instruction_group_index: 250
  }
  instructions {
    description: "Output byte from memory location specified in DS:(E)SI or RSI to I/O port specified in DX**."
    vendor_syntax {
      mnemonic: "OUTSB"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "6E"
    instruction_group_index: 250
  }
  instructions {
    description: "Output word from memory location specified in DS:(E)SI or RSI to I/O port specified in DX**."
    vendor_syntax {
      mnemonic: "OUTSW"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "6F"
    instruction_group_index: 250
  }
  instructions {
    description: "Output doubleword from memory location specified in DS:(E)SI or RSI to I/O port specified in DX**."
    vendor_syntax {
      mnemonic: "OUTSD"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "6F"
    instruction_group_index: 250
  }
  instructions {
    description: "Multiply scalar single-precision floating-point value from xmm1 and xmm3/m32, negate the multiplication result andadd to xmm2 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMADD132SS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.LIG.66.0F38.W0 9D /r"
    instruction_group_index: 251
  }
  instructions {
    description: "Multiply scalar single-precision floating-point value from xmm1 and xmm2, negate the multiplication result and add to xmm3/m32 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMADD213SS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.LIG.66.0F38.W0 AD /r"
    instruction_group_index: 251
  }
  instructions {
    description: "Multiply scalar single-precision floating-point value from xmm2 and xmm3/m32, negate the multiplication result and add to xmm1 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMADD231SS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.LIG.66.0F38.W0 BD /r"
    instruction_group_index: 251
  }
  instructions {
    description: "Multiply scalar single-precision floating-point value from xmm1 and xmm3/m32, negate the multiplication result andadd to xmm2 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMADD132SS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.LIG.66.0F38.W0 9D /r"
    instruction_group_index: 251
  }
  instructions {
    description: "Multiply scalar single-precision floating-point value from xmm1 and xmm2, negate the multiplication result and add to xmm3/m32 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMADD213SS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.LIG.66.0F38.W0 AD /r"
    instruction_group_index: 251
  }
  instructions {
    description: "Multiply scalar single-precision floating-point value from xmm2 and xmm3/m32, negate the multiplication result and add to xmm1 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMADD231SS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.LIG.66.0F38.W0 BD /r"
    instruction_group_index: 251
  }
  instructions {
    description: "Load FPU state from m94byte or m108byte."
    vendor_syntax {
      mnemonic: "FRSTOR"
      operands {
        name: "m94/108byte"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DD /4"
    instruction_group_index: 252
  }
  instructions {
    description: "Convert two packed double-precision floating-point values in xmm2/mem to two signed doubleword integers in xmm1 using truncation."
    vendor_syntax {
      mnemonic: "CVTTPD2DQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F E6 /r"
    instruction_group_index: 253
  }
  instructions {
    description: "Convert two packed double-precision floating-point values in xmm2/mem to two signed doubleword integers in xmm1 using truncation."
    vendor_syntax {
      mnemonic: "VCVTTPD2DQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F.WIG E6 /r"
    instruction_group_index: 253
  }
  instructions {
    description: "Convert four packed double-precision floating-point values in ymm2/mem to four signed doubleword integers in xmm1 using truncation."
    vendor_syntax {
      mnemonic: "VCVTTPD2DQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F.WIG E6 /r"
    instruction_group_index: 253
  }
  instructions {
    description: "Convert two packed double-precision floating-point values in xmm2/m128/m64bcst to two signed doubleword integers in xmm1 using truncation subject to writemask k1."
    vendor_syntax {
      mnemonic: "VCVTTPD2DQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F.W1 E6 /r"
    instruction_group_index: 253
  }
  instructions {
    description: "Convert four packed double-precision floating-point values in ymm2/m256/m64bcst to four signed doubleword integers in xmm1 using truncation subject to writemask k1."
    vendor_syntax {
      mnemonic: "VCVTTPD2DQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F.W1 E6 /r"
    instruction_group_index: 253
  }
  instructions {
    description: "Convert eight packed double-precision floating-point values in zmm2/m512/m64bcst to eight signed doubleword integers in ymm1 using truncation subject to writemask k1."
    vendor_syntax {
      mnemonic: "VCVTTPD2DQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F.W1 E6 /r"
    instruction_group_index: 253
  }
  instructions {
    description: "Replace ST(0) with the IEEE remainder obtained from dividing ST(0) by ST(1)."
    vendor_syntax {
      mnemonic: "FPREM1"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D9 F5"
    instruction_group_index: 254
  }
  instructions {
    description: "AL OR imm8."
    vendor_syntax {
      mnemonic: "OR"
      operands {
        name: "AL"
        encoding: IMPLICIT_ENCODING
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "I"
    raw_encoding_specification: "0C ib"
    instruction_group_index: 255
  }
  instructions {
    description: "AX OR imm16."
    vendor_syntax {
      mnemonic: "OR"
      operands {
        name: "AX"
        encoding: IMPLICIT_ENCODING
      }
      operands {
        name: "imm16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "I"
    raw_encoding_specification: "0D iw"
    instruction_group_index: 255
  }
  instructions {
    description: "EAX OR imm32."
    vendor_syntax {
      mnemonic: "OR"
      operands {
        name: "EAX"
        encoding: IMPLICIT_ENCODING
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "I"
    raw_encoding_specification: "0D id"
    instruction_group_index: 255
  }
  instructions {
    description: "RAX OR imm32 (sign-extended)."
    vendor_syntax {
      mnemonic: "OR"
      operands {
        name: "RAX"
        encoding: IMPLICIT_ENCODING
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "I"
    raw_encoding_specification: "REX.W + 0D id"
    instruction_group_index: 255
  }
  instructions {
    description: "r/m8 OR imm8."
    vendor_syntax {
      mnemonic: "OR"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "80 /1 ib"
    instruction_group_index: 255
  }
  instructions {
    description: "r/m8 OR imm8."
    vendor_syntax {
      mnemonic: "OR"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX + 80 /1 ib"
    instruction_group_index: 255
  }
  instructions {
    description: "r/m16 OR imm16."
    vendor_syntax {
      mnemonic: "OR"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "81 /1 iw"
    instruction_group_index: 255
  }
  instructions {
    description: "r/m32 OR imm32."
    vendor_syntax {
      mnemonic: "OR"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "81 /1 id"
    instruction_group_index: 255
  }
  instructions {
    description: "r/m64 OR imm32 (sign-extended)."
    vendor_syntax {
      mnemonic: "OR"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX.W + 81 /1 id"
    instruction_group_index: 255
  }
  instructions {
    description: "r/m16 OR imm8 (sign-extended)."
    vendor_syntax {
      mnemonic: "OR"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "83 /1 ib"
    instruction_group_index: 255
  }
  instructions {
    description: "r/m32 OR imm8 (sign-extended)."
    vendor_syntax {
      mnemonic: "OR"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "83 /1 ib"
    instruction_group_index: 255
  }
  instructions {
    description: "r/m64 OR imm8 (sign-extended)."
    vendor_syntax {
      mnemonic: "OR"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX.W + 83 /1 ib"
    instruction_group_index: 255
  }
  instructions {
    description: "r/m8 OR r8."
    vendor_syntax {
      mnemonic: "OR"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "08 /r"
    instruction_group_index: 255
  }
  instructions {
    description: "r/m8 OR r8."
    vendor_syntax {
      mnemonic: "OR"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MR"
    raw_encoding_specification: "REX + 08 /r"
    instruction_group_index: 255
  }
  instructions {
    description: "r/m16 OR r16."
    vendor_syntax {
      mnemonic: "OR"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "09 /r"
    instruction_group_index: 255
  }
  instructions {
    description: "r/m32 OR r32."
    vendor_syntax {
      mnemonic: "OR"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "09 /r"
    instruction_group_index: 255
  }
  instructions {
    description: "r/m64 OR r64."
    vendor_syntax {
      mnemonic: "OR"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MR"
    raw_encoding_specification: "REX.W + 09 /r"
    instruction_group_index: 255
  }
  instructions {
    description: "r8 OR r/m8."
    vendor_syntax {
      mnemonic: "OR"
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0A /r"
    instruction_group_index: 255
  }
  instructions {
    description: "r8 OR r/m8."
    vendor_syntax {
      mnemonic: "OR"
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX + 0A /r"
    instruction_group_index: 255
  }
  instructions {
    description: "r16 OR r/m16."
    vendor_syntax {
      mnemonic: "OR"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0B /r"
    instruction_group_index: 255
  }
  instructions {
    description: "r32 OR r/m32."
    vendor_syntax {
      mnemonic: "OR"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0B /r"
    instruction_group_index: 255
  }
  instructions {
    description: "r64 OR r/m64."
    vendor_syntax {
      mnemonic: "OR"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 0B /r"
    instruction_group_index: 255
  }
  instructions {
    description: "Move two packed single-precision floating-point values from m64 to low quadword of xmm1."
    vendor_syntax {
      mnemonic: "MOVLPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 12 /r"
    instruction_group_index: 256
  }
  instructions {
    description: "Merge two packed single-precision floating-point values from m64 and the high quadword of xmm1."
    vendor_syntax {
      mnemonic: "VMOVLPS"
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.0F.WIG 12 /r"
    instruction_group_index: 256
  }
  instructions {
    description: "Merge two packed single-precision floating-point values from m64 and the high quadword of xmm1."
    vendor_syntax {
      mnemonic: "VMOVLPS"
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.128.0F.W0 12 /r"
    instruction_group_index: 256
  }
  instructions {
    description: "Move two packed single-precision floating-point values from low quadword of xmm1 to m64."
    vendor_syntax {
      mnemonic: "MOVLPS"
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "0F 13/r"
    instruction_group_index: 256
  }
  instructions {
    description: "Move two packed single-precision floating-point values from low quadword of xmm1 to m64."
    vendor_syntax {
      mnemonic: "VMOVLPS"
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "VEX.128.0F.WIG 13/r"
    instruction_group_index: 256
  }
  instructions {
    description: "Move two packed single-precision floating-point values from low quadword of xmm1 to m64."
    vendor_syntax {
      mnemonic: "VMOVLPS"
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "E"
    raw_encoding_specification: "EVEX.128.0F.W0 13/r"
    instruction_group_index: 256
  }
  instructions {
    description: "Multiply packed signed doubleword integers in xmm1 by packed signed doubleword integers in xmm2/m128, and store the quadword results in xmm1."
    vendor_syntax {
      mnemonic: "PMULDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 38 28 /r"
    instruction_group_index: 257
  }
  instructions {
    description: "Multiply packed signed doubleword integers in xmm2 by packed signed doubleword integers in xmm3/m128, and store the quadword results in xmm1."
    vendor_syntax {
      mnemonic: "VPMULDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F38.WIG 28 /r"
    instruction_group_index: 257
  }
  instructions {
    description: "Multiply packed signed doubleword integers in ymm2 by packed signed doubleword integers in ymm3/m256, and store the quadword results in ymm1."
    vendor_syntax {
      mnemonic: "VPMULDQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F38.WIG 28 /r"
    instruction_group_index: 257
  }
  instructions {
    description: "Multiply packed signed doubleword integers in xmm2 by packed signed doubleword integers in xmm3/m128/m64bcst, and store the quadword results in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPMULDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 28 /r"
    instruction_group_index: 257
  }
  instructions {
    description: "Multiply packed signed doubleword integers in ymm2 by packed signed doubleword integers in ymm3/m256/m64bcst, and store the quadword results in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPMULDQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 28 /r"
    instruction_group_index: 257
  }
  instructions {
    description: "Multiply packed signed doubleword integers in zmm2 by packed signed doubleword integers in zmm3/m512/m64bcst, and store the quadword results in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPMULDQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 28 /r"
    instruction_group_index: 257
  }
  instructions {
    description: "Convert one signed doubleword integer from r/m32 to one single-precision floating-point value in xmm1."
    vendor_syntax {
      mnemonic: "VCVTUSI2SS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.LIG.F3.0F.W0 7B /r"
    instruction_group_index: 258
  }
  instructions {
    description: "Convert one signed quadword integer from r/m64 to one single-precision floating-point value in xmm1."
    vendor_syntax {
      mnemonic: "VCVTUSI2SS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.LIG.F3.0F.W1 7B /r"
    instruction_group_index: 258
  }
  instructions {
    description: "Convert two packed quadword integers from xmm2/m128/m64bcst to packed double-precision floatingpoint values in xmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTQQ2PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.F3.0F.W1 E6 /r"
    instruction_group_index: 259
  }
  instructions {
    description: "Convert four packed quadword integers from ymm2/m256/m64bcst to packed double-precision floatingpoint values in ymm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTQQ2PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.F3.0F.W1 E6 /r"
    instruction_group_index: 259
  }
  instructions {
    description: "Convert eight packed quadword integers from zmm2/m512/m64bcst to eight packed double-precision floating-point values in zmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTQQ2PD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.F3.0F.W1 E6 /r"
    instruction_group_index: 259
  }
  instructions {
    description: "Permute double-precision floating-point values in xmm2 using controls from xmm3/m128 and store result in xmm1."
    vendor_syntax {
      mnemonic: "VPERMILPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W0 0D /r"
    instruction_group_index: 260
  }
  instructions {
    description: "Permute double-precision floating-point values in ymm2 using controls from ymm3/m256 and store result in ymm1."
    vendor_syntax {
      mnemonic: "VPERMILPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W0 0D /r"
    instruction_group_index: 260
  }
  instructions {
    description: "Permute double-precision floating-point values in xmm2 using control from xmm3/m128/m64bcst and store the result in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMILPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 0D /r"
    instruction_group_index: 260
  }
  instructions {
    description: "Permute double-precision floating-point values in ymm2 using control from ymm3/m256/m64bcst and store the result in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMILPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 0D /r"
    instruction_group_index: 260
  }
  instructions {
    description: "Permute double-precision floating-point values in zmm2 using control from zmm3/m512/m64bcst and store the result in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMILPD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 0D /r"
    instruction_group_index: 260
  }
  instructions {
    description: "Permute double-precision floating-point values in xmm2/m128 using controls from imm8."
    vendor_syntax {
      mnemonic: "VPERMILPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F3A.W0 05 /r ib"
    instruction_group_index: 260
  }
  instructions {
    description: "Permute double-precision floating-point values in ymm2/m256 using controls from imm8."
    vendor_syntax {
      mnemonic: "VPERMILPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F3A.W0 05 /r ib"
    instruction_group_index: 260
  }
  instructions {
    description: "Permute double-precision floating-point values in xmm2/m128/m64bcst using controls from imm8 and store the result in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMILPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.128.66.0F3A.W1 05 /r ib"
    instruction_group_index: 260
  }
  instructions {
    description: "Permute double-precision floating-point values in ymm2/m256/m64bcst using controls from imm8 and store the result in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMILPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.256.66.0F3A.W1 05 /r ib"
    instruction_group_index: 260
  }
  instructions {
    description: "Permute double-precision floating-point values in zmm2/m512/m64bcst using controls from imm8 and store the result in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMILPD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.66.0F3A.W1 05 /r ib"
    instruction_group_index: 260
  }
  instructions {
    description: "Performs an intermediate calculation for the next four SHA1 message dwords using previous message dwords from xmm1 and xmm2/m128, storing the result in xmm1."
    vendor_syntax {
      mnemonic: "SHA1MSG1"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SHA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "NP 0F 38 C9 /r"
    instruction_group_index: 261
  }
  instructions {
    description: "Multiply scalar double-precision floating-point value from xmm1 and xmm3/m64, subtract xmm2 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMSUB132SD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.LIG.66.0F38.W1 9B /r"
    instruction_group_index: 262
  }
  instructions {
    description: "Multiply scalar double-precision floating-point value from xmm1 and xmm2, subtract xmm3/m64 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMSUB213SD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.LIG.66.0F38.W1 AB /r"
    instruction_group_index: 262
  }
  instructions {
    description: "Multiply scalar double-precision floating-point value from xmm2 and xmm3/m64, subtract xmm1 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMSUB231SD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.LIG.66.0F38.W1 BB /r"
    instruction_group_index: 262
  }
  instructions {
    description: "Multiply scalar double-precision floating-point value from xmm1 and xmm3/m64, subtract xmm2 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMSUB132SD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.LIG.66.0F38.W1 9B /r"
    instruction_group_index: 262
  }
  instructions {
    description: "Multiply scalar double-precision floating-point value from xmm1 and xmm2, subtract xmm3/m64 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMSUB213SD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.LIG.66.0F38.W1 AB /r"
    instruction_group_index: 262
  }
  instructions {
    description: "Multiply scalar double-precision floating-point value from xmm2 and xmm3/m64, subtract xmm1 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMSUB231SD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.LIG.66.0F38.W1 BB /r"
    instruction_group_index: 262
  }
  instructions {
    description: "Concatenate destination and source operands, extract result shifted to the left by constant value in imm8 into xmm1."
    vendor_syntax {
      mnemonic: "VPSHLDW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2 && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F3A.W1 70 /r /ib"
    instruction_group_index: 263
  }
  instructions {
    description: "Concatenate destination and source operands, extract result shifted to the left by constant value in imm8 into ymm1."
    vendor_syntax {
      mnemonic: "VPSHLDW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2 && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F3A.W1 70 /r /ib"
    instruction_group_index: 263
  }
  instructions {
    description: "Concatenate destination and source operands, extract result shifted to the left by constant value in imm8 into zmm1."
    vendor_syntax {
      mnemonic: "VPSHLDW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F3A.W1 70 /r /ib"
    instruction_group_index: 263
  }
  instructions {
    description: "Concatenate destination and source operands, extract result shifted to the left by constant value in imm8 into xmm1."
    vendor_syntax {
      mnemonic: "VPSHLDD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2 && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F3A.W0 71 /r /ib"
    instruction_group_index: 263
  }
  instructions {
    description: "Concatenate destination and source operands, extract result shifted to the left by constant value in imm8 into ymm1."
    vendor_syntax {
      mnemonic: "VPSHLDD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2 && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F3A.W0 71 /r /ib"
    instruction_group_index: 263
  }
  instructions {
    description: "Concatenate destination and source operands, extract result shifted to the left by constant value in imm8 into zmm1."
    vendor_syntax {
      mnemonic: "VPSHLDD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F3A.W0 71 /r /ib"
    instruction_group_index: 263
  }
  instructions {
    description: "Concatenate destination and source operands, extract result shifted to the left by constant value in imm8 into xmm1."
    vendor_syntax {
      mnemonic: "VPSHLDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2 && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F3A.W1 71 /r /ib"
    instruction_group_index: 263
  }
  instructions {
    description: "Concatenate destination and source operands, extract result shifted to the left by constant value in imm8 into ymm1."
    vendor_syntax {
      mnemonic: "VPSHLDQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2 && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F3A.W1 71 /r /ib"
    instruction_group_index: 263
  }
  instructions {
    description: "Concatenate destination and source operands, extract result shifted to the left by constant value in imm8 into zmm1."
    vendor_syntax {
      mnemonic: "VPSHLDQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F3A.W1 71 /r /ib"
    instruction_group_index: 263
  }
  instructions {
    description: "Exchange r8 and r/m8; load sum into r/m8."
    vendor_syntax {
      mnemonic: "XADD"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "0F C0 /r"
    instruction_group_index: 264
  }
  instructions {
    description: "Exchange r8 and r/m8; load sum into r/m8."
    vendor_syntax {
      mnemonic: "XADD"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MR"
    raw_encoding_specification: "REX + 0F C0 /r"
    instruction_group_index: 264
  }
  instructions {
    description: "Exchange r16 and r/m16; load sum into r/m16."
    vendor_syntax {
      mnemonic: "XADD"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "0F C1 /r"
    instruction_group_index: 264
  }
  instructions {
    description: "Exchange r32 and r/m32; load sum into r/m32."
    vendor_syntax {
      mnemonic: "XADD"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "0F C1 /r"
    instruction_group_index: 264
  }
  instructions {
    description: "Exchange r64 and r/m64; load sum into r/m64."
    vendor_syntax {
      mnemonic: "XADD"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MR"
    raw_encoding_specification: "REX.W + 0F C1 /r"
    instruction_group_index: 264
  }
  instructions {
    description: "Permute bytes in xmm3/m128 and xmm2 using byte indexes in xmm1 and store the byte results in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMI2B"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512_VBMI"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 75 /r"
    instruction_group_index: 266
  }
  instructions {
    description: "Permute bytes in ymm3/m256 and ymm2 using byte indexes in ymm1 and store the byte results in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMI2B"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512_VBMI"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 75 /r"
    instruction_group_index: 266
  }
  instructions {
    description: "Permute bytes in zmm3/m512 and zmm2 using byte indexes in zmm1 and store the byte results in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMI2B"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 75 /r"
    instruction_group_index: 266
  }
  instructions {
    description: "Convert one double-precision floating-point value from xmm1/m64 to one signed doubleword integer r32."
    vendor_syntax {
      mnemonic: "CVTSD2SI"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F2 0F 2D /r"
    instruction_group_index: 267
  }
  instructions {
    description: "Convert one double-precision floating-point value from xmm1/m64 to one signed quadword integer signextended into r64."
    vendor_syntax {
      mnemonic: "CVTSD2SI"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    encoding_scheme: "A"
    raw_encoding_specification: "F2 REX.W 0F 2D /r"
    instruction_group_index: 267
  }
  instructions {
    description: "Convert one double-precision floating-point value from xmm1/m64 to one signed doubleword integer r32."
    vendor_syntax {
      mnemonic: "VCVTSD2SI"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.LIG.F2.0F.W0 2D /r"
    instruction_group_index: 267
  }
  instructions {
    description: "Convert one double-precision floating-point value from xmm1/m64 to one signed quadword integer signextended into r64."
    vendor_syntax {
      mnemonic: "VCVTSD2SI"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.LIG.F2.0F.W1 2D /r"
    instruction_group_index: 267
  }
  instructions {
    description: "Convert one double-precision floating-point value from xmm1/m64 to one signed doubleword integer r32."
    vendor_syntax {
      mnemonic: "VCVTSD2SI"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.LIG.F2.0F.W0 2D /r"
    instruction_group_index: 267
  }
  instructions {
    description: "Convert one double-precision floating-point value from xmm1/m64 to one signed quadword integer signextended into r64."
    vendor_syntax {
      mnemonic: "VCVTSD2SI"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.LIG.F2.0F.W1 2D /r"
    instruction_group_index: 267
  }
  instructions {
    description: "Shift words in mm right by amount specified in mm/m64 while shifting in 0s."
    vendor_syntax {
      mnemonic: "PSRLW"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F D1 /r"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift words in xmm1 right by amount specified in xmm2/m128 while shifting in 0s."
    vendor_syntax {
      mnemonic: "PSRLW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F D1 /r"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift words in mm right by imm8 while shifting in 0s."
    vendor_syntax {
      mnemonic: "PSRLW"
      operands {
        name: "mm"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "NP 0F 71 /2 ib"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift words in xmm1 right by imm8 while shifting in 0s."
    vendor_syntax {
      mnemonic: "PSRLW"
      operands {
        name: "xmm1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "66 0F 71 /2 ib"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift doublewords in mm right by amount specified in mm/m64 while shifting in 0s."
    vendor_syntax {
      mnemonic: "PSRLD"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F D2 /r"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift doublewords in xmm1 right by amount specified in xmm2 /m128 while shifting in 0s."
    vendor_syntax {
      mnemonic: "PSRLD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F D2 /r"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift doublewords in mm right by imm8 while shifting in 0s."
    vendor_syntax {
      mnemonic: "PSRLD"
      operands {
        name: "mm"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "NP 0F 72 /2 ib"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift doublewords in xmm1 right by imm8 while shifting in 0s."
    vendor_syntax {
      mnemonic: "PSRLD"
      operands {
        name: "xmm1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "66 0F 72 /2 ib"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift mm right by amount specified in mm/m64 while shifting in 0s."
    vendor_syntax {
      mnemonic: "PSRLQ"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F D3 /r"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift quadwords in xmm1 right by amount specified in xmm2/m128 while shifting in 0s."
    vendor_syntax {
      mnemonic: "PSRLQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F D3 /r"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift mm right by imm8 while shifting in0s."
    vendor_syntax {
      mnemonic: "PSRLQ"
      operands {
        name: "mm"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "NP 0F 73 /2 ib"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift quadwords in xmm1 right by imm8 while shifting in 0s."
    vendor_syntax {
      mnemonic: "PSRLQ"
      operands {
        name: "xmm1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "66 0F 73 /2 ib"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift words in xmm2 right by amount specified in xmm3/m128 while shifting in 0s."
    vendor_syntax {
      mnemonic: "VPSRLW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "VEX.128.66.0F.WIG D1 /r"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift words in xmm2 right by imm8 while shifting in 0s."
    vendor_syntax {
      mnemonic: "VPSRLW"
      operands {
        name: "xmm1"
        encoding: VEX_V_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "VEX.128.66.0F.WIG 71 /2 ib"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift doublewords in xmm2 right by amount specified in xmm3/m128 while shifting in 0s."
    vendor_syntax {
      mnemonic: "VPSRLD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "VEX.128.66.0F.WIG D2 /r"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift doublewords in xmm2 right by imm8 while shifting in 0s."
    vendor_syntax {
      mnemonic: "VPSRLD"
      operands {
        name: "xmm1"
        encoding: VEX_V_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "VEX.128.66.0F.WIG 72 /2 ib"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift quadwords in xmm2 right by amount specified in xmm3/m128 while shifting in 0s."
    vendor_syntax {
      mnemonic: "VPSRLQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "VEX.128.66.0F.WIG D3 /r"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift quadwords in xmm2 right by imm8 while shifting in 0s."
    vendor_syntax {
      mnemonic: "VPSRLQ"
      operands {
        name: "xmm1"
        encoding: VEX_V_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "VEX.128.66.0F.WIG 73 /2 ib"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift words in ymm2 right by amount specified in xmm3/m128 while shifting in 0s."
    vendor_syntax {
      mnemonic: "VPSRLW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "VEX.256.66.0F.WIG D1 /r"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift words in ymm2 right by imm8 while shifting in 0s."
    vendor_syntax {
      mnemonic: "VPSRLW"
      operands {
        name: "ymm1"
        encoding: VEX_V_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "VEX.256.66.0F.WIG 71 /2 ib"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift doublewords in ymm2 right by amount specified in xmm3/m128 while shifting in 0s."
    vendor_syntax {
      mnemonic: "VPSRLD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "VEX.256.66.0F.WIG D2 /r"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift doublewords in ymm2 right by imm8 while shifting in 0s."
    vendor_syntax {
      mnemonic: "VPSRLD"
      operands {
        name: "ymm1"
        encoding: VEX_V_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "VEX.256.66.0F.WIG 72 /2 ib"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift quadwords in ymm2 right by amount specified in xmm3/m128 while shifting in 0s."
    vendor_syntax {
      mnemonic: "VPSRLQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "VEX.256.66.0F.WIG D3 /r"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift quadwords in ymm2 right by imm8 while shifting in 0s."
    vendor_syntax {
      mnemonic: "VPSRLQ"
      operands {
        name: "ymm1"
        encoding: VEX_V_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "VEX.256.66.0F.WIG 73 /2 ib"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift words in xmm2 right by amount specified in xmm3/m128 while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRLW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "G"
    raw_encoding_specification: "EVEX.128.66.0F.WIG D1 /r"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift words in ymm2 right by amount specified in xmm3/m128 while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRLW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "G"
    raw_encoding_specification: "EVEX.256.66.0F.WIG D1 /r"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift words in zmm2 right by amount specified in xmm3/m128 while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRLW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "G"
    raw_encoding_specification: "EVEX.512.66.0F.WIG D1 /r"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift words in xmm2/m128 right by imm8 while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRLW"
      operands {
        name: "xmm1"
        encoding: VEX_V_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "E"
    raw_encoding_specification: "EVEX.128.66.0F.WIG 71 /2 ib"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift words in ymm2/m256 right by imm8 while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRLW"
      operands {
        name: "ymm1"
        encoding: VEX_V_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "E"
    raw_encoding_specification: "EVEX.256.66.0F.WIG 71 /2 ib"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift words in zmm2/m512 right by imm8 while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRLW"
      operands {
        name: "zmm1"
        encoding: VEX_V_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "E"
    raw_encoding_specification: "EVEX.512.66.0F.WIG 71 /2 ib"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift doublewords in xmm2 right by amount specified in xmm3/m128 while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRLD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "G"
    raw_encoding_specification: "EVEX.128.66.0F.W0 D2 /r"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift doublewords in ymm2 right by amount specified in xmm3/m128 while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRLD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "G"
    raw_encoding_specification: "EVEX.256.66.0F.W0 D2 /r"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift doublewords in zmm2 right by amount specified in xmm3/m128 while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRLD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "G"
    raw_encoding_specification: "EVEX.512.66.0F.W0 D2 /r"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift doublewords in xmm2/m128/m32bcst right by imm8 while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRLD"
      operands {
        name: "xmm1"
        encoding: VEX_V_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "F"
    raw_encoding_specification: "EVEX.128.66.0F.W0 72 /2 ib"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift doublewords in ymm2/m256/m32bcst right by imm8 while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRLD"
      operands {
        name: "ymm1"
        encoding: VEX_V_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "F"
    raw_encoding_specification: "EVEX.256.66.0F.W0 72 /2 ib"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift doublewords in zmm2/m512/m32bcst right by imm8 while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRLD"
      operands {
        name: "zmm1"
        encoding: VEX_V_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "F"
    raw_encoding_specification: "EVEX.512.66.0F.W0 72 /2 ib"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift quadwords in xmm2 right by amount specified in xmm3/m128 while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRLQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "G"
    raw_encoding_specification: "EVEX.128.66.0F.W1 D3 /r"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift quadwords in ymm2 right by amount specified in xmm3/m128 while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRLQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "G"
    raw_encoding_specification: "EVEX.256.66.0F.W1 D3 /r"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift quadwords in zmm2 right by amount specified in xmm3/m128 while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRLQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "G"
    raw_encoding_specification: "EVEX.512.66.0F.W1 D3 /r"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift quadwords in xmm2/m128/m64bcst right by imm8 while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRLQ"
      operands {
        name: "xmm1"
        encoding: VEX_V_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "F"
    raw_encoding_specification: "EVEX.128.66.0F.W1 73 /2 ib"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift quadwords in ymm2/m256/m64bcst right by imm8 while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRLQ"
      operands {
        name: "ymm1"
        encoding: VEX_V_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "F"
    raw_encoding_specification: "EVEX.256.66.0F.W1 73 /2 ib"
    instruction_group_index: 268
  }
  instructions {
    description: "Shift quadwords in zmm2/m512/m64bcst right by imm8 while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRLQ"
      operands {
        name: "zmm1"
        encoding: VEX_V_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "F"
    raw_encoding_specification: "EVEX.512.66.0F.W1 73 /2 ib"
    instruction_group_index: 268
  }
  instructions {
    description: "Bit scan forward on r/m16."
    vendor_syntax {
      mnemonic: "BSF"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F BC /r"
    instruction_group_index: 269
  }
  instructions {
    description: "Bit scan forward on r/m32."
    vendor_syntax {
      mnemonic: "BSF"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F BC /r"
    instruction_group_index: 269
  }
  instructions {
    description: "Bit scan forward on r/m64."
    vendor_syntax {
      mnemonic: "BSF"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 0F BC /r"
    instruction_group_index: 269
  }
  instructions {
    description: "Converts 4 packed double-word integers from xmm2 into 4 packed word integers in xmm1/m64 with truncation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVDW"
      operands {
        name: "xmm1/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.F3.0F38.W0 33 /r"
    instruction_group_index: 270
  }
  instructions {
    description: "Converts 4 packed signed double-word integers from xmm2 into 4 packed signed word integers in ymm1/m64 using signed saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVSDW"
      operands {
        name: "xmm1/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.F3.0F38.W0 23 /r"
    instruction_group_index: 270
  }
  instructions {
    description: "Converts 4 packed unsigned double-word integers from xmm2 into 4 packed unsigned word integers in xmm1/m64 using unsigned saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVUSDW"
      operands {
        name: "xmm1/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.F3.0F38.W0 13 /r"
    instruction_group_index: 270
  }
  instructions {
    description: "Converts 8 packed double-word integers from ymm2 into 8 packed word integers in xmm1/m128 with truncation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVDW"
      operands {
        name: "xmm1/m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.F3.0F38.W0 33 /r"
    instruction_group_index: 270
  }
  instructions {
    description: "Converts 8 packed signed double-word integers from ymm2 into 8 packed signed word integers in xmm1/m128 using signed saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVSDW"
      operands {
        name: "xmm1/m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.F3.0F38.W0 23 /r"
    instruction_group_index: 270
  }
  instructions {
    description: "Converts 8 packed unsigned double-word integers from ymm2 into 8 packed unsigned word integers in xmm1/m128 using unsigned saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVUSDW"
      operands {
        name: "xmm1/m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.F3.0F38.W0 13 /r"
    instruction_group_index: 270
  }
  instructions {
    description: "Converts 16 packed double-word integers from zmm2 into 16 packed word integers in ymm1/m256 with truncation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVDW"
      operands {
        name: "ymm1/m256"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.F3.0F38.W0 33 /r"
    instruction_group_index: 270
  }
  instructions {
    description: "Converts 16 packed signed double-word integers from zmm2 into 16 packed signed word integers in ymm1/m256 using signed saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVSDW"
      operands {
        name: "ymm1/m256"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.F3.0F38.W0 23 /r"
    instruction_group_index: 270
  }
  instructions {
    description: "Converts 16 packed unsigned double-word integers from zmm2 into 16 packed unsigned word integers in ymm1/m256 using unsigned saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVUSDW"
      operands {
        name: "ymm1/m256"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.F3.0F38.W0 13 /r"
    instruction_group_index: 270
  }
  instructions {
    description: "Converts 4 signed word integers from mm and 4 signed word integers from mm/m64 into 8 unsigned byte integers in mm using unsigned saturation."
    vendor_syntax {
      mnemonic: "PACKUSWB"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 67 /r"
    instruction_group_index: 272
  }
  instructions {
    description: "Converts 8 signed word integers from xmm1 and 8 signed word integers from xmm2/m128 into 16 unsigned byte integers in xmm1 using unsigned saturation."
    vendor_syntax {
      mnemonic: "PACKUSWB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 67 /r"
    instruction_group_index: 272
  }
  instructions {
    description: "Converts 8 signed word integers from xmm2 and 8 signed word integers from xmm3/m128 into 16 unsigned byte integers in xmm1 using unsigned saturation."
    vendor_syntax {
      mnemonic: "VPACKUSWB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG 67 /r"
    instruction_group_index: 272
  }
  instructions {
    description: "Converts 16 signed word integers from ymm2 and 16signed word integers from ymm3/m256 into 32 unsigned byte integers in ymm1 using unsigned saturation."
    vendor_syntax {
      mnemonic: "VPACKUSWB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG 67 /r"
    instruction_group_index: 272
  }
  instructions {
    description: "Converts signed word integers from xmm2 and signed word integers from xmm3/m128 into unsigned byte integers in xmm1 using unsigned saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPACKUSWB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.WIG 67 /r"
    instruction_group_index: 272
  }
  instructions {
    description: "Converts signed word integers from ymm2 and signed word integers from ymm3/m256 into unsigned byte integers in ymm1 using unsigned saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPACKUSWB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.WIG 67 /r"
    instruction_group_index: 272
  }
  instructions {
    description: "Converts signed word integers from zmm2 and signed word integers from zmm3/m512 into unsigned byte integers in zmm1 using unsigned saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPACKUSWB"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.WIG 67 /r"
    instruction_group_index: 272
  }
  instructions {
    description: "Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly."
    vendor_syntax {
      mnemonic: "UCOMISS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 2E /r"
    instruction_group_index: 273
  }
  instructions {
    description: "Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly."
    vendor_syntax {
      mnemonic: "VUCOMISS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.LIG.0F.WIG 2E /r"
    instruction_group_index: 273
  }
  instructions {
    description: "Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly."
    vendor_syntax {
      mnemonic: "VUCOMISS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.LIG.0F.W0 2E /r"
    instruction_group_index: 273
  }
  instructions {
    description: "Set DF flag."
    vendor_syntax {
      mnemonic: "STD"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "FD"
    instruction_group_index: 274
  }
  instructions {
    description: "Horizontal subtract packed single-precision floating-point values from xmm2/m128 to xmm1."
    vendor_syntax {
      mnemonic: "HSUBPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "F2 0F 7D /r"
    instruction_group_index: 275
  }
  instructions {
    description: "Horizontal subtract packed single-precision floating-point values from xmm2 and xmm3/mem."
    vendor_syntax {
      mnemonic: "VHSUBPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.128.F2.0F.WIG 7D /r"
    instruction_group_index: 275
  }
  instructions {
    description: "Horizontal subtract packed single-precision floating-point values from ymm2 and ymm3/mem."
    vendor_syntax {
      mnemonic: "VHSUBPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.256.F2.0F.WIG 7D /r"
    instruction_group_index: 275
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from xmm1 and xmm3/mem, subtract xmm2 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMSUB132PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W1 9A /r"
    instruction_group_index: 276
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from xmm1 and xmm2, subtract xmm3/mem and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMSUB213PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W1 AA /r"
    instruction_group_index: 276
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from xmm2 and xmm3/mem, subtract xmm1 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMSUB231PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W1 BA /r"
    instruction_group_index: 276
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from ymm1 and ymm3/mem, subtract ymm2 and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFMSUB132PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W1 9A /r"
    instruction_group_index: 276
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from ymm1 and ymm2, subtract ymm3/mem and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFMSUB213PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W1 AA /r"
    instruction_group_index: 276
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from ymm2 and ymm3/mem, subtract ymm1 and put result in ymm1.S"
    vendor_syntax {
      mnemonic: "VFMSUB231PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W1 BA /r"
    instruction_group_index: 276
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from xmm1 and xmm3/m128/m64bcst, subtract xmm2 and put result in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMSUB132PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 9A /r"
    instruction_group_index: 276
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from xmm1 and xmm2, subtract   xmm3/m128/m64bcst and put result in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMSUB213PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 AA /r"
    instruction_group_index: 276
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from xmm2 and xmm3/m128/m64bcst, subtract   xmm1 and put result in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMSUB231PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 BA /r"
    instruction_group_index: 276
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from ymm1 and ymm3/m256/m64bcst, subtract ymm2 and put result in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMSUB132PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 9A /r"
    instruction_group_index: 276
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from ymm1 and ymm2, subtract ymm3/m256/m64bcst and put result in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMSUB213PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 AA /r"
    instruction_group_index: 276
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from ymm2 and ymm3/m256/m64bcst, subtract ymm1 and put result in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMSUB231PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 BA /r"
    instruction_group_index: 276
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from zmm1 and zmm3/m512/m64bcst, subtract zmm2 and put result in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMSUB132PD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 9A /r"
    instruction_group_index: 276
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from zmm1 and zmm2, subtract zmm3/m512/m64bcst and put result in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMSUB213PD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 AA /r"
    instruction_group_index: 276
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from zmm2 and zmm3/m512/m64bcst, subtract zmm1 and put result in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMSUB231PD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 BA /r"
    instruction_group_index: 276
  }
  instructions {
    description: "Test if executing in a transactional region"
    vendor_syntax {
      mnemonic: "XTEST"
    }
    feature_name: "HLE || RTM"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "NP 0F 01 D6"
    instruction_group_index: 277
  }
  instructions {
    description: "Compare low double-precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly."
    vendor_syntax {
      mnemonic: "COMISD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 2F /r"
    instruction_group_index: 279
  }
  instructions {
    description: "Compare low double-precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly."
    vendor_syntax {
      mnemonic: "VCOMISD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.LIG.66.0F.WIG 2F /r"
    instruction_group_index: 279
  }
  instructions {
    description: "Compare low double-precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly."
    vendor_syntax {
      mnemonic: "VCOMISD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.LIG.66.0F.W1 2F /r"
    instruction_group_index: 279
  }
  instructions {
    description: "Signed divide AX by r/m8, with result stored in: AL := Quotient, AH := Remainder."
    vendor_syntax {
      mnemonic: "IDIV"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "F6 /7"
    instruction_group_index: 280
  }
  instructions {
    description: "Signed divide AX by r/m8, with result stored in AL := Quotient, AH := Remainder."
    vendor_syntax {
      mnemonic: "IDIV"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX + F6 /7"
    instruction_group_index: 280
  }
  instructions {
    description: "Signed divide DX:AX by r/m16, with result stored in AX := Quotient, DX := Remainder."
    vendor_syntax {
      mnemonic: "IDIV"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "F7 /7"
    instruction_group_index: 280
  }
  instructions {
    description: "Signed divide EDX:EAX by r/m32, with result stored in EAX := Quotient, EDX := Remainder."
    vendor_syntax {
      mnemonic: "IDIV"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "F7 /7"
    instruction_group_index: 280
  }
  instructions {
    description: "Signed divide RDX:RAX by r/m64, with result stored in RAX := Quotient, RDX := Remainder."
    vendor_syntax {
      mnemonic: "IDIV"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX.W + F7 /7"
    instruction_group_index: 280
  }
  instructions {
    description: "Replace ST(0) with the remainder obtained from dividing ST(0) by ST(1)."
    vendor_syntax {
      mnemonic: "FPREM"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D9 F8"
    instruction_group_index: 281
  }
  instructions {
    description: "Calculate a RANGE operation output value from 2 doubleprecision floating-point values in xmm2 and xmm3/m64, store the output to xmm1 under writemask. Imm8 specifies the comparison and sign of the range operation."
    vendor_syntax {
      mnemonic: "VRANGESD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.LIG.66.0F3A.W1 51 /r"
    instruction_group_index: 282
  }
  instructions {
    description: "Computes Square Roots of the packed double-precision floating-point values in xmm2/m128 and stores the result in xmm1."
    vendor_syntax {
      mnemonic: "SQRTPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 51 /r"
    instruction_group_index: 283
  }
  instructions {
    description: "Computes Square Roots of the packed double-precision floating-point values in xmm2/m128 and stores the result in xmm1."
    vendor_syntax {
      mnemonic: "VSQRTPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F.WIG 51 /r"
    instruction_group_index: 283
  }
  instructions {
    description: "Computes Square Roots of the packed double-precision floating-point values in ymm2/m256 and stores the result in ymm1."
    vendor_syntax {
      mnemonic: "VSQRTPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F.WIG 51 /r"
    instruction_group_index: 283
  }
  instructions {
    description: "Computes Square Roots of the packed double-precision floating-point values in xmm2/m128/m64bcst and stores the result in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VSQRTPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F.W1 51 /r"
    instruction_group_index: 283
  }
  instructions {
    description: "Computes Square Roots of the packed double-precision floating-point values in ymm2/m256/m64bcst and stores the result in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VSQRTPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F.W1 51 /r"
    instruction_group_index: 283
  }
  instructions {
    description: "Computes Square Roots of the packed double-precision floating-point values in zmm2/m512/m64bcst and stores the result in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VSQRTPD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F.W1 51 /r"
    instruction_group_index: 283
  }
  instructions {
    description: "Unsigned addition of r32 with OF, r/m32 to r32, writes OF."
    vendor_syntax {
      mnemonic: "ADOX"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "ADX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "F3 0F 38 F6 /r"
    instruction_group_index: 284
  }
  instructions {
    description: "Unsigned addition of r64 with OF, r/m64 to r64, writes OF."
    vendor_syntax {
      mnemonic: "ADOX"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "ADX"
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "F3 REX.W 0F 38 F6 /r"
    instruction_group_index: 284
  }
  instructions {
    description: "Using signed dword indices, prefetch sparse byte memory locations containing single-precision data using writemask k1 and T0 hint with intent to write."
    vendor_syntax {
      mnemonic: "VSCATTERPF0DPS"
      operands {
        name: "vm32z"
        encoding: VSIB_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512PF"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 C6 /5 /vsib"
    instruction_group_index: 285
  }
  instructions {
    description: "Using signed qword indices, prefetch sparse byte memory locations containing single-precision data using writemask k1 and T0 hint with intent to write."
    vendor_syntax {
      mnemonic: "VSCATTERPF0QPS"
      operands {
        name: "vm64z"
        encoding: VSIB_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512PF"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 C7 /5 /vsib"
    instruction_group_index: 285
  }
  instructions {
    description: "Using signed dword indices, prefetch sparse byte memory locations containing double-precision data using writemask k1 and T0 hint with intent to write."
    vendor_syntax {
      mnemonic: "VSCATTERPF0DPD"
      operands {
        name: "vm32y"
        encoding: VSIB_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512PF"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 C6 /5 /vsib"
    instruction_group_index: 285
  }
  instructions {
    description: "Using signed qword indices, prefetch sparse byte memory locations containing double-precision data using writemask k1 and T0 hint with intent to write."
    vendor_syntax {
      mnemonic: "VSCATTERPF0QPD"
      operands {
        name: "vm64z"
        encoding: VSIB_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512PF"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 C7 /5 /vsib"
    instruction_group_index: 285
  }
  instructions {
    description: "Select words from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1."
    vendor_syntax {
      mnemonic: "PBLENDW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMI"
    raw_encoding_specification: "66 0F 3A 0E /r ib"
    instruction_group_index: 286
  }
  instructions {
    description: "Select words from xmm2 and xmm3/m128 from mask specified in imm8 and store the values into xmm1."
    vendor_syntax {
      mnemonic: "VPBLENDW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVMI"
    raw_encoding_specification: "VEX.128.66.0F3A.WIG 0E /r ib"
    instruction_group_index: 286
  }
  instructions {
    description: "Select words from ymm2 and ymm3/m256 from mask specified in imm8 and store the values into ymm1."
    vendor_syntax {
      mnemonic: "VPBLENDW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVMI"
    raw_encoding_specification: "VEX.256.66.0F3A.WIG 0E /r ib"
    instruction_group_index: 286
  }
  instructions {
    description: "Move packed double-precision values in xmm1 to m128 using non-temporal hint."
    vendor_syntax {
      mnemonic: "MOVNTPD"
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 2B /r"
    instruction_group_index: 287
  }
  instructions {
    description: "Move packed double-precision values in xmm1 to m128 using non-temporal hint."
    vendor_syntax {
      mnemonic: "VMOVNTPD"
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F.WIG 2B /r"
    instruction_group_index: 287
  }
  instructions {
    description: "Move packed double-precision values in ymm1 to m256 using non-temporal hint."
    vendor_syntax {
      mnemonic: "VMOVNTPD"
      operands {
        name: "m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F.WIG 2B /r"
    instruction_group_index: 287
  }
  instructions {
    description: "Move packed double-precision values in xmm1 to m128 using non-temporal hint."
    vendor_syntax {
      mnemonic: "VMOVNTPD"
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F.W1 2B /r"
    instruction_group_index: 287
  }
  instructions {
    description: "Move packed double-precision values in ymm1 to m256 using non-temporal hint."
    vendor_syntax {
      mnemonic: "VMOVNTPD"
      operands {
        name: "m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F.W1 2B /r"
    instruction_group_index: 287
  }
  instructions {
    description: "Move packed double-precision values in zmm1 to m512 using non-temporal hint."
    vendor_syntax {
      mnemonic: "VMOVNTPD"
      operands {
        name: "m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F.W1 2B /r"
    instruction_group_index: 287
  }
  instructions {
    description: "Computes the approximate reciprocal of the scalar single-precision floating-point value in xmm2/m32 and stores the result in xmm1."
    vendor_syntax {
      mnemonic: "RCPSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "F3 0F 53 /r"
    instruction_group_index: 288
  }
  instructions {
    description: "Computes the approximate reciprocal of the scalar single-precision floating-point value in xmm3/m32 and stores the result in xmm1.\nAlso, upper single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32]."
    vendor_syntax {
      mnemonic: "VRCPSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.LIG.F3.0F.WIG 53 /r"
    instruction_group_index: 288
  }
  instructions {
    description: "Convert two packed unsigned doubleword integers from ymm2/m64/m32bcst to packed double-precision floating-point values in zmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTUDQ2PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.F3.0F.W0 7A /r"
    instruction_group_index: 289
  }
  instructions {
    description: "Convert four packed unsigned doubleword integers from xmm2/m128/m32bcst to packed doubleprecision floating-point values in zmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTUDQ2PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.F3.0F.W0 7A /r"
    instruction_group_index: 289
  }
  instructions {
    description: "Convert eight packed unsigned doubleword integers from ymm2/m256/m32bcst to eight packed doubleprecision floating-point values in zmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTUDQ2PD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.F3.0F.W0 7A /r"
    instruction_group_index: 289
  }
  instructions {
    description: "ASCII adjust AX after multiply."
    vendor_syntax {
      mnemonic: "AAM"
    }
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "D4 0A"
    instruction_group_index: 290
  }
  instructions {
    description: "Adjust AX after multiply to number base imm8."
    vendor_syntax {
      mnemonic: "AAM"
      operands {
        name: "imm8"
      }
    }
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "D4 ib"
    instruction_group_index: 290
  }
  instructions {
    description: "Perform the last round of an AES encryption flow, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128."
    vendor_syntax {
      mnemonic: "AESENCLAST"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AES"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 38 DD /r"
    instruction_group_index: 291
  }
  instructions {
    description: "Perform the last round of an AES encryption flow, operating on a 128-bit data (state) from xmm2 with a 128 bit round key from xmm3/m128; store the result in xmm1."
    vendor_syntax {
      mnemonic: "VAESENCLAST"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AES && AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F38.WIG DD /r"
    instruction_group_index: 291
  }
  instructions {
    description: "Perform the last round of an AES encryption flow, operating on a 128-bit data (state) from ymm2 with a 128 bit round key from ymm3/m256; store the result in ymm1."
    vendor_syntax {
      mnemonic: "VAESENCLAST"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "VAES"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "VEX.256.66.0F38.WIG DD /r"
    instruction_group_index: 291
  }
  instructions {
    description: "Perform the last round of an AES encryption flow, operating on a 128-bit data (state) from xmm2 with a 128 bit round key from xmm3/m128; store the result in xmm1."
    vendor_syntax {
      mnemonic: "VAESENCLAST"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "VAES && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.128.66.0F38.WIG DD /r"
    instruction_group_index: 291
  }
  instructions {
    description: "Perform the last round of an AES encryption flow, operating on a 128-bit data (state) from ymm2 with a 128 bit round key from ymm3/m256; store the result in ymm1."
    vendor_syntax {
      mnemonic: "VAESENCLAST"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "VAES && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.256.66.0F38.WIG DD /r"
    instruction_group_index: 291
  }
  instructions {
    description: "Perform the last round of an AES encryption flow, operating on a 128-bit data (state) from zmm2 with a 128 bit round key from zmm3/m512; store the result in zmm1."
    vendor_syntax {
      mnemonic: "VAESENCLAST"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "VAES && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.66.0F38.WIG DD /r"
    instruction_group_index: 291
  }
  instructions {
    description: "Multiply scalar single-precision floating-point value from xmm1 and xmm3/m32, negate the multiplication result and subtract xmm2 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMSUB132SS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.LIG.66.0F38.W0 9F /r"
    instruction_group_index: 292
  }
  instructions {
    description: "Multiply scalar single-precision floating-point value from xmm1 and xmm2, negate the multiplication result and subtract xmm3/m32 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMSUB213SS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.LIG.66.0F38.W0 AF /r"
    instruction_group_index: 292
  }
  instructions {
    description: "Multiply scalar single-precision floating-point value from xmm2 and xmm3/m32, negate the multiplication result and subtract xmm1 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMSUB231SS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.LIG.66.0F38.W0 BF /r"
    instruction_group_index: 292
  }
  instructions {
    description: "Multiply scalar single-precision floating-point value from xmm1 and xmm3/m32, negate the multiplication result and subtract xmm2 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMSUB132SS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.LIG.66.0F38.W0 9F /r"
    instruction_group_index: 292
  }
  instructions {
    description: "Multiply scalar single-precision floating-point value from xmm1 and xmm2, negate the multiplication result and subtract xmm3/m32 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMSUB213SS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.LIG.66.0F38.W0 AF /r"
    instruction_group_index: 292
  }
  instructions {
    description: "Multiply scalar single-precision floating-point value from xmm2 and xmm3/m32, negate the multiplication result and subtract xmm1 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMSUB231SS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.LIG.66.0F38.W0 BF /r"
    instruction_group_index: 292
  }
  instructions {
    description: "Compare packed signed dword integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1."
    vendor_syntax {
      mnemonic: "PMINSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 38 39 /r"
    instruction_group_index: 293
  }
  instructions {
    description: "Compare packed signed dword integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1."
    vendor_syntax {
      mnemonic: "VPMINSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F38.WIG 39 /r"
    instruction_group_index: 293
  }
  instructions {
    description: "Compare packed signed dword integers in ymm2 and ymm3/m128 and store packed minimum values in ymm1."
    vendor_syntax {
      mnemonic: "VPMINSD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F38.WIG 39 /r"
    instruction_group_index: 293
  }
  instructions {
    description: "Compare packed signed dword integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMINSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 39 /r"
    instruction_group_index: 293
  }
  instructions {
    description: "Compare packed signed dword integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMINSD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 39 /r"
    instruction_group_index: 293
  }
  instructions {
    description: "Compare packed signed dword integers in zmm2 and zmm3/m512/m32bcst and store packed minimum values in zmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMINSD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 39 /r"
    instruction_group_index: 293
  }
  instructions {
    description: "Compare packed signed qword integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMINSQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 39 /r"
    instruction_group_index: 293
  }
  instructions {
    description: "Compare packed signed qword integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMINSQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 39 /r"
    instruction_group_index: 293
  }
  instructions {
    description: "Compare packed signed qword integers in zmm2 and zmm3/m512/m64bcst and store packed minimum values in zmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMINSQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 39 /r"
    instruction_group_index: 293
  }
  instructions {
    description: "Compute the sine and cosine of ST(0); replace ST(0) with the approximate sine, and push the approximate cosine onto the register stack."
    vendor_syntax {
      mnemonic: "FSINCOS"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D9 FB"
    instruction_group_index: 294
  }
  instructions {
    description: "Add the low double-precision floating-point value from xmm2/mem to xmm1 and store the result in xmm1."
    vendor_syntax {
      mnemonic: "ADDSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F2 0F 58 /r"
    instruction_group_index: 295
  }
  instructions {
    description: "Add the low double-precision floating-point value from xmm3/mem to xmm2 and store the result in xmm1."
    vendor_syntax {
      mnemonic: "VADDSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.LIG.F2.0F.WIG 58 /r"
    instruction_group_index: 295
  }
  instructions {
    description: "Add the low double-precision floating-point value from xmm3/m64 to xmm2 and store the result in xmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VADDSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.LIG.F2.0F.W1 58 /r"
    instruction_group_index: 295
  }
  instructions {
    description: "Convert one single-precision floating-point value from xmm1/m32 to one signed doubleword integer in r32."
    vendor_syntax {
      mnemonic: "CVTSS2SI"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F3 0F 2D /r"
    instruction_group_index: 296
  }
  instructions {
    description: "Convert one single-precision floating-point value from xmm1/m32 to one signed quadword integer in r64."
    vendor_syntax {
      mnemonic: "CVTSS2SI"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    encoding_scheme: "A"
    raw_encoding_specification: "F3 REX.W 0F 2D /r"
    instruction_group_index: 296
  }
  instructions {
    description: "Convert one single-precision floating-point value from xmm1/m32 to one signed doubleword integer in r32."
    vendor_syntax {
      mnemonic: "VCVTSS2SI"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.LIG.F3.0F.W0 2D /r"
    instruction_group_index: 296
  }
  instructions {
    description: "Convert one single-precision floating-point value from xmm1/m32 to one signed quadword integer in r64."
    vendor_syntax {
      mnemonic: "VCVTSS2SI"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.LIG.F3.0F.W1 2D /r"
    instruction_group_index: 296
  }
  instructions {
    description: "Convert one single-precision floating-point value from xmm1/m32 to one signed doubleword integer in r32."
    vendor_syntax {
      mnemonic: "VCVTSS2SI"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.LIG.F3.0F.W0 2D /r"
    instruction_group_index: 296
  }
  instructions {
    description: "Convert one single-precision floating-point value from xmm1/m32 to one signed quadword integer in r64."
    vendor_syntax {
      mnemonic: "VCVTSS2SI"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.LIG.F3.0F.W1 2D /r"
    instruction_group_index: 296
  }
  instructions {
    description: "Shift right 16 bits in k2 by immediate and write result in k1."
    vendor_syntax {
      mnemonic: "KSHIFTRW"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RRI"
    raw_encoding_specification: "VEX.L0.66.0F3A.W1 30 /r"
    instruction_group_index: 297
  }
  instructions {
    description: "Shift right 8 bits in k2 by immediate and write result in k1."
    vendor_syntax {
      mnemonic: "KSHIFTRB"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RRI"
    raw_encoding_specification: "VEX.L0.66.0F3A.W0 30 /r"
    instruction_group_index: 297
  }
  instructions {
    description: "Shift right 64 bits in k2 by immediate and write result in k1."
    vendor_syntax {
      mnemonic: "KSHIFTRQ"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RRI"
    raw_encoding_specification: "VEX.L0.66.0F3A.W1 31 /r"
    instruction_group_index: 297
  }
  instructions {
    description: "Shift right 32 bits in k2 by immediate and write result in k1."
    vendor_syntax {
      mnemonic: "KSHIFTRD"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RRI"
    raw_encoding_specification: "VEX.L0.66.0F3A.W0 31 /r"
    instruction_group_index: 297
  }
  instructions {
    description: "Bitwise OR of mm/m64 and mm."
    vendor_syntax {
      mnemonic: "POR"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F EB /r"
    instruction_group_index: 298
  }
  instructions {
    description: "Bitwise OR of xmm2/m128 and xmm1."
    vendor_syntax {
      mnemonic: "POR"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F EB /r"
    instruction_group_index: 298
  }
  instructions {
    description: "Bitwise OR of xmm2/m128 and xmm3."
    vendor_syntax {
      mnemonic: "VPOR"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG EB /r"
    instruction_group_index: 298
  }
  instructions {
    description: "Bitwise OR of ymm2/m256 and ymm3."
    vendor_syntax {
      mnemonic: "VPOR"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG EB /r"
    instruction_group_index: 298
  }
  instructions {
    description: "Bitwise OR of packed doubleword integers in xmm2 and xmm3/m128/m32bcst using writemask k1."
    vendor_syntax {
      mnemonic: "VPORD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.W0 EB /r"
    instruction_group_index: 298
  }
  instructions {
    description: "Bitwise OR of packed doubleword integers in ymm2 and ymm3/m256/m32bcst using writemask k1."
    vendor_syntax {
      mnemonic: "VPORD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.W0 EB /r"
    instruction_group_index: 298
  }
  instructions {
    description: "Bitwise OR of packed doubleword integers in zmm2 and zmm3/m512/m32bcst using writemask k1."
    vendor_syntax {
      mnemonic: "VPORD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.W0 EB /r"
    instruction_group_index: 298
  }
  instructions {
    description: "Bitwise OR of packed quadword integers in xmm2 and xmm3/m128/m64bcst using writemask k1."
    vendor_syntax {
      mnemonic: "VPORQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.W1 EB /r"
    instruction_group_index: 298
  }
  instructions {
    description: "Bitwise OR of packed quadword integers in ymm2 and ymm3/m256/m64bcst using writemask k1."
    vendor_syntax {
      mnemonic: "VPORQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.W1 EB /r"
    instruction_group_index: 298
  }
  instructions {
    description: "Bitwise OR of packed quadword integers in zmm2 and zmm3/m512/m64bcst using writemask k1."
    vendor_syntax {
      mnemonic: "VPORQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.W1 EB /r"
    instruction_group_index: 298
  }
  instructions {
    description: "Subtract imm8 from AL."
    vendor_syntax {
      mnemonic: "SUB"
      operands {
        name: "AL"
        encoding: IMPLICIT_ENCODING
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "I"
    raw_encoding_specification: "2C ib"
    instruction_group_index: 299
  }
  instructions {
    description: "Subtract imm16 from AX."
    vendor_syntax {
      mnemonic: "SUB"
      operands {
        name: "AX"
        encoding: IMPLICIT_ENCODING
      }
      operands {
        name: "imm16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "I"
    raw_encoding_specification: "2D iw"
    instruction_group_index: 299
  }
  instructions {
    description: "Subtract imm32 from EAX."
    vendor_syntax {
      mnemonic: "SUB"
      operands {
        name: "EAX"
        encoding: IMPLICIT_ENCODING
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "I"
    raw_encoding_specification: "2D id"
    instruction_group_index: 299
  }
  instructions {
    description: "Subtract imm32 sign-extended to 64-bits from RAX."
    vendor_syntax {
      mnemonic: "SUB"
      operands {
        name: "RAX"
        encoding: IMPLICIT_ENCODING
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "I"
    raw_encoding_specification: "REX.W + 2D id"
    instruction_group_index: 299
  }
  instructions {
    description: "Subtract imm8 from r/m8."
    vendor_syntax {
      mnemonic: "SUB"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "80 /5 ib"
    instruction_group_index: 299
  }
  instructions {
    description: "Subtract imm8 from r/m8."
    vendor_syntax {
      mnemonic: "SUB"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX + 80 /5 ib"
    instruction_group_index: 299
  }
  instructions {
    description: "Subtract imm16 from r/m16."
    vendor_syntax {
      mnemonic: "SUB"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "81 /5 iw"
    instruction_group_index: 299
  }
  instructions {
    description: "Subtract imm32 from r/m32."
    vendor_syntax {
      mnemonic: "SUB"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "81 /5 id"
    instruction_group_index: 299
  }
  instructions {
    description: "Subtract imm32 sign-extended to 64-bits from r/m64."
    vendor_syntax {
      mnemonic: "SUB"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX.W + 81 /5 id"
    instruction_group_index: 299
  }
  instructions {
    description: "Subtract sign-extended imm8 from r/m16."
    vendor_syntax {
      mnemonic: "SUB"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "83 /5 ib"
    instruction_group_index: 299
  }
  instructions {
    description: "Subtract sign-extended imm8 from r/m32."
    vendor_syntax {
      mnemonic: "SUB"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "83 /5 ib"
    instruction_group_index: 299
  }
  instructions {
    description: "Subtract sign-extended imm8 from r/m64."
    vendor_syntax {
      mnemonic: "SUB"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX.W + 83 /5 ib"
    instruction_group_index: 299
  }
  instructions {
    description: "Subtract r8 from r/m8."
    vendor_syntax {
      mnemonic: "SUB"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "28 /r"
    instruction_group_index: 299
  }
  instructions {
    description: "Subtract r8 from r/m8."
    vendor_syntax {
      mnemonic: "SUB"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MR"
    raw_encoding_specification: "REX + 28 /r"
    instruction_group_index: 299
  }
  instructions {
    description: "Subtract r16 from r/m16."
    vendor_syntax {
      mnemonic: "SUB"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "29 /r"
    instruction_group_index: 299
  }
  instructions {
    description: "Subtract r32 from r/m32."
    vendor_syntax {
      mnemonic: "SUB"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "29 /r"
    instruction_group_index: 299
  }
  instructions {
    description: "Subtract r64 from r/m64."
    vendor_syntax {
      mnemonic: "SUB"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MR"
    raw_encoding_specification: "REX.W + 29 /r"
    instruction_group_index: 299
  }
  instructions {
    description: "Subtract r/m8 from r8."
    vendor_syntax {
      mnemonic: "SUB"
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "2A /r"
    instruction_group_index: 299
  }
  instructions {
    description: "Subtract r/m8 from r8."
    vendor_syntax {
      mnemonic: "SUB"
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX + 2A /r"
    instruction_group_index: 299
  }
  instructions {
    description: "Subtract r/m16 from r16."
    vendor_syntax {
      mnemonic: "SUB"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "2B /r"
    instruction_group_index: 299
  }
  instructions {
    description: "Subtract r/m32 from r32."
    vendor_syntax {
      mnemonic: "SUB"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "2B /r"
    instruction_group_index: 299
  }
  instructions {
    description: "Subtract r/m64 from r64."
    vendor_syntax {
      mnemonic: "SUB"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 2B /r"
    instruction_group_index: 299
  }
  instructions {
    description: "Fix up special numbers in float32 vector xmm1, float32 vector xmm2 and int32 vector xmm3/m128/m32bcst and store the result in xmm1, under writemask."
    vendor_syntax {
      mnemonic: "VFIXUPIMMPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F3A.W0 54 /r"
    instruction_group_index: 300
  }
  instructions {
    description: "Fix up special numbers in float32 vector ymm1, float32 vector ymm2 and int32 vector ymm3/m256/m32bcst and store the result in ymm1, under writemask."
    vendor_syntax {
      mnemonic: "VFIXUPIMMPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F3A.W0 54 /r"
    instruction_group_index: 300
  }
  instructions {
    description: "Fix up elements of float32 vector in zmm2 using int32 vector table in zmm3/m512/m32bcst, combine with preserved elements from zmm1, and store the result in zmm1."
    vendor_syntax {
      mnemonic: "VFIXUPIMMPS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F3A.W0 54 /r ib"
    instruction_group_index: 300
  }
  instructions {
    description: "Compare ST(0) with m32fp."
    vendor_syntax {
      mnemonic: "FCOM"
      operands {
        name: "m32fp"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D8 /2"
    instruction_group_index: 301
  }
  instructions {
    description: "Compare ST(0) with m64fp."
    vendor_syntax {
      mnemonic: "FCOM"
      operands {
        name: "m64fp"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DC /2"
    instruction_group_index: 301
  }
  instructions {
    description: "Compare ST(0) with ST(i)."
    vendor_syntax {
      mnemonic: "FCOM"
      operands {
        name: "ST(i)"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D8 D0+i"
    instruction_group_index: 301
  }
  instructions {
    description: "Compare ST(0) with ST(1)."
    vendor_syntax {
      mnemonic: "FCOM"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D8 D1"
    instruction_group_index: 301
  }
  instructions {
    description: "Compare ST(0) with m32fp and pop register stack."
    vendor_syntax {
      mnemonic: "FCOMP"
      operands {
        name: "m32fp"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D8 /3"
    instruction_group_index: 301
  }
  instructions {
    description: "Compare ST(0) with m64fp and pop register stack."
    vendor_syntax {
      mnemonic: "FCOMP"
      operands {
        name: "m64fp"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DC /3"
    instruction_group_index: 301
  }
  instructions {
    description: "Compare ST(0) with ST(i) and pop register stack."
    vendor_syntax {
      mnemonic: "FCOMP"
      operands {
        name: "ST(i)"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D8 D8+i"
    instruction_group_index: 301
  }
  instructions {
    description: "Compare ST(0) with ST(1) and pop register stack."
    vendor_syntax {
      mnemonic: "FCOMP"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D8 D9"
    instruction_group_index: 301
  }
  instructions {
    description: "Compare ST(0) with ST(1) and pop register stack twice."
    vendor_syntax {
      mnemonic: "FCOMPP"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DE D9"
    instruction_group_index: 301
  }
  instructions {
    description: "Stores segment selector from LDTR in r/m16."
    vendor_syntax {
      mnemonic: "SLDT"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 00 /0"
    instruction_group_index: 302
  }
  instructions {
    description: "Stores segment selector from LDTR in r64/m16."
    vendor_syntax {
      mnemonic: "SLDT"
      operands {
        name: "r64/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX.W + 0F 00 /0"
    instruction_group_index: 302
  }
  instructions {
    description: "Count the number of leading zero bits in each dword element of xmm2/m128/m32bcst using writemask k1."
    vendor_syntax {
      mnemonic: "VPLZCNTD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512CD"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 44 /r"
    instruction_group_index: 303
  }
  instructions {
    description: "Count the number of leading zero bits in each dword element of ymm2/m256/m32bcst using writemask k1."
    vendor_syntax {
      mnemonic: "VPLZCNTD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512CD"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 44 /r"
    instruction_group_index: 303
  }
  instructions {
    description: "Count the number of leading zero bits in each dword element of zmm2/m512/m32bcst using writemask k1."
    vendor_syntax {
      mnemonic: "VPLZCNTD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512CD"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 44 /r"
    instruction_group_index: 303
  }
  instructions {
    description: "Count the number of leading zero bits in each qword element of xmm2/m128/m64bcst using writemask k1."
    vendor_syntax {
      mnemonic: "VPLZCNTQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512CD"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 44 /r"
    instruction_group_index: 303
  }
  instructions {
    description: "Count the number of leading zero bits in each qword element of ymm2/m256/m64bcst using writemask k1."
    vendor_syntax {
      mnemonic: "VPLZCNTQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512CD"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 44 /r"
    instruction_group_index: 303
  }
  instructions {
    description: "Count the number of leading zero bits in each qword element of zmm2/m512/m64bcst using writemask k1."
    vendor_syntax {
      mnemonic: "VPLZCNTQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512CD"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 44 /r"
    instruction_group_index: 303
  }
  instructions {
    description: "Permute bytes in xmm3/m128 and xmm1 using byte indexes in xmm2 and store the byte results in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMT2B"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512_VBMI"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 7D /r"
    instruction_group_index: 304
  }
  instructions {
    description: "Permute bytes in ymm3/m256 and ymm1 using byte indexes in ymm2 and store the byte results in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMT2B"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512_VBMI"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 7D /r"
    instruction_group_index: 304
  }
  instructions {
    description: "Permute bytes in zmm3/m512 and zmm1 using byte indexes in zmm2 and store the byte results in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMT2B"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 7D /r"
    instruction_group_index: 304
  }
  instructions {
    description: "Computes approximate reciprocal square root (<2^-28 relative error) of the scalar double-precision floating-point value from xmm3/m64 and stores result in xmm1with writemask k1. Also, upper double-precision floating-point value (bits[127:64]) from xmm2 is copied to xmm1[127:64]."
    vendor_syntax {
      mnemonic: "VRSQRT28SD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512ER"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.LIG.66.0F38.W1 CD /r"
    instruction_group_index: 305
  }
  instructions {
    description: "Move two packed single-precision floating-point values from m64 to high quadword of xmm1."
    vendor_syntax {
      mnemonic: "MOVHPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 16 /r"
    instruction_group_index: 306
  }
  instructions {
    description: "Merge two packed single-precision floating-point values from m64 and the low quadword of xmm1."
    vendor_syntax {
      mnemonic: "VMOVHPS"
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.0F.WIG 16 /r"
    instruction_group_index: 306
  }
  instructions {
    description: "Merge two packed single-precision floating-point values from m64 and the low quadword of xmm1."
    vendor_syntax {
      mnemonic: "VMOVHPS"
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.128.0F.W0 16 /r"
    instruction_group_index: 306
  }
  instructions {
    description: "Move two packed single-precision floating-point values from high quadword of xmm1 to m64."
    vendor_syntax {
      mnemonic: "MOVHPS"
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "NP 0F 17 /r"
    instruction_group_index: 306
  }
  instructions {
    description: "Move two packed single-precision floating-point values from high quadword of xmm1 to m64."
    vendor_syntax {
      mnemonic: "VMOVHPS"
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "VEX.128.0F.WIG 17 /r"
    instruction_group_index: 306
  }
  instructions {
    description: "Move two packed single-precision floating-point values from high quadword of xmm1 to m64."
    vendor_syntax {
      mnemonic: "VMOVHPS"
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "E"
    raw_encoding_specification: "EVEX.128.0F.W0 17 /r"
    instruction_group_index: 306
  }
  instructions {
    description: "For legacy mode, Move byte from address DS:(E)SI to ES:(E)DI. For 64-bit mode move byte from address (R|E)SI to (R|E)DI."
    vendor_syntax {
      mnemonic: "MOVS"
      operands {
        name: "m8"
      }
      operands {
        name: "m8"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "A4"
    instruction_group_index: 307
  }
  instructions {
    description: "For legacy mode, move word from address DS:(E)SI to ES:(E)DI. For 64-bit mode move word at address (R|E)SI to (R|E)DI."
    vendor_syntax {
      mnemonic: "MOVS"
      operands {
        name: "m16"
      }
      operands {
        name: "m16"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "A5"
    instruction_group_index: 307
  }
  instructions {
    description: "For legacy mode, move dword from address DS:(E)SI to ES:(E)DI. For 64-bit mode move dword from address (R|E)SI to (R|E)DI."
    vendor_syntax {
      mnemonic: "MOVS"
      operands {
        name: "m32"
      }
      operands {
        name: "m32"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "A5"
    instruction_group_index: 307
  }
  instructions {
    description: "Move qword from address (R|E)SI to (R|E)DI."
    vendor_syntax {
      mnemonic: "MOVS"
      operands {
        name: "m64"
      }
      operands {
        name: "m64"
      }
    }
    available_in_64_bit: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "REX.W + A5"
    instruction_group_index: 307
  }
  instructions {
    description: "For legacy mode, Move byte from address DS:(E)SI to ES:(E)DI. For 64-bit mode move byte from address (R|E)SI to (R|E)DI."
    vendor_syntax {
      mnemonic: "MOVSB"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "A4"
    instruction_group_index: 307
  }
  instructions {
    description: "For legacy mode, move word from address DS:(E)SI to ES:(E)DI. For 64-bit mode move word at address (R|E)SI to (R|E)DI."
    vendor_syntax {
      mnemonic: "MOVSW"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "A5"
    instruction_group_index: 307
  }
  instructions {
    description: "For legacy mode, move dword from address DS:(E)SI to ES:(E)DI. For 64-bit mode move dword from address (R|E)SI to (R|E)DI."
    vendor_syntax {
      mnemonic: "MOVSD"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "A5"
    instruction_group_index: 307
  }
  instructions {
    description: "Move qword from address (R|E)SI to (R|E)DI."
    vendor_syntax {
      mnemonic: "MOVSQ"
    }
    available_in_64_bit: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "REX.W + A5"
    instruction_group_index: 307
  }
  instructions {
    description: "Shift left 16 bits in k2 by immediate and write result in k1."
    vendor_syntax {
      mnemonic: "KSHIFTLW"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RRI"
    raw_encoding_specification: "VEX.L0.66.0F3A.W1 32 /r"
    instruction_group_index: 308
  }
  instructions {
    description: "Shift left 8 bits in k2 by immediate and write result in k1."
    vendor_syntax {
      mnemonic: "KSHIFTLB"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RRI"
    raw_encoding_specification: "VEX.L0.66.0F3A.W0 32 /r"
    instruction_group_index: 308
  }
  instructions {
    description: "Shift left 64 bits in k2 by immediate and write result in k1."
    vendor_syntax {
      mnemonic: "KSHIFTLQ"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RRI"
    raw_encoding_specification: "VEX.L0.66.0F3A.W1 33 /r"
    instruction_group_index: 308
  }
  instructions {
    description: "Shift left 32 bits in k2 by immediate and write result in k1."
    vendor_syntax {
      mnemonic: "KSHIFTLD"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RRI"
    raw_encoding_specification: "VEX.L0.66.0F3A.W0 33 /r"
    instruction_group_index: 308
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from xmm1 and xmm3/mem, negate the multiplication result and add to xmm2 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMADD132PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W1 9C /r"
    instruction_group_index: 309
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from xmm1 and xmm2, negate the multiplication result and add to xmm3/mem and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMADD213PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W1 AC /r"
    instruction_group_index: 309
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from xmm2 and xmm3/mem, negate the multiplication result andadd to xmm1 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMADD231PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W1 BC /r"
    instruction_group_index: 309
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from ymm1 and ymm3/mem, negate the multiplication result and add to ymm2 and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFNMADD132PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W1 9C /r"
    instruction_group_index: 309
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from ymm1 and ymm2, negate the multiplication result andadd to ymm3/mem and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFNMADD213PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W1 AC /r"
    instruction_group_index: 309
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from ymm2 and ymm3/mem, negate the multiplication result and add to ymm1 and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFNMADD231PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W1 BC /r"
    instruction_group_index: 309
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from xmm1 and xmm3/m128/m64bcst, negate the multiplication result and add to xmm2 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMADD132PD"
      operands {
        name: "xmm0"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm1"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm2/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 9C /r"
    instruction_group_index: 309
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from xmm1 and xmm2, negate the multiplication result and add to xmm3/m128/m64bcst and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMADD213PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 AC /r"
    instruction_group_index: 309
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from xmm2 and xmm3/m128/m64bcst, negate the multiplication result and add to xmm1 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMADD231PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 BC /r"
    instruction_group_index: 309
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from ymm1 and ymm3/m256/m64bcst, negate the multiplication result and add to ymm2 and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFNMADD132PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 9C /r"
    instruction_group_index: 309
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from ymm1 and ymm2, negate the multiplication result and add to ymm3/m256/m64bcst and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFNMADD213PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 AC /r"
    instruction_group_index: 309
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from ymm2 and ymm3/m256/m64bcst, negate the multiplication result and add to ymm1 and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFNMADD231PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 BC /r"
    instruction_group_index: 309
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from zmm1 and zmm3/m512/m64bcst, negate the multiplication result and add to zmm2 and put result in zmm1."
    vendor_syntax {
      mnemonic: "VFNMADD132PD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 9C /r"
    instruction_group_index: 309
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from zmm1 and zmm2, negate the multiplication result and add to zmm3/m512/m64bcst and put result in zmm1."
    vendor_syntax {
      mnemonic: "VFNMADD213PD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 AC /r"
    instruction_group_index: 309
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from zmm2 and zmm3/m512/m64bcst, negate the multiplication result and add to zmm1 and put result in zmm1."
    vendor_syntax {
      mnemonic: "VFNMADD231PD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 BC /r"
    instruction_group_index: 309
  }
  instructions {
    description: "Convert two packed single precision floating-point values from xmm2/m64/m32bcst to two packed signed quadword values in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VCVTPS2QQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F.W0 7B /r"
    instruction_group_index: 310
  }
  instructions {
    description: "Convert four packed single precision floating-point values from xmm2/m128/m32bcst to four packed signed quadword values in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VCVTPS2QQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F.W0 7B /r"
    instruction_group_index: 310
  }
  instructions {
    description: "Convert eight packed single precision floating-point values from ymm2/m256/m32bcst to eight packed signed quadword values in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VCVTPS2QQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F.W0 7B /r"
    instruction_group_index: 310
  }
  instructions {
    description: "Multiply scalar single-precision floating-point value from xmm1 and xmm3/m32, add to xmm2 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMADD132SS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.LIG.66.0F38.W0 99 /r"
    instruction_group_index: 311
  }
  instructions {
    description: "Multiply scalar single-precision floating-point value from xmm1 and xmm2, add to xmm3/m32 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMADD213SS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.LIG.66.0F38.W0 A9 /r"
    instruction_group_index: 311
  }
  instructions {
    description: "Multiply scalar single-precision floating-point value from xmm2 and xmm3/m32, add to xmm1 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMADD231SS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.LIG.66.0F38.W0 B9 /r"
    instruction_group_index: 311
  }
  instructions {
    description: "Multiply scalar single-precision floating-point value from xmm1 and xmm3/m32, add to xmm2 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMADD132SS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.LIG.66.0F38.W0 99 /r"
    instruction_group_index: 311
  }
  instructions {
    description: "Multiply scalar single-precision floating-point value from xmm1 and xmm2, add to xmm3/m32 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMADD213SS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.LIG.66.0F38.W0 A9 /r"
    instruction_group_index: 311
  }
  instructions {
    description: "Multiply scalar single-precision floating-point value from xmm2 and xmm3/m32, add to xmm1 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMADD231SS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.LIG.66.0F38.W0 B9 /r"
    instruction_group_index: 311
  }
  instructions {
    description: "Rotate doublewords in xmm2 left by count in the corresponding element of xmm3/m128/m32bcst.\nResult written to xmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPROLVD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 15 /r"
    instruction_group_index: 312
  }
  instructions {
    description: "Rotate doublewords in xmm2/m128/m32bcst left by imm8. Result written to xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPROLD"
      operands {
        name: "xmm1"
        encoding: VEX_V_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F.W0 72 /1 ib"
    instruction_group_index: 312
  }
  instructions {
    description: "Rotate quadwords in xmm2 left by count in the corresponding element of xmm3/m128/m64bcst.\nResult written to xmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPROLVQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 15 /r"
    instruction_group_index: 312
  }
  instructions {
    description: "Rotate quadwords in xmm2/m128/m64bcst left by imm8. Result written to xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPROLQ"
      operands {
        name: "xmm1"
        encoding: VEX_V_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F.W1 72 /1 ib"
    instruction_group_index: 312
  }
  instructions {
    description: "Rotate doublewords in ymm2 left by count in the corresponding element of ymm3/m256/m32bcst.\nResult written to ymm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPROLVD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 15 /r"
    instruction_group_index: 312
  }
  instructions {
    description: "Rotate doublewords in ymm2/m256/m32bcst left by imm8. Result written to ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPROLD"
      operands {
        name: "ymm1"
        encoding: VEX_V_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F.W0 72 /1 ib"
    instruction_group_index: 312
  }
  instructions {
    description: "Rotate quadwords in ymm2 left by count in the corresponding element of ymm3/m256/m64bcst.\nResult written to ymm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPROLVQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 15 /r"
    instruction_group_index: 312
  }
  instructions {
    description: "Rotate quadwords in ymm2/m256/m64bcst left by imm8. Result written to ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPROLQ"
      operands {
        name: "ymm1"
        encoding: VEX_V_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F.W1 72 /1 ib"
    instruction_group_index: 312
  }
  instructions {
    description: "Rotate left of doublewords in zmm2 by count in the corresponding element of zmm3/m512/m32bcst. Result written to zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPROLVD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 15 /r"
    instruction_group_index: 312
  }
  instructions {
    description: "Rotate left of doublewords in zmm3/m512/m32bcst by imm8. Result written to zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPROLD"
      operands {
        name: "zmm1"
        encoding: VEX_V_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F.W0 72 /1 ib"
    instruction_group_index: 312
  }
  instructions {
    description: "Rotate quadwords in zmm2 left by count in the corresponding element of zmm3/m512/m64bcst.\nResult written to zmm1under writemask k1."
    vendor_syntax {
      mnemonic: "VPROLVQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 15 /r"
    instruction_group_index: 312
  }
  instructions {
    description: "Rotate quadwords in zmm2/m512/m64bcst left by imm8. Result written to zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPROLQ"
      operands {
        name: "zmm1"
        encoding: VEX_V_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F.W1 72 /1 ib"
    instruction_group_index: 312
  }
  instructions {
    description: "Call to VM monitor by causing VM exit."
    vendor_syntax {
      mnemonic: "VMCALL"
    }
    feature_name: "VMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "0F 01 C1"
    instruction_group_index: 313
  }
  instructions {
    description: "Flush internal caches; initiate flushing of external caches."
    vendor_syntax {
      mnemonic: "INVD"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "0F 08"
    instruction_group_index: 314
  }
  instructions {
    description: "Store ST(0) in m16int."
    vendor_syntax {
      mnemonic: "FIST"
      operands {
        name: "m16int"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DF /2"
    instruction_group_index: 315
  }
  instructions {
    description: "Store ST(0) in m32int."
    vendor_syntax {
      mnemonic: "FIST"
      operands {
        name: "m32int"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DB /2"
    instruction_group_index: 315
  }
  instructions {
    description: "Store ST(0) in m16int and pop register stack."
    vendor_syntax {
      mnemonic: "FISTP"
      operands {
        name: "m16int"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DF /3"
    instruction_group_index: 315
  }
  instructions {
    description: "Store ST(0) in m32int and pop register stack."
    vendor_syntax {
      mnemonic: "FISTP"
      operands {
        name: "m32int"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DB /3"
    instruction_group_index: 315
  }
  instructions {
    description: "Store ST(0) in m64int and pop register stack."
    vendor_syntax {
      mnemonic: "FISTP"
      operands {
        name: "m64int"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DF /7"
    instruction_group_index: 315
  }
  instructions {
    description: "Convert the biased exponent (bits 62:52) of the low doubleprecision floating-point value in xmm3/m64 to a DP FP value representing unbiased integer exponent. Stores the result to the low 64-bit of xmm1 under the writemask k1 and merge with the other elements of xmm2."
    vendor_syntax {
      mnemonic: "VGETEXPSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.LIG.66.0F38.W1 43 /r"
    instruction_group_index: 316
  }
  instructions {
    description: "Converts 4 packed signed word integers from mm1 and from mm2/m64 into 8 packed signed byte integers in mm1 using signed saturation."
    vendor_syntax {
      mnemonic: "PACKSSWB"
      operands {
        name: "mm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 63 /r"
    instruction_group_index: 318
  }
  instructions {
    description: "Converts 8 packed signed word integers from xmm1 and from xmm2/m128 into 16 packed signed byte integers in xmm1 using signed saturation."
    vendor_syntax {
      mnemonic: "PACKSSWB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 63 /r"
    instruction_group_index: 318
  }
  instructions {
    description: "Converts 2 packed signed doubleword integers from mm1 and from mm2/m64 into 4 packed signed word integers in mm1 using signed saturation."
    vendor_syntax {
      mnemonic: "PACKSSDW"
      operands {
        name: "mm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 6B /r"
    instruction_group_index: 318
  }
  instructions {
    description: "Converts 4 packed signed doubleword integers from xmm1 and from xmm2/m128 into 8 packed signed word integers in xmm1 using signed saturation."
    vendor_syntax {
      mnemonic: "PACKSSDW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 6B /r"
    instruction_group_index: 318
  }
  instructions {
    description: "Converts 8 packed signed word integers from xmm2 and from xmm3/m128 into 16 packed signed byte integers in xmm1 using signed saturation."
    vendor_syntax {
      mnemonic: "VPACKSSWB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG 63 /r"
    instruction_group_index: 318
  }
  instructions {
    description: "Converts 4 packed signed doubleword integers from xmm2 and from xmm3/m128 into 8 packed signed word integers in xmm1 using signed saturation."
    vendor_syntax {
      mnemonic: "VPACKSSDW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG 6B /r"
    instruction_group_index: 318
  }
  instructions {
    description: "Converts 16 packed signed word integers from ymm2 and from ymm3/m256 into 32 packed signed byte integers in ymm1 using signed saturation."
    vendor_syntax {
      mnemonic: "VPACKSSWB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG 63 /r"
    instruction_group_index: 318
  }
  instructions {
    description: "Converts 8 packed signed doubleword integers from ymm2 and from ymm3/m256 into 16 packed signed word integers in ymm1using signed saturation."
    vendor_syntax {
      mnemonic: "VPACKSSDW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG 6B /r"
    instruction_group_index: 318
  }
  instructions {
    description: "Converts packed signed word integers from xmm2 and from xmm3/m128 into packed signed byte integers in xmm1 using signed saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPACKSSWB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.WIG 63 /r"
    instruction_group_index: 318
  }
  instructions {
    description: "Converts packed signed word integers from ymm2 and from ymm3/m256 into packed signed byte integers in ymm1 using signed saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPACKSSWB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.WIG 63 /r"
    instruction_group_index: 318
  }
  instructions {
    description: "Converts packed signed word integers from zmm2 and from zmm3/m512 into packed signed byte integers in zmm1 using signed saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPACKSSWB"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.WIG 63 /r"
    instruction_group_index: 318
  }
  instructions {
    description: "Converts packed signed doubleword integers from xmm2 and from xmm3/m128/m32bcst into packed signed word integers in xmm1 using signed saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPACKSSDW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.128.66.0F.W0 6B /r"
    instruction_group_index: 318
  }
  instructions {
    description: "Converts packed signed doubleword integers from ymm2 and from ymm3/m256/m32bcst into packed signed word integers in ymm1 using signed saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPACKSSDW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.256.66.0F.W0 6B /r"
    instruction_group_index: 318
  }
  instructions {
    description: "Converts packed signed doubleword integers from zmm2 and from zmm3/m512/m32bcst into packed signed word integers in zmm1 using signed saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPACKSSDW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.66.0F.W0 6B /r"
    instruction_group_index: 318
  }
  instructions {
    description: "ASCII adjust AX before division."
    vendor_syntax {
      mnemonic: "AAD"
    }
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "D5 0A"
    instruction_group_index: 319
  }
  instructions {
    description: "Adjust AX before division to number base imm8."
    vendor_syntax {
      mnemonic: "AAD"
      operands {
        name: "imm8"
      }
    }
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "D5 ib"
    instruction_group_index: 319
  }
  instructions {
    description: "Create a stack frame for a procedure."
    vendor_syntax {
      mnemonic: "ENTER"
      operands {
        name: "imm16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "0"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "II"
    raw_encoding_specification: "C8 iw 00"
    instruction_group_index: 320
  }
  instructions {
    description: "Create a stack frame with a nested pointer for a procedure."
    vendor_syntax {
      mnemonic: "ENTER"
      operands {
        name: "imm16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "1"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "II"
    raw_encoding_specification: "C8 iw 01"
    instruction_group_index: 320
  }
  instructions {
    description: "Create a stack frame with nested pointers for a procedure."
    vendor_syntax {
      mnemonic: "ENTER"
      operands {
        name: "imm16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "II"
    raw_encoding_specification: "C8 iw ib"
    instruction_group_index: 320
  }
  instructions {
    description: "Jump short if above (CF=0 and ZF=0)."
    vendor_syntax {
      mnemonic: "JA"
      operands {
        name: "rel8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "77 cb"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump short if above or equal (CF=0)."
    vendor_syntax {
      mnemonic: "JAE"
      operands {
        name: "rel8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "73 cb"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump short if below (CF=1)."
    vendor_syntax {
      mnemonic: "JB"
      operands {
        name: "rel8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "72 cb"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump short if below or equal (CF=1 or ZF=1)."
    vendor_syntax {
      mnemonic: "JBE"
      operands {
        name: "rel8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "76 cb"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump short if carry (CF=1)."
    vendor_syntax {
      mnemonic: "JC"
      operands {
        name: "rel8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "72 cb"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump short if CX register is 0."
    vendor_syntax {
      mnemonic: "JCXZ"
      operands {
        name: "rel8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "E3 cb"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump short if ECX register is 0."
    vendor_syntax {
      mnemonic: "JECXZ"
      operands {
        name: "rel8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "E3 cb"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump short if RCX register is 0."
    vendor_syntax {
      mnemonic: "JRCXZ"
      operands {
        name: "rel8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "D"
    raw_encoding_specification: "E3 cb"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump short if equal (ZF=1)."
    vendor_syntax {
      mnemonic: "JE"
      operands {
        name: "rel8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "74 cb"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump short if greater (ZF=0 and SF=OF)."
    vendor_syntax {
      mnemonic: "JG"
      operands {
        name: "rel8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "7F cb"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump short if greater or equal (SF=OF)."
    vendor_syntax {
      mnemonic: "JGE"
      operands {
        name: "rel8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "7D cb"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump short if less (SF\342\211\240 OF)."
    vendor_syntax {
      mnemonic: "JL"
      operands {
        name: "rel8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "7C cb"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump short if less or equal (ZF=1 or SF\342\211\240 OF)."
    vendor_syntax {
      mnemonic: "JLE"
      operands {
        name: "rel8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "7E cb"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump short if not above (CF=1 or ZF=1)."
    vendor_syntax {
      mnemonic: "JNA"
      operands {
        name: "rel8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "76 cb"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump short if not above or equal (CF=1)."
    vendor_syntax {
      mnemonic: "JNAE"
      operands {
        name: "rel8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "72 cb"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump short if not below (CF=0)."
    vendor_syntax {
      mnemonic: "JNB"
      operands {
        name: "rel8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "73 cb"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump short if not below or equal (CF=0 and ZF=0)."
    vendor_syntax {
      mnemonic: "JNBE"
      operands {
        name: "rel8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "77 cb"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump short if not carry (CF=0)."
    vendor_syntax {
      mnemonic: "JNC"
      operands {
        name: "rel8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "73 cb"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump short if not equal (ZF=0)."
    vendor_syntax {
      mnemonic: "JNE"
      operands {
        name: "rel8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "75 cb"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump short if not greater (ZF=1 or SF\342\211\240 OF)."
    vendor_syntax {
      mnemonic: "JNG"
      operands {
        name: "rel8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "7E cb"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump short if not greater or equal (SF\342\211\240 OF)."
    vendor_syntax {
      mnemonic: "JNGE"
      operands {
        name: "rel8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "7C cb"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump short if not less (SF=OF)."
    vendor_syntax {
      mnemonic: "JNL"
      operands {
        name: "rel8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "7D cb"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump short if not less or equal (ZF=0 and SF=OF)."
    vendor_syntax {
      mnemonic: "JNLE"
      operands {
        name: "rel8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "7F cb"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump short if not overflow (OF=0)."
    vendor_syntax {
      mnemonic: "JNO"
      operands {
        name: "rel8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "71 cb"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump short if not parity (PF=0)."
    vendor_syntax {
      mnemonic: "JNP"
      operands {
        name: "rel8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "7B cb"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump short if not sign (SF=0)."
    vendor_syntax {
      mnemonic: "JNS"
      operands {
        name: "rel8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "79 cb"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump short if not zero (ZF=0)."
    vendor_syntax {
      mnemonic: "JNZ"
      operands {
        name: "rel8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "75 cb"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump short if overflow (OF=1)."
    vendor_syntax {
      mnemonic: "JO"
      operands {
        name: "rel8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "70 cb"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump short if parity (PF=1)."
    vendor_syntax {
      mnemonic: "JP"
      operands {
        name: "rel8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "7A cb"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump short if parity even (PF=1)."
    vendor_syntax {
      mnemonic: "JPE"
      operands {
        name: "rel8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "7A cb"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump short if parity odd (PF=0)."
    vendor_syntax {
      mnemonic: "JPO"
      operands {
        name: "rel8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "7B cb"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump short if sign (SF=1)."
    vendor_syntax {
      mnemonic: "JS"
      operands {
        name: "rel8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "78 cb"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump short if zero (ZF = 1)."
    vendor_syntax {
      mnemonic: "JZ"
      operands {
        name: "rel8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "74 cb"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if above (CF=0 and ZF=0). Not supported in 64-bit mode."
    vendor_syntax {
      mnemonic: "JA"
      operands {
        name: "rel16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 87 cw"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if above (CF=0 and ZF=0)."
    vendor_syntax {
      mnemonic: "JA"
      operands {
        name: "rel32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 87 cd"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if above or equal (CF=0). Not supported in 64-bit mode."
    vendor_syntax {
      mnemonic: "JAE"
      operands {
        name: "rel16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 83 cw"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if above or equal (CF=0)."
    vendor_syntax {
      mnemonic: "JAE"
      operands {
        name: "rel32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 83 cd"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if below (CF=1). Not supported in 64-bit mode."
    vendor_syntax {
      mnemonic: "JB"
      operands {
        name: "rel16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 82 cw"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if below (CF=1)."
    vendor_syntax {
      mnemonic: "JB"
      operands {
        name: "rel32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 82 cd"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if below or equal (CF=1 or ZF=1).\nNot supported in 64-bit mode."
    vendor_syntax {
      mnemonic: "JBE"
      operands {
        name: "rel16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 86 cw"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if below or equal (CF=1 or ZF=1)."
    vendor_syntax {
      mnemonic: "JBE"
      operands {
        name: "rel32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 86 cd"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if carry (CF=1). Not supported in 64-bit mode."
    vendor_syntax {
      mnemonic: "JC"
      operands {
        name: "rel16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 82 cw"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if carry (CF=1)."
    vendor_syntax {
      mnemonic: "JC"
      operands {
        name: "rel32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 82 cd"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if equal (ZF=1). Not supported in 64-bit mode."
    vendor_syntax {
      mnemonic: "JE"
      operands {
        name: "rel16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 84 cw"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if equal (ZF=1)."
    vendor_syntax {
      mnemonic: "JE"
      operands {
        name: "rel32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 84 cd"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if 0 (ZF=1). Not supported in 64-bit mode."
    vendor_syntax {
      mnemonic: "JZ"
      operands {
        name: "rel16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 84 cw"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if 0 (ZF=1)."
    vendor_syntax {
      mnemonic: "JZ"
      operands {
        name: "rel32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 84 cd"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if greater (ZF=0 and SF=OF). Not supported in 64-bit mode."
    vendor_syntax {
      mnemonic: "JG"
      operands {
        name: "rel16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 8F cw"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if greater (ZF=0 and SF=OF)."
    vendor_syntax {
      mnemonic: "JG"
      operands {
        name: "rel32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 8F cd"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if greater or equal (SF=OF). Not supported in 64-bit mode."
    vendor_syntax {
      mnemonic: "JGE"
      operands {
        name: "rel16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 8D cw"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if greater or equal (SF=OF)."
    vendor_syntax {
      mnemonic: "JGE"
      operands {
        name: "rel32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 8D cd"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if less (SF\342\211\240 OF). Not supported in 64-bit mode."
    vendor_syntax {
      mnemonic: "JL"
      operands {
        name: "rel16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 8C cw"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if less (SF\342\211\240 OF)."
    vendor_syntax {
      mnemonic: "JL"
      operands {
        name: "rel32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 8C cd"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if less or equal (ZF=1 or SF\342\211\240 OF).\nNot supported in 64-bit mode."
    vendor_syntax {
      mnemonic: "JLE"
      operands {
        name: "rel16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 8E cw"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if less or equal (ZF=1 or SF\342\211\240 OF)."
    vendor_syntax {
      mnemonic: "JLE"
      operands {
        name: "rel32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 8E cd"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if not above (CF=1 or ZF=1). Not supported in 64-bit mode."
    vendor_syntax {
      mnemonic: "JNA"
      operands {
        name: "rel16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 86 cw"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if not above (CF=1 or ZF=1)."
    vendor_syntax {
      mnemonic: "JNA"
      operands {
        name: "rel32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 86 cd"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if not above or equal (CF=1). Not supported in 64-bit mode."
    vendor_syntax {
      mnemonic: "JNAE"
      operands {
        name: "rel16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 82 cw"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if not above or equal (CF=1)."
    vendor_syntax {
      mnemonic: "JNAE"
      operands {
        name: "rel32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 82 cd"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if not below (CF=0). Not supported in 64-bit mode."
    vendor_syntax {
      mnemonic: "JNB"
      operands {
        name: "rel16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 83 cw"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if not below (CF=0)."
    vendor_syntax {
      mnemonic: "JNB"
      operands {
        name: "rel32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 83 cd"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if not below or equal (CF=0 and ZF=0). Not supported in 64-bit mode."
    vendor_syntax {
      mnemonic: "JNBE"
      operands {
        name: "rel16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 87 cw"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if not below or equal (CF=0 and ZF=0)."
    vendor_syntax {
      mnemonic: "JNBE"
      operands {
        name: "rel32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 87 cd"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if not carry (CF=0). Not supported in 64-bit mode."
    vendor_syntax {
      mnemonic: "JNC"
      operands {
        name: "rel16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 83 cw"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if not carry (CF=0)."
    vendor_syntax {
      mnemonic: "JNC"
      operands {
        name: "rel32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 83 cd"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if not equal (ZF=0). Not supported in 64-bit mode."
    vendor_syntax {
      mnemonic: "JNE"
      operands {
        name: "rel16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 85 cw"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if not equal (ZF=0)."
    vendor_syntax {
      mnemonic: "JNE"
      operands {
        name: "rel32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 85 cd"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if not greater (ZF=1 or SF\342\211\240 OF).\nNot supported in 64-bit mode."
    vendor_syntax {
      mnemonic: "JNG"
      operands {
        name: "rel16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 8E cw"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if not greater (ZF=1 or SF\342\211\240 OF)."
    vendor_syntax {
      mnemonic: "JNG"
      operands {
        name: "rel32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 8E cd"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if not greater or equal (SF\342\211\240 OF).\nNot supported in 64-bit mode."
    vendor_syntax {
      mnemonic: "JNGE"
      operands {
        name: "rel16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 8C cw"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if not greater or equal (SF\342\211\240 OF)."
    vendor_syntax {
      mnemonic: "JNGE"
      operands {
        name: "rel32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 8C cd"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if not less (SF=OF). Not supported in 64-bit mode."
    vendor_syntax {
      mnemonic: "JNL"
      operands {
        name: "rel16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 8D cw"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if not less (SF=OF)."
    vendor_syntax {
      mnemonic: "JNL"
      operands {
        name: "rel32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 8D cd"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if not less or equal (ZF=0 and SF=OF). Not supported in 64-bit mode."
    vendor_syntax {
      mnemonic: "JNLE"
      operands {
        name: "rel16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 8F cw"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if not less or equal (ZF=0 and SF=OF)."
    vendor_syntax {
      mnemonic: "JNLE"
      operands {
        name: "rel32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 8F cd"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if not overflow (OF=0). Not supported in 64-bit mode."
    vendor_syntax {
      mnemonic: "JNO"
      operands {
        name: "rel16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 81 cw"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if not overflow (OF=0)."
    vendor_syntax {
      mnemonic: "JNO"
      operands {
        name: "rel32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 81 cd"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if not parity (PF=0). Not supported in 64-bit mode."
    vendor_syntax {
      mnemonic: "JNP"
      operands {
        name: "rel16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 8B cw"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if not parity (PF=0)."
    vendor_syntax {
      mnemonic: "JNP"
      operands {
        name: "rel32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 8B cd"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if not sign (SF=0). Not supported in 64-bit mode."
    vendor_syntax {
      mnemonic: "JNS"
      operands {
        name: "rel16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 89 cw"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if not sign (SF=0)."
    vendor_syntax {
      mnemonic: "JNS"
      operands {
        name: "rel32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 89 cd"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if not zero (ZF=0). Not supported in 64-bit mode."
    vendor_syntax {
      mnemonic: "JNZ"
      operands {
        name: "rel16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 85 cw"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if not zero (ZF=0)."
    vendor_syntax {
      mnemonic: "JNZ"
      operands {
        name: "rel32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 85 cd"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if overflow (OF=1). Not supported in 64-bit mode."
    vendor_syntax {
      mnemonic: "JO"
      operands {
        name: "rel16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 80 cw"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if overflow (OF=1)."
    vendor_syntax {
      mnemonic: "JO"
      operands {
        name: "rel32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 80 cd"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if parity (PF=1). Not supported in 64-bit mode."
    vendor_syntax {
      mnemonic: "JP"
      operands {
        name: "rel16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 8A cw"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if parity (PF=1)."
    vendor_syntax {
      mnemonic: "JP"
      operands {
        name: "rel32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 8A cd"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if parity even (PF=1). Not supported in 64-bit mode."
    vendor_syntax {
      mnemonic: "JPE"
      operands {
        name: "rel16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 8A cw"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if parity even (PF=1)."
    vendor_syntax {
      mnemonic: "JPE"
      operands {
        name: "rel32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 8A cd"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if parity odd (PF=0). Not supported in 64-bit mode."
    vendor_syntax {
      mnemonic: "JPO"
      operands {
        name: "rel16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 8B cw"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if parity odd (PF=0)."
    vendor_syntax {
      mnemonic: "JPO"
      operands {
        name: "rel32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 8B cd"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if sign (SF=1). Not supported in 64- bit mode."
    vendor_syntax {
      mnemonic: "JS"
      operands {
        name: "rel16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 88 cw"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if sign (SF=1)."
    vendor_syntax {
      mnemonic: "JS"
      operands {
        name: "rel32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 88 cd"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if 0 (ZF=1). Not supported in 64-bit mode."
    vendor_syntax {
      mnemonic: "JZ"
      operands {
        name: "rel16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 84 cw"
    instruction_group_index: 321
  }
  instructions {
    description: "Jump near if 0 (ZF=1)."
    vendor_syntax {
      mnemonic: "JZ"
      operands {
        name: "rel32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "0F 84 cd"
    instruction_group_index: 321
  }
  instructions {
    description: "Read IA32_TSC_AUX into r32."
    vendor_syntax {
      mnemonic: "RDPID"
      operands {
        name: "r32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    feature_name: "RDPID"
    legacy_instruction: true
    encoding_scheme: "R"
    raw_encoding_specification: "F3 0F C7 /7"
    instruction_group_index: 322
  }
  instructions {
    description: "Read IA32_TSC_AUX into r64."
    vendor_syntax {
      mnemonic: "RDPID"
      operands {
        name: "r64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    feature_name: "RDPID"
    available_in_64_bit: true
    encoding_scheme: "R"
    raw_encoding_specification: "F3 0F C7 /7"
    instruction_group_index: 322
  }
  instructions {
    description: "Computes the approximate reciprocals of the square roots of the packed single-precision floating-point values in xmm2/m128 and stores the results in xmm1."
    vendor_syntax {
      mnemonic: "RSQRTPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "NP 0F 52 /r"
    instruction_group_index: 323
  }
  instructions {
    description: "Computes the approximate reciprocals of the square roots of packed single-precision values in xmm2/mem and stores the results in xmm1."
    vendor_syntax {
      mnemonic: "VRSQRTPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "VEX.128.0F.WIG 52 /r"
    instruction_group_index: 323
  }
  instructions {
    description: "Computes the approximate reciprocals of the square roots of packed single-precision values in ymm2/mem and stores the results in ymm1."
    vendor_syntax {
      mnemonic: "VRSQRTPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "VEX.256.0F.WIG 52 /r"
    instruction_group_index: 323
  }
  instructions {
    description: "Convert two packed single-precision floatingpoint values from xmm/m64 to two packed signed doubleword integers in mm."
    vendor_syntax {
      mnemonic: "CVTPS2PI"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "NP 0F 2D /r"
    instruction_group_index: 324
  }
  instructions {
    description: "Convert two packed double-precision floating-point values from zmm2/m128/m64bcst to two packed quadword integers in zmm1 using truncation with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTTPD2QQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F.W1 7A /r"
    instruction_group_index: 325
  }
  instructions {
    description: "Convert four packed double-precision floating-point values from ymm2/m256/m64bcst to four packed quadword integers in ymm1 using truncation with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTTPD2QQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F.W1 7A /r"
    instruction_group_index: 325
  }
  instructions {
    description: "Convert eight packed double-precision floating-point values from zmm2/m512 to eight packed quadword integers in zmm1 using truncation with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTTPD2QQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F.W1 7A /r"
    instruction_group_index: 325
  }
  instructions {
    description: "Decimal adjust AL after addition."
    vendor_syntax {
      mnemonic: "DAA"
    }
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "27"
    instruction_group_index: 326
  }
  instructions {
    description: "Round packed double precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by imm8."
    vendor_syntax {
      mnemonic: "ROUNDPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMI"
    raw_encoding_specification: "66 0F 3A 09 /r ib"
    instruction_group_index: 327
  }
  instructions {
    description: "Round packed double-precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by imm8."
    vendor_syntax {
      mnemonic: "VROUNDPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMI"
    raw_encoding_specification: "VEX.128.66.0F3A.WIG 09 /r ib"
    instruction_group_index: 327
  }
  instructions {
    description: "Round packed double-precision floating-point values in ymm2/m256 and place the result in ymm1. The rounding mode is determined by imm8."
    vendor_syntax {
      mnemonic: "VROUNDPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMI"
    raw_encoding_specification: "VEX.256.66.0F3A.WIG 09 /r ib"
    instruction_group_index: 327
  }
  instructions {
    description: "Computes square root of ST(0) and stores the result in ST(0)."
    vendor_syntax {
      mnemonic: "FSQRT"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D9 FA"
    instruction_group_index: 328
  }
  instructions {
    description: "Move a byte mask of mm to reg. The upper bits of r32 or r64 are zeroed"
    vendor_syntax {
      mnemonic: "PMOVMSKB"
      operands {
        name: "reg"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "mm"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "NP 0F D7 /r"
    instruction_group_index: 329
  }
  instructions {
    description: "Move a byte mask of xmm to reg. The upper bits of r32 or r64 are zeroed"
    vendor_syntax {
      mnemonic: "PMOVMSKB"
      operands {
        name: "reg"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "66 0F D7 /r"
    instruction_group_index: 329
  }
  instructions {
    description: "Move a byte mask of xmm1 to reg. The upper bits of r32 or r64 are filled with zeros."
    vendor_syntax {
      mnemonic: "VPMOVMSKB"
      operands {
        name: "reg"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "VEX.128.66.0F.WIG D7 /r"
    instruction_group_index: 329
  }
  instructions {
    description: "Move a 32-bit mask of ymm1 to reg. The upper bits of r64 are filled with zeros."
    vendor_syntax {
      mnemonic: "VPMOVMSKB"
      operands {
        name: "reg"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "VEX.256.66.0F.WIG D7 /r"
    instruction_group_index: 329
  }
  instructions {
    description: "r16 := access rights referenced by r16/m16"
    vendor_syntax {
      mnemonic: "LAR"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r16/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 02 /r"
    instruction_group_index: 330
  }
  instructions {
    description: "reg := access rights referenced by r32/m16"
    vendor_syntax {
      mnemonic: "LAR"
      operands {
        name: "reg"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r32/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 02 /r"
    instruction_group_index: 330
  }
  instructions {
    description: "Convert one single-precision floating-point value from xmm1/m32 to one unsigned doubleword integer in r32."
    vendor_syntax {
      mnemonic: "VCVTSS2USI"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.LIG.F3.0F.W0 79 /r"
    instruction_group_index: 331
  }
  instructions {
    description: "Convert one single-precision floating-point value from xmm1/m32 to one unsigned quadword integer in r64."
    vendor_syntax {
      mnemonic: "VCVTSS2USI"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.LIG.F3.0F.W1 79 /r"
    instruction_group_index: 331
  }
  instructions {
    description: "Convert two packed double-precision floating-point values in xmm2/m128/m64bcst to two unsigned doubleword integers in xmm1 using truncation subject to writemask k1."
    vendor_syntax {
      mnemonic: "VCVTTPD2UDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.0F.W1 78 /r"
    instruction_group_index: 332
  }
  instructions {
    description: "Convert four packed double-precision floating-point values in ymm2/m256/m64bcst to four unsigned doubleword integers in xmm1 using truncation subject to writemask k1."
    vendor_syntax {
      mnemonic: "VCVTTPD2UDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.0F.W1 78 /r"
    instruction_group_index: 332
  }
  instructions {
    description: "Convert eight packed double-precision floating-point values in zmm2/m512/m64bcst to eight unsigned doubleword integers in ymm1 using truncation subject to writemask k1."
    vendor_syntax {
      mnemonic: "VCVTTPD2UDQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.0F.W1 78 /r"
    instruction_group_index: 332
  }
  instructions {
    description: "Store effective address for m in register r16."
    vendor_syntax {
      mnemonic: "LEA"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "m"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "8D /r"
    instruction_group_index: 333
  }
  instructions {
    description: "Store effective address for m in register r32."
    vendor_syntax {
      mnemonic: "LEA"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "m"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "8D /r"
    instruction_group_index: 333
  }
  instructions {
    description: "Store effective address for m in register r64."
    vendor_syntax {
      mnemonic: "LEA"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "m"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 8D /r"
    instruction_group_index: 333
  }
  instructions {
    description: "Perform a packed comparison of string data with implicit lengths, generating an index, and storing the result in ECX."
    vendor_syntax {
      mnemonic: "PCMPISTRI"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "66 0F 3A 63 /r imm8"
    instruction_group_index: 334
  }
  instructions {
    description: "Perform a packed comparison of string data with implicit lengths, generating an index, and storing the result in ECX."
    vendor_syntax {
      mnemonic: "VPCMPISTRI"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "VEX.128.66.0F3A.WIG 63 /r ib"
    instruction_group_index: 334
  }
  instructions {
    description: "Computes the approximate reciprocals of the packed doubleprecision floating-point values in xmm2/m128/m64bcst and stores the results in xmm1. Under writemask."
    vendor_syntax {
      mnemonic: "VRCP14PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 4C /r"
    instruction_group_index: 335
  }
  instructions {
    description: "Computes the approximate reciprocals of the packed doubleprecision floating-point values in ymm2/m256/m64bcst and stores the results in ymm1. Under writemask."
    vendor_syntax {
      mnemonic: "VRCP14PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 4C /r"
    instruction_group_index: 335
  }
  instructions {
    description: "Computes the approximate reciprocals of the packed doubleprecision floating-point values in zmm2/m512/m64bcst and stores the results in zmm1. Under writemask."
    vendor_syntax {
      mnemonic: "VRCP14PD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 4C /r"
    instruction_group_index: 335
  }
  instructions {
    description: "Computes the approximate reciprocal of the scalar doubleprecision floating-point value in xmm3/m64 and stores the result in xmm1 using writemask k1. Also, upper doubleprecision floating-point value (bits[127:64]) from xmm2 is copied to xmm1[127:64]."
    vendor_syntax {
      mnemonic: "VRCP14SD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.LIG.66.0F38.W1 4D /r"
    instruction_group_index: 336
  }
  instructions {
    description: "Multiply signed words from source register block indicated by zmm2 by signed words from m128 and accumulate the resulting dword results with signed saturation in zmm1."
    vendor_syntax {
      mnemonic: "VP4DPWSSDS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2+3"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_4VNNIW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.F2.0F38.W0 53 /r"
    instruction_group_index: 337
  }
  instructions {
    description: "Multiply the packed signed word integers in mm1 register and mm2/m64, and store the high 16 bits of the results in mm1."
    vendor_syntax {
      mnemonic: "PMULHW"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F E5 /r"
    instruction_group_index: 339
  }
  instructions {
    description: "Multiply the packed signed word integers in xmm1 and xmm2/m128, and store the high 16 bits of the results in xmm1."
    vendor_syntax {
      mnemonic: "PMULHW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F E5 /r"
    instruction_group_index: 339
  }
  instructions {
    description: "Multiply the packed signed word integers in xmm2 and xmm3/m128, and store the high 16 bits of the results in xmm1."
    vendor_syntax {
      mnemonic: "VPMULHW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG E5 /r"
    instruction_group_index: 339
  }
  instructions {
    description: "Multiply the packed signed word integers in ymm2 and ymm3/m256, and store the high 16 bits of the results in ymm1."
    vendor_syntax {
      mnemonic: "VPMULHW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG E5 /r"
    instruction_group_index: 339
  }
  instructions {
    description: "Multiply the packed signed word integers in xmm2 and xmm3/m128, and store the high 16 bits of the results in xmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMULHW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.WIG E5 /r"
    instruction_group_index: 339
  }
  instructions {
    description: "Multiply the packed signed word integers in ymm2 and ymm3/m256, and store the high 16 bits of the results in ymm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMULHW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.WIG E5 /r"
    instruction_group_index: 339
  }
  instructions {
    description: "Multiply the packed signed word integers in zmm2 and zmm3/m512, and store the high 16 bits of the results in zmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMULHW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.WIG E5 /r"
    instruction_group_index: 339
  }
  instructions {
    description: "Computes the approximate reciprocal square root of the scalar single-precision floating-point value in xmm3/m32 and stores the result in the low doubleword element of xmm1 using writemask k1. Bits[127:32] of xmm2 is copied to xmm1[127:32]."
    vendor_syntax {
      mnemonic: "VRSQRT14SS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.LIG.66.0F38.W0 4F /r"
    instruction_group_index: 340
  }
  instructions {
    description: "Writes EAX into PKRU."
    vendor_syntax {
      mnemonic: "WRPKRU"
    }
    feature_name: "OSPKE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "NP 0F 01 EF"
    instruction_group_index: 341
  }
  instructions {
    description: "Bitwise XNOR 16-bit masks k2 and k3 and place result in k1."
    vendor_syntax {
      mnemonic: "KXNORW"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "k3"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVR"
    raw_encoding_specification: "VEX.L1.0F.W0 46 /r"
    instruction_group_index: 342
  }
  instructions {
    description: "Bitwise XNOR 8-bit masks k2 and k3 and place result in k1."
    vendor_syntax {
      mnemonic: "KXNORB"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "k3"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVR"
    raw_encoding_specification: "VEX.NDS.L1.66.0F.W0 46 /r"
    instruction_group_index: 342
  }
  instructions {
    description: "Bitwise XNOR 64-bit masks k2 and k3 and place result in k1."
    vendor_syntax {
      mnemonic: "KXNORQ"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "k3"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVR"
    raw_encoding_specification: "VEX.NDS.L1.0F.W1 46 /r"
    instruction_group_index: 342
  }
  instructions {
    description: "Bitwise XNOR 32-bit masks k2 and k3 and place result in k1."
    vendor_syntax {
      mnemonic: "KXNORD"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "k3"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVR"
    raw_encoding_specification: "VEX.NDS.L1.66.0F.W1 46 /r"
    instruction_group_index: 342
  }
  instructions {
    description: "Separate value in ST(0) into exponent and significand, store exponent in ST(0), and push the significand onto the register stack."
    vendor_syntax {
      mnemonic: "FXTRACT"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D9 F4"
    instruction_group_index: 343
  }
  instructions {
    description: "Convert one signed doubleword integer from r/m32 to one single-precision floating-point value in xmm1."
    vendor_syntax {
      mnemonic: "CVTSI2SS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F3 0F 2A /r"
    instruction_group_index: 344
  }
  instructions {
    description: "Convert one signed quadword integer from r/m64 to one single-precision floating-point value in xmm1."
    vendor_syntax {
      mnemonic: "CVTSI2SS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    encoding_scheme: "A"
    raw_encoding_specification: "F3 REX.W 0F 2A /r"
    instruction_group_index: 344
  }
  instructions {
    description: "Convert one signed doubleword integer from r/m32 to one single-precision floating-point value in xmm1."
    vendor_syntax {
      mnemonic: "VCVTSI2SS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.LIG.F3.0F.W0 2A /r"
    instruction_group_index: 344
  }
  instructions {
    description: "Convert one signed quadword integer from r/m64 to one single-precision floating-point value in xmm1."
    vendor_syntax {
      mnemonic: "VCVTSI2SS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.LIG.F3.0F.W1 2A /r"
    instruction_group_index: 344
  }
  instructions {
    description: "Convert one signed doubleword integer from r/m32 to one single-precision floating-point value in xmm1."
    vendor_syntax {
      mnemonic: "VCVTSI2SS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.LIG.F3.0F.W0 2A /r"
    instruction_group_index: 344
  }
  instructions {
    description: "Convert one signed quadword integer from r/m64 to one single-precision floating-point value in xmm1."
    vendor_syntax {
      mnemonic: "VCVTSI2SS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.LIG.F3.0F.W1 2A /r"
    instruction_group_index: 344
  }
  instructions {
    description: "Compare ST(0) with ST(i) and set status flags accordingly."
    vendor_syntax {
      mnemonic: "FCOMI"
      operands {
        name: "ST"
      }
      operands {
        name: "ST(i)"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DB F0+i"
    instruction_group_index: 345
  }
  instructions {
    description: "Compare ST(0) with ST(i), set status flags accordingly, and pop register stack."
    vendor_syntax {
      mnemonic: "FCOMIP"
      operands {
        name: "ST"
      }
      operands {
        name: "ST(i)"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DF F0+i"
    instruction_group_index: 345
  }
  instructions {
    description: "Compare ST(0) with ST(i), check for ordered values, and set status flags accordingly."
    vendor_syntax {
      mnemonic: "FUCOMI"
      operands {
        name: "ST"
      }
      operands {
        name: "ST(i)"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DB E8+i"
    instruction_group_index: 345
  }
  instructions {
    description: "Compare ST(0) with ST(i), check for ordered values, set status flags accordingly, and pop register stack."
    vendor_syntax {
      mnemonic: "FUCOMIP"
      operands {
        name: "ST"
      }
      operands {
        name: "ST(i)"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DF E8+i"
    instruction_group_index: 345
  }
  instructions {
    description: "Computes affine transformation in the finite field GF(2^8)."
    vendor_syntax {
      mnemonic: "GF2P8AFFINEQB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "GFNI"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F3A CE /r /ib"
    instruction_group_index: 346
  }
  instructions {
    description: "Computes affine transformation in the finite field GF(2^8)."
    vendor_syntax {
      mnemonic: "VGF2P8AFFINEQB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX && GFNI"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F3A.W1 CE /r /ib"
    instruction_group_index: 346
  }
  instructions {
    description: "Computes affine transformation in the finite field GF(2^8)."
    vendor_syntax {
      mnemonic: "VGF2P8AFFINEQB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX && GFNI"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F3A.W1 CE /r /ib"
    instruction_group_index: 346
  }
  instructions {
    description: "Computes affine transformation in the finite field GF(2^8)."
    vendor_syntax {
      mnemonic: "VGF2P8AFFINEQB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && GFNI"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F3A.W1 CE /r /ib"
    instruction_group_index: 346
  }
  instructions {
    description: "Computes affine transformation in the finite field GF(2^8)."
    vendor_syntax {
      mnemonic: "VGF2P8AFFINEQB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && GFNI"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F3A.W1 CE /r /ib"
    instruction_group_index: 346
  }
  instructions {
    description: "Computes affine transformation in the finite field GF(2^8)."
    vendor_syntax {
      mnemonic: "VGF2P8AFFINEQB"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F && GFNI"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F3A.W1 CE /r /ib"
    instruction_group_index: 346
  }
  instructions {
    description: "Extract values in xmm2 using control bits of xmm3/m128 with writemask k2 and leave the result in mask register k1."
    vendor_syntax {
      mnemonic: "VPSHUFBITQMB"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_BITALG && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 8F /r"
    instruction_group_index: 347
  }
  instructions {
    description: "Extract values in ymm2 using control bits of ymm3/m256 with writemask k2 and leave the result in mask register k1."
    vendor_syntax {
      mnemonic: "VPSHUFBITQMB"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_BITALG && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 8F /r"
    instruction_group_index: 347
  }
  instructions {
    description: "Extract values in zmm2 using control bits of zmm3/m512 with writemask k2 and leave the result in mask register k1."
    vendor_syntax {
      mnemonic: "VPSHUFBITQMB"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_BITALG"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 8F /r"
    instruction_group_index: 347
  }
  instructions {
    description: "Performs the final calculation for the next four SHA256 message dwords using previous message dwords from xmm1 and xmm2/m128, storing the result in xmm1."
    vendor_syntax {
      mnemonic: "SHA256MSG2"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SHA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "NP 0F 38 CD /r"
    instruction_group_index: 348
  }
  instructions {
    description: "Store the bounds in bnd and the pointer value in the index register of mib to a bound table entry (BTE) with address translation using the base of mib."
    vendor_syntax {
      mnemonic: "BNDSTX"
      operands {
        name: "mib"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "bnd"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MPX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "NP 0F 1B /r"
    instruction_group_index: 349
  }
  instructions {
    description: "Fix up a float32 number in the low doubleword element in xmm2 using scalar int32 table in xmm3/m32 and store the result in xmm1."
    vendor_syntax {
      mnemonic: "VFIXUPIMMSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.LIG.66.0F3A.W0 55 /r ib"
    instruction_group_index: 350
  }
  instructions {
    description: "Shuffle 128-bit packed single-precision floating-point values selected by imm8 from ymm2 and ymm3/m256/m32bcst and place results in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VSHUFF32X4"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F3A.W0 23 /r ib"
    instruction_group_index: 351
  }
  instructions {
    description: "Shuffle 128-bit packed single-precision floating-point values selected by imm8 from zmm2 and zmm3/m512/m32bcst and place results in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VSHUFF32x4"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F3A.W0 23 /r ib"
    instruction_group_index: 351
  }
  instructions {
    description: "Shuffle 128-bit packed double-precision floating-point values selected by imm8 from ymm2 and ymm3/m256/m64bcst and place results in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VSHUFF64X2"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F3A.W1 23 /r ib"
    instruction_group_index: 351
  }
  instructions {
    description: "Shuffle 128-bit packed double-precision floating-point values selected by imm8 from zmm2 and zmm3/m512/m64bcst and place results in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VSHUFF64x2"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F3A.W1 23 /r ib"
    instruction_group_index: 351
  }
  instructions {
    description: "Shuffle 128-bit packed double-word values selected by imm8 from ymm2 and ymm3/m256/m32bcst and place results in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VSHUFI32X4"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F3A.W0 43 /r ib"
    instruction_group_index: 351
  }
  instructions {
    description: "Shuffle 128-bit packed double-word values selected by imm8 from zmm2 and zmm3/m512/m32bcst and place results in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VSHUFI32x4"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F3A.W0 43 /r ib"
    instruction_group_index: 351
  }
  instructions {
    description: "Shuffle 128-bit packed quad-word values selected by imm8 from ymm2 and ymm3/m256/m64bcst and place results in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VSHUFI64X2"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F3A.W1 43 /r ib"
    instruction_group_index: 351
  }
  instructions {
    description: "Shuffle 128-bit packed quad-word values selected by imm8 from zmm2 and zmm3/m512/m64bcst and place results in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VSHUFI64x2"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F3A.W1 43 /r ib"
    instruction_group_index: 351
  }
  instructions {
    description: "Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers in xmm1 and xmm2/m128 and writes the results in xmm1. Starting offsets within xmm1 and xmm2/m128 are determined by imm8."
    vendor_syntax {
      mnemonic: "MPSADBW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMI"
    raw_encoding_specification: "66 0F 3A 42 /r ib"
    instruction_group_index: 352
  }
  instructions {
    description: "Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers in xmm2 and xmm3/m128 and writes the results in xmm1. Starting offsets within xmm2 and xmm3/m128 are determined by imm8."
    vendor_syntax {
      mnemonic: "VMPSADBW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVMI"
    raw_encoding_specification: "VEX.128.66.0F3A.WIG 42 /r ib"
    instruction_group_index: 352
  }
  instructions {
    description: "Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers in xmm2 and ymm3/m128 and writes the results in ymm1. Starting offsets within ymm2 and xmm3/m128 are determined by imm8."
    vendor_syntax {
      mnemonic: "VMPSADBW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVMI"
    raw_encoding_specification: "VEX.256.66.0F3A.WIG 42 /r ib"
    instruction_group_index: 352
  }
  instructions {
    description: "Store contents of MXCSR register to m32."
    vendor_syntax {
      mnemonic: "STMXCSR"
      operands {
        name: "m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "NP 0F AE /3"
    instruction_group_index: 353
  }
  instructions {
    description: "Store contents of MXCSR register to m32."
    vendor_syntax {
      mnemonic: "VSTMXCSR"
      operands {
        name: "m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "VEX.LZ.0F.WIG AE /3"
    instruction_group_index: 353
  }
  instructions {
    description: "Set ZF and CF depending on sign bit AND and ANDN of 16 bits mask register sources."
    vendor_syntax {
      mnemonic: "KTESTW"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "k2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RR"
    raw_encoding_specification: "VEX.L0.0F.W0 99 /r"
    instruction_group_index: 354
  }
  instructions {
    description: "Set ZF and CF depending on sign bit AND and ANDN of 8 bits mask register sources."
    vendor_syntax {
      mnemonic: "KTESTB"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "k2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RR"
    raw_encoding_specification: "VEX.L0.66.0F.W0 99 /r"
    instruction_group_index: 354
  }
  instructions {
    description: "Set ZF and CF depending on sign bit AND and ANDN of 64 bits mask register sources."
    vendor_syntax {
      mnemonic: "KTESTQ"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "k2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RR"
    raw_encoding_specification: "VEX.L0.0F.W1 99 /r"
    instruction_group_index: 354
  }
  instructions {
    description: "Set ZF and CF depending on sign bit AND and ANDN of 32 bits mask register sources."
    vendor_syntax {
      mnemonic: "KTESTD"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "k2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RR"
    raw_encoding_specification: "VEX.L0.66.0F.W1 99 /r"
    instruction_group_index: 354
  }
  instructions {
    description: "Unsigned multiply (AX := AL \342\210\227 r/m8)."
    vendor_syntax {
      mnemonic: "MUL"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "F6 /4"
    instruction_group_index: 355
  }
  instructions {
    description: "Unsigned multiply (AX := AL \342\210\227 r/m8)."
    vendor_syntax {
      mnemonic: "MUL"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX + F6 /4"
    instruction_group_index: 355
  }
  instructions {
    description: "Unsigned multiply (DX:AX := AX \342\210\227 r/m16)."
    vendor_syntax {
      mnemonic: "MUL"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "F7 /4"
    instruction_group_index: 355
  }
  instructions {
    description: "Unsigned multiply (EDX:EAX := EAX \342\210\227 r/m32)."
    vendor_syntax {
      mnemonic: "MUL"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "F7 /4"
    instruction_group_index: 355
  }
  instructions {
    description: "Unsigned multiply (RDX:RAX := RAX \342\210\227 r/m64)."
    vendor_syntax {
      mnemonic: "MUL"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX.W + F7 /4"
    instruction_group_index: 355
  }
  instructions {
    description: "Convert one double-precision floating-point value from xmm1/m64 to one unsigned doubleword integer r32."
    vendor_syntax {
      mnemonic: "VCVTSD2USI"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.LIG.F2.0F.W0 79 /r"
    instruction_group_index: 356
  }
  instructions {
    description: "Convert one double-precision floating-point value from xmm1/m64 to one unsigned quadword integer zeroextended into r64."
    vendor_syntax {
      mnemonic: "VCVTSD2USI"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.LIG.F2.0F.W1 79 /r"
    instruction_group_index: 356
  }
  instructions {
    description: "Shift xmm1 left by imm8 bytes while shifting in 0s."
    vendor_syntax {
      mnemonic: "PSLLDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 73 /7 ib"
    instruction_group_index: 357
  }
  instructions {
    description: "Shift xmm2 left by imm8 bytes while shifting in 0s and store result in xmm1."
    vendor_syntax {
      mnemonic: "VPSLLDQ"
      operands {
        name: "xmm1"
        encoding: VEX_V_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG 73 /7 ib"
    instruction_group_index: 357
  }
  instructions {
    description: "Shift ymm2 left by imm8 bytes while shifting in 0s and store result in ymm1."
    vendor_syntax {
      mnemonic: "VPSLLDQ"
      operands {
        name: "ymm1"
        encoding: VEX_V_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG 73 /7 ib"
    instruction_group_index: 357
  }
  instructions {
    description: "Shift xmm2/m128 left by imm8 bytes while shifting in 0s and store result in xmm1."
    vendor_syntax {
      mnemonic: "VPSLLDQ"
      operands {
        name: "xmm1"
        encoding: VEX_V_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.WIG 73 /7 ib"
    instruction_group_index: 357
  }
  instructions {
    description: "Shift ymm2/m256 left by imm8 bytes while shifting in 0s and store result in ymm1."
    vendor_syntax {
      mnemonic: "VPSLLDQ"
      operands {
        name: "ymm1"
        encoding: VEX_V_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.WIG 73 /7 ib"
    instruction_group_index: 357
  }
  instructions {
    description: "Shift zmm2/m512 left by imm8 bytes while shifting in 0s and store result in zmm1."
    vendor_syntax {
      mnemonic: "VPSLLDQ"
      operands {
        name: "zmm1"
        encoding: VEX_V_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.WIG 73 /7 ib"
    instruction_group_index: 357
  }
  instructions {
    description: "Return the bitwise logical OR of packed single-precision floating-point values in xmm1 and xmm2/mem."
    vendor_syntax {
      mnemonic: "ORPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 56 /r"
    instruction_group_index: 358
  }
  instructions {
    description: "Return the bitwise logical OR of packed single-precision floating-point values in xmm2 and xmm3/mem."
    vendor_syntax {
      mnemonic: "VORPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.0F 56 /r"
    instruction_group_index: 358
  }
  instructions {
    description: "Return the bitwise logical OR of packed single-precision floating-point values in ymm2 and ymm3/mem."
    vendor_syntax {
      mnemonic: "VORPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.0F 56 /r"
    instruction_group_index: 358
  }
  instructions {
    description: "Return the bitwise logical OR of packed single-precision floating-point values in xmm2 and xmm3/m128/m32bcst subject to writemask k1."
    vendor_syntax {
      mnemonic: "VORPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.0F.W0 56 /r"
    instruction_group_index: 358
  }
  instructions {
    description: "Return the bitwise logical OR of packed single-precision floating-point values in ymm2 and ymm3/m256/m32bcst subject to writemask k1."
    vendor_syntax {
      mnemonic: "VORPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.0F.W0 56 /r"
    instruction_group_index: 358
  }
  instructions {
    description: "Return the bitwise logical OR of packed single-precision floating-point values in zmm2 and zmm3/m512/m32bcst subject to writemask k1."
    vendor_syntax {
      mnemonic: "VORPS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.0F.W0 56 /r"
    instruction_group_index: 358
  }
  instructions {
    description: "POPCNT on r/m16"
    vendor_syntax {
      mnemonic: "POPCNT"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "F3 0F B8 /r"
    instruction_group_index: 359
  }
  instructions {
    description: "POPCNT on r/m32"
    vendor_syntax {
      mnemonic: "POPCNT"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "F3 0F B8 /r"
    instruction_group_index: 359
  }
  instructions {
    description: "POPCNT on r/m64"
    vendor_syntax {
      mnemonic: "POPCNT"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "F3 REX.W 0F B8 /r"
    instruction_group_index: 359
  }
  instructions {
    description: "Save the x87 FPU, MMX, XMM, and MXCSR register state to m512byte."
    vendor_syntax {
      mnemonic: "FXSAVE"
      operands {
        name: "m512byte"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "NP 0F AE /0"
    instruction_group_index: 360
  }
  instructions {
    description: "Save the x87 FPU, MMX, XMM, and MXCSR register state to m512byte."
    vendor_syntax {
      mnemonic: "FXSAVE64"
      operands {
        name: "m512byte"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "NP REX.W + 0F AE /0"
    instruction_group_index: 360
  }
  instructions {
    description: "Move even index single-precision floating-point values from xmm2/mem and duplicate each element into xmm1."
    vendor_syntax {
      mnemonic: "MOVSLDUP"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F3 0F 12 /r"
    instruction_group_index: 361
  }
  instructions {
    description: "Move even index single-precision floating-point values from xmm2/mem and duplicate each element into xmm1."
    vendor_syntax {
      mnemonic: "VMOVSLDUP"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.F3.0F.WIG 12 /r"
    instruction_group_index: 361
  }
  instructions {
    description: "Move even index single-precision floating-point values from ymm2/mem and duplicate each element into ymm1."
    vendor_syntax {
      mnemonic: "VMOVSLDUP"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.F3.0F.WIG 12 /r"
    instruction_group_index: 361
  }
  instructions {
    description: "Move even index single-precision floating-point values from xmm2/m128 and duplicate each element into xmm1 under writemask."
    vendor_syntax {
      mnemonic: "VMOVSLDUP"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.F3.0F.W0 12 /r"
    instruction_group_index: 361
  }
  instructions {
    description: "Move even index single-precision floating-point values from ymm2/m256 and duplicate each element into ymm1 under writemask."
    vendor_syntax {
      mnemonic: "VMOVSLDUP"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.F3.0F.W0 12 /r"
    instruction_group_index: 361
  }
  instructions {
    description: "Move even index single-precision floating-point values from zmm2/m512 and duplicate each element into zmm1 under writemask."
    vendor_syntax {
      mnemonic: "VMOVSLDUP"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.F3.0F.W0 12 /r"
    instruction_group_index: 361
  }
  instructions {
    description: "Extract the word specified by imm8 from mm and move it to reg, bits 15-0. The upper bits of r32 or r64 is zeroed."
    vendor_syntax {
      mnemonic: "PEXTRW"
      operands {
        name: "reg"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "mm"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F C5 /r ib"
    instruction_group_index: 362
  }
  instructions {
    description: "Extract the word specified by imm8 from xmm and move it to reg, bits 15-0. The upper bits of r32 or r64 is zeroed."
    vendor_syntax {
      mnemonic: "PEXTRW"
      operands {
        name: "reg"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F C5 /r ib"
    instruction_group_index: 362
  }
  instructions {
    description: "Extract the word specified by imm8 from xmm and copy it to lowest 16 bits of reg or m16.\nZero-extend the result in the destination, r32 or r64."
    vendor_syntax {
      mnemonic: "PEXTRW"
      operands {
        name: "reg/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "66 0F 3A 15 /r ib"
    instruction_group_index: 362
  }
  instructions {
    description: "Extract the word specified by imm8 from xmm1 and move it to reg, bits 15:0. Zeroextend the result. The upper bits of r64/r32 is filled with zeros."
    vendor_syntax {
      mnemonic: "VPEXTRW"
      operands {
        name: "reg"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F.W0 C5 /r ib"
    instruction_group_index: 362
  }
  instructions {
    description: "Extract a word integer value from xmm2 at the source word offset specified by imm8 into reg or m16. The upper bits of r64/r32 is filled with zeros."
    vendor_syntax {
      mnemonic: "VPEXTRW"
      operands {
        name: "reg/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F3A.W0 15 /r ib"
    instruction_group_index: 362
  }
  instructions {
    description: "Extract the word specified by imm8 from xmm1 and move it to reg, bits 15:0. Zero-extend the result. The upper bits of r64/r32 is filled with zeros."
    vendor_syntax {
      mnemonic: "VPEXTRW"
      operands {
        name: "reg"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F.WIG C5 /r ib"
    instruction_group_index: 362
  }
  instructions {
    description: "Extract a word integer value from xmm2 at the source word offset specified by imm8 into reg or m16. The upper bits of r64/r32 is filled with zeros."
    vendor_syntax {
      mnemonic: "VPEXTRW"
      operands {
        name: "reg/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F3A.WIG 15 /r ib"
    instruction_group_index: 362
  }
  instructions {
    description: "Computes square root of the low double-precision floatingpoint value in xmm2/m64 and stores the results in xmm1."
    vendor_syntax {
      mnemonic: "SQRTSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F2 0F 51/r"
    instruction_group_index: 363
  }
  instructions {
    description: "Computes square root of the low double-precision floatingpoint value in xmm3/m64 and stores the results in xmm1.\nAlso, upper double-precision floating-point value (bits[127:64]) from xmm2 is copied to xmm1[127:64]."
    vendor_syntax {
      mnemonic: "VSQRTSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.LIG.F2.0F.WIG 51/r"
    instruction_group_index: 363
  }
  instructions {
    description: "Computes square root of the low double-precision floatingpoint value in xmm3/m64 and stores the results in xmm1 under writemask k1. Also, upper double-precision floatingpoint value (bits[127:64]) from xmm2 is copied to xmm1[127:64]."
    vendor_syntax {
      mnemonic: "VSQRTSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.LIG.F2.0F.W1 51/r"
    instruction_group_index: 363
  }
  instructions {
    description: "Subtract the low single-precision floating-point value in xmm2/m32 from xmm1 and store the result in xmm1."
    vendor_syntax {
      mnemonic: "SUBSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F3 0F 5C /r"
    instruction_group_index: 364
  }
  instructions {
    description: "Subtract the low single-precision floating-point value in xmm3/m32 from xmm2 and store the result in xmm1."
    vendor_syntax {
      mnemonic: "VSUBSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.LIG.F3.0F.WIG 5C /r"
    instruction_group_index: 364
  }
  instructions {
    description: "Subtract the low single-precision floating-point value in xmm3/m32 from xmm2 and store the result in xmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VSUBSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.LIG.F3.0F.W0 5C /r"
    instruction_group_index: 364
  }
  instructions {
    description: "Shift r/m16 to left imm8 places while shifting bits from r16 in from the right."
    vendor_syntax {
      mnemonic: "SHLD"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MRI"
    raw_encoding_specification: "0F A4 /r ib"
    instruction_group_index: 365
  }
  instructions {
    description: "Shift r/m16 to left CL places while shifting bits from r16 in from the right."
    vendor_syntax {
      mnemonic: "SHLD"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MRC"
    raw_encoding_specification: "0F A5 /r"
    instruction_group_index: 365
  }
  instructions {
    description: "Shift r/m32 to left imm8 places while shifting bits from r32 in from the right."
    vendor_syntax {
      mnemonic: "SHLD"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MRI"
    raw_encoding_specification: "0F A4 /r ib"
    instruction_group_index: 365
  }
  instructions {
    description: "Shift r/m64 to left imm8 places while shifting bits from r64 in from the right."
    vendor_syntax {
      mnemonic: "SHLD"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MRI"
    raw_encoding_specification: "REX.W + 0F A4 /r ib"
    instruction_group_index: 365
  }
  instructions {
    description: "Shift r/m32 to left CL places while shifting bits from r32 in from the right."
    vendor_syntax {
      mnemonic: "SHLD"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MRC"
    raw_encoding_specification: "0F A5 /r"
    instruction_group_index: 365
  }
  instructions {
    description: "Shift r/m64 to left CL places while shifting bits from r64 in from the right."
    vendor_syntax {
      mnemonic: "SHLD"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MRC"
    raw_encoding_specification: "REX.W + 0F A5 /r"
    instruction_group_index: 365
  }
  instructions {
    description: "Tests the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result."
    vendor_syntax {
      mnemonic: "VFPCLASSSS"
      operands {
        name: "k2"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.LIG.66.0F3A.W0 67 /r"
    instruction_group_index: 366
  }
  instructions {
    description: "Store selected bit in CF flag and clear."
    vendor_syntax {
      mnemonic: "BTR"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "0F B3 /r"
    instruction_group_index: 367
  }
  instructions {
    description: "Store selected bit in CF flag and clear."
    vendor_syntax {
      mnemonic: "BTR"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "0F B3 /r"
    instruction_group_index: 367
  }
  instructions {
    description: "Store selected bit in CF flag and clear."
    vendor_syntax {
      mnemonic: "BTR"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MR"
    raw_encoding_specification: "REX.W + 0F B3 /r"
    instruction_group_index: 367
  }
  instructions {
    description: "Store selected bit in CF flag and clear."
    vendor_syntax {
      mnemonic: "BTR"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "0F BA /6 ib"
    instruction_group_index: 367
  }
  instructions {
    description: "Store selected bit in CF flag and clear."
    vendor_syntax {
      mnemonic: "BTR"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "0F BA /6 ib"
    instruction_group_index: 367
  }
  instructions {
    description: "Store selected bit in CF flag and clear."
    vendor_syntax {
      mnemonic: "BTR"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX.W + 0F BA /6 ib"
    instruction_group_index: 367
  }
  instructions {
    description: "Compare signed word integers in mm2/m64 and mm1 and return minimum values."
    vendor_syntax {
      mnemonic: "PMINSW"
      operands {
        name: "mm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F EA /r"
    instruction_group_index: 368
  }
  instructions {
    description: "Compare packed signed byte integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1."
    vendor_syntax {
      mnemonic: "PMINSB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 38 38 /r"
    instruction_group_index: 368
  }
  instructions {
    description: "Compare packed signed word integers in xmm2/m128 and xmm1 and store packed minimum values in xmm1."
    vendor_syntax {
      mnemonic: "PMINSW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F EA /r"
    instruction_group_index: 368
  }
  instructions {
    description: "Compare packed signed byte integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1."
    vendor_syntax {
      mnemonic: "VPMINSB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F38 38 /r"
    instruction_group_index: 368
  }
  instructions {
    description: "Compare packed signed word integers in xmm3/m128 and xmm2 and return packed minimum values in xmm1."
    vendor_syntax {
      mnemonic: "VPMINSW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F EA /r"
    instruction_group_index: 368
  }
  instructions {
    description: "Compare packed signed byte integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1."
    vendor_syntax {
      mnemonic: "VPMINSB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F38 38 /r"
    instruction_group_index: 368
  }
  instructions {
    description: "Compare packed signed word integers in ymm3/m256 and ymm2 and return packed minimum values in ymm1."
    vendor_syntax {
      mnemonic: "VPMINSW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F EA /r"
    instruction_group_index: 368
  }
  instructions {
    description: "Compare packed signed byte integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMINSB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F38.WIG 38 /r"
    instruction_group_index: 368
  }
  instructions {
    description: "Compare packed signed byte integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMINSB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38.WIG 38 /r"
    instruction_group_index: 368
  }
  instructions {
    description: "Compare packed signed byte integers in zmm2 and zmm3/m512 and store packed minimum values in zmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMINSB"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38.WIG 38 /r"
    instruction_group_index: 368
  }
  instructions {
    description: "Compare packed signed word integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMINSW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.WIG EA /r"
    instruction_group_index: 368
  }
  instructions {
    description: "Compare packed signed word integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMINSW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.WIG EA /r"
    instruction_group_index: 368
  }
  instructions {
    description: "Compare packed signed word integers in zmm2 and zmm3/m512 and store packed minimum values in zmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMINSW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.WIG EA /r"
    instruction_group_index: 368
  }
  instructions {
    description: "Set all lower bits in r32 to \342\200\2341\342\200\235 starting from bit 0 to lowest set bit in r/m32."
    vendor_syntax {
      mnemonic: "BLSMSK"
      operands {
        name: "r32"
        encoding: VEX_V_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "BMI1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "VM"
    raw_encoding_specification: "VEX.LZ.0F38.W0 F3 /2"
    instruction_group_index: 369
  }
  instructions {
    description: "Set all lower bits in r64 to \342\200\2341\342\200\235 starting from bit 0 to lowest set bit in r/m64."
    vendor_syntax {
      mnemonic: "BLSMSK"
      operands {
        name: "r64"
        encoding: VEX_V_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "BMI1"
    available_in_64_bit: true
    encoding_scheme: "VM"
    raw_encoding_specification: "VEX.LZ.0F38.W1 F3 /2"
    instruction_group_index: 369
  }
  instructions {
    description: "Set ZF=1 if segment specified with r/m16 can be read."
    vendor_syntax {
      mnemonic: "VERR"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 00 /4"
    instruction_group_index: 370
  }
  instructions {
    description: "Set ZF=1 if segment specified with r/m16 can be written."
    vendor_syntax {
      mnemonic: "VERW"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 00 /5"
    instruction_group_index: 370
  }
  instructions {
    description: "Divide ST(0) by m32fp and store result in ST(0)."
    vendor_syntax {
      mnemonic: "FDIV"
      operands {
        name: "m32fp"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D8 /6"
    instruction_group_index: 371
  }
  instructions {
    description: "Divide ST(0) by m64fp and store result in ST(0)."
    vendor_syntax {
      mnemonic: "FDIV"
      operands {
        name: "m64fp"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DC /6"
    instruction_group_index: 371
  }
  instructions {
    description: "Divide ST(0) by ST(i) and store result in ST(0)."
    vendor_syntax {
      mnemonic: "FDIV"
      operands {
        name: "ST(0)"
      }
      operands {
        name: "ST(i)"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D8 F0+i"
    instruction_group_index: 371
  }
  instructions {
    description: "Divide ST(i) by ST(0) and store result in ST(i)."
    vendor_syntax {
      mnemonic: "FDIV"
      operands {
        name: "ST(i)"
      }
      operands {
        name: "ST(0)"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DC F8+i"
    instruction_group_index: 371
  }
  instructions {
    description: "Divide ST(i) by ST(0), store result in ST(i), and pop the register stack."
    vendor_syntax {
      mnemonic: "FDIVP"
      operands {
        name: "ST(i)"
      }
      operands {
        name: "ST(0)"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DE F8+i"
    instruction_group_index: 371
  }
  instructions {
    description: "Divide ST(1) by ST(0), store result in ST(1), and pop the register stack."
    vendor_syntax {
      mnemonic: "FDIVP"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DE F9"
    instruction_group_index: 371
  }
  instructions {
    description: "Divide ST(0) by m32int and store result in ST(0)."
    vendor_syntax {
      mnemonic: "FIDIV"
      operands {
        name: "m32int"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DA /6"
    instruction_group_index: 371
  }
  instructions {
    description: "Divide ST(0) by m16int and store result in ST(0)."
    vendor_syntax {
      mnemonic: "FIDIV"
      operands {
        name: "m16int"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DE /6"
    instruction_group_index: 371
  }
  instructions {
    description: "Move double-precision floating-point value from m64 to high quadword of xmm1."
    vendor_syntax {
      mnemonic: "MOVHPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 16 /r"
    instruction_group_index: 372
  }
  instructions {
    description: "Merge double-precision floating-point value from m64 and the low quadword of xmm1."
    vendor_syntax {
      mnemonic: "VMOVHPD"
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG 16 /r"
    instruction_group_index: 372
  }
  instructions {
    description: "Merge double-precision floating-point value from m64 and the low quadword of xmm1."
    vendor_syntax {
      mnemonic: "VMOVHPD"
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.128.66.0F.W1 16 /r"
    instruction_group_index: 372
  }
  instructions {
    description: "Move double-precision floating-point value from high quadword of xmm1 to m64."
    vendor_syntax {
      mnemonic: "MOVHPD"
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "66 0F 17 /r"
    instruction_group_index: 372
  }
  instructions {
    description: "Move double-precision floating-point value from high quadword of xmm1 to m64."
    vendor_syntax {
      mnemonic: "VMOVHPD"
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "VEX.128.66.0F.WIG 17 /r"
    instruction_group_index: 372
  }
  instructions {
    description: "Move double-precision floating-point value from high quadword of xmm1 to m64."
    vendor_syntax {
      mnemonic: "VMOVHPD"
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "E"
    raw_encoding_specification: "EVEX.128.66.0F.W1 17 /r"
    instruction_group_index: 372
  }
  instructions {
    description: "Move byte to word with zero-extension."
    vendor_syntax {
      mnemonic: "MOVZX"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F B6 /r"
    instruction_group_index: 373
  }
  instructions {
    description: "Move byte to doubleword, zero-extension."
    vendor_syntax {
      mnemonic: "MOVZX"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F B6 /r"
    instruction_group_index: 373
  }
  instructions {
    description: "Move byte to quadword, zero-extension."
    vendor_syntax {
      mnemonic: "MOVZX"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 0F B6 /r"
    instruction_group_index: 373
  }
  instructions {
    description: "Move word to doubleword, zero-extension."
    vendor_syntax {
      mnemonic: "MOVZX"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F B7 /r"
    instruction_group_index: 373
  }
  instructions {
    description: "Move word to quadword, zero-extension."
    vendor_syntax {
      mnemonic: "MOVZX"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 0F B7 /r"
    instruction_group_index: 373
  }
  instructions {
    description: "Store selected bit in CF flag and complement."
    vendor_syntax {
      mnemonic: "BTC"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "0F BB /r"
    instruction_group_index: 374
  }
  instructions {
    description: "Store selected bit in CF flag and complement."
    vendor_syntax {
      mnemonic: "BTC"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "0F BB /r"
    instruction_group_index: 374
  }
  instructions {
    description: "Store selected bit in CF flag and complement."
    vendor_syntax {
      mnemonic: "BTC"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MR"
    raw_encoding_specification: "REX.W + 0F BB /r"
    instruction_group_index: 374
  }
  instructions {
    description: "Store selected bit in CF flag and complement."
    vendor_syntax {
      mnemonic: "BTC"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "0F BA /7 ib"
    instruction_group_index: 374
  }
  instructions {
    description: "Store selected bit in CF flag and complement."
    vendor_syntax {
      mnemonic: "BTC"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "0F BA /7 ib"
    instruction_group_index: 374
  }
  instructions {
    description: "Store selected bit in CF flag and complement."
    vendor_syntax {
      mnemonic: "BTC"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX.W + 0F BA /7 ib"
    instruction_group_index: 374
  }
  instructions {
    description: "Shuffle two pairs of double-precision floating-point values from xmm1 and xmm2/m128 using imm8 to select from each pair, interleaved result is stored in xmm1."
    vendor_syntax {
      mnemonic: "SHUFPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F C6 /r ib"
    instruction_group_index: 375
  }
  instructions {
    description: "Shuffle two pairs of double-precision floating-point values from xmm2 and xmm3/m128 using imm8 to select from each pair, interleaved result is stored in xmm1."
    vendor_syntax {
      mnemonic: "VSHUFPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG C6 /r ib"
    instruction_group_index: 375
  }
  instructions {
    description: "Shuffle four pairs of double-precision floating-point values from ymm2 and ymm3/m256 using imm8 to select from each pair, interleaved result is stored in xmm1."
    vendor_syntax {
      mnemonic: "VSHUFPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG C6 /r ib"
    instruction_group_index: 375
  }
  instructions {
    description: "Shuffle two paris of double-precision floating-point values from xmm2 and xmm3/m128/m64bcst using imm8 to select from each pair. store interleaved results in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VSHUFPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.W1 C6 /r ib"
    instruction_group_index: 375
  }
  instructions {
    description: "Shuffle four paris of double-precision floating-point values from ymm2 and ymm3/m256/m64bcst using imm8 to select from each pair. store interleaved results in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VSHUFPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.W1 C6 /r ib"
    instruction_group_index: 375
  }
  instructions {
    description: "Shuffle eight paris of double-precision floating-point values from zmm2 and zmm3/m512/m64bcst using imm8 to select from each pair. store interleaved results in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VSHUFPD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.W1 C6 /r ib"
    instruction_group_index: 375
  }
  instructions {
    description: "Compare packed bytes in mm/m64 and mm for equality."
    vendor_syntax {
      mnemonic: "PCMPEQB"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 74 /r"
    instruction_group_index: 376
  }
  instructions {
    description: "Compare packed bytes in xmm2/m128 and xmm1 for equality."
    vendor_syntax {
      mnemonic: "PCMPEQB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 74 /r"
    instruction_group_index: 376
  }
  instructions {
    description: "Compare packed words in mm/m64 and mm for equality."
    vendor_syntax {
      mnemonic: "PCMPEQW"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 75 /r"
    instruction_group_index: 376
  }
  instructions {
    description: "Compare packed words in xmm2/m128 and xmm1 for equality."
    vendor_syntax {
      mnemonic: "PCMPEQW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 75 /r"
    instruction_group_index: 376
  }
  instructions {
    description: "Compare packed doublewords in mm/m64 and mm for equality."
    vendor_syntax {
      mnemonic: "PCMPEQD"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 76 /r"
    instruction_group_index: 376
  }
  instructions {
    description: "Compare packed doublewords in xmm2/m128 and xmm1 for equality."
    vendor_syntax {
      mnemonic: "PCMPEQD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 76 /r"
    instruction_group_index: 376
  }
  instructions {
    description: "Compare packed bytes in xmm3/m128 and xmm2 for equality."
    vendor_syntax {
      mnemonic: "VPCMPEQB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG 74 /r"
    instruction_group_index: 376
  }
  instructions {
    description: "Compare packed words in xmm3/m128 and xmm2 for equality."
    vendor_syntax {
      mnemonic: "VPCMPEQW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG 75 /r"
    instruction_group_index: 376
  }
  instructions {
    description: "Compare packed doublewords in xmm3/m128 and xmm2 for equality."
    vendor_syntax {
      mnemonic: "VPCMPEQD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG 76 /r"
    instruction_group_index: 376
  }
  instructions {
    description: "Compare packed bytes in ymm3/m256 and ymm2 for equality."
    vendor_syntax {
      mnemonic: "VPCMPEQB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG 74 /r"
    instruction_group_index: 376
  }
  instructions {
    description: "Compare packed words in ymm3/m256 and ymm2 for equality."
    vendor_syntax {
      mnemonic: "VPCMPEQW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG 75 /r"
    instruction_group_index: 376
  }
  instructions {
    description: "Compare packed doublewords in ymm3/m256 and ymm2 for equality."
    vendor_syntax {
      mnemonic: "VPCMPEQD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG 76 /r"
    instruction_group_index: 376
  }
  instructions {
    description: "Compare Equal between int32 vector xmm2 and int32 vector xmm3/m128/m32bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
    vendor_syntax {
      mnemonic: "VPCMPEQD"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.W0 76 /r"
    instruction_group_index: 376
  }
  instructions {
    description: "Compare Equal between int32 vector ymm2 and int32 vector ymm3/m256/m32bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
    vendor_syntax {
      mnemonic: "VPCMPEQD"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.W0 76 /r"
    instruction_group_index: 376
  }
  instructions {
    description: "Compare Equal between int32 vectors in zmm2 and zmm3/m512/m32bcst, and set destination k1 according to the comparison results under writemask k2."
    vendor_syntax {
      mnemonic: "VPCMPEQD"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.W0 76 /r"
    instruction_group_index: 376
  }
  instructions {
    description: "Compare packed bytes in xmm3/m128 and xmm2 for equality and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
    vendor_syntax {
      mnemonic: "VPCMPEQB"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.128.66.0F.WIG 74 /r"
    instruction_group_index: 376
  }
  instructions {
    description: "Compare packed bytes in ymm3/m256 and ymm2 for equality and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
    vendor_syntax {
      mnemonic: "VPCMPEQB"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.256.66.0F.WIG 74 /r"
    instruction_group_index: 376
  }
  instructions {
    description: "Compare packed bytes in zmm3/m512 and zmm2 for equality and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
    vendor_syntax {
      mnemonic: "VPCMPEQB"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.66.0F.WIG 74 /r"
    instruction_group_index: 376
  }
  instructions {
    description: "Compare packed words in xmm3/m128 and xmm2 for equality and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
    vendor_syntax {
      mnemonic: "VPCMPEQW"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.128.66.0F.WIG 75 /r"
    instruction_group_index: 376
  }
  instructions {
    description: "Compare packed words in ymm3/m256 and ymm2 for equality and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
    vendor_syntax {
      mnemonic: "VPCMPEQW"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.256.66.0F.WIG 75 /r"
    instruction_group_index: 376
  }
  instructions {
    description: "Compare packed words in zmm3/m512 and zmm2 for equality and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
    vendor_syntax {
      mnemonic: "VPCMPEQW"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.66.0F.WIG 75 /r"
    instruction_group_index: 376
  }
  instructions {
    description: "Convert two packed single precision floating-point values from xmm2/m64/m32bcst to two packed unsigned quadword values in xmm1 using truncation subject to writemask k1."
    vendor_syntax {
      mnemonic: "VCVTTPS2UQQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F.W0 78 /r"
    instruction_group_index: 377
  }
  instructions {
    description: "Convert four packed single precision floating-point values from xmm2/m128/m32bcst to four packed unsigned quadword values in ymm1 using truncation subject to writemask k1."
    vendor_syntax {
      mnemonic: "VCVTTPS2UQQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F.W0 78 /r"
    instruction_group_index: 377
  }
  instructions {
    description: "Convert eight packed single precision floating-point values from ymm2/m256/m32bcst to eight packed unsigned quadword values in zmm1 using truncation subject to writemask k1."
    vendor_syntax {
      mnemonic: "VCVTTPS2UQQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F.W0 78 /r"
    instruction_group_index: 377
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from xmm1 and xmm3/mem, add to xmm2 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMADD132PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W1 98 /r"
    instruction_group_index: 378
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from xmm1 and xmm2, add to xmm3/mem and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMADD213PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W1 A8 /r"
    instruction_group_index: 378
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from xmm2 and xmm3/mem, add to xmm1 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMADD231PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W1 B8 /r"
    instruction_group_index: 378
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from ymm1 and ymm3/mem, add to ymm2 and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFMADD132PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W1 98 /r"
    instruction_group_index: 378
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from ymm1 and ymm2, add to ymm3/mem and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFMADD213PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W1 A8 /r"
    instruction_group_index: 378
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from ymm2 and ymm3/mem, add to ymm1 and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFMADD231PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W1 B8 /r"
    instruction_group_index: 378
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from xmm1 and xmm3/m128/m64bcst, add to xmm2 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMADD132PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 98 /r"
    instruction_group_index: 378
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from xmm1 and xmm2, add to xmm3/m128/m64bcst and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMADD213PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 A8 /r"
    instruction_group_index: 378
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from xmm2 and xmm3/m128/m64bcst, add to xmm1 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMADD231PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 B8 /r"
    instruction_group_index: 378
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from ymm1 and ymm3/m256/m64bcst, add to ymm2 and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFMADD132PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 98 /r"
    instruction_group_index: 378
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from ymm1 and ymm2, add to ymm3/m256/m64bcst and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFMADD213PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 A8 /r"
    instruction_group_index: 378
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from ymm2 and ymm3/m256/m64bcst, add to ymm1 and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFMADD231PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 B8 /r"
    instruction_group_index: 378
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from zmm1 and zmm3/m512/m64bcst, add to zmm2 and put result in zmm1."
    vendor_syntax {
      mnemonic: "VFMADD132PD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 98 /r"
    instruction_group_index: 378
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from zmm1 and zmm2, add to zmm3/m512/m64bcst and put result in zmm1."
    vendor_syntax {
      mnemonic: "VFMADD213PD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 A8 /r"
    instruction_group_index: 378
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from zmm2 and zmm3/m512/m64bcst, add to zmm1 and put result in zmm1."
    vendor_syntax {
      mnemonic: "VFMADD231PD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 B8 /r"
    instruction_group_index: 378
  }
  instructions {
    description: "Input (E)CX bytes from port DX into ES:[(E)DI]."
    vendor_syntax {
      mnemonic: "REP INS"
      operands {
        name: "m8"
      }
      operands {
        name: "DX"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F3 6C"
    instruction_group_index: 379
  }
  instructions {
    description: "Input RCX bytes from port DX into [RDI]."
    vendor_syntax {
      mnemonic: "REP INS"
      operands {
        name: "m8"
      }
      operands {
        name: "DX"
      }
    }
    available_in_64_bit: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F3 6C"
    instruction_group_index: 379
  }
  instructions {
    description: "Input (E)CX words from port DX into ES:[(E)DI.]"
    vendor_syntax {
      mnemonic: "REP INS"
      operands {
        name: "m16"
      }
      operands {
        name: "DX"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F3 6D"
    instruction_group_index: 379
  }
  instructions {
    description: "Input (E)CX doublewords from port DX into ES:[(E)DI]."
    vendor_syntax {
      mnemonic: "REP INS"
      operands {
        name: "m32"
      }
      operands {
        name: "DX"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F3 6D"
    instruction_group_index: 379
  }
  instructions {
    description: "Input RCX default size from port DX into [RDI]."
    vendor_syntax {
      mnemonic: "REP INS"
      operands {
        name: "r/m32"
      }
      operands {
        name: "DX"
      }
    }
    available_in_64_bit: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F3 6D"
    instruction_group_index: 379
  }
  instructions {
    description: "Move (E)CX bytes from DS:[(E)SI] to ES:[(E)DI]."
    vendor_syntax {
      mnemonic: "REP MOVS"
      operands {
        name: "m8"
      }
      operands {
        name: "m8"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F3 A4"
    instruction_group_index: 379
  }
  instructions {
    description: "Move RCX bytes from [RSI] to [RDI]."
    vendor_syntax {
      mnemonic: "REP MOVS"
      operands {
        name: "m8"
      }
      operands {
        name: "m8"
      }
    }
    available_in_64_bit: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F3 REX.W A4"
    instruction_group_index: 379
  }
  instructions {
    description: "Move (E)CX words from DS:[(E)SI] to ES:[(E)DI]."
    vendor_syntax {
      mnemonic: "REP MOVS"
      operands {
        name: "m16"
      }
      operands {
        name: "m16"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F3 A5"
    instruction_group_index: 379
  }
  instructions {
    description: "Move (E)CX doublewords from DS:[(E)SI] to ES:[(E)DI]."
    vendor_syntax {
      mnemonic: "REP MOVS"
      operands {
        name: "m32"
      }
      operands {
        name: "m32"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F3 A5"
    instruction_group_index: 379
  }
  instructions {
    description: "Move RCX quadwords from [RSI] to [RDI]."
    vendor_syntax {
      mnemonic: "REP MOVS"
      operands {
        name: "m64"
      }
      operands {
        name: "m64"
      }
    }
    available_in_64_bit: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F3 REX.W A5"
    instruction_group_index: 379
  }
  instructions {
    description: "Output (E)CX bytes from DS:[(E)SI] to port DX."
    vendor_syntax {
      mnemonic: "REP OUTS"
      operands {
        name: "DX"
      }
      operands {
        name: "r/m8"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F3 6E"
    instruction_group_index: 379
  }
  instructions {
    description: "Output RCX bytes from [RSI] to port DX."
    vendor_syntax {
      mnemonic: "REP OUTS"
      operands {
        name: "DX"
      }
      operands {
        name: "r/m8"
      }
    }
    available_in_64_bit: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F3 REX.W 6E"
    instruction_group_index: 379
  }
  instructions {
    description: "Output (E)CX words from DS:[(E)SI] to port DX."
    vendor_syntax {
      mnemonic: "REP OUTS"
      operands {
        name: "DX"
      }
      operands {
        name: "r/m16"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F3 6F"
    instruction_group_index: 379
  }
  instructions {
    description: "Output (E)CX doublewords from DS:[(E)SI] to port DX."
    vendor_syntax {
      mnemonic: "REP OUTS"
      operands {
        name: "DX"
      }
      operands {
        name: "r/m32"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F3 6F"
    instruction_group_index: 379
  }
  instructions {
    description: "Output RCX default size from [RSI] to port DX."
    vendor_syntax {
      mnemonic: "REP OUTS"
      operands {
        name: "DX"
      }
      operands {
        name: "r/m32"
      }
    }
    available_in_64_bit: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F3 REX.W 6F"
    instruction_group_index: 379
  }
  instructions {
    description: "Load (E)CX bytes from DS:[(E)SI] to AL."
    vendor_syntax {
      mnemonic: "REP LODS"
      operands {
        name: "AL"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F3 AC"
    instruction_group_index: 379
  }
  instructions {
    description: "Load RCX bytes from [RSI] to AL."
    vendor_syntax {
      mnemonic: "REP LODS"
      operands {
        name: "AL"
      }
    }
    available_in_64_bit: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F3 REX.W AC"
    instruction_group_index: 379
  }
  instructions {
    description: "Load (E)CX words from DS:[(E)SI] to AX."
    vendor_syntax {
      mnemonic: "REP LODS"
      operands {
        name: "AX"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F3 AD"
    instruction_group_index: 379
  }
  instructions {
    description: "Load (E)CX doublewords from DS:[(E)SI] to EAX."
    vendor_syntax {
      mnemonic: "REP LODS"
      operands {
        name: "EAX"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F3 AD"
    instruction_group_index: 379
  }
  instructions {
    description: "Load RCX quadwords from [RSI] to RAX."
    vendor_syntax {
      mnemonic: "REP LODS"
      operands {
        name: "RAX"
      }
    }
    available_in_64_bit: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F3 REX.W AD"
    instruction_group_index: 379
  }
  instructions {
    description: "Fill (E)CX bytes at ES:[(E)DI] with AL."
    vendor_syntax {
      mnemonic: "REP STOS"
      operands {
        name: "m8"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F3 AA"
    instruction_group_index: 379
  }
  instructions {
    description: "Fill RCX bytes at [RDI] with AL."
    vendor_syntax {
      mnemonic: "REP STOS"
      operands {
        name: "m8"
      }
    }
    available_in_64_bit: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F3 REX.W AA"
    instruction_group_index: 379
  }
  instructions {
    description: "Fill (E)CX words at ES:[(E)DI] with AX."
    vendor_syntax {
      mnemonic: "REP STOS"
      operands {
        name: "m16"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F3 AB"
    instruction_group_index: 379
  }
  instructions {
    description: "Fill (E)CX doublewords at ES:[(E)DI] with EAX."
    vendor_syntax {
      mnemonic: "REP STOS"
      operands {
        name: "m32"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F3 AB"
    instruction_group_index: 379
  }
  instructions {
    description: "Fill RCX quadwords at [RDI] with RAX."
    vendor_syntax {
      mnemonic: "REP STOS"
      operands {
        name: "m64"
      }
    }
    available_in_64_bit: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F3 REX.W AB"
    instruction_group_index: 379
  }
  instructions {
    description: "Find nonmatching bytes in ES:[(E)DI] and DS:[(E)SI]."
    vendor_syntax {
      mnemonic: "REPE CMPS"
      operands {
        name: "m8"
      }
      operands {
        name: "m8"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F3 A6"
    instruction_group_index: 379
  }
  instructions {
    description: "Find non-matching bytes in [RDI] and [RSI]."
    vendor_syntax {
      mnemonic: "REPE CMPS"
      operands {
        name: "m8"
      }
      operands {
        name: "m8"
      }
    }
    available_in_64_bit: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F3 REX.W A6"
    instruction_group_index: 379
  }
  instructions {
    description: "Find nonmatching words in ES:[(E)DI] and DS:[(E)SI]."
    vendor_syntax {
      mnemonic: "REPE CMPS"
      operands {
        name: "m16"
      }
      operands {
        name: "m16"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F3 A7"
    instruction_group_index: 379
  }
  instructions {
    description: "Find nonmatching doublewords in ES:[(E)DI] and DS:[(E)SI]."
    vendor_syntax {
      mnemonic: "REPE CMPS"
      operands {
        name: "m32"
      }
      operands {
        name: "m32"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F3 A7"
    instruction_group_index: 379
  }
  instructions {
    description: "Find non-matching quadwords in [RDI] and [RSI]."
    vendor_syntax {
      mnemonic: "REPE CMPS"
      operands {
        name: "m64"
      }
      operands {
        name: "m64"
      }
    }
    available_in_64_bit: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F3 REX.W A7"
    instruction_group_index: 379
  }
  instructions {
    description: "Find non-AL byte starting at ES:[(E)DI]."
    vendor_syntax {
      mnemonic: "REPE SCAS"
      operands {
        name: "m8"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F3 AE"
    instruction_group_index: 379
  }
  instructions {
    description: "Find non-AL byte starting at [RDI]."
    vendor_syntax {
      mnemonic: "REPE SCAS"
      operands {
        name: "m8"
      }
    }
    available_in_64_bit: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F3 REX.W AE"
    instruction_group_index: 379
  }
  instructions {
    description: "Find non-AX word starting at ES:[(E)DI]."
    vendor_syntax {
      mnemonic: "REPE SCAS"
      operands {
        name: "m16"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F3 AF"
    instruction_group_index: 379
  }
  instructions {
    description: "Find non-EAX doubleword starting at ES:[(E)DI]."
    vendor_syntax {
      mnemonic: "REPE SCAS"
      operands {
        name: "m32"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F3 AF"
    instruction_group_index: 379
  }
  instructions {
    description: "Find non-RAX quadword starting at [RDI]."
    vendor_syntax {
      mnemonic: "REPE SCAS"
      operands {
        name: "m64"
      }
    }
    available_in_64_bit: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F3 REX.W AF"
    instruction_group_index: 379
  }
  instructions {
    description: "Find matching bytes in ES:[(E)DI] and DS:[(E)SI]."
    vendor_syntax {
      mnemonic: "REPNE CMPS"
      operands {
        name: "m8"
      }
      operands {
        name: "m8"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F2 A6"
    instruction_group_index: 379
  }
  instructions {
    description: "Find matching bytes in [RDI] and [RSI]."
    vendor_syntax {
      mnemonic: "REPNE CMPS"
      operands {
        name: "m8"
      }
      operands {
        name: "m8"
      }
    }
    available_in_64_bit: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F2 REX.W A6"
    instruction_group_index: 379
  }
  instructions {
    description: "Find matching words in ES:[(E)DI] and DS:[(E)SI]."
    vendor_syntax {
      mnemonic: "REPNE CMPS"
      operands {
        name: "m16"
      }
      operands {
        name: "m16"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F2 A7"
    instruction_group_index: 379
  }
  instructions {
    description: "Find matching doublewords in ES:[(E)DI] and DS:[(E)SI]."
    vendor_syntax {
      mnemonic: "REPNE CMPS"
      operands {
        name: "m32"
      }
      operands {
        name: "m32"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F2 A7"
    instruction_group_index: 379
  }
  instructions {
    description: "Find matching doublewords in [RDI] and [RSI]."
    vendor_syntax {
      mnemonic: "REPNE CMPS"
      operands {
        name: "m64"
      }
      operands {
        name: "m64"
      }
    }
    available_in_64_bit: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F2 REX.W A7"
    instruction_group_index: 379
  }
  instructions {
    description: "Find AL, starting at ES:[(E)DI]."
    vendor_syntax {
      mnemonic: "REPNE SCAS"
      operands {
        name: "m8"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F2 AE"
    instruction_group_index: 379
  }
  instructions {
    description: "Find AL, starting at [RDI]."
    vendor_syntax {
      mnemonic: "REPNE SCAS"
      operands {
        name: "m8"
      }
    }
    available_in_64_bit: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F2 REX.W AE"
    instruction_group_index: 379
  }
  instructions {
    description: "Find AX, starting at ES:[(E)DI]."
    vendor_syntax {
      mnemonic: "REPNE SCAS"
      operands {
        name: "m16"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F2 AF"
    instruction_group_index: 379
  }
  instructions {
    description: "Find EAX, starting at ES:[(E)DI]."
    vendor_syntax {
      mnemonic: "REPNE SCAS"
      operands {
        name: "m32"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F2 AF"
    instruction_group_index: 379
  }
  instructions {
    description: "Find RAX, starting at [RDI]."
    vendor_syntax {
      mnemonic: "REPNE SCAS"
      operands {
        name: "m64"
      }
    }
    available_in_64_bit: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F2 REX.W AF"
    instruction_group_index: 379
  }
  instructions {
    description: "Using signed qword indices, gather single-precision floating-point values from memory using k1 as completion mask."
    vendor_syntax {
      mnemonic: "VGATHERQPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "vm64x"
        encoding: VSIB_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 93 /vsib"
    instruction_group_index: 380
  }
  instructions {
    description: "Using signed qword indices, gather single-precision floating-point values from memory using k1 as completion mask."
    vendor_syntax {
      mnemonic: "VGATHERQPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "vm64y"
        encoding: VSIB_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 93 /vsib"
    instruction_group_index: 380
  }
  instructions {
    description: "Using signed qword indices, gather single-precision floating-point values from memory using k1 as completion mask."
    vendor_syntax {
      mnemonic: "VGATHERQPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "vm64z"
        encoding: VSIB_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 93 /vsib"
    instruction_group_index: 380
  }
  instructions {
    description: "Using signed qword indices, gather float64 vector into float64 vector xmm1 using k1 as completion mask."
    vendor_syntax {
      mnemonic: "VGATHERQPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "vm64x"
        encoding: VSIB_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 93 /vsib"
    instruction_group_index: 380
  }
  instructions {
    description: "Using signed qword indices, gather float64 vector into float64 vector ymm1 using k1 as completion mask."
    vendor_syntax {
      mnemonic: "VGATHERQPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "vm64y"
        encoding: VSIB_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 93 /vsib"
    instruction_group_index: 380
  }
  instructions {
    description: "Using signed qword indices, gather float64 vector into float64 vector zmm1 using k1 as completion mask."
    vendor_syntax {
      mnemonic: "VGATHERQPD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "vm64z"
        encoding: VSIB_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 93 /vsib"
    instruction_group_index: 380
  }
  instructions {
    description: "Subtract 16-bit signed integers horizontally, pack to mm1."
    vendor_syntax {
      mnemonic: "PHSUBW"
      operands {
        name: "mm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "NP 0F 38 05 /r"
    instruction_group_index: 381
  }
  instructions {
    description: "Subtract 16-bit signed integers horizontally, pack to xmm1."
    vendor_syntax {
      mnemonic: "PHSUBW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "66 0F 38 05 /r"
    instruction_group_index: 381
  }
  instructions {
    description: "Subtract 32-bit signed integers horizontally, pack to mm1."
    vendor_syntax {
      mnemonic: "PHSUBD"
      operands {
        name: "mm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "NP 0F 38 06 /r"
    instruction_group_index: 381
  }
  instructions {
    description: "Subtract 32-bit signed integers horizontally, pack to xmm1."
    vendor_syntax {
      mnemonic: "PHSUBD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "66 0F 38 06 /r"
    instruction_group_index: 381
  }
  instructions {
    description: "Subtract 16-bit signed integers horizontally, pack to xmm1."
    vendor_syntax {
      mnemonic: "VPHSUBW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.128.66.0F38.WIG 05 /r"
    instruction_group_index: 381
  }
  instructions {
    description: "Subtract 32-bit signed integers horizontally, pack to xmm1."
    vendor_syntax {
      mnemonic: "VPHSUBD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.128.66.0F38.WIG 06 /r"
    instruction_group_index: 381
  }
  instructions {
    description: "Subtract 16-bit signed integers horizontally, pack to ymm1."
    vendor_syntax {
      mnemonic: "VPHSUBW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.256.66.0F38.WIG 05 /r"
    instruction_group_index: 381
  }
  instructions {
    description: "Subtract 32-bit signed integers horizontally, pack to ymm1."
    vendor_syntax {
      mnemonic: "VPHSUBD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.256.66.0F38.WIG 06 /r"
    instruction_group_index: 381
  }
  instructions {
    description: "Save state components specified by EDX:EAX to mem with compaction, optimizing if possible."
    vendor_syntax {
      mnemonic: "XSAVES"
      operands {
        name: "mem"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    feature_name: "XSS"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "NP 0F C7 /5"
    instruction_group_index: 382
  }
  instructions {
    description: "Save state components specified by EDX:EAX to mem with compaction, optimizing if possible."
    vendor_syntax {
      mnemonic: "XSAVES64"
      operands {
        name: "mem"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    feature_name: "XSS"
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "NP REX.W + 0F C7 /5"
    instruction_group_index: 382
  }
  instructions {
    description: "Compare ST(0) with ST(i)."
    vendor_syntax {
      mnemonic: "FUCOM"
      operands {
        name: "ST(i)"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DD E0+i"
    instruction_group_index: 383
  }
  instructions {
    description: "Compare ST(0) with ST(1)."
    vendor_syntax {
      mnemonic: "FUCOM"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DD E1"
    instruction_group_index: 383
  }
  instructions {
    description: "Compare ST(0) with ST(i) and pop register stack."
    vendor_syntax {
      mnemonic: "FUCOMP"
      operands {
        name: "ST(i)"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DD E8+i"
    instruction_group_index: 383
  }
  instructions {
    description: "Compare ST(0) with ST(1) and pop register stack."
    vendor_syntax {
      mnemonic: "FUCOMP"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DD E9"
    instruction_group_index: 383
  }
  instructions {
    description: "Compare ST(0) with ST(1) and pop register stack twice."
    vendor_syntax {
      mnemonic: "FUCOMPP"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DA E9"
    instruction_group_index: 383
  }
  instructions {
    description: "Horizontal add packed single-precision floating-point values from xmm2/m128 to xmm1."
    vendor_syntax {
      mnemonic: "HADDPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "F2 0F 7C /r"
    instruction_group_index: 384
  }
  instructions {
    description: "Horizontal add packed single-precision floating-point values from xmm2 and xmm3/mem."
    vendor_syntax {
      mnemonic: "VHADDPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.128.F2.0F.WIG 7C /r"
    instruction_group_index: 384
  }
  instructions {
    description: "Horizontal add packed single-precision floating-point values from ymm2 and ymm3/mem."
    vendor_syntax {
      mnemonic: "VHADDPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.256.F2.0F.WIG 7C /r"
    instruction_group_index: 384
  }
  instructions {
    description: "Move doubleword from r32 to m32 using direct store."
    vendor_syntax {
      mnemonic: "MOVDIRI"
      operands {
        name: "m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MOVDIRI"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 38 F9 /r"
    instruction_group_index: 385
  }
  instructions {
    description: "Move quadword from r64 to m64 using direct store."
    vendor_syntax {
      mnemonic: "MOVDIRI"
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MOVDIRI"
    available_in_64_bit: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP REX.W + 0F 38 F9 /r"
    instruction_group_index: 385
  }
  instructions {
    description: "Set ZF and CF depending on sign bit AND and ANDN of packed single-precision floating-point sources."
    vendor_syntax {
      mnemonic: "VTESTPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "VEX.128.66.0F38.W0 0E /r"
    instruction_group_index: 386
  }
  instructions {
    description: "Set ZF and CF depending on sign bit AND and ANDN of packed single-precision floating-point sources."
    vendor_syntax {
      mnemonic: "VTESTPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "VEX.256.66.0F38.W0 0E /r"
    instruction_group_index: 386
  }
  instructions {
    description: "Set ZF and CF depending on sign bit AND and ANDN of packed double-precision floating-point sources."
    vendor_syntax {
      mnemonic: "VTESTPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "VEX.128.66.0F38.W0 0F /r"
    instruction_group_index: 386
  }
  instructions {
    description: "Set ZF and CF depending on sign bit AND and ANDN of packed double-precision floating-point sources."
    vendor_syntax {
      mnemonic: "VTESTPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "VEX.256.66.0F38.W0 0F /r"
    instruction_group_index: 386
  }
  instructions {
    description: "Writes a specified VMCS field (in 64-bit mode)."
    vendor_syntax {
      mnemonic: "VMWRITE"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "VMX"
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "NP 0F 79"
    instruction_group_index: 387
  }
  instructions {
    description: "Writes a specified VMCS field (outside 64-bit mode)."
    vendor_syntax {
      mnemonic: "VMWRITE"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "VMX"
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "NP 0F 79"
    instruction_group_index: 387
  }
  instructions {
    description: "This instruction is used to execute privileged SGX leaf functions that are reserved for VMM use. They are used for managing the enclaves."
    vendor_syntax {
      mnemonic: "ENCLV"
    }
    feature_name: "<UNKNOWN>"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "NP 0F 01 C0"
    instruction_group_index: 388
    leaf_instructions {
      description: "This leaf function decrements the SECS VIRTCHILDCNT field."
      llvm_mnemonic: "EDECVIRTCHILD"
      vendor_syntax {
        mnemonic: "EDECVIRTCHILD"
        operands {
          name: "EAX"
          description: "EDECVIRTCHILD (In); Return error code (Out)"
          value: "\000"
          encoding: X86_REGISTER_EAX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RBX"
          description: "Address of an enclave page (In)"
          encoding: X86_REGISTER_RBX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RCX"
          description: "Address of an SECS page (In)"
          encoding: X86_REGISTER_RCX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
      }
      feature_name: "<UNKNOWN>"
      available_in_64_bit: true
      legacy_instruction: true
      encoding_scheme: "IR"
      instruction_group_index: 0
    }
    leaf_instructions {
      description: "This leaf function increments the SECS VIRTCHILDCNT field."
      llvm_mnemonic: "EINCVIRTCHILD"
      vendor_syntax {
        mnemonic: "EINCVIRTCHILD"
        operands {
          name: "EAX"
          description: "EINCVIRTCHILD (In); Return error code (Out)"
          value: "\001"
          encoding: X86_REGISTER_EAX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RBX"
          description: "Address of an enclave page (In)"
          encoding: X86_REGISTER_RBX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RCX"
          description: "Address of an SECS page (In)"
          encoding: X86_REGISTER_RCX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
      }
      feature_name: "<UNKNOWN>"
      available_in_64_bit: true
      legacy_instruction: true
      encoding_scheme: "IR"
      instruction_group_index: 0
    }
    leaf_instructions {
      description: "This leaf function sets the ENCLAVECONTEXT field in SECS."
      llvm_mnemonic: "ESETCONTEXT"
      vendor_syntax {
        mnemonic: "ESETCONTEXT"
        operands {
          name: "EAX"
          description: "ESETCONTEXT (In); Return error code (Out)"
          value: "\002"
          encoding: X86_REGISTER_EAX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RCX"
          description: "Address of the destination EPC page \n(In, EA)"
          encoding: X86_REGISTER_RCX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RDX"
          description: "Context Value (In, EA)"
          encoding: X86_REGISTER_RDX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
      }
      feature_name: "<UNKNOWN>"
      available_in_64_bit: true
      legacy_instruction: true
      encoding_scheme: "IR"
      instruction_group_index: 0
    }
  }
  instructions {
    description: "Perform the InvMixColumn transformation on a 128-bit round key from xmm2/m128 and store the result in xmm1."
    vendor_syntax {
      mnemonic: "AESIMC"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AES"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "66 0F 38 DB /r"
    instruction_group_index: 389
  }
  instructions {
    description: "Perform the InvMixColumn transformation on a 128-bit round key from xmm2/m128 and store the result in xmm1."
    vendor_syntax {
      mnemonic: "VAESIMC"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AES && AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "VEX.128.66.0F38.WIG DB /r"
    instruction_group_index: 389
  }
  instructions {
    description: "Convert two packed double-precision floating-point values from xmm2/m128/m64bcst to two packed quadword integers in xmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTPD2QQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F.W1 7B /r"
    instruction_group_index: 390
  }
  instructions {
    description: "Convert four packed double-precision floating-point values from ymm2/m256/m64bcst to four packed quadword integers in ymm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTPD2QQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F.W1 7B /r"
    instruction_group_index: 390
  }
  instructions {
    description: "Convert eight packed double-precision floating-point values from zmm2/m512/m64bcst to eight packed quadword integers in zmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTPD2QQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F.W1 7B /r"
    instruction_group_index: 390
  }
  instructions {
    description: "Make lower and upper bounds from m32 and store them in bnd."
    vendor_syntax {
      mnemonic: "BNDMK"
      operands {
        name: "bnd"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MPX"
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "F3 0F 1B /r"
    instruction_group_index: 391
  }
  instructions {
    description: "Make lower and upper bounds from m64 and store them in bnd."
    vendor_syntax {
      mnemonic: "BNDMK"
      operands {
        name: "bnd"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MPX"
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "F3 0F 1B /r"
    instruction_group_index: 391
  }
  instructions {
    description: "Return to compatibility mode from fast system call"
    vendor_syntax {
      mnemonic: "SYSRET"
    }
    available_in_64_bit: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "0F 07"
    instruction_group_index: 392
  }
  instructions {
    description: "Return to 64-bit mode from fast system call"
    vendor_syntax {
      mnemonic: "SYSRET"
    }
    available_in_64_bit: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "REX.W + 0F 07"
    instruction_group_index: 392
  }
  instructions {
    description: "Compress packed doubleword integer values from xmm2 to xmm1/m128 using controlmask k1."
    vendor_syntax {
      mnemonic: "VPCOMPRESSD"
      operands {
        name: "xmm1/m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 8B /r"
    instruction_group_index: 393
  }
  instructions {
    description: "Compress packed doubleword integer values from ymm2 to ymm1/m256 using controlmask k1."
    vendor_syntax {
      mnemonic: "VPCOMPRESSD"
      operands {
        name: "ymm1/m256"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 8B /r"
    instruction_group_index: 393
  }
  instructions {
    description: "Compress packed doubleword integer values from zmm2 to zmm1/m512 using controlmask k1."
    vendor_syntax {
      mnemonic: "VPCOMPRESSD"
      operands {
        name: "zmm1/m512"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 8B /r"
    instruction_group_index: 393
  }
  instructions {
    description: "Divide packed double-precision floating-point values in xmm1 by packed double-precision floating-point values in xmm2/mem."
    vendor_syntax {
      mnemonic: "DIVPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 5E /r"
    instruction_group_index: 394
  }
  instructions {
    description: "Divide packed double-precision floating-point values in xmm2 by packed double-precision floating-point values in xmm3/mem."
    vendor_syntax {
      mnemonic: "VDIVPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG 5E /r"
    instruction_group_index: 394
  }
  instructions {
    description: "Divide packed double-precision floating-point values in ymm2 by packed double-precision floating-point values in ymm3/mem."
    vendor_syntax {
      mnemonic: "VDIVPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG 5E /r"
    instruction_group_index: 394
  }
  instructions {
    description: "Divide packed double-precision floating-point values in xmm2 by packed double-precision floating-point values in xmm3/m128/m64bcst and write results to xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VDIVPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.W1 5E /r"
    instruction_group_index: 394
  }
  instructions {
    description: "Divide packed double-precision floating-point values in ymm2 by packed double-precision floating-point values in ymm3/m256/m64bcst and write results to ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VDIVPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.W1 5E /r"
    instruction_group_index: 394
  }
  instructions {
    description: "Divide packed double-precision floating-point values in zmm2 by packed double-precision FP values in zmm3/m512/m64bcst and write results to zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VDIVPD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.W1 5E /r"
    instruction_group_index: 394
  }
  instructions {
    description: "Find the minimum unsigned word in xmm2/m128 and place its value in the low word of xmm1 and its index in the secondlowest word of xmm1."
    vendor_syntax {
      mnemonic: "PHMINPOSUW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "66 0F 38 41 /r"
    instruction_group_index: 395
  }
  instructions {
    description: "Find the minimum unsigned word in xmm2/m128 and place its value in the low word of xmm1 and its index in the secondlowest word of xmm1."
    vendor_syntax {
      mnemonic: "VPHMINPOSUW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "VEX.128.66.0F38.WIG 41 /r"
    instruction_group_index: 395
  }
  instructions {
    description: "Terminate indirect branch in 64 bit mode."
    vendor_syntax {
      mnemonic: "ENDBR64"
    }
    feature_name: "CET_IBT"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F3 0F 1E FA"
    instruction_group_index: 396
  }
  instructions {
    description: "Zero bits in r/m32 starting with the position in r32b, write result to r32a."
    vendor_syntax {
      mnemonic: "BZHI"
      operands {
        name: "r32a"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r32b"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "BMI2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMV"
    raw_encoding_specification: "VEX.LZ.0F38.W0 F5 /r"
    instruction_group_index: 397
  }
  instructions {
    description: "Zero bits in r/m64 starting with the position in r64b, write result to r64a."
    vendor_syntax {
      mnemonic: "BZHI"
      operands {
        name: "r64a"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r64b"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "BMI2"
    available_in_64_bit: true
    encoding_scheme: "RMV"
    raw_encoding_specification: "VEX.LZ.0F38.W1 F5 /r"
    instruction_group_index: 397
  }
  instructions {
    description: "Load r/m16 into task register."
    vendor_syntax {
      mnemonic: "LTR"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 00 /3"
    instruction_group_index: 398
  }
  instructions {
    description: "Shift doublewords in xmm2 left by amount specified in the corresponding element of xmm3/m128 while shifting in 0s."
    vendor_syntax {
      mnemonic: "VPSLLVD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W0 47 /r"
    instruction_group_index: 399
  }
  instructions {
    description: "Shift quadwords in xmm2 left by amount specified in the corresponding element of xmm3/m128 while shifting in 0s."
    vendor_syntax {
      mnemonic: "VPSLLVQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W1 47 /r"
    instruction_group_index: 399
  }
  instructions {
    description: "Shift doublewords in ymm2 left by amount specified in the corresponding element of ymm3/m256 while shifting in 0s."
    vendor_syntax {
      mnemonic: "VPSLLVD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W0 47 /r"
    instruction_group_index: 399
  }
  instructions {
    description: "Shift quadwords in ymm2 left by amount specified in the corresponding element of ymm3/m256 while shifting in 0s."
    vendor_syntax {
      mnemonic: "VPSLLVQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W1 47 /r"
    instruction_group_index: 399
  }
  instructions {
    description: "Shift words in xmm2 left by amount specified in the corresponding element of xmm3/m128 while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSLLVW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 12 /r"
    instruction_group_index: 399
  }
  instructions {
    description: "Shift words in ymm2 left by amount specified in the corresponding element of ymm3/m256 while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSLLVW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 12 /r"
    instruction_group_index: 399
  }
  instructions {
    description: "Shift words in zmm2 left by amount specified in the corresponding element of zmm3/m512 while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSLLVW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 12 /r"
    instruction_group_index: 399
  }
  instructions {
    description: "Shift doublewords in xmm2 left by amount specified in the corresponding element of xmm3/m128/m32bcst while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSLLVD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 47 /r"
    instruction_group_index: 399
  }
  instructions {
    description: "Shift doublewords in ymm2 left by amount specified in the corresponding element of ymm3/m256/m32bcst while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSLLVD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 47 /r"
    instruction_group_index: 399
  }
  instructions {
    description: "Shift doublewords in zmm2 left by amount specified in the corresponding element of zmm3/m512/m32bcst while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSLLVD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 47 /r"
    instruction_group_index: 399
  }
  instructions {
    description: "Shift quadwords in xmm2 left by amount specified in the corresponding element of xmm3/m128/m64bcst while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSLLVQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 47 /r"
    instruction_group_index: 399
  }
  instructions {
    description: "Shift quadwords in ymm2 left by amount specified in the corresponding element of ymm3/m256/m64bcst while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSLLVQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 47 /r"
    instruction_group_index: 399
  }
  instructions {
    description: "Shift quadwords in zmm2 left by amount specified in the corresponding element of zmm3/m512/m64bcst while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSLLVQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 47 /r"
    instruction_group_index: 399
  }
  instructions {
    description: "For legacy mode, Load byte at address DS:(E)SI into AL. For 64-bit mode load byte at address (R)SI into AL."
    vendor_syntax {
      mnemonic: "LODS"
      operands {
        name: "m8"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "AC"
    instruction_group_index: 400
  }
  instructions {
    description: "For legacy mode, Load word at address DS:(E)SI into AX. For 64-bit mode load word at address (R)SI into AX."
    vendor_syntax {
      mnemonic: "LODS"
      operands {
        name: "m16"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "AD"
    instruction_group_index: 400
  }
  instructions {
    description: "For legacy mode, Load dword at address DS:(E)SI into EAX. For 64-bit mode load dword at address (R)SI into EAX."
    vendor_syntax {
      mnemonic: "LODS"
      operands {
        name: "m32"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "AD"
    instruction_group_index: 400
  }
  instructions {
    description: "Load qword at address (R)SI into RAX."
    vendor_syntax {
      mnemonic: "LODS"
      operands {
        name: "m64"
      }
    }
    available_in_64_bit: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "REX.W + AD"
    instruction_group_index: 400
  }
  instructions {
    description: "For legacy mode, Load byte at address DS:(E)SI into AL. For 64-bit mode load byte at address (R)SI into AL."
    vendor_syntax {
      mnemonic: "LODSB"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "AC"
    instruction_group_index: 400
  }
  instructions {
    description: "For legacy mode, Load word at address DS:(E)SI into AX. For 64-bit mode load word at address (R)SI into AX."
    vendor_syntax {
      mnemonic: "LODSW"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "AD"
    instruction_group_index: 400
  }
  instructions {
    description: "For legacy mode, Load dword at address DS:(E)SI into EAX. For 64-bit mode load dword at address (R)SI into EAX."
    vendor_syntax {
      mnemonic: "LODSD"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "AD"
    instruction_group_index: 400
  }
  instructions {
    description: "Load qword at address (R)SI into RAX."
    vendor_syntax {
      mnemonic: "LODSQ"
    }
    available_in_64_bit: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "REX.W + AD"
    instruction_group_index: 400
  }
  instructions {
    description: "Load the bounds stored in a bound table entry (BTE) into bnd with address translation using the base of mib and conditional on the index of mib matching the pointer value in the BTE."
    vendor_syntax {
      mnemonic: "BNDLDX"
      operands {
        name: "bnd"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "mib"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MPX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "NP 0F 1A /r"
    instruction_group_index: 401
  }
  instructions {
    description: "Extract lowest set bit from r/m32 and set that bit in r32."
    vendor_syntax {
      mnemonic: "BLSI"
      operands {
        name: "r32"
        encoding: VEX_V_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "BMI1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "VM"
    raw_encoding_specification: "VEX.LZ.0F38.W0 F3 /3"
    instruction_group_index: 402
  }
  instructions {
    description: "Extract lowest set bit from r/m64, and set that bit in r64."
    vendor_syntax {
      mnemonic: "BLSI"
      operands {
        name: "r64"
        encoding: VEX_V_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "BMI1"
    available_in_64_bit: true
    encoding_scheme: "VM"
    raw_encoding_specification: "VEX.LZ.0F38.W1 F3 /3"
    instruction_group_index: 402
  }
  instructions {
    description: "Shift doublewords in xmm2 right by amount specified in the corresponding element of xmm3/m128 while shifting in 0s."
    vendor_syntax {
      mnemonic: "VPSRLVD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W0 45 /r"
    instruction_group_index: 403
  }
  instructions {
    description: "Shift quadwords in xmm2 right by amount specified in the corresponding element of xmm3/m128 while shifting in 0s."
    vendor_syntax {
      mnemonic: "VPSRLVQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W1 45 /r"
    instruction_group_index: 403
  }
  instructions {
    description: "Shift doublewords in ymm2 right by amount specified in the corresponding element of ymm3/m256 while shifting in 0s."
    vendor_syntax {
      mnemonic: "VPSRLVD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W0 45 /r"
    instruction_group_index: 403
  }
  instructions {
    description: "Shift quadwords in ymm2 right by amount specified in the corresponding element of ymm3/m256 while shifting in 0s."
    vendor_syntax {
      mnemonic: "VPSRLVQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W1 45 /r"
    instruction_group_index: 403
  }
  instructions {
    description: "Shift words in xmm2 right by amount specified in the corresponding element of xmm3/m128 while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRLVW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 10 /r"
    instruction_group_index: 403
  }
  instructions {
    description: "Shift words in ymm2 right by amount specified in the corresponding element of ymm3/m256 while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRLVW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 10 /r"
    instruction_group_index: 403
  }
  instructions {
    description: "Shift words in zmm2 right by amount specified in the corresponding element of zmm3/m512 while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRLVW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 10 /r"
    instruction_group_index: 403
  }
  instructions {
    description: "Shift doublewords in xmm2 right by amount specified in the corresponding element of xmm3/m128/m32bcst while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRLVD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 45 /r"
    instruction_group_index: 403
  }
  instructions {
    description: "Shift doublewords in ymm2 right by amount specified in the corresponding element of ymm3/m256/m32bcst while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRLVD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 45 /r"
    instruction_group_index: 403
  }
  instructions {
    description: "Shift doublewords in zmm2 right by amount specified in the corresponding element of zmm3/m512/m32bcst while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRLVD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 45 /r"
    instruction_group_index: 403
  }
  instructions {
    description: "Shift quadwords in xmm2 right by amount specified in the corresponding element of xmm3/m128/m64bcst while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRLVQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 45 /r"
    instruction_group_index: 403
  }
  instructions {
    description: "Shift quadwords in ymm2 right by amount specified in the corresponding element of ymm3/m256/m64bcst while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRLVQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 45 /r"
    instruction_group_index: 403
  }
  instructions {
    description: "Shift quadwords in zmm2 right by amount specified in the corresponding element of zmm3/m512/m64bcst while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSRLVQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 45 /r"
    instruction_group_index: 403
  }
  instructions {
    description: "Convert four packed single-precision floating-point values from xmm2/mem to four packed signed doubleword values in xmm1."
    vendor_syntax {
      mnemonic: "CVTPS2DQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 5B /r"
    instruction_group_index: 404
  }
  instructions {
    description: "Convert four packed single-precision floating-point values from xmm2/mem to four packed signed doubleword values in xmm1."
    vendor_syntax {
      mnemonic: "VCVTPS2DQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F.WIG 5B /r"
    instruction_group_index: 404
  }
  instructions {
    description: "Convert eight packed single-precision floating-point values from ymm2/mem to eight packed signed doubleword values in ymm1."
    vendor_syntax {
      mnemonic: "VCVTPS2DQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F.WIG 5B /r"
    instruction_group_index: 404
  }
  instructions {
    description: "Convert four packed single precision floating-point values from xmm2/m128/m32bcst to four packed signed doubleword values in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VCVTPS2DQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F.W0 5B /r"
    instruction_group_index: 404
  }
  instructions {
    description: "Convert eight packed single precision floating-point values from ymm2/m256/m32bcst to eight packed signed doubleword values in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VCVTPS2DQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F.W0 5B /r"
    instruction_group_index: 404
  }
  instructions {
    description: "Convert sixteen packed single-precision floating-point values from zmm2/m512/m32bcst to sixteen packed signed doubleword values in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VCVTPS2DQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F.W0 5B /r"
    instruction_group_index: 404
  }
  instructions {
    description: "Compare packed single-precision floating-point values in xmm2/m128 and xmm1 using bits 2:0 of imm8 as a comparison predicate."
    vendor_syntax {
      mnemonic: "CMPPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F C2 /r ib"
    instruction_group_index: 405
  }
  instructions {
    description: "Compare packed single-precision floating-point values in xmm3/m128 and xmm2 using bits 4:0 of imm8 as a comparison predicate."
    vendor_syntax {
      mnemonic: "VCMPPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.0F.WIG C2 /r ib"
    instruction_group_index: 405
  }
  instructions {
    description: "Compare packed single-precision floating-point values in ymm3/m256 and ymm2 using bits 4:0 of imm8 as a comparison predicate."
    vendor_syntax {
      mnemonic: "VCMPPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.0F.WIG C2 /r ib"
    instruction_group_index: 405
  }
  instructions {
    description: "Compare packed single-precision floating-point values in xmm3/m128/m32bcst and xmm2 using bits 4:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
    vendor_syntax {
      mnemonic: "VCMPPS"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.0F.W0 C2 /r ib"
    instruction_group_index: 405
  }
  instructions {
    description: "Compare packed single-precision floating-point values in ymm3/m256/m32bcst and ymm2 using bits 4:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
    vendor_syntax {
      mnemonic: "VCMPPS"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.0F.W0 C2 /r ib"
    instruction_group_index: 405
  }
  instructions {
    description: "Compare packed single-precision floating-point values in zmm3/m512/m32bcst and zmm2 using bits 4:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
    vendor_syntax {
      mnemonic: "VCMPPS"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.0F.W0 C2 /r ib"
    instruction_group_index: 405
  }
  instructions {
    description: "Subtract with borrow imm8 from AL."
    vendor_syntax {
      mnemonic: "SBB"
      operands {
        name: "AL"
        encoding: IMPLICIT_ENCODING
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "I"
    raw_encoding_specification: "1C ib"
    instruction_group_index: 406
  }
  instructions {
    description: "Subtract with borrow imm16 from AX."
    vendor_syntax {
      mnemonic: "SBB"
      operands {
        name: "AX"
        encoding: IMPLICIT_ENCODING
      }
      operands {
        name: "imm16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "I"
    raw_encoding_specification: "1D iw"
    instruction_group_index: 406
  }
  instructions {
    description: "Subtract with borrow imm32 from EAX."
    vendor_syntax {
      mnemonic: "SBB"
      operands {
        name: "EAX"
        encoding: IMPLICIT_ENCODING
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "I"
    raw_encoding_specification: "1D id"
    instruction_group_index: 406
  }
  instructions {
    description: "Subtract with borrow sign-extended imm.32 to 64-bits from RAX."
    vendor_syntax {
      mnemonic: "SBB"
      operands {
        name: "RAX"
        encoding: IMPLICIT_ENCODING
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "I"
    raw_encoding_specification: "REX.W + 1D id"
    instruction_group_index: 406
  }
  instructions {
    description: "Subtract with borrow imm8 from r/m8."
    vendor_syntax {
      mnemonic: "SBB"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "80 /3 ib"
    instruction_group_index: 406
  }
  instructions {
    description: "Subtract with borrow imm8 from r/m8."
    vendor_syntax {
      mnemonic: "SBB"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX + 80 /3 ib"
    instruction_group_index: 406
  }
  instructions {
    description: "Subtract with borrow imm16 from r/m16."
    vendor_syntax {
      mnemonic: "SBB"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "imm16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "81 /3 iw"
    instruction_group_index: 406
  }
  instructions {
    description: "Subtract with borrow imm32 from r/m32."
    vendor_syntax {
      mnemonic: "SBB"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "81 /3 id"
    instruction_group_index: 406
  }
  instructions {
    description: "Subtract with borrow sign-extended imm32 to 64-bits from r/m64."
    vendor_syntax {
      mnemonic: "SBB"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX.W + 81 /3 id"
    instruction_group_index: 406
  }
  instructions {
    description: "Subtract with borrow sign-extended imm8 from r/m16."
    vendor_syntax {
      mnemonic: "SBB"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "83 /3 ib"
    instruction_group_index: 406
  }
  instructions {
    description: "Subtract with borrow sign-extended imm8 from r/m32."
    vendor_syntax {
      mnemonic: "SBB"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "83 /3 ib"
    instruction_group_index: 406
  }
  instructions {
    description: "Subtract with borrow sign-extended imm8 from r/m64."
    vendor_syntax {
      mnemonic: "SBB"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX.W + 83 /3 ib"
    instruction_group_index: 406
  }
  instructions {
    description: "Subtract with borrow r8 from r/m8."
    vendor_syntax {
      mnemonic: "SBB"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "18 /r"
    instruction_group_index: 406
  }
  instructions {
    description: "Subtract with borrow r8 from r/m8."
    vendor_syntax {
      mnemonic: "SBB"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MR"
    raw_encoding_specification: "REX + 18 /r"
    instruction_group_index: 406
  }
  instructions {
    description: "Subtract with borrow r16 from r/m16."
    vendor_syntax {
      mnemonic: "SBB"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "19 /r"
    instruction_group_index: 406
  }
  instructions {
    description: "Subtract with borrow r32 from r/m32."
    vendor_syntax {
      mnemonic: "SBB"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "19 /r"
    instruction_group_index: 406
  }
  instructions {
    description: "Subtract with borrow r64 from r/m64."
    vendor_syntax {
      mnemonic: "SBB"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MR"
    raw_encoding_specification: "REX.W + 19 /r"
    instruction_group_index: 406
  }
  instructions {
    description: "Subtract with borrow r/m8 from r8."
    vendor_syntax {
      mnemonic: "SBB"
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "1A /r"
    instruction_group_index: 406
  }
  instructions {
    description: "Subtract with borrow r/m8 from r8."
    vendor_syntax {
      mnemonic: "SBB"
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX + 1A /r"
    instruction_group_index: 406
  }
  instructions {
    description: "Subtract with borrow r/m16 from r16."
    vendor_syntax {
      mnemonic: "SBB"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "1B /r"
    instruction_group_index: 406
  }
  instructions {
    description: "Subtract with borrow r/m32 from r32."
    vendor_syntax {
      mnemonic: "SBB"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "1B /r"
    instruction_group_index: 406
  }
  instructions {
    description: "Subtract with borrow r/m64 from r64."
    vendor_syntax {
      mnemonic: "SBB"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 1B /r"
    instruction_group_index: 406
  }
  instructions {
    description: "Expands up to 128 bits of packed byte values from m128 to xmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VPEXPANDB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2 && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 62 /r"
    instruction_group_index: 407
  }
  instructions {
    description: "Expands up to 128 bits of packed byte values from xmm2 to xmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VPEXPANDB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2 && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 62 /r"
    instruction_group_index: 407
  }
  instructions {
    description: "Expands up to 256 bits of packed byte values from m256 to ymm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VPEXPANDB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2 && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 62 /r"
    instruction_group_index: 407
  }
  instructions {
    description: "Expands up to 256 bits of packed byte values from ymm2 to ymm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VPEXPANDB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2 && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 62 /r"
    instruction_group_index: 407
  }
  instructions {
    description: "Expands up to 512 bits of packed byte values from m512 to zmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VPEXPANDB"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 62 /r"
    instruction_group_index: 407
  }
  instructions {
    description: "Expands up to 512 bits of packed byte values from zmm2 to zmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VPEXPANDB"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 62 /r"
    instruction_group_index: 407
  }
  instructions {
    description: "Expands up to 128 bits of packed word values from m128 to xmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VPEXPANDW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2 && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 62 /r"
    instruction_group_index: 407
  }
  instructions {
    description: "Expands up to 128 bits of packed word values from xmm2 to xmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VPEXPANDW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2 && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 62 /r"
    instruction_group_index: 407
  }
  instructions {
    description: "Expands up to 256 bits of packed word values from m256 to ymm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VPEXPANDW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2 && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 62 /r"
    instruction_group_index: 407
  }
  instructions {
    description: "Expands up to 256 bits of packed word values from ymm2 to ymm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VPEXPANDW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2 && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 62 /r"
    instruction_group_index: 407
  }
  instructions {
    description: "Expands up to 512 bits of packed word values from m512 to zmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VPEXPANDW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 62 /r"
    instruction_group_index: 407
  }
  instructions {
    description: "Expands up to 512 bits of packed byte integer values from zmm2 to zmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VPEXPANDW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 62 /r"
    instruction_group_index: 407
  }
  instructions {
    description: "Load the FS base address with the 32-bit value in the source register."
    vendor_syntax {
      mnemonic: "WRFSBASE"
      operands {
        name: "r32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FSGSBASE"
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "F3 0F AE /2"
    instruction_group_index: 408
  }
  instructions {
    description: "Load the FS base address with the 64-bit value in the source register."
    vendor_syntax {
      mnemonic: "WRFSBASE"
      operands {
        name: "r64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FSGSBASE"
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "F3 REX.W 0F AE /2"
    instruction_group_index: 408
  }
  instructions {
    description: "Load the GS base address with the 32-bit value in the source register."
    vendor_syntax {
      mnemonic: "WRGSBASE"
      operands {
        name: "r32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FSGSBASE"
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "F3 0F AE /3"
    instruction_group_index: 408
  }
  instructions {
    description: "Load the GS base address with the 64-bit value in the source register."
    vendor_syntax {
      mnemonic: "WRGSBASE"
      operands {
        name: "r64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FSGSBASE"
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "F3 REX.W 0F AE /3"
    instruction_group_index: 408
  }
  instructions {
    description: "Invalidates entries in the TLBs and paging-structure caches based on VPID (in 64-bit mode)."
    vendor_syntax {
      mnemonic: "INVVPID"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "VMX"
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "66 0F 38 81"
    instruction_group_index: 409
  }
  instructions {
    description: "Invalidates entries in the TLBs and paging-structure caches based on VPID (outside 64-bit mode)."
    vendor_syntax {
      mnemonic: "INVVPID"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "VMX"
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "66 0F 38 81"
    instruction_group_index: 409
  }
  instructions {
    description: "Set byte if above (CF=0 and ZF=0)."
    vendor_syntax {
      mnemonic: "SETA"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 97"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if above (CF=0 and ZF=0)."
    vendor_syntax {
      mnemonic: "SETA"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX + 0F 97"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if above or equal (CF=0)."
    vendor_syntax {
      mnemonic: "SETAE"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 93"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if above or equal (CF=0)."
    vendor_syntax {
      mnemonic: "SETAE"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX + 0F 93"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if below (CF=1)."
    vendor_syntax {
      mnemonic: "SETB"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 92"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if below (CF=1)."
    vendor_syntax {
      mnemonic: "SETB"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX + 0F 92"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if below or equal (CF=1 or ZF=1)."
    vendor_syntax {
      mnemonic: "SETBE"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 96"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if below or equal (CF=1 or ZF=1)."
    vendor_syntax {
      mnemonic: "SETBE"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX + 0F 96"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if carry (CF=1)."
    vendor_syntax {
      mnemonic: "SETC"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 92"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if carry (CF=1)."
    vendor_syntax {
      mnemonic: "SETC"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX + 0F 92"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if equal (ZF=1)."
    vendor_syntax {
      mnemonic: "SETE"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 94"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if equal (ZF=1)."
    vendor_syntax {
      mnemonic: "SETE"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX + 0F 94"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if greater (ZF=0 and SF=OF)."
    vendor_syntax {
      mnemonic: "SETG"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 9F"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if greater (ZF=0 and SF=OF)."
    vendor_syntax {
      mnemonic: "SETG"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX + 0F 9F"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if greater or equal (SF=OF)."
    vendor_syntax {
      mnemonic: "SETGE"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 9D"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if greater or equal (SF=OF)."
    vendor_syntax {
      mnemonic: "SETGE"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX + 0F 9D"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if less (SF\342\211\240 OF)."
    vendor_syntax {
      mnemonic: "SETL"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 9C"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if less (SF\342\211\240 OF)."
    vendor_syntax {
      mnemonic: "SETL"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX + 0F 9C"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if less or equal (ZF=1 or SF\342\211\240 OF)."
    vendor_syntax {
      mnemonic: "SETLE"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 9E"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if less or equal (ZF=1 or SF\342\211\240 OF)."
    vendor_syntax {
      mnemonic: "SETLE"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX + 0F 9E"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if not above (CF=1 or ZF=1)."
    vendor_syntax {
      mnemonic: "SETNA"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 96"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if not above (CF=1 or ZF=1)."
    vendor_syntax {
      mnemonic: "SETNA"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX + 0F 96"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if not above or equal (CF=1)."
    vendor_syntax {
      mnemonic: "SETNAE"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 92"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if not above or equal (CF=1)."
    vendor_syntax {
      mnemonic: "SETNAE"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX + 0F 92"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if not below (CF=0)."
    vendor_syntax {
      mnemonic: "SETNB"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 93"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if not below (CF=0)."
    vendor_syntax {
      mnemonic: "SETNB"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX + 0F 93"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if not below or equal (CF=0 and ZF=0)."
    vendor_syntax {
      mnemonic: "SETNBE"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 97"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if not below or equal (CF=0 and ZF=0)."
    vendor_syntax {
      mnemonic: "SETNBE"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX + 0F 97"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if not carry (CF=0)."
    vendor_syntax {
      mnemonic: "SETNC"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 93"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if not carry (CF=0)."
    vendor_syntax {
      mnemonic: "SETNC"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX + 0F 93"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if not equal (ZF=0)."
    vendor_syntax {
      mnemonic: "SETNE"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 95"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if not equal (ZF=0)."
    vendor_syntax {
      mnemonic: "SETNE"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX + 0F 95"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if not greater (ZF=1 or SF\342\211\240 OF)"
    vendor_syntax {
      mnemonic: "SETNG"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 9E"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if not greater (ZF=1 or SF\342\211\240 OF)."
    vendor_syntax {
      mnemonic: "SETNG"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX + 0F 9E"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if not greater or equal (SF\342\211\240 OF)."
    vendor_syntax {
      mnemonic: "SETNGE"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 9C"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if not greater or equal (SF\342\211\240 OF)."
    vendor_syntax {
      mnemonic: "SETNGE"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX + 0F 9C"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if not less (SF=OF)."
    vendor_syntax {
      mnemonic: "SETNL"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 9D"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if not less (SF=OF)."
    vendor_syntax {
      mnemonic: "SETNL"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX + 0F 9D"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if not less or equal (ZF=0 and SF=OF)."
    vendor_syntax {
      mnemonic: "SETNLE"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 9F"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if not less or equal (ZF=0 and SF=OF)."
    vendor_syntax {
      mnemonic: "SETNLE"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX + 0F 9F"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if not overflow (OF=0)."
    vendor_syntax {
      mnemonic: "SETNO"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 91"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if not overflow (OF=0)."
    vendor_syntax {
      mnemonic: "SETNO"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX + 0F 91"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if not parity (PF=0)."
    vendor_syntax {
      mnemonic: "SETNP"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 9B"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if not parity (PF=0)."
    vendor_syntax {
      mnemonic: "SETNP"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX + 0F 9B"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if not sign (SF=0)."
    vendor_syntax {
      mnemonic: "SETNS"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 99"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if not sign (SF=0)."
    vendor_syntax {
      mnemonic: "SETNS"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX + 0F 99"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if not zero (ZF=0)."
    vendor_syntax {
      mnemonic: "SETNZ"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 95"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if not zero (ZF=0)."
    vendor_syntax {
      mnemonic: "SETNZ"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX + 0F 95"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if overflow (OF=1)"
    vendor_syntax {
      mnemonic: "SETO"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 90"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if overflow (OF=1)."
    vendor_syntax {
      mnemonic: "SETO"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX + 0F 90"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if parity (PF=1)."
    vendor_syntax {
      mnemonic: "SETP"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 9A"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if parity (PF=1)."
    vendor_syntax {
      mnemonic: "SETP"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX + 0F 9A"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if parity even (PF=1)."
    vendor_syntax {
      mnemonic: "SETPE"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 9A"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if parity even (PF=1)."
    vendor_syntax {
      mnemonic: "SETPE"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX + 0F 9A"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if parity odd (PF=0)."
    vendor_syntax {
      mnemonic: "SETPO"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 9B"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if parity odd (PF=0)."
    vendor_syntax {
      mnemonic: "SETPO"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX + 0F 9B"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if sign (SF=1)."
    vendor_syntax {
      mnemonic: "SETS"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 98"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if sign (SF=1)."
    vendor_syntax {
      mnemonic: "SETS"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX + 0F 98"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if zero (ZF=1)."
    vendor_syntax {
      mnemonic: "SETZ"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 94"
    instruction_group_index: 410
  }
  instructions {
    description: "Set byte if zero (ZF=1)."
    vendor_syntax {
      mnemonic: "SETZ"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX + 0F 94"
    instruction_group_index: 410
  }
  instructions {
    description: "A hint that allows the processor to stop instruction execution and enter an implementation-dependent optimized state until occurrence of a class of events."
    vendor_syntax {
      mnemonic: "MWAIT"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "0F 01 C9"
    instruction_group_index: 412
  }
  instructions {
    description: "Write 4 bytes to shadow stack."
    vendor_syntax {
      mnemonic: "WRUSSD"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "CET_SS"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "66 0F 38 F5"
    instruction_group_index: 413
  }
  instructions {
    description: "Write 8 bytes to shadow stack."
    vendor_syntax {
      mnemonic: "WRUSSQ"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "CET_SS"
    available_in_64_bit: true
    encoding_scheme: "MR"
    raw_encoding_specification: "66 REX.W 0F 38 F5"
    instruction_group_index: 413
  }
  instructions {
    description: "Shift xmm1 right by imm8 while shifting in 0s."
    vendor_syntax {
      mnemonic: "PSRLDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 73 /3 ib"
    instruction_group_index: 414
  }
  instructions {
    description: "Shift xmm2 right by imm8 bytes while shifting in 0s."
    vendor_syntax {
      mnemonic: "VPSRLDQ"
      operands {
        name: "xmm1"
        encoding: VEX_V_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG 73 /3 ib"
    instruction_group_index: 414
  }
  instructions {
    description: "Shift ymm1 right by imm8 bytes while shifting in 0s."
    vendor_syntax {
      mnemonic: "VPSRLDQ"
      operands {
        name: "ymm1"
        encoding: VEX_V_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG 73 /3 ib"
    instruction_group_index: 414
  }
  instructions {
    description: "Shift xmm2/m128 right by imm8 bytes while shifting in 0s and store result in xmm1."
    vendor_syntax {
      mnemonic: "VPSRLDQ"
      operands {
        name: "xmm1"
        encoding: VEX_V_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.WIG 73 /3 ib"
    instruction_group_index: 414
  }
  instructions {
    description: "Shift ymm2/m256 right by imm8 bytes while shifting in 0s and store result in ymm1."
    vendor_syntax {
      mnemonic: "VPSRLDQ"
      operands {
        name: "ymm1"
        encoding: VEX_V_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.WIG 73 /3 ib"
    instruction_group_index: 414
  }
  instructions {
    description: "Shift zmm2/m512 right by imm8 bytes while shifting in 0s and store result in zmm1."
    vendor_syntax {
      mnemonic: "VPSRLDQ"
      operands {
        name: "zmm1"
        encoding: VEX_V_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.WIG 73 /3 ib"
    instruction_group_index: 414
  }
  instructions {
    description: "Using dword indices specified in vm32x, gather dword values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."
    vendor_syntax {
      mnemonic: "VPGATHERDD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "vm32x"
        encoding: VSIB_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMV"
    raw_encoding_specification: "VEX.128.66.0F38.W0 90 /r"
    instruction_group_index: 415
  }
  instructions {
    description: "Using qword indices specified in vm64x, gather dword values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."
    vendor_syntax {
      mnemonic: "VPGATHERQD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "vm64x"
        encoding: VSIB_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMV"
    raw_encoding_specification: "VEX.128.66.0F38.W0 91 /r"
    instruction_group_index: 415
  }
  instructions {
    description: "Using dword indices specified in vm32y, gather dword from memory conditioned on mask specified by ymm2.\nConditionally gathered elements are merged into ymm1."
    vendor_syntax {
      mnemonic: "VPGATHERDD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "vm32y"
        encoding: VSIB_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMV"
    raw_encoding_specification: "VEX.256.66.0F38.W0 90 /r"
    instruction_group_index: 415
  }
  instructions {
    description: "Using qword indices specified in vm64y, gather dword values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."
    vendor_syntax {
      mnemonic: "VPGATHERQD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "vm64y"
        encoding: VSIB_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMV"
    raw_encoding_specification: "VEX.256.66.0F38.W0 91 /r"
    instruction_group_index: 415
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from xmm1 and xmm3/mem, subtract xmm2 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMSUB132PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W0 9A /r"
    instruction_group_index: 416
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from xmm1 and xmm2, subtract xmm3/mem and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMSUB213PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W0 AA /r"
    instruction_group_index: 416
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from xmm2 and xmm3/mem, subtract xmm1 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMSUB231PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W0 BA /r"
    instruction_group_index: 416
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from ymm1 and ymm3/mem, subtract ymm2 and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFMSUB132PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W0 9A /r"
    instruction_group_index: 416
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from ymm1 and ymm2, subtract ymm3/mem and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFMSUB213PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W0 AA /r"
    instruction_group_index: 416
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from ymm2 and ymm3/mem, subtract ymm1 and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFMSUB231PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.0 BA /r"
    instruction_group_index: 416
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from xmm1 and xmm3/m128/m32bcst, subtract xmm2 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMSUB132PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 9A /r"
    instruction_group_index: 416
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from xmm1 and xmm2, subtract xmm3/m128/m32bcst and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMSUB213PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 AA /r"
    instruction_group_index: 416
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from xmm2 and xmm3/m128/m32bcst, subtract xmm1 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMSUB231PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 BA /r"
    instruction_group_index: 416
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from ymm1 and ymm3/m256/m32bcst, subtract ymm2 and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFMSUB132PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 9A /r"
    instruction_group_index: 416
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from ymm1 and ymm2, subtract ymm3/m256/m32bcst and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFMSUB213PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 AA /r"
    instruction_group_index: 416
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from ymm2 and ymm3/m256/m32bcst, subtract ymm1 and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFMSUB231PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 BA /r"
    instruction_group_index: 416
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from zmm1 and zmm3/m512/m32bcst, subtract zmm2 and put result in zmm1."
    vendor_syntax {
      mnemonic: "VFMSUB132PS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 9A /r"
    instruction_group_index: 416
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from zmm1 and zmm2, subtract zmm3/m512/m32bcst and put result in zmm1."
    vendor_syntax {
      mnemonic: "VFMSUB213PS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 AA /r"
    instruction_group_index: 416
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from zmm2 and zmm3/m512/m32bcst, subtract zmm1 and put result in zmm1."
    vendor_syntax {
      mnemonic: "VFMSUB231PS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 BA /r"
    instruction_group_index: 416
  }
  instructions {
    description: "Move doubleword from r/m32 to mm."
    vendor_syntax {
      mnemonic: "MOVD"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 6E /r"
    instruction_group_index: 417
  }
  instructions {
    description: "Move quadword from r/m64 to mm."
    vendor_syntax {
      mnemonic: "MOVQ"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP REX.W + 0F 6E /r"
    instruction_group_index: 417
  }
  instructions {
    description: "Move doubleword from mm to r/m32."
    vendor_syntax {
      mnemonic: "MOVD"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "NP 0F 7E /r"
    instruction_group_index: 417
  }
  instructions {
    description: "Move quadword from mm to r/m64."
    vendor_syntax {
      mnemonic: "MOVQ"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    encoding_scheme: "B"
    raw_encoding_specification: "NP REX.W + 0F 7E /r"
    instruction_group_index: 417
  }
  instructions {
    description: "Move doubleword from r/m32 to xmm."
    vendor_syntax {
      mnemonic: "MOVD"
      operands {
        name: "xmm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 6E /r"
    instruction_group_index: 417
  }
  instructions {
    description: "Move quadword from r/m64 to xmm."
    vendor_syntax {
      mnemonic: "MOVQ"
      operands {
        name: "xmm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 REX.W 0F 6E /r"
    instruction_group_index: 417
  }
  instructions {
    description: "Move doubleword from xmm register to r/m32."
    vendor_syntax {
      mnemonic: "MOVD"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "66 0F 7E /r"
    instruction_group_index: 417
  }
  instructions {
    description: "Move quadword from xmm register to r/m64."
    vendor_syntax {
      mnemonic: "MOVQ"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    encoding_scheme: "B"
    raw_encoding_specification: "66 REX.W 0F 7E /r"
    instruction_group_index: 417
  }
  instructions {
    description: "Move doubleword from r/m32 to xmm1."
    vendor_syntax {
      mnemonic: "VMOVD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F.W0 6E /r"
    instruction_group_index: 417
  }
  instructions {
    description: "Move quadword from r/m64 to xmm1."
    vendor_syntax {
      mnemonic: "VMOVQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F.W1 6E /r"
    instruction_group_index: 417
  }
  instructions {
    description: "Move doubleword from xmm1 register to r/m32."
    vendor_syntax {
      mnemonic: "VMOVD"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.W0 7E /r"
    instruction_group_index: 417
  }
  instructions {
    description: "Move quadword from xmm1 register to r/m64."
    vendor_syntax {
      mnemonic: "VMOVQ"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.W1 7E /r"
    instruction_group_index: 417
  }
  instructions {
    description: "Move doubleword from r/m32 to xmm1."
    vendor_syntax {
      mnemonic: "VMOVD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.W0 6E /r"
    instruction_group_index: 417
  }
  instructions {
    description: "Move quadword from r/m64 to xmm1."
    vendor_syntax {
      mnemonic: "VMOVQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.W1 6E /r"
    instruction_group_index: 417
  }
  instructions {
    description: "Move doubleword from xmm1 register to r/m32."
    vendor_syntax {
      mnemonic: "VMOVD"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.128.66.0F.W0 7E /r"
    instruction_group_index: 417
  }
  instructions {
    description: "Move quadword from xmm1 register to r/m64."
    vendor_syntax {
      mnemonic: "VMOVQ"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.128.66.0F.W1 7E /r"
    instruction_group_index: 417
  }
  instructions {
    description: "Load FPU environment from m14byte or m28byte."
    vendor_syntax {
      mnemonic: "FLDENV"
      operands {
        name: "m14/28byte"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D9 /4"
    instruction_group_index: 418
  }
  instructions {
    description: "Tests the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result."
    vendor_syntax {
      mnemonic: "VFPCLASSSD"
      operands {
        name: "k2"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.LIG.66.0F3A.W1 67 /r ib"
    instruction_group_index: 419
  }
  instructions {
    description: "Compare unsigned byte integers in mm2/m64 and mm1 and returns minimum values."
    vendor_syntax {
      mnemonic: "PMINUB"
      operands {
        name: "mm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F DA /r"
    instruction_group_index: 420
  }
  instructions {
    description: "Compare packed unsigned byte integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1."
    vendor_syntax {
      mnemonic: "PMINUB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F DA /r"
    instruction_group_index: 420
  }
  instructions {
    description: "Compare packed unsigned word integers in xmm2/m128 and xmm1 and store packed minimum values in xmm1."
    vendor_syntax {
      mnemonic: "PMINUW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 38 3A/r"
    instruction_group_index: 420
  }
  instructions {
    description: "Compare packed unsigned byte integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1."
    vendor_syntax {
      mnemonic: "VPMINUB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F DA /r"
    instruction_group_index: 420
  }
  instructions {
    description: "Compare packed unsigned word integers in xmm3/m128 and xmm2 and return packed minimum values in xmm1."
    vendor_syntax {
      mnemonic: "VPMINUW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F38 3A/r"
    instruction_group_index: 420
  }
  instructions {
    description: "Compare packed unsigned byte integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1."
    vendor_syntax {
      mnemonic: "VPMINUB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F DA /r"
    instruction_group_index: 420
  }
  instructions {
    description: "Compare packed unsigned word integers in ymm3/m256 and ymm2 and return packed minimum values in ymm1."
    vendor_syntax {
      mnemonic: "VPMINUW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F38 3A/r"
    instruction_group_index: 420
  }
  instructions {
    description: "Compare packed unsigned byte integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMINUB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F DA /r"
    instruction_group_index: 420
  }
  instructions {
    description: "Compare packed unsigned byte integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMINUB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F DA /r"
    instruction_group_index: 420
  }
  instructions {
    description: "Compare packed unsigned byte integers in zmm2 and zmm3/m512 and store packed minimum values in zmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMINUB"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F DA /r"
    instruction_group_index: 420
  }
  instructions {
    description: "Compare packed unsigned word integers in xmm3/m128 and xmm2 and return packed minimum values in xmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMINUW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F38 3A/r"
    instruction_group_index: 420
  }
  instructions {
    description: "Compare packed unsigned word integers in ymm3/m256 and ymm2 and return packed minimum values in ymm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMINUW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38 3A/r"
    instruction_group_index: 420
  }
  instructions {
    description: "Compare packed unsigned word integers in zmm3/m512 and zmm2 and return packed minimum values in zmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMINUW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38 3A/r"
    instruction_group_index: 420
  }
  instructions {
    description: "DX:AX := sign-extend of AX."
    vendor_syntax {
      mnemonic: "CWD"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "99"
    instruction_group_index: 422
  }
  instructions {
    description: "EDX:EAX := sign-extend of EAX."
    vendor_syntax {
      mnemonic: "CDQ"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "99"
    instruction_group_index: 422
  }
  instructions {
    description: "RDX:RAX:= sign-extend of RAX."
    vendor_syntax {
      mnemonic: "CQO"
    }
    available_in_64_bit: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "REX.W + 99"
    instruction_group_index: 422
  }
  instructions {
    description: "Unpacks and Interleaves single-precision floating-point values from high quadwords of xmm1 and xmm2/m128."
    vendor_syntax {
      mnemonic: "UNPCKHPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 15 /r"
    instruction_group_index: 423
  }
  instructions {
    description: "Unpacks and Interleaves single-precision floating-point values from high quadwords of xmm2 and xmm3/m128."
    vendor_syntax {
      mnemonic: "VUNPCKHPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.0F.WIG 15 /r"
    instruction_group_index: 423
  }
  instructions {
    description: "Unpacks and Interleaves single-precision floating-point values from high quadwords of ymm2 and ymm3/m256."
    vendor_syntax {
      mnemonic: "VUNPCKHPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.0F.WIG 15 /r"
    instruction_group_index: 423
  }
  instructions {
    description: "Unpacks and Interleaves single-precision floating-point values from high quadwords of xmm2 and xmm3/m128/m32bcst and write result to xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VUNPCKHPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.0F.W0 15 /r"
    instruction_group_index: 423
  }
  instructions {
    description: "Unpacks and Interleaves single-precision floating-point values from high quadwords of ymm2 and ymm3/m256/m32bcst and write result to ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VUNPCKHPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.0F.W0 15 /r"
    instruction_group_index: 423
  }
  instructions {
    description: "Unpacks and Interleaves single-precision floating-point values from high quadwords of zmm2 and zmm3/m512/m32bcst and write result to zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VUNPCKHPS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.0F.W0 15 /r"
    instruction_group_index: 423
  }
  instructions {
    description: "Restore the x87 FPU, MMX, XMM, and MXCSR register state from m512byte."
    vendor_syntax {
      mnemonic: "FXRSTOR"
      operands {
        name: "m512byte"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "NP 0F AE /1"
    instruction_group_index: 424
  }
  instructions {
    description: "Restore the x87 FPU, MMX, XMM, and MXCSR register state from m512byte."
    vendor_syntax {
      mnemonic: "FXRSTOR64"
      operands {
        name: "m512byte"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "NP REX.W + 0F AE /1"
    instruction_group_index: 424
  }
  instructions {
    description: "Replace ST with its absolute value."
    vendor_syntax {
      mnemonic: "FABS"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D9 E1"
    instruction_group_index: 425
  }
  instructions {
    description: "Fix up a float64 number in the low quadword element of xmm2 using scalar int32 table in xmm3/m64 and store the result in xmm1."
    vendor_syntax {
      mnemonic: "VFIXUPIMMSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.LIG.66.0F3A.W1 55 /r ib"
    instruction_group_index: 426
  }
  instructions {
    description: "Convert four packed unsigned doubleword integers from xmm2/m128/m32bcst to packed single-precision floating-point values in xmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTUDQ2PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.F2.0F.W0 7A /r"
    instruction_group_index: 427
  }
  instructions {
    description: "Convert eight packed unsigned doubleword integers from ymm2/m256/m32bcst to packed single-precision floating-point values in zmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTUDQ2PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.F2.0F.W0 7A /r"
    instruction_group_index: 427
  }
  instructions {
    description: "Convert sixteen packed unsigned doubleword integers from zmm2/m512/m32bcst to sixteen packed singleprecision floating-point values in zmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTUDQ2PS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.F2.0F.W0 7A /r"
    instruction_group_index: 427
  }
  instructions {
    description: "Return the minimum scalar single-precision floatingpoint value between xmm2/m32 and xmm1."
    vendor_syntax {
      mnemonic: "MINSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F3 0F 5D /r"
    instruction_group_index: 428
  }
  instructions {
    description: "Return the minimum scalar single-precision floatingpoint value between xmm3/m32 and xmm2."
    vendor_syntax {
      mnemonic: "VMINSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.LIG.F3.0F.WIG 5D /r"
    instruction_group_index: 428
  }
  instructions {
    description: "Return the minimum scalar single-precision floatingpoint value between xmm3/m32 and xmm2."
    vendor_syntax {
      mnemonic: "VMINSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.LIG.F3.0F.W0 5D /r"
    instruction_group_index: 428
  }
  instructions {
    description: "Add packed signed byte integers from mm/m64 and mm and saturate the results."
    vendor_syntax {
      mnemonic: "PADDSB"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F EC /r"
    instruction_group_index: 430
  }
  instructions {
    description: "Add packed signed byte integers from xmm2/m128 and xmm1 saturate the results."
    vendor_syntax {
      mnemonic: "PADDSB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F EC /r"
    instruction_group_index: 430
  }
  instructions {
    description: "Add packed signed word integers from mm/m64 and mm and saturate the results."
    vendor_syntax {
      mnemonic: "PADDSW"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F ED /r"
    instruction_group_index: 430
  }
  instructions {
    description: "Add packed signed word integers from xmm2/m128 and xmm1 and saturate the results."
    vendor_syntax {
      mnemonic: "PADDSW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F ED /r"
    instruction_group_index: 430
  }
  instructions {
    description: "Add packed signed byte integers from xmm3/m128 and xmm2 saturate the results."
    vendor_syntax {
      mnemonic: "VPADDSB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG EC /r"
    instruction_group_index: 430
  }
  instructions {
    description: "Add packed signed word integers from xmm3/m128 and xmm2 and saturate the results."
    vendor_syntax {
      mnemonic: "VPADDSW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG ED /r"
    instruction_group_index: 430
  }
  instructions {
    description: "Add packed signed byte integers from ymm2, and ymm3/m256 and store the saturated results in ymm1."
    vendor_syntax {
      mnemonic: "VPADDSB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG EC /r"
    instruction_group_index: 430
  }
  instructions {
    description: "Add packed signed word integers from ymm2, and ymm3/m256 and store the saturated results in ymm1."
    vendor_syntax {
      mnemonic: "VPADDSW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG ED /r"
    instruction_group_index: 430
  }
  instructions {
    description: "Add packed signed byte integers from xmm2, and xmm3/m128 and store the saturated results in xmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPADDSB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.WIG EC /r"
    instruction_group_index: 430
  }
  instructions {
    description: "Add packed signed byte integers from ymm2, and ymm3/m256 and store the saturated results in ymm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPADDSB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.WIG EC /r"
    instruction_group_index: 430
  }
  instructions {
    description: "Add packed signed byte integers from zmm2, and zmm3/m512 and store the saturated results in zmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPADDSB"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.WIG EC /r"
    instruction_group_index: 430
  }
  instructions {
    description: "Add packed signed word integers from xmm2, and xmm3/m128 and store the saturated results in xmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPADDSW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.WIG ED /r"
    instruction_group_index: 430
  }
  instructions {
    description: "Add packed signed word integers from ymm2, and ymm3/m256 and store the saturated results in ymm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPADDSW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.WIG ED /r"
    instruction_group_index: 430
  }
  instructions {
    description: "Add packed signed word integers from zmm2, and zmm3/m512 and store the saturated results in zmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPADDSW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.WIG ED /r"
    instruction_group_index: 430
  }
  instructions {
    description: "Convert two signed doubleword integers from mm/m64 to two single-precision floating-point values in xmm."
    vendor_syntax {
      mnemonic: "CVTPI2PS"
      operands {
        name: "xmm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "NP 0F 2A /r"
    instruction_group_index: 431
  }
  instructions {
    description: "Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly."
    vendor_syntax {
      mnemonic: "COMISS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 2F /r"
    instruction_group_index: 432
  }
  instructions {
    description: "Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly."
    vendor_syntax {
      mnemonic: "VCOMISS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.LIG.0F.WIG 2F /r"
    instruction_group_index: 432
  }
  instructions {
    description: "Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly."
    vendor_syntax {
      mnemonic: "VCOMISS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.LIG.0F.W0 2F /r"
    instruction_group_index: 432
  }
  instructions {
    description: "Extract 4-bit sign mask from xmm and store in reg.\nThe upper bits of r32 or r64 are filled with zeros."
    vendor_syntax {
      mnemonic: "MOVMSKPS"
      operands {
        name: "reg"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "NP 0F 50 /r"
    instruction_group_index: 433
  }
  instructions {
    description: "Extract 4-bit sign mask from xmm2 and store in reg.\nThe upper bits of r32 or r64 are zeroed."
    vendor_syntax {
      mnemonic: "VMOVMSKPS"
      operands {
        name: "reg"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "VEX.128.0F.WIG 50 /r"
    instruction_group_index: 433
  }
  instructions {
    description: "Extract 8-bit sign mask from ymm2 and store in reg.\nThe upper bits of r32 or r64 are zeroed."
    vendor_syntax {
      mnemonic: "VMOVMSKPS"
      operands {
        name: "reg"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "VEX.256.0F.WIG 50 /r"
    instruction_group_index: 433
  }
  instructions {
    description: "Write the value in EDX:EAX to MSR specified by ECX."
    vendor_syntax {
      mnemonic: "WRMSR"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "0F 30"
    instruction_group_index: 434
  }
  instructions {
    description: "Save state components specified by EDX:EAX to mem, optimizing if possible."
    vendor_syntax {
      mnemonic: "XSAVEOPT"
      operands {
        name: "mem"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    feature_name: "XSAVEOPT"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "NP 0F AE /6"
    instruction_group_index: 435
  }
  instructions {
    description: "Save state components specified by EDX:EAX to mem, optimizing if possible."
    vendor_syntax {
      mnemonic: "XSAVEOPT64"
      operands {
        name: "mem"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    feature_name: "XSAVEOPT"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "NP REX.W + 0F AE /6"
    instruction_group_index: 435
  }
  instructions {
    description: "Push AX, CX, DX, BX, original SP, BP, SI, and DI."
    vendor_syntax {
      mnemonic: "PUSHA"
    }
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "60"
    instruction_group_index: 436
  }
  instructions {
    description: "Push EAX, ECX, EDX, EBX, original ESP, EBP, ESI, and EDI."
    vendor_syntax {
      mnemonic: "PUSHAD"
    }
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "60"
    instruction_group_index: 436
  }
  instructions {
    description: "Extract 128 bits of integer data from ymm2 and store results in xmm1/m128."
    vendor_syntax {
      mnemonic: "VEXTRACTI128"
      operands {
        name: "xmm1/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F3A.W0 39 /r ib"
    instruction_group_index: 437
  }
  instructions {
    description: "Extract 128 bits of double-word integer values from ymm2 and store results in xmm1/m128 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VEXTRACTI32X4"
      operands {
        name: "xmm1/m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F3A.W0 39 /r ib"
    instruction_group_index: 437
  }
  instructions {
    description: "Extract 128 bits of double-word integer values from zmm2 and store results in xmm1/m128 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VEXTRACTI32x4"
      operands {
        name: "xmm1/m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F3A.W0 39 /r ib"
    instruction_group_index: 437
  }
  instructions {
    description: "Extract 128 bits of quad-word integer values from ymm2 and store results in xmm1/m128 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VEXTRACTI64X2"
      operands {
        name: "xmm1/m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F3A.W1 39 /r ib"
    instruction_group_index: 437
  }
  instructions {
    description: "Extract 128 bits of quad-word integer values from zmm2 and store results in xmm1/m128 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VEXTRACTI64X2"
      operands {
        name: "xmm1/m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F3A.W1 39 /r ib"
    instruction_group_index: 437
  }
  instructions {
    description: "Extract 256 bits of double-word integer values from zmm2 and store results in ymm1/m256 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VEXTRACTI32X8"
      operands {
        name: "ymm1/m256"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.66.0F3A.W0 3B /r ib"
    instruction_group_index: 437
  }
  instructions {
    description: "Extract 256 bits of quad-word integer values from zmm2 and store results in ymm1/m256 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VEXTRACTI64x4"
      operands {
        name: "ymm1/m256"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F3A.W1 3B /r ib"
    instruction_group_index: 437
  }
  instructions {
    description: "ASCII adjust AL after subtraction."
    vendor_syntax {
      mnemonic: "AAS"
    }
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "3F"
    instruction_group_index: 438
  }
  instructions {
    description: "Decimal adjust AL after subtraction."
    vendor_syntax {
      mnemonic: "DAS"
    }
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "2F"
    instruction_group_index: 439
  }
  instructions {
    description: "Replace ST(0) with the approximate of its sine."
    vendor_syntax {
      mnemonic: "FSIN"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D9 FE"
    instruction_group_index: 440
  }
  instructions {
    description: "Expand packed double-word integer values from xmm2/m128 to xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPEXPANDD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 89 /r"
    instruction_group_index: 441
  }
  instructions {
    description: "Expand packed double-word integer values from ymm2/m256 to ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPEXPANDD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 89 /r"
    instruction_group_index: 441
  }
  instructions {
    description: "Expand packed double-word integer values from zmm2/m512 to zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPEXPANDD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 89 /r"
    instruction_group_index: 441
  }
  instructions {
    description: "Move data from m8 closer to the processor using T1 hint with intent to write."
    vendor_syntax {
      mnemonic: "PREFETCHWT1"
      operands {
        name: "m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "3DNOW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 0D /2"
    instruction_group_index: 442
  }
  instructions {
    description: "Multiply packed double-precision floating-point values in xmm2/m128 with xmm1 and store result in xmm1."
    vendor_syntax {
      mnemonic: "MULPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 59 /r"
    instruction_group_index: 443
  }
  instructions {
    description: "Multiply packed double-precision floating-point values in xmm3/m128 with xmm2 and store result in xmm1."
    vendor_syntax {
      mnemonic: "VMULPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG 59 /r"
    instruction_group_index: 443
  }
  instructions {
    description: "Multiply packed double-precision floating-point values in ymm3/m256 with ymm2 and store result in ymm1."
    vendor_syntax {
      mnemonic: "VMULPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG 59 /r"
    instruction_group_index: 443
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from xmm3/m128/m64bcst to xmm2 and store result in xmm1."
    vendor_syntax {
      mnemonic: "VMULPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.W1 59 /r"
    instruction_group_index: 443
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from ymm3/m256/m64bcst to ymm2 and store result in ymm1."
    vendor_syntax {
      mnemonic: "VMULPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.W1 59 /r"
    instruction_group_index: 443
  }
  instructions {
    description: "Multiply packed double-precision floating-point values in zmm3/m512/m64bcst with zmm2 and store result in zmm1."
    vendor_syntax {
      mnemonic: "VMULPD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.W1 59 /r"
    instruction_group_index: 443
  }
  instructions {
    description: "Add 16-bit integers horizontally, pack to mm1."
    vendor_syntax {
      mnemonic: "PHADDW"
      operands {
        name: "mm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "NP 0F 38 01 /r"
    instruction_group_index: 444
  }
  instructions {
    description: "Add 16-bit integers horizontally, pack to xmm1."
    vendor_syntax {
      mnemonic: "PHADDW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "66 0F 38 01 /r"
    instruction_group_index: 444
  }
  instructions {
    description: "Add 32-bit integers horizontally, pack to mm1."
    vendor_syntax {
      mnemonic: "PHADDD"
      operands {
        name: "mm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "NP 0F 38 02 /r"
    instruction_group_index: 444
  }
  instructions {
    description: "Add 32-bit integers horizontally, pack to xmm1."
    vendor_syntax {
      mnemonic: "PHADDD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "66 0F 38 02 /r"
    instruction_group_index: 444
  }
  instructions {
    description: "Add 16-bit integers horizontally, pack to xmm1."
    vendor_syntax {
      mnemonic: "VPHADDW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.128.66.0F38.WIG 01 /r"
    instruction_group_index: 444
  }
  instructions {
    description: "Add 32-bit integers horizontally, pack to xmm1."
    vendor_syntax {
      mnemonic: "VPHADDD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.128.66.0F38.WIG 02 /r"
    instruction_group_index: 444
  }
  instructions {
    description: "Add 16-bit signed integers horizontally, pack to ymm1."
    vendor_syntax {
      mnemonic: "VPHADDW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.256.66.0F38.WIG 01 /r"
    instruction_group_index: 444
  }
  instructions {
    description: "Add 32-bit signed integers horizontally, pack to ymm1."
    vendor_syntax {
      mnemonic: "VPHADDD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.256.66.0F38.WIG 02 /r"
    instruction_group_index: 444
  }
  instructions {
    description: "Permute word integers from two tables in xmm3/m128 and xmm1 using indexes in xmm2 and store the result in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMT2W"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 7D /r"
    instruction_group_index: 445
  }
  instructions {
    description: "Permute word integers from two tables in ymm3/m256 and ymm1 using indexes in ymm2 and store the result in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMT2W"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 7D /r"
    instruction_group_index: 445
  }
  instructions {
    description: "Permute word integers from two tables in zmm3/m512 and zmm1 using indexes in zmm2 and store the result in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMT2W"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 7D /r"
    instruction_group_index: 445
  }
  instructions {
    description: "Permute double-words from two tables in xmm3/m128/m32bcst and xmm1 using indexes in xmm2 and store the result in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMT2D"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 7E /r"
    instruction_group_index: 445
  }
  instructions {
    description: "Permute double-words from two tables in ymm3/m256/m32bcst and ymm1 using indexes in ymm2 and store the result in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMT2D"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 7E /r"
    instruction_group_index: 445
  }
  instructions {
    description: "Permute double-words from two tables in zmm3/m512/m32bcst and zmm1 using indices in zmm2 and store the result in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMT2D"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 7E /r"
    instruction_group_index: 445
  }
  instructions {
    description: "Permute quad-words from two tables in xmm3/m128/m64bcst and xmm1 using indexes in xmm2 and store the result in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMT2Q"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 7E /r"
    instruction_group_index: 445
  }
  instructions {
    description: "Permute quad-words from two tables in ymm3/m256/m64bcst and ymm1 using indexes in ymm2 and store the result in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMT2Q"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 7E /r"
    instruction_group_index: 445
  }
  instructions {
    description: "Permute quad-words from two tables in zmm3/m512/m64bcst and zmm1 using indices in zmm2 and store the result in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMT2Q"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 7E /r"
    instruction_group_index: 445
  }
  instructions {
    description: "Permute single-precision FP values from two tables in xmm3/m128/m32bcst and xmm1 using indexes in xmm2 and store the result in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMT2PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 7F /r"
    instruction_group_index: 445
  }
  instructions {
    description: "Permute single-precision FP values from two tables in ymm3/m256/m32bcst and ymm1 using indexes in ymm2 and store the result in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMT2PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 7F /r"
    instruction_group_index: 445
  }
  instructions {
    description: "Permute single-precision FP values from two tables in zmm3/m512/m32bcst and zmm1 using indices in zmm2 and store the result in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMT2PS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 7F /r"
    instruction_group_index: 445
  }
  instructions {
    description: "Permute double-precision FP values from two tables in xmm3/m128/m64bcst and xmm1 using indexes in xmm2 and store the result in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMT2PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 7F /r"
    instruction_group_index: 445
  }
  instructions {
    description: "Permute double-precision FP values from two tables in ymm3/m256/m64bcst and ymm1 using indexes in ymm2 and store the result in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMT2PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 7F /r"
    instruction_group_index: 445
  }
  instructions {
    description: "Permute double-precision FP values from two tables in zmm3/m512/m64bcst and zmm1 using indices in zmm2 and store the result in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMT2PD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 7F /r"
    instruction_group_index: 445
  }
  instructions {
    description: "Subtract m32fp from ST(0) and store result in ST(0)."
    vendor_syntax {
      mnemonic: "FSUB"
      operands {
        name: "m32fp"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D8 /4"
    instruction_group_index: 446
  }
  instructions {
    description: "Subtract m64fp from ST(0) and store result in ST(0)."
    vendor_syntax {
      mnemonic: "FSUB"
      operands {
        name: "m64fp"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DC /4"
    instruction_group_index: 446
  }
  instructions {
    description: "Subtract ST(i) from ST(0) and store result in ST(0)."
    vendor_syntax {
      mnemonic: "FSUB"
      operands {
        name: "ST(0)"
      }
      operands {
        name: "ST(i)"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D8 E0+i"
    instruction_group_index: 446
  }
  instructions {
    description: "Subtract ST(0) from ST(i) and store result in ST(i)."
    vendor_syntax {
      mnemonic: "FSUB"
      operands {
        name: "ST(i)"
      }
      operands {
        name: "ST(0)"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DC E8+i"
    instruction_group_index: 446
  }
  instructions {
    description: "Subtract ST(0) from ST(i), store result in ST(i), and pop register stack."
    vendor_syntax {
      mnemonic: "FSUBP"
      operands {
        name: "ST(i)"
      }
      operands {
        name: "ST(0)"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DE E8+i"
    instruction_group_index: 446
  }
  instructions {
    description: "Subtract ST(0) from ST(1), store result in ST(1), and pop register stack."
    vendor_syntax {
      mnemonic: "FSUBP"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DE E9"
    instruction_group_index: 446
  }
  instructions {
    description: "Subtract m32int from ST(0) and store result in ST(0)."
    vendor_syntax {
      mnemonic: "FISUB"
      operands {
        name: "m32int"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DA /4"
    instruction_group_index: 446
  }
  instructions {
    description: "Subtract m16int from ST(0) and store result in ST(0)."
    vendor_syntax {
      mnemonic: "FISUB"
      operands {
        name: "m16int"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DE /4"
    instruction_group_index: 446
  }
  instructions {
    description: "Reset lowest set bit of r/m32, keep all other bits of r/m32 and write result to r32."
    vendor_syntax {
      mnemonic: "BLSR"
      operands {
        name: "r32"
        encoding: VEX_V_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "BMI1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "VM"
    raw_encoding_specification: "VEX.LZ.0F38.W0 F3 /1"
    instruction_group_index: 447
  }
  instructions {
    description: "Reset lowest set bit of r/m64, keep all other bits of r/m64 and write result to r64."
    vendor_syntax {
      mnemonic: "BLSR"
      operands {
        name: "r64"
        encoding: VEX_V_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "BMI1"
    available_in_64_bit: true
    encoding_scheme: "VM"
    raw_encoding_specification: "VEX.LZ.0F38.W1 F3 /1"
    instruction_group_index: 447
  }
  instructions {
    description: "Compute the absolute value of bytes in mm2/m64 and store UNSIGNED result in mm1."
    vendor_syntax {
      mnemonic: "PABSB"
      operands {
        name: "mm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "mm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 38 1C /r"
    instruction_group_index: 448
  }
  instructions {
    description: "Compute the absolute value of bytes in xmm2/m128 and store UNSIGNED result in xmm1."
    vendor_syntax {
      mnemonic: "PABSB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 38 1C /r"
    instruction_group_index: 448
  }
  instructions {
    description: "Compute the absolute value of 16-bit integers in mm2/m64 and store UNSIGNED result in mm1."
    vendor_syntax {
      mnemonic: "PABSW"
      operands {
        name: "mm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "mm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 38 1D /r"
    instruction_group_index: 448
  }
  instructions {
    description: "Compute the absolute value of 16-bit integers in xmm2/m128 and store UNSIGNED result in xmm1."
    vendor_syntax {
      mnemonic: "PABSW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 38 1D /r"
    instruction_group_index: 448
  }
  instructions {
    description: "Compute the absolute value of 32-bit integers in mm2/m64 and store UNSIGNED result in mm1."
    vendor_syntax {
      mnemonic: "PABSD"
      operands {
        name: "mm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "mm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 38 1E /r"
    instruction_group_index: 448
  }
  instructions {
    description: "Compute the absolute value of 32-bit integers in xmm2/m128 and store UNSIGNED result in xmm1."
    vendor_syntax {
      mnemonic: "PABSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 38 1E /r"
    instruction_group_index: 448
  }
  instructions {
    description: "Compute the absolute value of bytes in xmm2/m128 and store UNSIGNED result in xmm1."
    vendor_syntax {
      mnemonic: "VPABSB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.WIG 1C /r"
    instruction_group_index: 448
  }
  instructions {
    description: "Compute the absolute value of 16- bit integers in xmm2/m128 and store UNSIGNED result in xmm1."
    vendor_syntax {
      mnemonic: "VPABSW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.WIG 1D /r"
    instruction_group_index: 448
  }
  instructions {
    description: "Compute the absolute value of 32- bit integers in xmm2/m128 and store UNSIGNED result in xmm1."
    vendor_syntax {
      mnemonic: "VPABSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.WIG 1E /r"
    instruction_group_index: 448
  }
  instructions {
    description: "Compute the absolute value of bytes in ymm2/m256 and store UNSIGNED result in ymm1."
    vendor_syntax {
      mnemonic: "VPABSB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.WIG 1C /r"
    instruction_group_index: 448
  }
  instructions {
    description: "Compute the absolute value of 16-bit integers in ymm2/m256 and store UNSIGNED result in ymm1."
    vendor_syntax {
      mnemonic: "VPABSW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.WIG 1D /r"
    instruction_group_index: 448
  }
  instructions {
    description: "Compute the absolute value of 32-bit integers in ymm2/m256 and store UNSIGNED result in ymm1."
    vendor_syntax {
      mnemonic: "VPABSD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.WIG 1E /r"
    instruction_group_index: 448
  }
  instructions {
    description: "Compute the absolute value of bytes in xmm2/m128 and store UNSIGNED result in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPABSB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.WIG 1C /r"
    instruction_group_index: 448
  }
  instructions {
    description: "Compute the absolute value of bytes in ymm2/m256 and store UNSIGNED result in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPABSB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.WIG 1C /r"
    instruction_group_index: 448
  }
  instructions {
    description: "Compute the absolute value of bytes in zmm2/m512 and store UNSIGNED result in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPABSB"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.WIG 1C /r"
    instruction_group_index: 448
  }
  instructions {
    description: "Compute the absolute value of 16-bit integers in xmm2/m128 and store UNSIGNED result in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPABSW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.WIG 1D /r"
    instruction_group_index: 448
  }
  instructions {
    description: "Compute the absolute value of 16-bit integers in ymm2/m256 and store UNSIGNED result in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPABSW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.WIG 1D /r"
    instruction_group_index: 448
  }
  instructions {
    description: "Compute the absolute value of 16-bit integers in zmm2/m512 and store UNSIGNED result in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPABSW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.WIG 1D /r"
    instruction_group_index: 448
  }
  instructions {
    description: "Compute the absolute value of 32-bit integers in xmm2/m128/m32bcst and store UNSIGNED result in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPABSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 1E /r"
    instruction_group_index: 448
  }
  instructions {
    description: "Compute the absolute value of 32-bit integers in ymm2/m256/m32bcst and store UNSIGNED result in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPABSD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 1E /r"
    instruction_group_index: 448
  }
  instructions {
    description: "Compute the absolute value of 32-bit integers in zmm2/m512/m32bcst and store UNSIGNED result in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPABSD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 1E /r"
    instruction_group_index: 448
  }
  instructions {
    description: "Compute the absolute value of 64-bit integers in xmm2/m128/m64bcst and store UNSIGNED result in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPABSQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 1F /r"
    instruction_group_index: 448
  }
  instructions {
    description: "Compute the absolute value of 64-bit integers in ymm2/m256/m64bcst and store UNSIGNED result in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPABSQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 1F /r"
    instruction_group_index: 448
  }
  instructions {
    description: "Compute the absolute value of 64-bit integers in zmm2/m512/m64bcst and store UNSIGNED result in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPABSQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 1F /r"
    instruction_group_index: 448
  }
  instructions {
    description: "Negate/zero/preserve packed byte integers in mm1 depending on the corresponding sign in mm2/m64."
    vendor_syntax {
      mnemonic: "PSIGNB"
      operands {
        name: "mm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "NP 0F 38 08 /r"
    instruction_group_index: 449
  }
  instructions {
    description: "Negate/zero/preserve packed byte integers in xmm1 depending on the corresponding sign in xmm2/m128."
    vendor_syntax {
      mnemonic: "PSIGNB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "66 0F 38 08 /r"
    instruction_group_index: 449
  }
  instructions {
    description: "Negate/zero/preserve packed word integers in mm1 depending on the corresponding sign in mm2/m128."
    vendor_syntax {
      mnemonic: "PSIGNW"
      operands {
        name: "mm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "NP 0F 38 09 /r"
    instruction_group_index: 449
  }
  instructions {
    description: "Negate/zero/preserve packed word integers in xmm1 depending on the corresponding sign in xmm2/m128."
    vendor_syntax {
      mnemonic: "PSIGNW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "66 0F 38 09 /r"
    instruction_group_index: 449
  }
  instructions {
    description: "Negate/zero/preserve packed doubleword integers in mm1 depending on the corresponding sign in mm2/m128."
    vendor_syntax {
      mnemonic: "PSIGND"
      operands {
        name: "mm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "NP 0F 38 0A /r"
    instruction_group_index: 449
  }
  instructions {
    description: "Negate/zero/preserve packed doubleword integers in xmm1 depending on the corresponding sign in xmm2/m128."
    vendor_syntax {
      mnemonic: "PSIGND"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "66 0F 38 0A /r"
    instruction_group_index: 449
  }
  instructions {
    description: "Negate/zero/preserve packed byte integers in xmm2 depending on the corresponding sign in xmm3/m128."
    vendor_syntax {
      mnemonic: "VPSIGNB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.128.66.0F38.WIG 08 /r"
    instruction_group_index: 449
  }
  instructions {
    description: "Negate/zero/preserve packed word integers in xmm2 depending on the corresponding sign in xmm3/m128."
    vendor_syntax {
      mnemonic: "VPSIGNW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.128.66.0F38.WIG 09 /r"
    instruction_group_index: 449
  }
  instructions {
    description: "Negate/zero/preserve packed doubleword integers in xmm2 depending on the corresponding sign in xmm3/m128."
    vendor_syntax {
      mnemonic: "VPSIGND"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.128.66.0F38.WIG 0A /r"
    instruction_group_index: 449
  }
  instructions {
    description: "Negate packed byte integers in ymm2 if the corresponding sign in ymm3/m256 is less than zero."
    vendor_syntax {
      mnemonic: "VPSIGNB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.256.66.0F38.WIG 08 /r"
    instruction_group_index: 449
  }
  instructions {
    description: "Negate packed 16-bit integers in ymm2 if the corresponding sign in ymm3/m256 is less than zero."
    vendor_syntax {
      mnemonic: "VPSIGNW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.256.66.0F38.WIG 09 /r"
    instruction_group_index: 449
  }
  instructions {
    description: "Negate packed doubleword integers in ymm2 if the corresponding sign in ymm3/m256 is less than zero."
    vendor_syntax {
      mnemonic: "VPSIGND"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.256.66.0F38.WIG 0A /r"
    instruction_group_index: 449
  }
  instructions {
    description: "Computes the approximate reciprocals ( < 2^-28 relative error) of the packed double-precision floating-point values in zmm2/m512/m64bcst and stores the results in zmm1. Under writemask."
    vendor_syntax {
      mnemonic: "VRCP28PD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512ER"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 CA /r"
    instruction_group_index: 450
  }
  instructions {
    description: "Invalidates EPT-derived entries in the TLBs and paging-structure caches (in 64-bit mode)."
    vendor_syntax {
      mnemonic: "INVEPT"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "VMX"
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "66 0F 38 80"
    instruction_group_index: 451
  }
  instructions {
    description: "Invalidates EPT-derived entries in the TLBs and paging-structure caches (outside 64-bit mode)."
    vendor_syntax {
      mnemonic: "INVEPT"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "VMX"
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "66 0F 38 80"
    instruction_group_index: 451
  }
  instructions {
    description: "Store FPU status word at m2byte after checking for pending unmasked floating-point exceptions."
    vendor_syntax {
      mnemonic: "FSTSW"
      operands {
        name: "m2byte"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "9B DD /7"
    instruction_group_index: 452
  }
  instructions {
    description: "Store FPU status word in AX register after checking for pending unmasked floating-point exceptions."
    vendor_syntax {
      mnemonic: "FSTSW"
      operands {
        name: "AX"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "9B DF E0"
    instruction_group_index: 452
  }
  instructions {
    description: "Store FPU status word at m2byte without checking for pending unmasked floating-point exceptions."
    vendor_syntax {
      mnemonic: "FNSTSW"
      operands {
        name: "m2byte"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DD /7"
    instruction_group_index: 452
  }
  instructions {
    description: "Store FPU status word in AX register without checking for pending unmasked floating-point exceptions."
    vendor_syntax {
      mnemonic: "FNSTSW"
      operands {
        name: "AX"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DF E0"
    instruction_group_index: 452
  }
  instructions {
    description: "Convert two packed unsigned quadword integers from xmm2/m128/m64bcst to packed single-precision floatingpoint values in zmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTUQQ2PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.F2.0F.W1 7A /r"
    instruction_group_index: 453
  }
  instructions {
    description: "Convert four packed unsigned quadword integers from ymm2/m256/m64bcst to packed single-precision floatingpoint values in xmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTUQQ2PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.F2.0F.W1 7A /r"
    instruction_group_index: 453
  }
  instructions {
    description: "Convert eight packed unsigned quadword integers from zmm2/m512/m64bcst to eight packed single-precision floating-point values in zmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTUQQ2PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.F2.0F.W1 7A /r"
    instruction_group_index: 453
  }
  instructions {
    description: "Save state components specified by EDX:EAX to mem."
    vendor_syntax {
      mnemonic: "XSAVE"
      operands {
        name: "mem"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    feature_name: "XSAVE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "NP 0F AE /4"
    instruction_group_index: 454
  }
  instructions {
    description: "Save state components specified by EDX:EAX to mem."
    vendor_syntax {
      mnemonic: "XSAVE64"
      operands {
        name: "mem"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    feature_name: "XSAVE"
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "NP REX.W + 0F AE /4"
    instruction_group_index: 454
  }
  instructions {
    description: "Extract a byte integer value from xmm2 at the source byte offset specified by imm8 into reg or m8. The upper bits of r32 or r64 are zeroed."
    vendor_syntax {
      mnemonic: "PEXTRB"
      operands {
        name: "reg/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 3A 14 /r ib"
    instruction_group_index: 455
  }
  instructions {
    description: "Extract a dword integer value from xmm2 at the source dword offset specified by imm8 into r/m32."
    vendor_syntax {
      mnemonic: "PEXTRD"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 3A 16 /r ib"
    instruction_group_index: 455
  }
  instructions {
    description: "Extract a qword integer value from xmm2 at the source qword offset specified by imm8 into r/m64."
    vendor_syntax {
      mnemonic: "PEXTRQ"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 REX.W 0F 3A 16 /r ib"
    instruction_group_index: 455
  }
  instructions {
    description: "Extract a byte integer value from xmm2 at the source byte offset specified by imm8 into reg or m8. The upper bits of r64/r32 is filled with zeros."
    vendor_syntax {
      mnemonic: "VPEXTRB"
      operands {
        name: "reg/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F3A.W0 14 /r ib"
    instruction_group_index: 455
  }
  instructions {
    description: "Extract a dword integer value from xmm2 at the source dword offset specified by imm8 into r32/m32."
    vendor_syntax {
      mnemonic: "VPEXTRD"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F3A.W0 16 /r ib"
    instruction_group_index: 455
  }
  instructions {
    description: "Extract a qword integer value from xmm2 at the source dword offset specified by imm8 into r64/m64."
    vendor_syntax {
      mnemonic: "VPEXTRQ"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F3A.W1 16 /r ib"
    instruction_group_index: 455
  }
  instructions {
    description: "Extract a byte integer value from xmm2 at the source byte offset specified by imm8 into reg or m8. The upper bits of r64/r32 is filled with zeros."
    vendor_syntax {
      mnemonic: "VPEXTRB"
      operands {
        name: "reg/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F3A.WIG 14 /r ib"
    instruction_group_index: 455
  }
  instructions {
    description: "Extract a dword integer value from xmm2 at the source dword offset specified by imm8 into r32/m32."
    vendor_syntax {
      mnemonic: "VPEXTRD"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F3A.W0 16 /r ib"
    instruction_group_index: 455
  }
  instructions {
    description: "Extract a qword integer value from xmm2 at the source dword offset specified by imm8 into r64/m64."
    vendor_syntax {
      mnemonic: "VPEXTRQ"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F3A.W1 16 /r ib"
    instruction_group_index: 455
  }
  instructions {
    description: "A hint that allows the processor to stop instruction execution and enter an implementation-dependent optimized state until occurrence of a class of events."
    vendor_syntax {
      mnemonic: "UMWAIT"
      operands {
        name: "r32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "WAITPKG"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F2 0F AE /6"
    instruction_group_index: 456
  }
  instructions {
    description: "Loads the current VMCS pointer from memory."
    vendor_syntax {
      mnemonic: "VMPTRLD"
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "VMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "NP 0F C7 /6"
    instruction_group_index: 457
  }
  instructions {
    description: "Clears TS flag in CR0."
    vendor_syntax {
      mnemonic: "CLTS"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "0F 06"
    instruction_group_index: 458
  }
  instructions {
    description: "Computes the approximate reciprocal square roots of the packed single-precision floating-point values in xmm2/m128/m32bcst and stores the results in xmm1.\nUnder writemask."
    vendor_syntax {
      mnemonic: "VRSQRT14PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 4E /r"
    instruction_group_index: 459
  }
  instructions {
    description: "Computes the approximate reciprocal square roots of the packed single-precision floating-point values in ymm2/m256/m32bcst and stores the results in ymm1.\nUnder writemask."
    vendor_syntax {
      mnemonic: "VRSQRT14PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 4E /r"
    instruction_group_index: 459
  }
  instructions {
    description: "Computes the approximate reciprocal square roots of the packed single-precision floating-point values in zmm2/m512/m32bcst and stores the results in zmm1. Under writemask."
    vendor_syntax {
      mnemonic: "VRSQRT14PS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 4E /r"
    instruction_group_index: 459
  }
  instructions {
    description: "Expand packed single-precision floating-point values from xmm2/m128 to xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VEXPANDPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 88 /r"
    instruction_group_index: 460
  }
  instructions {
    description: "Expand packed single-precision floating-point values from ymm2/m256 to ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VEXPANDPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 88 /r"
    instruction_group_index: 460
  }
  instructions {
    description: "Expand packed single-precision floating-point values from zmm2/m512 to zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VEXPANDPS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 88 /r"
    instruction_group_index: 460
  }
  instructions {
    description: "ASCII adjust AL after addition."
    vendor_syntax {
      mnemonic: "AAA"
    }
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "37"
    instruction_group_index: 461
  }
  instructions {
    description: "Convert the exponent of packed double-precision floating-point values in the source operand to DP FP results representing unbiased integer exponents and stores the results in the destination register."
    vendor_syntax {
      mnemonic: "VGETEXPPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 42 /r"
    instruction_group_index: 462
  }
  instructions {
    description: "Convert the exponent of packed double-precision floating-point values in the source operand to DP FP results representing unbiased integer exponents and stores the results in the destination register."
    vendor_syntax {
      mnemonic: "VGETEXPPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 42 /r"
    instruction_group_index: 462
  }
  instructions {
    description: "Convert the exponent of packed double-precision floating-point values in the source operand to DP FP results representing unbiased integer exponents and stores the results in the destination under writemask k1."
    vendor_syntax {
      mnemonic: "VGETEXPPD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 42 /r"
    instruction_group_index: 462
  }
  instructions {
    description: "Compress up to 128 bits of packed byte values from xmm1 to m128 with writemask k1."
    vendor_syntax {
      mnemonic: "VPCOMPRESSB"
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2 && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 63 /r"
    instruction_group_index: 463
  }
  instructions {
    description: "Compress up to 128 bits of packed byte values from xmm2 to xmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VPCOMPRESSB"
      operands {
        name: "xmm1"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2 && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 63 /r"
    instruction_group_index: 463
  }
  instructions {
    description: "Compress up to 256 bits of packed byte values from ymm1 to m256 with writemask k1."
    vendor_syntax {
      mnemonic: "VPCOMPRESSB"
      operands {
        name: "m256"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2 && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 63 /r"
    instruction_group_index: 463
  }
  instructions {
    description: "Compress up to 256 bits of packed byte values from ymm2 to ymm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VPCOMPRESSB"
      operands {
        name: "ymm1"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2 && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 63 /r"
    instruction_group_index: 463
  }
  instructions {
    description: "Compress up to 512 bits of packed byte values from zmm1 to m512 with writemask k1."
    vendor_syntax {
      mnemonic: "VPCOMPRESSB"
      operands {
        name: "m512"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 63 /r"
    instruction_group_index: 463
  }
  instructions {
    description: "Compress up to 512 bits of packed byte values from zmm2 to zmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VPCOMPRESSB"
      operands {
        name: "zmm1"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 63 /r"
    instruction_group_index: 463
  }
  instructions {
    description: "Compress up to 128 bits of packed word values from xmm1 to m128 with writemask k1."
    vendor_syntax {
      mnemonic: "VPCOMPRESSW"
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2 && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 63 /r"
    instruction_group_index: 463
  }
  instructions {
    description: "Compress up to 128 bits of packed word values from xmm2 to xmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VPCOMPRESSW"
      operands {
        name: "xmm1"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2 && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 63 /r"
    instruction_group_index: 463
  }
  instructions {
    description: "Compress up to 256 bits of packed word values from ymm1 to m256 with writemask k1."
    vendor_syntax {
      mnemonic: "VPCOMPRESSW"
      operands {
        name: "m256"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2 && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 63 /r"
    instruction_group_index: 463
  }
  instructions {
    description: "Compress up to 256 bits of packed word values from ymm2 to ymm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VPCOMPRESSW"
      operands {
        name: "ymm1"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2 && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 63 /r"
    instruction_group_index: 463
  }
  instructions {
    description: "Compress up to 512 bits of packed word values from zmm1 to m512 with writemask k1."
    vendor_syntax {
      mnemonic: "VPCOMPRESSW"
      operands {
        name: "m512"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 63 /r"
    instruction_group_index: 463
  }
  instructions {
    description: "Compress up to 512 bits of packed word values from zmm2 to zmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VPCOMPRESSW"
      operands {
        name: "zmm1"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 63 /r"
    instruction_group_index: 463
  }
  instructions {
    description: "Using signed dword indices, gather dword values from memory using writemask k1 for merging-masking."
    vendor_syntax {
      mnemonic: "VPGATHERDD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "vm32x"
        encoding: VSIB_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 90 /vsib"
    instruction_group_index: 464
  }
  instructions {
    description: "Using signed dword indices, gather dword values from memory using writemask k1 for merging-masking."
    vendor_syntax {
      mnemonic: "VPGATHERDD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "vm32y"
        encoding: VSIB_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 90 /vsib"
    instruction_group_index: 464
  }
  instructions {
    description: "Using signed dword indices, gather dword values from memory using writemask k1 for merging-masking."
    vendor_syntax {
      mnemonic: "VPGATHERDD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "vm32z"
        encoding: VSIB_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 90 /vsib"
    instruction_group_index: 464
  }
  instructions {
    description: "Using signed dword indices, gather quadword values from memory using writemask k1 for merging-masking."
    vendor_syntax {
      mnemonic: "VPGATHERDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "vm32x"
        encoding: VSIB_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 90 /vsib"
    instruction_group_index: 464
  }
  instructions {
    description: "Using signed dword indices, gather quadword values from memory using writemask k1 for merging-masking."
    vendor_syntax {
      mnemonic: "VPGATHERDQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "vm32x"
        encoding: VSIB_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 90 /vsib"
    instruction_group_index: 464
  }
  instructions {
    description: "Using signed dword indices, gather quadword values from memory using writemask k1 for merging-masking."
    vendor_syntax {
      mnemonic: "VPGATHERDQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "vm32y"
        encoding: VSIB_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 90 /vsib"
    instruction_group_index: 464
  }
  instructions {
    description: "Compare ST(0) with m16int."
    vendor_syntax {
      mnemonic: "FICOM"
      operands {
        name: "m16int"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DE /2"
    instruction_group_index: 465
  }
  instructions {
    description: "Compare ST(0) with m32int."
    vendor_syntax {
      mnemonic: "FICOM"
      operands {
        name: "m32int"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DA /2"
    instruction_group_index: 465
  }
  instructions {
    description: "Compare ST(0) with m16int and pop stack register."
    vendor_syntax {
      mnemonic: "FICOMP"
      operands {
        name: "m16int"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DE /3"
    instruction_group_index: 465
  }
  instructions {
    description: "Compare ST(0) with m32int and pop stack register."
    vendor_syntax {
      mnemonic: "FICOMP"
      operands {
        name: "m32int"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DA /3"
    instruction_group_index: 465
  }
  instructions {
    description: "Subtract packed single-precision floating-point values in xmm2/mem from xmm1 and store result in xmm1."
    vendor_syntax {
      mnemonic: "SUBPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 5C /r"
    instruction_group_index: 466
  }
  instructions {
    description: "Subtract packed single-precision floating-point values in xmm3/mem from xmm2 and stores result in xmm1."
    vendor_syntax {
      mnemonic: "VSUBPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.0F.WIG 5C /r"
    instruction_group_index: 466
  }
  instructions {
    description: "Subtract packed single-precision floating-point values in ymm3/mem from ymm2 and stores result in ymm1."
    vendor_syntax {
      mnemonic: "VSUBPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.0F.WIG 5C /r"
    instruction_group_index: 466
  }
  instructions {
    description: "Subtract packed single-precision floating-point values from xmm3/m128/m32bcst to xmm2 and stores result in xmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VSUBPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.0F.W0 5C /r"
    instruction_group_index: 466
  }
  instructions {
    description: "Subtract packed single-precision floating-point values from ymm3/m256/m32bcst to ymm2 and stores result in ymm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VSUBPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.0F.W0 5C /r"
    instruction_group_index: 466
  }
  instructions {
    description: "Subtract packed single-precision floating-point values in zmm3/m512/m32bcst from zmm2 and stores result in zmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VSUBPS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.0F.W0 5C /r"
    instruction_group_index: 466
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from source register block indicated by zmm2 by values from m128 and accumulate the result in zmm1."
    vendor_syntax {
      mnemonic: "V4FMADDPS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2+3"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_4FMAPS"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.F2.0F38.W0 9A /r"
    instruction_group_index: 467
  }
  instructions {
    description: "Multiply and negate packed single-precision floating-point values from source register block indicated by zmm2 by values from m128 and accumulate the result in zmm1."
    vendor_syntax {
      mnemonic: "V4FNMADDPS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2+3"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_4FMAPS"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.F2.0F38.W0 AA /r"
    instruction_group_index: 467
  }
  instructions {
    description: "Bitwise ternary logic taking xmm1, xmm2 and xmm3/m128/m32bcst as source operands and writing the result to xmm1 under writemask k1 with dword granularity. The immediate value determines the specific binary function being implemented."
    vendor_syntax {
      mnemonic: "VPTERNLOGD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F3A.W0 25 /r ib"
    instruction_group_index: 468
  }
  instructions {
    description: "Bitwise ternary logic taking ymm1, ymm2 and ymm3/m256/m32bcst as source operands and writing the result to ymm1 under writemask k1 with dword granularity. The immediate value determines the specific binary function being implemented."
    vendor_syntax {
      mnemonic: "VPTERNLOGD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F3A.W0 25 /r ib"
    instruction_group_index: 468
  }
  instructions {
    description: "Bitwise ternary logic taking zmm1, zmm2 and zmm3/m512/m32bcst as source operands and writing the result to zmm1 under writemask k1 with dword granularity. The immediate value determines the specific binary function being implemented."
    vendor_syntax {
      mnemonic: "VPTERNLOGD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F3A.W0 25 /r ib"
    instruction_group_index: 468
  }
  instructions {
    description: "Bitwise ternary logic taking xmm1, xmm2 and xmm3/m128/m64bcst as source operands and writing the result to xmm1 under writemask k1 with qword granularity. The immediate value determines the specific binary function being implemented."
    vendor_syntax {
      mnemonic: "VPTERNLOGQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F3A.W1 25 /r ib"
    instruction_group_index: 468
  }
  instructions {
    description: "Bitwise ternary logic taking ymm1, ymm2 and ymm3/m256/m64bcst as source operands and writing the result to ymm1 under writemask k1 with qword granularity. The immediate value determines the specific binary function being implemented."
    vendor_syntax {
      mnemonic: "VPTERNLOGQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F3A.W1 25 /r ib"
    instruction_group_index: 468
  }
  instructions {
    description: "Bitwise ternary logic taking zmm1, zmm2 and zmm3/m512/m64bcst as source operands and writing the result to zmm1 under writemask k1 with qword granularity. The immediate value determines the specific binary function being implemented."
    vendor_syntax {
      mnemonic: "VPTERNLOGQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F3A.W1 25 /r ib"
    instruction_group_index: 468
  }
  instructions {
    description: "Move two packed single-precision floating-point values from high quadword of xmm2 to low quadword of xmm1."
    vendor_syntax {
      mnemonic: "MOVHLPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "NP 0F 12 /r"
    instruction_group_index: 469
  }
  instructions {
    description: "Merge two packed single-precision floating-point values from high quadword of xmm3 and low quadword of xmm2."
    vendor_syntax {
      mnemonic: "VMOVHLPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.128.0F.WIG 12 /r"
    instruction_group_index: 469
  }
  instructions {
    description: "Merge two packed single-precision floating-point values from high quadword of xmm3 and low quadword of xmm2."
    vendor_syntax {
      mnemonic: "VMOVHLPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "EVEX.128.0F.W0 12 /r"
    instruction_group_index: 469
  }
  instructions {
    description: "Shift words in mm left mm/m64 while shifting in 0s."
    vendor_syntax {
      mnemonic: "PSLLW"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F F1 /r"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift words in xmm1 left by xmm2/m128 while shifting in 0s."
    vendor_syntax {
      mnemonic: "PSLLW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F F1 /r"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift words in mm left by imm8 while shifting in 0s."
    vendor_syntax {
      mnemonic: "PSLLW"
      operands {
        name: "mm1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "NP 0F 71 /6 ib"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift words in xmm1 left by imm8 while shifting in 0s."
    vendor_syntax {
      mnemonic: "PSLLW"
      operands {
        name: "xmm1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "66 0F 71 /6 ib"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift doublewords in mm left by mm/m64 while shifting in 0s."
    vendor_syntax {
      mnemonic: "PSLLD"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F F2 /r"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift doublewords in xmm1 left by xmm2/m128 while shifting in 0s."
    vendor_syntax {
      mnemonic: "PSLLD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F F2 /r"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift doublewords in mm left by imm8 while shifting in 0s."
    vendor_syntax {
      mnemonic: "PSLLD"
      operands {
        name: "mm"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "NP 0F 72 /6 ib"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift doublewords in xmm1 left by imm8 while shifting in 0s."
    vendor_syntax {
      mnemonic: "PSLLD"
      operands {
        name: "xmm1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "66 0F 72 /6 ib"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift quadword in mm left by mm/m64 while shifting in 0s."
    vendor_syntax {
      mnemonic: "PSLLQ"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F F3 /r"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift quadwords in xmm1 left by xmm2/m128 while shifting in 0s."
    vendor_syntax {
      mnemonic: "PSLLQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F F3 /r"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift quadword in mm left by imm8 while shifting in 0s."
    vendor_syntax {
      mnemonic: "PSLLQ"
      operands {
        name: "mm"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "NP 0F 73 /6 ib"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift quadwords in xmm1 left by imm8 while shifting in 0s."
    vendor_syntax {
      mnemonic: "PSLLQ"
      operands {
        name: "xmm1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "66 0F 73 /6 ib"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift words in xmm2 left by amount specified in xmm3/m128 while shifting in 0s."
    vendor_syntax {
      mnemonic: "VPSLLW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "VEX.128.66.0F.WIG F1 /r"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift words in xmm2 left by imm8 while shifting in 0s."
    vendor_syntax {
      mnemonic: "VPSLLW"
      operands {
        name: "xmm1"
        encoding: VEX_V_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "VEX.128.66.0F.WIG 71 /6 ib"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift doublewords in xmm2 left by amount specified in xmm3/m128 while shifting in 0s."
    vendor_syntax {
      mnemonic: "VPSLLD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "VEX.128.66.0F.WIG F2 /r"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift doublewords in xmm2 left by imm8 while shifting in 0s."
    vendor_syntax {
      mnemonic: "VPSLLD"
      operands {
        name: "xmm1"
        encoding: VEX_V_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "VEX.128.66.0F.WIG 72 /6 ib"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift quadwords in xmm2 left by amount specified in xmm3/m128 while shifting in 0s."
    vendor_syntax {
      mnemonic: "VPSLLQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "VEX.128.66.0F.WIG F3 /r"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift quadwords in xmm2 left by imm8 while shifting in 0s."
    vendor_syntax {
      mnemonic: "VPSLLQ"
      operands {
        name: "xmm1"
        encoding: VEX_V_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "VEX.128.66.0F.WIG 73 /6 ib"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift words in ymm2 left by amount specified in xmm3/m128 while shifting in 0s."
    vendor_syntax {
      mnemonic: "VPSLLW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "VEX.256.66.0F.WIG F1 /r"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift words in ymm2 left by imm8 while shifting in 0s."
    vendor_syntax {
      mnemonic: "VPSLLW"
      operands {
        name: "ymm1"
        encoding: VEX_V_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "VEX.256.66.0F.WIG 71 /6 ib"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift doublewords in ymm2 left by amount specified in xmm3/m128 while shifting in 0s."
    vendor_syntax {
      mnemonic: "VPSLLD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "VEX.256.66.0F.WIG F2 /r"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift doublewords in ymm2 left by imm8 while shifting in 0s."
    vendor_syntax {
      mnemonic: "VPSLLD"
      operands {
        name: "ymm1"
        encoding: VEX_V_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "VEX.256.66.0F.WIG 72 /6 ib"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift quadwords in ymm2 left by amount specified in xmm3/m128 while shifting in 0s."
    vendor_syntax {
      mnemonic: "VPSLLQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "VEX.256.66.0F.WIG F3 /r"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift quadwords in ymm2 left by imm8 while shifting in 0s."
    vendor_syntax {
      mnemonic: "VPSLLQ"
      operands {
        name: "ymm1"
        encoding: VEX_V_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "VEX.256.66.0F.WIG 73 /6 ib"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift words in xmm2 left by amount specified in xmm3/m128 while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSLLW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "G"
    raw_encoding_specification: "EVEX.128.66.0F.WIG F1 /r"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift words in ymm2 left by amount specified in xmm3/m128 while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSLLW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "G"
    raw_encoding_specification: "EVEX.256.66.0F.WIG F1 /r"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift words in zmm2 left by amount specified in xmm3/m128 while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSLLW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "G"
    raw_encoding_specification: "EVEX.512.66.0F.WIG F1 /r"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift words in xmm2/m128 left by imm8 while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSLLW"
      operands {
        name: "xmm1"
        encoding: VEX_V_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "E"
    raw_encoding_specification: "EVEX.128.66.0F.WIG 71 /6 ib"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift words in ymm2/m256 left by imm8 while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSLLW"
      operands {
        name: "ymm1"
        encoding: VEX_V_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "E"
    raw_encoding_specification: "EVEX.256.66.0F.WIG 71 /6 ib"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift words in zmm2/m512 left by imm8 while shifting in 0 using writemask k1."
    vendor_syntax {
      mnemonic: "VPSLLW"
      operands {
        name: "zmm1"
        encoding: VEX_V_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "E"
    raw_encoding_specification: "EVEX.512.66.0F.WIG 71 /6 ib"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift doublewords in xmm2 left by amount specified in xmm3/m128 while shifting in 0s under writemask k1."
    vendor_syntax {
      mnemonic: "VPSLLD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "G"
    raw_encoding_specification: "EVEX.128.66.0F.W0 F2 /r"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift doublewords in ymm2 left by amount specified in xmm3/m128 while shifting in 0s under writemask k1."
    vendor_syntax {
      mnemonic: "VPSLLD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "G"
    raw_encoding_specification: "EVEX.256.66.0F.W0 F2 /r"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift doublewords in zmm2 left by amount specified in xmm3/m128 while shifting in 0s under writemask k1."
    vendor_syntax {
      mnemonic: "VPSLLD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "G"
    raw_encoding_specification: "EVEX.512.66.0F.W0 F2 /r"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift doublewords in xmm2/m128/m32bcst left by imm8 while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSLLD"
      operands {
        name: "xmm1"
        encoding: VEX_V_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "F"
    raw_encoding_specification: "EVEX.128.66.0F.W0 72 /6 ib"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift doublewords in ymm2/m256/m32bcst left by imm8 while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSLLD"
      operands {
        name: "ymm1"
        encoding: VEX_V_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "F"
    raw_encoding_specification: "EVEX.256.66.0F.W0 72 /6 ib"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift doublewords in zmm2/m512/m32bcst left by imm8 while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSLLD"
      operands {
        name: "zmm1"
        encoding: VEX_V_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "F"
    raw_encoding_specification: "EVEX.512.66.0F.W0 72 /6 ib"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift quadwords in xmm2 left by amount specified in xmm3/m128 while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSLLQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "G"
    raw_encoding_specification: "EVEX.128.66.0F.W1 F3 /r"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift quadwords in ymm2 left by amount specified in xmm3/m128 while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSLLQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "G"
    raw_encoding_specification: "EVEX.256.66.0F.W1 F3 /r"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift quadwords in zmm2 left by amount specified in xmm3/m128 while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSLLQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "G"
    raw_encoding_specification: "EVEX.512.66.0F.W1 F3 /r"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift quadwords in xmm2/m128/m64bcst left by imm8 while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSLLQ"
      operands {
        name: "xmm1"
        encoding: VEX_V_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "F"
    raw_encoding_specification: "EVEX.128.66.0F.W1 73 /6 ib"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift quadwords in ymm2/m256/m64bcst left by imm8 while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSLLQ"
      operands {
        name: "ymm1"
        encoding: VEX_V_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "F"
    raw_encoding_specification: "EVEX.256.66.0F.W1 73 /6 ib"
    instruction_group_index: 470
  }
  instructions {
    description: "Shift quadwords in zmm2/m512/m64bcst left by imm8 while shifting in 0s using writemask k1."
    vendor_syntax {
      mnemonic: "VPSLLQ"
      operands {
        name: "zmm1"
        encoding: VEX_V_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "F"
    raw_encoding_specification: "EVEX.512.66.0F.W1 73 /6 ib"
    instruction_group_index: 470
  }
  instructions {
    description: "Select dwords from xmm2 and xmm3/m128 from mask specified in imm8 and store the values into xmm1."
    vendor_syntax {
      mnemonic: "VPBLENDD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVMI"
    raw_encoding_specification: "VEX.128.66.0F3A.W0 02 /r ib"
    instruction_group_index: 471
  }
  instructions {
    description: "Select dwords from ymm2 and ymm3/m256 from mask specified in imm8 and store the values into ymm1."
    vendor_syntax {
      mnemonic: "VPBLENDD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVMI"
    raw_encoding_specification: "VEX.256.66.0F3A.W0 02 /r ib"
    instruction_group_index: 471
  }
  instructions {
    description: "Calculate a RANGE operation output value from 2 singleprecision floating-point values in xmm2 and xmm3/m32, store the output to xmm1 under writemask. Imm8 specifies the comparison and sign of the range operation."
    vendor_syntax {
      mnemonic: "VRANGESS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.LIG.66.0F3A.W0 51 /r"
    instruction_group_index: 472
  }
  instructions {
    description: "Convert one single-precision floating-point value from xmm1/m32 to one unsigned doubleword integer in r32 using truncation."
    vendor_syntax {
      mnemonic: "VCVTTSS2USI"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.LIG.F3.0F.W0 78 /r"
    instruction_group_index: 473
  }
  instructions {
    description: "Convert one single-precision floating-point value from xmm1/m32 to one unsigned quadword integer in r64 using truncation."
    vendor_syntax {
      mnemonic: "VCVTTSS2USI"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.LIG.F3.0F.W1 78 /r"
    instruction_group_index: 473
  }
  instructions {
    description: "Computes Square Roots of the packed single-precision floating-point values in xmm2/m128 and stores the result in xmm1."
    vendor_syntax {
      mnemonic: "SQRTPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 51 /r"
    instruction_group_index: 474
  }
  instructions {
    description: "Computes Square Roots of the packed single-precision floating-point values in xmm2/m128 and stores the result in xmm1."
    vendor_syntax {
      mnemonic: "VSQRTPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.0F.WIG 51 /r"
    instruction_group_index: 474
  }
  instructions {
    description: "Computes Square Roots of the packed single-precision floating-point values in ymm2/m256 and stores the result in ymm1."
    vendor_syntax {
      mnemonic: "VSQRTPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.0F.WIG 51/r"
    instruction_group_index: 474
  }
  instructions {
    description: "Computes Square Roots of the packed single-precision floating-point values in xmm2/m128/m32bcst and stores the result in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VSQRTPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.0F.W0 51 /r"
    instruction_group_index: 474
  }
  instructions {
    description: "Computes Square Roots of the packed single-precision floating-point values in ymm2/m256/m32bcst and stores the result in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VSQRTPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.0F.W0 51 /r"
    instruction_group_index: 474
  }
  instructions {
    description: "Computes Square Roots of the packed single-precision floating-point values in zmm2/m512/m32bcst and stores the result in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VSQRTPS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.0F.W0 51/r"
    instruction_group_index: 474
  }
  instructions {
    description: "Increment SSP by 4 * r32[7:0]."
    vendor_syntax {
      mnemonic: "INCSSPD"
      operands {
        name: "r32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "CET_SS"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "R"
    raw_encoding_specification: "F3 0F AE /05"
    instruction_group_index: 475
  }
  instructions {
    description: "Increment SSP by 8 * r64[7:0]."
    vendor_syntax {
      mnemonic: "INCSSPQ"
      operands {
        name: "r64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "CET_SS"
    available_in_64_bit: true
    encoding_scheme: "R"
    raw_encoding_specification: "F3 REX.W 0F AE /05"
    instruction_group_index: 475
  }
  instructions {
    description: "Computes the approximate reciprocals of the packed singleprecision floating-point values in xmm2/m128/m32bcst and stores the results in xmm1. Under writemask."
    vendor_syntax {
      mnemonic: "VRCP14PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 4C /r"
    instruction_group_index: 476
  }
  instructions {
    description: "Computes the approximate reciprocals of the packed singleprecision floating-point values in ymm2/m256/m32bcst and stores the results in ymm1. Under writemask."
    vendor_syntax {
      mnemonic: "VRCP14PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 4C /r"
    instruction_group_index: 476
  }
  instructions {
    description: "Computes the approximate reciprocals of the packed singleprecision floating-point values in zmm2/m512/m32bcst and stores the results in zmm1. Under writemask."
    vendor_syntax {
      mnemonic: "VRCP14PS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 4C /r"
    instruction_group_index: 476
  }
  instructions {
    description: "Bitwise NOT of 16 bits mask k2."
    vendor_syntax {
      mnemonic: "KNOTW"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RR"
    raw_encoding_specification: "VEX.L0.0F.W0 44 /r"
    instruction_group_index: 477
  }
  instructions {
    description: "Bitwise NOT of 8 bits mask k2."
    vendor_syntax {
      mnemonic: "KNOTB"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RR"
    raw_encoding_specification: "VEX.L0.66.0F.W0 44 /r"
    instruction_group_index: 477
  }
  instructions {
    description: "Bitwise NOT of 64 bits mask k2."
    vendor_syntax {
      mnemonic: "KNOTQ"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RR"
    raw_encoding_specification: "VEX.L0.0F.W1 44 /r"
    instruction_group_index: 477
  }
  instructions {
    description: "Bitwise NOT of 32 bits mask k2."
    vendor_syntax {
      mnemonic: "KNOTD"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RR"
    raw_encoding_specification: "VEX.L0.66.0F.W1 44 /r"
    instruction_group_index: 477
  }
  instructions {
    description: "Merge scalar single-precision floating-point value from xmm2 to xmm1 register."
    vendor_syntax {
      mnemonic: "MOVSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F3 0F 10 /r"
    instruction_group_index: 478
  }
  instructions {
    description: "Load scalar single-precision floating-point value from m32 to xmm1 register."
    vendor_syntax {
      mnemonic: "MOVSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F3 0F 10 /r"
    instruction_group_index: 478
  }
  instructions {
    description: "Merge scalar single-precision floating-point value from xmm2 and xmm3 to xmm1 register"
    vendor_syntax {
      mnemonic: "VMOVSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.LIG.F3.0F.WIG 10 /r"
    instruction_group_index: 478
  }
  instructions {
    description: "Load scalar single-precision floating-point value from m32 to xmm1 register."
    vendor_syntax {
      mnemonic: "VMOVSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "VEX.LIG.F3.0F.WIG 10 /r"
    instruction_group_index: 478
  }
  instructions {
    description: "Move scalar single-precision floating-point value from xmm1 register to xmm2/m32."
    vendor_syntax {
      mnemonic: "MOVSS"
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "F3 0F 11 /r"
    instruction_group_index: 478
  }
  instructions {
    description: "Move scalar single-precision floating-point value from xmm2 and xmm3 to xmm1 register."
    vendor_syntax {
      mnemonic: "VMOVSS"
      operands {
        name: "xmm1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "E"
    raw_encoding_specification: "VEX.LIG.F3.0F.WIG 11 /r"
    instruction_group_index: 478
  }
  instructions {
    description: "Move scalar single-precision floating-point value from xmm1 register to m32."
    vendor_syntax {
      mnemonic: "VMOVSS"
      operands {
        name: "m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "VEX.LIG.F3.0F.WIG 11 /r"
    instruction_group_index: 478
  }
  instructions {
    description: "Move scalar single-precision floating-point value from xmm2 and xmm3 to xmm1 register under writemask k1."
    vendor_syntax {
      mnemonic: "VMOVSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.LIG.F3.0F.W0 10 /r"
    instruction_group_index: 478
  }
  instructions {
    description: "Move scalar single-precision floating-point values from m32 to xmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VMOVSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "F"
    raw_encoding_specification: "EVEX.LIG.F3.0F.W0 10 /r"
    instruction_group_index: 478
  }
  instructions {
    description: "Move scalar single-precision floating-point value from xmm2 and xmm3 to xmm1 register under writemask k1."
    vendor_syntax {
      mnemonic: "VMOVSS"
      operands {
        name: "xmm1"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "E"
    raw_encoding_specification: "EVEX.LIG.F3.0F.W0 11 /r"
    instruction_group_index: 478
  }
  instructions {
    description: "Move scalar single-precision floating-point values from xmm1 to m32 under writemask k1."
    vendor_syntax {
      mnemonic: "VMOVSS"
      operands {
        name: "m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "G"
    raw_encoding_specification: "EVEX.LIG.F3.0F.W0 11 /r"
    instruction_group_index: 478
  }
  instructions {
    description: "Shuffle the doublewords in xmm2/m128 based on the encoding in imm8 and store the result in xmm1."
    vendor_syntax {
      mnemonic: "PSHUFD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 70 /r ib"
    instruction_group_index: 479
  }
  instructions {
    description: "Shuffle the doublewords in xmm2/m128 based on the encoding in imm8 and store the result in xmm1."
    vendor_syntax {
      mnemonic: "VPSHUFD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F.WIG 70 /r ib"
    instruction_group_index: 479
  }
  instructions {
    description: "Shuffle the doublewords in ymm2/m256 based on the encoding in imm8 and store the result in ymm1."
    vendor_syntax {
      mnemonic: "VPSHUFD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F.WIG 70 /r ib"
    instruction_group_index: 479
  }
  instructions {
    description: "Shuffle the doublewords in xmm2/m128/m32bcst based on the encoding in imm8 and store the result in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPSHUFD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F.W0 70 /r ib"
    instruction_group_index: 479
  }
  instructions {
    description: "Shuffle the doublewords in ymm2/m256/m32bcst based on the encoding in imm8 and store the result in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPSHUFD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F.W0 70 /r ib"
    instruction_group_index: 479
  }
  instructions {
    description: "Shuffle the doublewords in zmm2/m512/m32bcst based on the encoding in imm8 and store the result in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPSHUFD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F.W0 70 /r ib"
    instruction_group_index: 479
  }
  instructions {
    description: "Specifies the start of an RTM region. Provides a 16-bit relative offset to compute the address of the fallback instruction address at which execution resumes following an RTM abort."
    vendor_syntax {
      mnemonic: "XBEGIN"
      operands {
        name: "rel16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "RTM"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "C7 F8"
    instruction_group_index: 480
  }
  instructions {
    description: "Specifies the start of an RTM region. Provides a 32-bit relative offset to compute the address of the fallback instruction address at which execution resumes following an RTM abort."
    vendor_syntax {
      mnemonic: "XBEGIN"
      operands {
        name: "rel32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "RTM"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "C7 F8"
    instruction_group_index: 480
  }
  instructions {
    description: "Read a 16-bit NIST SP800-90B & C compliant random value and store in the destination register."
    vendor_syntax {
      mnemonic: "RDSEED"
      operands {
        name: "r16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    feature_name: "RDSEED"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "NFx 0F C7 /7"
    instruction_group_index: 481
  }
  instructions {
    description: "Read a 32-bit NIST SP800-90B & C compliant random value and store in the destination register."
    vendor_syntax {
      mnemonic: "RDSEED"
      operands {
        name: "r32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    feature_name: "RDSEED"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "NFx 0F C7 /7"
    instruction_group_index: 481
  }
  instructions {
    description: "Read a 64-bit NIST SP800-90B & C compliant random value and store in the destination register."
    vendor_syntax {
      mnemonic: "RDSEED"
      operands {
        name: "r64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    feature_name: "RDSEED"
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "NFx REX.W + 0F C7 /7"
    instruction_group_index: 481
  }
  instructions {
    description: "Sign extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1."
    vendor_syntax {
      mnemonic: "PMOVSXBW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0f 38 20 /r"
    instruction_group_index: 482
  }
  instructions {
    description: "Sign extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1."
    vendor_syntax {
      mnemonic: "PMOVSXBD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0f 38 21 /r"
    instruction_group_index: 482
  }
  instructions {
    description: "Sign extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1."
    vendor_syntax {
      mnemonic: "PMOVSXBQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0f 38 22 /r"
    instruction_group_index: 482
  }
  instructions {
    description: "Sign extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1."
    vendor_syntax {
      mnemonic: "PMOVSXWD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0f 38 23/r"
    instruction_group_index: 482
  }
  instructions {
    description: "Sign extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1."
    vendor_syntax {
      mnemonic: "PMOVSXWQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0f 38 24 /r"
    instruction_group_index: 482
  }
  instructions {
    description: "Sign extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1."
    vendor_syntax {
      mnemonic: "PMOVSXDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0f 38 25 /r"
    instruction_group_index: 482
  }
  instructions {
    description: "Sign extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1."
    vendor_syntax {
      mnemonic: "VPMOVSXBW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.WIG 20 /r"
    instruction_group_index: 482
  }
  instructions {
    description: "Sign extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1."
    vendor_syntax {
      mnemonic: "VPMOVSXBD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.WIG 21 /r"
    instruction_group_index: 482
  }
  instructions {
    description: "Sign extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1."
    vendor_syntax {
      mnemonic: "VPMOVSXBQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.WIG 22 /r"
    instruction_group_index: 482
  }
  instructions {
    description: "Sign extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1."
    vendor_syntax {
      mnemonic: "VPMOVSXWD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.WIG 23 /r"
    instruction_group_index: 482
  }
  instructions {
    description: "Sign extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1."
    vendor_syntax {
      mnemonic: "VPMOVSXWQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.WIG 24 /r"
    instruction_group_index: 482
  }
  instructions {
    description: "Sign extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1."
    vendor_syntax {
      mnemonic: "VPMOVSXDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.WIG 25 /r"
    instruction_group_index: 482
  }
  instructions {
    description: "Sign extend 16 packed 8-bit integers in xmm2/m128 to 16 packed 16-bit integers in ymm1."
    vendor_syntax {
      mnemonic: "VPMOVSXBW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.WIG 20 /r"
    instruction_group_index: 482
  }
  instructions {
    description: "Sign extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 32-bit integers in ymm1."
    vendor_syntax {
      mnemonic: "VPMOVSXBD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.WIG 21 /r"
    instruction_group_index: 482
  }
  instructions {
    description: "Sign extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 64-bit integers in ymm1."
    vendor_syntax {
      mnemonic: "VPMOVSXBQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.WIG 22 /r"
    instruction_group_index: 482
  }
  instructions {
    description: "Sign extend 8 packed 16-bit integers in the low 16 bytes of xmm2/m128 to 8 packed 32-bit integers in ymm1."
    vendor_syntax {
      mnemonic: "VPMOVSXWD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.WIG 23 /r"
    instruction_group_index: 482
  }
  instructions {
    description: "Sign extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 64-bit integers in ymm1."
    vendor_syntax {
      mnemonic: "VPMOVSXWQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.WIG 24 /r"
    instruction_group_index: 482
  }
  instructions {
    description: "Sign extend 4 packed 32-bit integers in the low 16 bytes of xmm2/m128 to 4 packed 64-bit integers in ymm1."
    vendor_syntax {
      mnemonic: "VPMOVSXDQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.WIG 25 /r"
    instruction_group_index: 482
  }
  instructions {
    description: "Sign extend 8 packed 8-bit integers in xmm2/m64 to 8 packed 16-bit integers in zmm1."
    vendor_syntax {
      mnemonic: "VPMOVSXBW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.WIG 20 /r"
    instruction_group_index: 482
  }
  instructions {
    description: "Sign extend 16 packed 8-bit integers in xmm2/m128 to 16 packed 16-bit integers in ymm1."
    vendor_syntax {
      mnemonic: "VPMOVSXBW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.WIG 20 /r"
    instruction_group_index: 482
  }
  instructions {
    description: "Sign extend 32 packed 8-bit integers in ymm2/m256 to 32 packed 16-bit integers in zmm1."
    vendor_syntax {
      mnemonic: "VPMOVSXBW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.WIG 20 /r"
    instruction_group_index: 482
  }
  instructions {
    description: "Sign extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVSXBD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F38.WIG 21 /r"
    instruction_group_index: 482
  }
  instructions {
    description: "Sign extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 32-bit integers in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVSXBD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38.WIG 21 /r"
    instruction_group_index: 482
  }
  instructions {
    description: "Sign extend 16 packed 8-bit integers in the low 16 bytes of xmm2/m128 to 16 packed 32-bit integers in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVSXBD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38.WIG 21 /r"
    instruction_group_index: 482
  }
  instructions {
    description: "Sign extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVSXBQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.128.66.0F38.WIG 22 /r"
    instruction_group_index: 482
  }
  instructions {
    description: "Sign extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 64-bit integers in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVSXBQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.256.66.0F38.WIG 22 /r"
    instruction_group_index: 482
  }
  instructions {
    description: "Sign extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 64-bit integers in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVSXBQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.66.0F38.WIG 22 /r"
    instruction_group_index: 482
  }
  instructions {
    description: "Sign extend 4 packed 16-bit integers in the low 8 bytes of ymm2/mem to 4 packed 32-bit integers in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVSXWD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.WIG 23 /r"
    instruction_group_index: 482
  }
  instructions {
    description: "Sign extend 8 packed 16-bit integers in the low 16 bytes of ymm2/m128 to 8 packed 32-bit integers in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVSXWD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.WIG 23 /r"
    instruction_group_index: 482
  }
  instructions {
    description: "Sign extend 16 packed 16-bit integers in the low 32 bytes of ymm2/m256 to 16 packed 32-bit integers in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVSXWD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.WIG 23 /r"
    instruction_group_index: 482
  }
  instructions {
    description: "Sign extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVSXWQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F38.WIG 24 /r"
    instruction_group_index: 482
  }
  instructions {
    description: "Sign extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 64-bit integers in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVSXWQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38.WIG 24 /r"
    instruction_group_index: 482
  }
  instructions {
    description: "Sign extend 8 packed 16-bit integers in the low 16 bytes of xmm2/m128 to 8 packed 64-bit integers in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVSXWQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38.WIG 24 /r"
    instruction_group_index: 482
  }
  instructions {
    description: "Sign extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVSXDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 25 /r"
    instruction_group_index: 482
  }
  instructions {
    description: "Sign extend 4 packed 32-bit integers in the low 16 bytes of xmm2/m128 to 4 packed 64-bit integers in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVSXDQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 25 /r"
    instruction_group_index: 482
  }
  instructions {
    description: "Sign extend 8 packed 32-bit integers in the low 32 bytes of ymm2/m256 to 8 packed 64-bit integers in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVSXDQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 25 /r"
    instruction_group_index: 482
  }
  instructions {
    description: "Convert two packed quadword integers from xmm2/mem to packed single-precision floating-point values in xmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTQQ2PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.0F.W1 5B /r"
    instruction_group_index: 483
  }
  instructions {
    description: "Convert four packed quadword integers from ymm2/mem to packed single-precision floating-point values in xmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTQQ2PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.0F.W1 5B /r"
    instruction_group_index: 483
  }
  instructions {
    description: "Convert eight packed quadword integers from zmm2/mem to eight packed single-precision floating-point values in ymm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTQQ2PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.0F.W1 5B /r"
    instruction_group_index: 483
  }
  instructions {
    description: "Unsigned multiply of r/m32 with EDX without affecting arithmetic flags."
    vendor_syntax {
      mnemonic: "MULX"
      operands {
        name: "r32a"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r32b"
        encoding: VEX_V_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "BMI2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.LZ.F2.0F38.W0 F6 /r"
    instruction_group_index: 484
  }
  instructions {
    description: "Unsigned multiply of r/m64 with RDX without affecting arithmetic flags."
    vendor_syntax {
      mnemonic: "MULX"
      operands {
        name: "r64a"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r64b"
        encoding: VEX_V_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "BMI2"
    available_in_64_bit: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.LZ.F2.0F38.W1 F6 /r"
    instruction_group_index: 484
  }
  instructions {
    description: "Store machine status word to r/m16."
    vendor_syntax {
      mnemonic: "SMSW"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 01 /4"
    instruction_group_index: 485
  }
  instructions {
    description: "Store machine status word in low-order 16 bits of r32/m16; high-order 16 bits of r32 are undefined."
    vendor_syntax {
      mnemonic: "SMSW"
      operands {
        name: "r32/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 01 /4"
    instruction_group_index: 485
  }
  instructions {
    description: "Store machine status word in low-order 16 bits of r64/m16; high-order 16 bits of r32 are undefined."
    vendor_syntax {
      mnemonic: "SMSW"
      operands {
        name: "r64/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX.W + 0F 01 /4"
    instruction_group_index: 485
  }
  instructions {
    description: "Convert two packed signed doubleword integers from xmm2/mem to two packed double-precision floatingpoint values in xmm1."
    vendor_syntax {
      mnemonic: "CVTDQ2PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F3 0F E6 /r"
    instruction_group_index: 486
  }
  instructions {
    description: "Convert two packed signed doubleword integers from xmm2/mem to two packed double-precision floatingpoint values in xmm1."
    vendor_syntax {
      mnemonic: "VCVTDQ2PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.F3.0F.WIG E6 /r"
    instruction_group_index: 486
  }
  instructions {
    description: "Convert four packed signed doubleword integers from xmm2/mem to four packed double-precision floatingpoint values in ymm1."
    vendor_syntax {
      mnemonic: "VCVTDQ2PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.F3.0F.WIG E6 /r"
    instruction_group_index: 486
  }
  instructions {
    description: "Convert 2 packed signed doubleword integers from xmm2/m64/m32bcst to eight packed double-precision floating-point values in xmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTDQ2PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.F3.0F.W0 E6 /r"
    instruction_group_index: 486
  }
  instructions {
    description: "Convert 4 packed signed doubleword integers from xmm2/m128/m32bcst to 4 packed double-precision floating-point values in ymm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTDQ2PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.F3.0F.W0 E6 /r"
    instruction_group_index: 486
  }
  instructions {
    description: "Convert eight packed signed doubleword integers from ymm2/m256/m32bcst to eight packed double-precision floating-point values in zmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTDQ2PD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.F3.0F.W0 E6 /r"
    instruction_group_index: 486
  }
  instructions {
    description: "Clear CF flag."
    vendor_syntax {
      mnemonic: "CLC"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F8"
    instruction_group_index: 487
  }
  instructions {
    description: "Store IDTR to m."
    vendor_syntax {
      mnemonic: "SIDT"
      operands {
        name: "m"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 01 /1"
    instruction_group_index: 488
  }
  instructions {
    description: "Convert one double-precision floating-point value from xmm1/m64 to one unsigned doubleword integer r32 using truncation."
    vendor_syntax {
      mnemonic: "VCVTTSD2USI"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.LIG.F2.0F.W0 78 /r"
    instruction_group_index: 489
  }
  instructions {
    description: "Convert one double-precision floating-point value from xmm1/m64 to one unsigned quadword integer zeroextended into r64 using truncation."
    vendor_syntax {
      mnemonic: "VCVTTSD2USI"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.LIG.F2.0F.W1 78 /r"
    instruction_group_index: 489
  }
  instructions {
    description: "Carry-less multiplication of one quadword of xmm1 by one quadword of xmm2/m128, stores the 128-bit result in xmm1. The immediate is used to determine which quadwords of xmm1 and xmm2/m128 should be used."
    vendor_syntax {
      mnemonic: "PCLMULQDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "CLMUL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 3A 44 /r ib"
    instruction_group_index: 490
  }
  instructions {
    description: "Carry-less multiplication of one quadword of xmm2 by one quadword of xmm3/m128, stores the 128-bit result in xmm1. The immediate is used to determine which quadwords of xmm2 and xmm3/m128 should be used."
    vendor_syntax {
      mnemonic: "VPCLMULQDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "CLMUL && AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F3A.WIG 44 /r ib"
    instruction_group_index: 490
  }
  instructions {
    description: "Carry-less multiplication of one quadword of ymm2 by one quadword of ymm3/m256, stores the 128-bit result in ymm1. The immediate is used to determine which quadwords of ymm2 and ymm3/m256 should be used."
    vendor_syntax {
      mnemonic: "VPCLMULQDQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "VPCLMULQDQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "VEX.256.66.0F3A.WIG 44 /r /ib"
    instruction_group_index: 490
  }
  instructions {
    description: "Carry-less multiplication of one quadword of xmm2 by one quadword of xmm3/m128, stores the 128-bit result in xmm1. The immediate is used to determine which quadwords of xmm2 and xmm3/m128 should be used."
    vendor_syntax {
      mnemonic: "VPCLMULQDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "VPCLMULQDQ && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.128.66.0F3A.WIG 44 /r /ib"
    instruction_group_index: 490
  }
  instructions {
    description: "Carry-less multiplication of one quadword of ymm2 by one quadword of ymm3/m256, stores the 128-bit result in ymm1. The immediate is used to determine which quadwords of ymm2 and ymm3/m256 should be used."
    vendor_syntax {
      mnemonic: "VPCLMULQDQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "VPCLMULQDQ && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.256.66.0F3A.WIG 44 /r /ib"
    instruction_group_index: 490
  }
  instructions {
    description: "Carry-less multiplication of one quadword of zmm2 by one quadword of zmm3/m512, stores the 128-bit result in zmm1. The immediate is used to determine which quadwords of zmm2 and zmm3/m512 should be used."
    vendor_syntax {
      mnemonic: "VPCLMULQDQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "VPCLMULQDQ && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.66.0F3A.WIG 44 /r /ib"
    instruction_group_index: 490
  }
  instructions {
    description: "Compare low double-precision floating-point value in xmm2/m64 and xmm1 using bits 2:0 of imm8 as comparison predicate."
    vendor_syntax {
      mnemonic: "CMPSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F2 0F C2 /r ib"
    instruction_group_index: 491
  }
  instructions {
    description: "Compare low double-precision floating-point value in xmm3/m64 and xmm2 using bits 4:0 of imm8 as comparison predicate."
    vendor_syntax {
      mnemonic: "VCMPSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.LIG.F2.0F.WIG C2 /r ib"
    instruction_group_index: 491
  }
  instructions {
    description: "Compare low double-precision floating-point value in xmm3/m64 and xmm2 using bits 4:0 of imm8 as comparison predicate with writemask k2 and leave the result in mask register k1."
    vendor_syntax {
      mnemonic: "VCMPSD"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.LIG.F2.0F.W1 C2 /r ib"
    instruction_group_index: 491
  }
  instructions {
    description: "Load: r16 := segment limit, selector r16/m16."
    vendor_syntax {
      mnemonic: "LSL"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r16/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 03 /r"
    instruction_group_index: 492
  }
  instructions {
    description: "Load: r32 := segment limit, selector r32/m16."
    vendor_syntax {
      mnemonic: "LSL"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r32/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 03 /r"
    instruction_group_index: 492
  }
  instructions {
    description: "Load: r64 := segment limit, selector r32/m16"
    vendor_syntax {
      mnemonic: "LSL"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r32/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 0F 03 /r"
    instruction_group_index: 492
  }
  instructions {
    description: "Multiply packed single-precision floating-point values in xmm2/m128 with xmm1 and store result in xmm1."
    vendor_syntax {
      mnemonic: "MULPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 59 /r"
    instruction_group_index: 493
  }
  instructions {
    description: "Multiply packed single-precision floating-point values in xmm3/m128 with xmm2 and store result in xmm1."
    vendor_syntax {
      mnemonic: "VMULPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.0F.WIG 59 /r"
    instruction_group_index: 493
  }
  instructions {
    description: "Multiply packed single-precision floating-point values in ymm3/m256 with ymm2 and store result in ymm1."
    vendor_syntax {
      mnemonic: "VMULPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.0F.WIG 59 /r"
    instruction_group_index: 493
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from xmm3/m128/m32bcst to xmm2 and store result in xmm1."
    vendor_syntax {
      mnemonic: "VMULPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.0F.W0 59 /r"
    instruction_group_index: 493
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from ymm3/m256/m32bcst to ymm2 and store result in ymm1."
    vendor_syntax {
      mnemonic: "VMULPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.0F.W0 59 /r"
    instruction_group_index: 493
  }
  instructions {
    description: "Multiply packed single-precision floating-point values in zmm3/m512/m32bcst with zmm2 and store result in zmm1."
    vendor_syntax {
      mnemonic: "VMULPS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.0F.W0 59 /r"
    instruction_group_index: 493
  }
  instructions {
    description: "Shift r/m32 arithmetically right with count specified in r32b."
    vendor_syntax {
      mnemonic: "SARX"
      operands {
        name: "r32a"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r32b"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "BMI2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMV"
    raw_encoding_specification: "VEX.LZ.F3.0F38.W0 F7 /r"
    instruction_group_index: 494
  }
  instructions {
    description: "Shift r/m32 logically left with count specified in r32b."
    vendor_syntax {
      mnemonic: "SHLX"
      operands {
        name: "r32a"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r32b"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "BMI2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMV"
    raw_encoding_specification: "VEX.LZ.66.0F38.W0 F7 /r"
    instruction_group_index: 494
  }
  instructions {
    description: "Shift r/m32 logically right with count specified in r32b."
    vendor_syntax {
      mnemonic: "SHRX"
      operands {
        name: "r32a"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r32b"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "BMI2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMV"
    raw_encoding_specification: "VEX.LZ.F2.0F38.W0 F7 /r"
    instruction_group_index: 494
  }
  instructions {
    description: "Shift r/m64 arithmetically right with count specified in r64b."
    vendor_syntax {
      mnemonic: "SARX"
      operands {
        name: "r64a"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r64b"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "BMI2"
    available_in_64_bit: true
    encoding_scheme: "RMV"
    raw_encoding_specification: "VEX.LZ.F3.0F38.W1 F7 /r"
    instruction_group_index: 494
  }
  instructions {
    description: "Shift r/m64 logically left with count specified in r64b."
    vendor_syntax {
      mnemonic: "SHLX"
      operands {
        name: "r64a"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r64b"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "BMI2"
    available_in_64_bit: true
    encoding_scheme: "RMV"
    raw_encoding_specification: "VEX.LZ.66.0F38.W1 F7 /r"
    instruction_group_index: 494
  }
  instructions {
    description: "Shift r/m64 logically right with count specified in r64b."
    vendor_syntax {
      mnemonic: "SHRX"
      operands {
        name: "r64a"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r64b"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "BMI2"
    available_in_64_bit: true
    encoding_scheme: "RMV"
    raw_encoding_specification: "VEX.LZ.F2.0F38.W1 F7 /r"
    instruction_group_index: 494
  }
  instructions {
    description: "Sets tag for ST(i) to empty."
    vendor_syntax {
      mnemonic: "FFREE"
      operands {
        name: "ST(i)"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DD C0+i"
    instruction_group_index: 495
  }
  instructions {
    description: "Convert two packed double-precision floating-point values in xmm2/m128/m64bcst to two unsigned doubleword integers in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VCVTPD2UDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.0F.W1 79 /r"
    instruction_group_index: 496
  }
  instructions {
    description: "Convert four packed double-precision floating-point values in ymm2/m256/m64bcst to four unsigned doubleword integers in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VCVTPD2UDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.0F.W1 79 /r"
    instruction_group_index: 496
  }
  instructions {
    description: "Convert eight packed double-precision floating-point values in zmm2/m512/m64bcst to eight unsigned doubleword integers in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VCVTPD2UDQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.0F.W1 79 /r"
    instruction_group_index: 496
  }
  instructions {
    description: "Permute 128-bit floating-point fields in ymm2 and ymm3/mem using controls from imm8 and store result in ymm1."
    vendor_syntax {
      mnemonic: "VPERM2F128"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVMI"
    raw_encoding_specification: "VEX.256.66.0F3A.W0 06 /r ib"
    instruction_group_index: 497
  }
  instructions {
    description: "Multiply unsigned 52-bit integers in xmm2 and xmm3/m128 and add the high 52 bits of the 104- bit product to the qword unsigned integers in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPMADD52HUQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_IFMA && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 B5 /r"
    instruction_group_index: 498
  }
  instructions {
    description: "Multiply unsigned 52-bit integers in ymm2 and ymm3/m256 and add the high 52 bits of the 104- bit product to the qword unsigned integers in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPMADD52HUQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_IFMA && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 B5 /r"
    instruction_group_index: 498
  }
  instructions {
    description: "Multiply unsigned 52-bit integers in zmm2 and zmm3/m512 and add the high 52 bits of the 104- bit product to the qword unsigned integers in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPMADD52HUQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_IFMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 B5 /r"
    instruction_group_index: 498
  }
  instructions {
    description: "Write 4 bytes to shadow stack."
    vendor_syntax {
      mnemonic: "WRSSD"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "CET_SS"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "0F 38 F6"
    instruction_group_index: 499
  }
  instructions {
    description: "Write 8 bytes to shadow stack."
    vendor_syntax {
      mnemonic: "WRSSQ"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "CET_SS"
    available_in_64_bit: true
    encoding_scheme: "MR"
    raw_encoding_specification: "REX.W 0F 38 F6"
    instruction_group_index: 499
  }
  instructions {
    description: "Reads the data from r64/m64 to encode into a PTW packet if dependencies are met (see details below)."
    vendor_syntax {
      mnemonic: "PTWRITE"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "F3 REX.W 0F AE /4"
    instruction_group_index: 500
  }
  instructions {
    description: "Reads the data from r32/m32 to encode into a PTW packet if dependencies are met (see details below)."
    vendor_syntax {
      mnemonic: "PTWRITE"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "F3 0F AE /4"
    instruction_group_index: 500
  }
  instructions {
    description: "Read 64-bit time-stamp counter and IA32_TSC_AUX value into EDX:EAX and ECX."
    vendor_syntax {
      mnemonic: "RDTSCP"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "0F 01 F9"
    instruction_group_index: 501
  }
  instructions {
    description: "Broadcast low byte value in k1 to two locations in xmm1."
    vendor_syntax {
      mnemonic: "VPBROADCASTMB2Q"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512CD"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "EVEX.128.F3.0F38.W1 2A /r"
    instruction_group_index: 502
  }
  instructions {
    description: "Broadcast low byte value in k1 to four locations in ymm1."
    vendor_syntax {
      mnemonic: "VPBROADCASTMB2Q"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512CD"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "EVEX.256.F3.0F38.W1 2A /r"
    instruction_group_index: 502
  }
  instructions {
    description: "Broadcast low byte value in k1 to eight locations in zmm1."
    vendor_syntax {
      mnemonic: "VPBROADCASTMB2Q"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512CD"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "EVEX.512.F3.0F38.W1 2A /r"
    instruction_group_index: 502
  }
  instructions {
    description: "Broadcast low word value in k1 to four locations in xmm1."
    vendor_syntax {
      mnemonic: "VPBROADCASTMW2D"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512CD"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "EVEX.128.F3.0F38.W0 3A /r"
    instruction_group_index: 502
  }
  instructions {
    description: "Broadcast low word value in k1 to eight locations in ymm1."
    vendor_syntax {
      mnemonic: "VPBROADCASTMW2D"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512CD"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "EVEX.256.F3.0F38.W0 3A /r"
    instruction_group_index: 502
  }
  instructions {
    description: "Broadcast low word value in k1 to sixteen locations in zmm1."
    vendor_syntax {
      mnemonic: "VPBROADCASTMW2D"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512CD"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "EVEX.512.F3.0F38.W0 3A /r"
    instruction_group_index: 502
  }
  instructions {
    description: "Insert a byte integer value from r32/m8 into xmm1 at the destination element in xmm1 specified by imm8."
    vendor_syntax {
      mnemonic: "PINSRB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r32/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 3A 20 /r ib"
    instruction_group_index: 503
  }
  instructions {
    description: "Insert a dword integer value from r/m32 into the xmm1 at the destination element specified by imm8."
    vendor_syntax {
      mnemonic: "PINSRD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 3A 22 /r ib"
    instruction_group_index: 503
  }
  instructions {
    description: "Insert a qword integer value from r/m64 into the xmm1 at the destination element specified by imm8."
    vendor_syntax {
      mnemonic: "PINSRQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 REX.W 0F 3A 22 /r ib"
    instruction_group_index: 503
  }
  instructions {
    description: "Merge a byte integer value from r32/m8 and rest from xmm2 into xmm1 at the byte offset in imm8."
    vendor_syntax {
      mnemonic: "VPINSRB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r32/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F3A.W0 20 /r ib"
    instruction_group_index: 503
  }
  instructions {
    description: "Insert a dword integer value from r32/m32 and rest from xmm2 into xmm1 at the dword offset in imm8."
    vendor_syntax {
      mnemonic: "VPINSRD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F3A.W0 22 /r ib"
    instruction_group_index: 503
  }
  instructions {
    description: "Insert a qword integer value from r64/m64 and rest from xmm2 into xmm1 at the qword offset in imm8."
    vendor_syntax {
      mnemonic: "VPINSRQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F3A.W1 22 /r ib"
    instruction_group_index: 503
  }
  instructions {
    description: "Merge a byte integer value from r32/m8 and rest from xmm2 into xmm1 at the byte offset in imm8."
    vendor_syntax {
      mnemonic: "VPINSRB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r32/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F3A.WIG 20 /r ib"
    instruction_group_index: 503
  }
  instructions {
    description: "Insert a dword integer value from r32/m32 and rest from xmm2 into xmm1 at the dword offset in imm8."
    vendor_syntax {
      mnemonic: "VPINSRD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F3A.W0 22 /r ib"
    instruction_group_index: 503
  }
  instructions {
    description: "Insert a qword integer value from r64/m64 and rest from xmm2 into xmm1 at the qword offset in imm8."
    vendor_syntax {
      mnemonic: "VPINSRQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F3A.W1 22 /r ib"
    instruction_group_index: 503
  }
  instructions {
    description: "Concatenate destination and source operands, extract result shifted to the right by constant value in imm8 into xmm1."
    vendor_syntax {
      mnemonic: "VPSHRDW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2 && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F3A.W1 72 /r /ib"
    instruction_group_index: 504
  }
  instructions {
    description: "Concatenate destination and source operands, extract result shifted to the right by constant value in imm8 into ymm1."
    vendor_syntax {
      mnemonic: "VPSHRDW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2 && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F3A.W1 72 /r /ib"
    instruction_group_index: 504
  }
  instructions {
    description: "Concatenate destination and source operands, extract result shifted to the right by constant value in imm8 into zmm1."
    vendor_syntax {
      mnemonic: "VPSHRDW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F3A.W1 72 /r /ib"
    instruction_group_index: 504
  }
  instructions {
    description: "Concatenate destination and source operands, extract result shifted to the right by constant value in imm8 into xmm1."
    vendor_syntax {
      mnemonic: "VPSHRDD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2 && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F3A.W0 73 /r /ib"
    instruction_group_index: 504
  }
  instructions {
    description: "Concatenate destination and source operands, extract result shifted to the right by constant value in imm8 into ymm1."
    vendor_syntax {
      mnemonic: "VPSHRDD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2 && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F3A.W0 73 /r /ib"
    instruction_group_index: 504
  }
  instructions {
    description: "Concatenate destination and source operands, extract result shifted to the right by constant value in imm8 into zmm1."
    vendor_syntax {
      mnemonic: "VPSHRDD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F3A.W0 73 /r /ib"
    instruction_group_index: 504
  }
  instructions {
    description: "Concatenate destination and source operands, extract result shifted to the right by constant value in imm8 into xmm1."
    vendor_syntax {
      mnemonic: "VPSHRDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2 && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F3A.W1 73 /r /ib"
    instruction_group_index: 504
  }
  instructions {
    description: "Concatenate destination and source operands, extract result shifted to the right by constant value in imm8 into ymm1."
    vendor_syntax {
      mnemonic: "VPSHRDQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2 && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F3A.W1 73 /r /ib"
    instruction_group_index: 504
  }
  instructions {
    description: "Concatenate destination and source operands, extract result shifted to the right by constant value in imm8 into zmm1."
    vendor_syntax {
      mnemonic: "VPSHRDQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F3A.W1 73 /r /ib"
    instruction_group_index: 504
  }
  instructions {
    description: "Move lower and upper bound from bnd2/m64 to bound register bnd1."
    vendor_syntax {
      mnemonic: "BNDMOV"
      operands {
        name: "bnd1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "bnd2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MPX"
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "66 0F 1A /r"
    instruction_group_index: 505
  }
  instructions {
    description: "Move lower and upper bound from bnd2/m128 to bound register bnd1."
    vendor_syntax {
      mnemonic: "BNDMOV"
      operands {
        name: "bnd1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "bnd2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MPX"
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "66 0F 1A /r"
    instruction_group_index: 505
  }
  instructions {
    description: "Move lower and upper bound from bnd2 to bnd1/m64."
    vendor_syntax {
      mnemonic: "BNDMOV"
      operands {
        name: "bnd1/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "bnd2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MPX"
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "66 0F 1B /r"
    instruction_group_index: 505
  }
  instructions {
    description: "Move lower and upper bound from bnd2 to bound register bnd1/m128."
    vendor_syntax {
      mnemonic: "BNDMOV"
      operands {
        name: "bnd1/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "bnd2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MPX"
    available_in_64_bit: true
    encoding_scheme: "MR"
    raw_encoding_specification: "66 0F 1B /r"
    instruction_group_index: 505
  }
  instructions {
    description: "Move debug register to r32."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "r32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "DR0-DR7"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "0F 21/r"
    instruction_group_index: 506
  }
  instructions {
    description: "Move extended debug register to r64."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "r64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "DR0-DR7"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MR"
    raw_encoding_specification: "0F 21/r"
    instruction_group_index: 506
  }
  instructions {
    description: "Move r32 to debug register."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "DR0-DR7"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 23 /r"
    instruction_group_index: 506
  }
  instructions {
    description: "Move r64 to extended debug register."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "DR0-DR7"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 23 /r"
    instruction_group_index: 506
  }
  instructions {
    description: "Compare packed unsigned dword integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1."
    vendor_syntax {
      mnemonic: "PMAXUD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 38 3F /r"
    instruction_group_index: 507
  }
  instructions {
    description: "Compare packed unsigned dword integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1."
    vendor_syntax {
      mnemonic: "VPMAXUD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F38.WIG 3F /r"
    instruction_group_index: 507
  }
  instructions {
    description: "Compare packed unsigned dword integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1."
    vendor_syntax {
      mnemonic: "VPMAXUD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F38.WIG 3F /r"
    instruction_group_index: 507
  }
  instructions {
    description: "Compare packed unsigned dword integers in xmm2 and xmm3/m128/m32bcst and store packed maximum values in xmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMAXUD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 3F /r"
    instruction_group_index: 507
  }
  instructions {
    description: "Compare packed unsigned dword integers in ymm2 and ymm3/m256/m32bcst and store packed maximum values in ymm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMAXUD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 3F /r"
    instruction_group_index: 507
  }
  instructions {
    description: "Compare packed unsigned dword integers in zmm2 and zmm3/m512/m32bcst and store packed maximum values in zmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMAXUD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 3F /r"
    instruction_group_index: 507
  }
  instructions {
    description: "Compare packed unsigned qword integers in xmm2 and xmm3/m128/m64bcst and store packed maximum values in xmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMAXUQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 3F /r"
    instruction_group_index: 507
  }
  instructions {
    description: "Compare packed unsigned qword integers in ymm2 and ymm3/m256/m64bcst and store packed maximum values in ymm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMAXUQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 3F /r"
    instruction_group_index: 507
  }
  instructions {
    description: "Compare packed unsigned qword integers in zmm2 and zmm3/m512/m64bcst and store packed maximum values in zmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMAXUQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 3F /r"
    instruction_group_index: 507
  }
  instructions {
    description: "Move data from m8 closer to the processor in anticipation of a write."
    vendor_syntax {
      mnemonic: "PREFETCHW"
      operands {
        name: "m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "PREFETCHW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 0D /1"
    instruction_group_index: 508
  }
  instructions {
    description: "Rotate 9 bits (CF, r/m8) left once."
    vendor_syntax {
      mnemonic: "RCL"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "1"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M1"
    raw_encoding_specification: "D0 /2"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 9 bits (CF, r/m8) left once."
    vendor_syntax {
      mnemonic: "RCL"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "1"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M1"
    raw_encoding_specification: "REX + D0 /2"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 9 bits (CF, r/m8) left CL times."
    vendor_syntax {
      mnemonic: "RCL"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MC"
    raw_encoding_specification: "D2 /2"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 9 bits (CF, r/m8) left CL times."
    vendor_syntax {
      mnemonic: "RCL"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MC"
    raw_encoding_specification: "REX + D2 /2"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 9 bits (CF, r/m8) left imm8 times."
    vendor_syntax {
      mnemonic: "RCL"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "C0 /2 ib"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 9 bits (CF, r/m8) left imm8 times."
    vendor_syntax {
      mnemonic: "RCL"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX + C0 /2 ib"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 17 bits (CF, r/m16) left once."
    vendor_syntax {
      mnemonic: "RCL"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "1"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M1"
    raw_encoding_specification: "D1 /2"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 17 bits (CF, r/m16) left CL times."
    vendor_syntax {
      mnemonic: "RCL"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MC"
    raw_encoding_specification: "D3 /2"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 17 bits (CF, r/m16) left imm8 times."
    vendor_syntax {
      mnemonic: "RCL"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "C1 /2 ib"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 33 bits (CF, r/m32) left once."
    vendor_syntax {
      mnemonic: "RCL"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "1"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M1"
    raw_encoding_specification: "D1 /2"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 65 bits (CF, r/m64) left once. Uses a 6 bit count."
    vendor_syntax {
      mnemonic: "RCL"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "1"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M1"
    raw_encoding_specification: "REX.W + D1 /2"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 33 bits (CF, r/m32) left CL times."
    vendor_syntax {
      mnemonic: "RCL"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MC"
    raw_encoding_specification: "D3 /2"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 65 bits (CF, r/m64) left CL times. Uses a 6 bit count."
    vendor_syntax {
      mnemonic: "RCL"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MC"
    raw_encoding_specification: "REX.W + D3 /2"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 33 bits (CF, r/m32) left imm8 times."
    vendor_syntax {
      mnemonic: "RCL"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "C1 /2 ib"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 65 bits (CF, r/m64) left imm8 times.\nUses a 6 bit count."
    vendor_syntax {
      mnemonic: "RCL"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX.W + C1 /2 ib"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 9 bits (CF, r/m8) right once."
    vendor_syntax {
      mnemonic: "RCR"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "1"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M1"
    raw_encoding_specification: "D0 /3"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 9 bits (CF, r/m8) right once."
    vendor_syntax {
      mnemonic: "RCR"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "1"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M1"
    raw_encoding_specification: "REX + D0 /3"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 9 bits (CF, r/m8) right CL times."
    vendor_syntax {
      mnemonic: "RCR"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MC"
    raw_encoding_specification: "D2 /3"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 9 bits (CF, r/m8) right CL times."
    vendor_syntax {
      mnemonic: "RCR"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MC"
    raw_encoding_specification: "REX + D2 /3"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 9 bits (CF, r/m8) right imm8 times."
    vendor_syntax {
      mnemonic: "RCR"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "C0 /3 ib"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 9 bits (CF, r/m8) right imm8 times."
    vendor_syntax {
      mnemonic: "RCR"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX + C0 /3 ib"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 17 bits (CF, r/m16) right once."
    vendor_syntax {
      mnemonic: "RCR"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "1"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M1"
    raw_encoding_specification: "D1 /3"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 17 bits (CF, r/m16) right CL times."
    vendor_syntax {
      mnemonic: "RCR"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MC"
    raw_encoding_specification: "D3 /3"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 17 bits (CF, r/m16) right imm8 times."
    vendor_syntax {
      mnemonic: "RCR"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "C1 /3 ib"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 33 bits (CF, r/m32) right once. Uses a 6 bit count."
    vendor_syntax {
      mnemonic: "RCR"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "1"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M1"
    raw_encoding_specification: "D1 /3"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 65 bits (CF, r/m64) right once. Uses a 6 bit count."
    vendor_syntax {
      mnemonic: "RCR"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "1"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M1"
    raw_encoding_specification: "REX.W + D1 /3"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 33 bits (CF, r/m32) right CL times."
    vendor_syntax {
      mnemonic: "RCR"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MC"
    raw_encoding_specification: "D3 /3"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 65 bits (CF, r/m64) right CL times. Uses a 6 bit count."
    vendor_syntax {
      mnemonic: "RCR"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MC"
    raw_encoding_specification: "REX.W + D3 /3"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 33 bits (CF, r/m32) right imm8 times."
    vendor_syntax {
      mnemonic: "RCR"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "C1 /3 ib"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 65 bits (CF, r/m64) right imm8 times.\nUses a 6 bit count."
    vendor_syntax {
      mnemonic: "RCR"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX.W + C1 /3 ib"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 8 bits r/m8 left once."
    vendor_syntax {
      mnemonic: "ROL"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "1"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M1"
    raw_encoding_specification: "D0 /0"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 8 bits r/m8 left once"
    vendor_syntax {
      mnemonic: "ROL"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "1"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M1"
    raw_encoding_specification: "REX + D0 /0"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 8 bits r/m8 left CL times."
    vendor_syntax {
      mnemonic: "ROL"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MC"
    raw_encoding_specification: "D2 /0"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 8 bits r/m8 left CL times."
    vendor_syntax {
      mnemonic: "ROL"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MC"
    raw_encoding_specification: "REX + D2 /0"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 8 bits r/m8 left imm8 times."
    vendor_syntax {
      mnemonic: "ROL"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "C0 /0 ib"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 8 bits r/m8 left imm8 times."
    vendor_syntax {
      mnemonic: "ROL"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX + C0 /0 ib"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 16 bits r/m16 left once."
    vendor_syntax {
      mnemonic: "ROL"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "1"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M1"
    raw_encoding_specification: "D1 /0"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 16 bits r/m16 left CL times."
    vendor_syntax {
      mnemonic: "ROL"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MC"
    raw_encoding_specification: "D3 /0"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 16 bits r/m16 left imm8 times."
    vendor_syntax {
      mnemonic: "ROL"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "C1 /0 ib"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 32 bits r/m32 left once."
    vendor_syntax {
      mnemonic: "ROL"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "1"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M1"
    raw_encoding_specification: "D1 /0"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 64 bits r/m64 left once. Uses a 6 bit count."
    vendor_syntax {
      mnemonic: "ROL"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "1"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M1"
    raw_encoding_specification: "REX.W + D1 /0"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 32 bits r/m32 left CL times."
    vendor_syntax {
      mnemonic: "ROL"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MC"
    raw_encoding_specification: "D3 /0"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 64 bits r/m64 left CL times. Uses a 6 bit count."
    vendor_syntax {
      mnemonic: "ROL"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MC"
    raw_encoding_specification: "REX.W + D3 /0"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 32 bits r/m32 left imm8 times."
    vendor_syntax {
      mnemonic: "ROL"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "C1 /0 ib"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 64 bits r/m64 left imm8 times. Uses a 6 bit count."
    vendor_syntax {
      mnemonic: "ROL"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX.W + C1 /0 ib"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 8 bits r/m8 right once."
    vendor_syntax {
      mnemonic: "ROR"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "1"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M1"
    raw_encoding_specification: "D0 /1"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 8 bits r/m8 right once."
    vendor_syntax {
      mnemonic: "ROR"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "1"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M1"
    raw_encoding_specification: "REX + D0 /1"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 8 bits r/m8 right CL times."
    vendor_syntax {
      mnemonic: "ROR"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MC"
    raw_encoding_specification: "D2 /1"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 8 bits r/m8 right CL times."
    vendor_syntax {
      mnemonic: "ROR"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MC"
    raw_encoding_specification: "REX + D2 /1"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 8 bits r/m16 right imm8 times."
    vendor_syntax {
      mnemonic: "ROR"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "C0 /1 ib"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 8 bits r/m16 right imm8 times."
    vendor_syntax {
      mnemonic: "ROR"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX + C0 /1 ib"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 16 bits r/m16 right once."
    vendor_syntax {
      mnemonic: "ROR"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "1"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M1"
    raw_encoding_specification: "D1 /1"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 16 bits r/m16 right CL times."
    vendor_syntax {
      mnemonic: "ROR"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MC"
    raw_encoding_specification: "D3 /1"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 16 bits r/m16 right imm8 times."
    vendor_syntax {
      mnemonic: "ROR"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "C1 /1 ib"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 32 bits r/m32 right once."
    vendor_syntax {
      mnemonic: "ROR"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "1"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M1"
    raw_encoding_specification: "D1 /1"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 64 bits r/m64 right once. Uses a 6 bit count."
    vendor_syntax {
      mnemonic: "ROR"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "1"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M1"
    raw_encoding_specification: "REX.W + D1 /1"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 32 bits r/m32 right CL times."
    vendor_syntax {
      mnemonic: "ROR"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MC"
    raw_encoding_specification: "D3 /1"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 64 bits r/m64 right CL times. Uses a 6 bit count."
    vendor_syntax {
      mnemonic: "ROR"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MC"
    raw_encoding_specification: "REX.W + D3 /1"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 32 bits r/m32 right imm8 times."
    vendor_syntax {
      mnemonic: "ROR"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "C1 /1 ib"
    instruction_group_index: 509
  }
  instructions {
    description: "Rotate 64 bits r/m64 right imm8 times. Uses a 6 bit count."
    vendor_syntax {
      mnemonic: "ROR"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX.W + C1 /1 ib"
    instruction_group_index: 509
  }
  instructions {
    description: "Conditionally load dword values from m128 using mask in xmm2 and store in xmm1."
    vendor_syntax {
      mnemonic: "VPMASKMOVD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.128.66.0F38.W0 8C /r"
    instruction_group_index: 510
  }
  instructions {
    description: "Conditionally load dword values from m256 using mask in ymm2 and store in ymm1."
    vendor_syntax {
      mnemonic: "VPMASKMOVD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.256.66.0F38.W0 8C /r"
    instruction_group_index: 510
  }
  instructions {
    description: "Conditionally load qword values from m128 using mask in xmm2 and store in xmm1."
    vendor_syntax {
      mnemonic: "VPMASKMOVQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.128.66.0F38.W1 8C /r"
    instruction_group_index: 510
  }
  instructions {
    description: "Conditionally load qword values from m256 using mask in ymm2 and store in ymm1."
    vendor_syntax {
      mnemonic: "VPMASKMOVQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.256.66.0F38.W1 8C /r"
    instruction_group_index: 510
  }
  instructions {
    description: "Conditionally store dword values from xmm2 using mask in xmm1."
    vendor_syntax {
      mnemonic: "VPMASKMOVD"
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MVR"
    raw_encoding_specification: "VEX.128.66.0F38.W0 8E /r"
    instruction_group_index: 510
  }
  instructions {
    description: "Conditionally store dword values from ymm2 using mask in ymm1."
    vendor_syntax {
      mnemonic: "VPMASKMOVD"
      operands {
        name: "m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm1"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MVR"
    raw_encoding_specification: "VEX.256.66.0F38.W0 8E /r"
    instruction_group_index: 510
  }
  instructions {
    description: "Conditionally store qword values from xmm2 using mask in xmm1."
    vendor_syntax {
      mnemonic: "VPMASKMOVQ"
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MVR"
    raw_encoding_specification: "VEX.128.66.0F38.W1 8E /r"
    instruction_group_index: 510
  }
  instructions {
    description: "Conditionally store qword values from ymm2 using mask in ymm1."
    vendor_syntax {
      mnemonic: "VPMASKMOVQ"
      operands {
        name: "m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm1"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MVR"
    raw_encoding_specification: "VEX.256.66.0F38.W1 8E /r"
    instruction_group_index: 510
  }
  instructions {
    description: "Move byte to word with sign-extension."
    vendor_syntax {
      mnemonic: "MOVSX"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F BE /r"
    instruction_group_index: 511
  }
  instructions {
    description: "Move byte to doubleword with signextension."
    vendor_syntax {
      mnemonic: "MOVSX"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F BE /r"
    instruction_group_index: 511
  }
  instructions {
    description: "Move byte to quadword with sign-extension."
    vendor_syntax {
      mnemonic: "MOVSX"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 0F BE /r"
    instruction_group_index: 511
  }
  instructions {
    description: "Move word to doubleword, with signextension."
    vendor_syntax {
      mnemonic: "MOVSX"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F BF /r"
    instruction_group_index: 511
  }
  instructions {
    description: "Move word to quadword with sign-extension."
    vendor_syntax {
      mnemonic: "MOVSX"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 0F BF /r"
    instruction_group_index: 511
  }
  instructions {
    description: "Move word to word with sign-extension."
    vendor_syntax {
      mnemonic: "MOVSXD"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "63 /r"
    instruction_group_index: 511
  }
  instructions {
    description: "Move doubleword to doubleword with signextension."
    vendor_syntax {
      mnemonic: "MOVSXD"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "63 /r"
    instruction_group_index: 511
  }
  instructions {
    description: "Move doubleword to quadword with signextension."
    vendor_syntax {
      mnemonic: "MOVSXD"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 63 /r"
    instruction_group_index: 511
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from xmm1 and xmm3/mem, negate the multiplication result and subtract xmm2 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMSUB132PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W0 9E /r"
    instruction_group_index: 512
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from xmm1 and xmm2, negate the multiplication result and subtract xmm3/mem and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMSUB213PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W0 AE /r"
    instruction_group_index: 512
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from xmm2 and xmm3/mem, negate the multiplication result and subtract xmm1 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMSUB231PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W0 BE /r"
    instruction_group_index: 512
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from ymm1 and ymm3/mem, negate the multiplication result and subtract ymm2 and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFNMSUB132PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W0 9E /r"
    instruction_group_index: 512
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from ymm1 and ymm2, negate the multiplication result and subtract ymm3/mem and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFNMSUB213PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W0 AE /r"
    instruction_group_index: 512
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from ymm2 and ymm3/mem, negate the multiplication result and subtract ymm1 and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFNMSUB231PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.0 BE /r"
    instruction_group_index: 512
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from xmm1 and xmm3/m128/m32bcst, negate the multiplication result and subtract xmm2 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMSUB132PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 9E /r"
    instruction_group_index: 512
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from xmm1 and xmm2, negate the multiplication result and subtract xmm3/m128/m32bcst and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMSUB213PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 AE /r"
    instruction_group_index: 512
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from xmm2 and xmm3/m128/m32bcst, negate the multiplication result subtract add to xmm1 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMSUB231PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 BE /r"
    instruction_group_index: 512
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from ymm1 and ymm3/m256/m32bcst, negate the multiplication result and subtract ymm2 and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFNMSUB132PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 9E /r"
    instruction_group_index: 512
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from ymm1 and ymm2, negate the multiplication result and subtract ymm3/m256/m32bcst and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFNMSUB213PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 AE /r"
    instruction_group_index: 512
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from ymm2 and ymm3/m256/m32bcst, negate the multiplication result subtract add to ymm1 and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFNMSUB231PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 BE /r"
    instruction_group_index: 512
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from zmm1 and zmm3/m512/m32bcst, negate the multiplication result and subtract zmm2 and put result in zmm1."
    vendor_syntax {
      mnemonic: "VFNMSUB132PS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 9E /r"
    instruction_group_index: 512
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from zmm1 and zmm2, negate the multiplication result and subtract zmm3/m512/m32bcst and put result in zmm1."
    vendor_syntax {
      mnemonic: "VFNMSUB213PS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 AE /r"
    instruction_group_index: 512
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from zmm2 and zmm3/m512/m32bcst, negate the multiplication result subtract add to zmm1 and put result in zmm1."
    vendor_syntax {
      mnemonic: "VFNMSUB231PS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 BE /r"
    instruction_group_index: 512
  }
  instructions {
    description: "Serializes load operations."
    vendor_syntax {
      mnemonic: "LFENCE"
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "NP 0F AE E8"
    instruction_group_index: 513
  }
  instructions {
    description: "Using signed dword indices, prefetch sparse byte memory locations containing single-precision data using writemask k1 and T1 hint with intent to write."
    vendor_syntax {
      mnemonic: "VSCATTERPF1DPS"
      operands {
        name: "vm32z"
        encoding: VSIB_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512PF"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 C6 /6 /vsib"
    instruction_group_index: 514
  }
  instructions {
    description: "Using signed qword indices, prefetch sparse byte memory locations containing single-precision data using writemask k1 and T1 hint with intent to write."
    vendor_syntax {
      mnemonic: "VSCATTERPF1QPS"
      operands {
        name: "vm64z"
        encoding: VSIB_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512PF"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 C7 /6 /vsib"
    instruction_group_index: 514
  }
  instructions {
    description: "Using signed dword indices, prefetch sparse byte memory locations containing double-precision data using writemask k1 and T1 hint with intent to write."
    vendor_syntax {
      mnemonic: "VSCATTERPF1DPD"
      operands {
        name: "vm32y"
        encoding: VSIB_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512PF"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 C6 /6 /vsib"
    instruction_group_index: 514
  }
  instructions {
    description: "Using signed qword indices, prefetch sparse byte memory locations containing double-precision data using writemask k1 and T1 hint with intent to write."
    vendor_syntax {
      mnemonic: "VSCATTERPF1QPD"
      operands {
        name: "vm64z"
        encoding: VSIB_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512PF"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 C7 /6 /vsib"
    instruction_group_index: 514
  }
  instructions {
    description: "Unpacks and Interleaves double-precision floating-point values from low quadwords of xmm1 and xmm2/m128."
    vendor_syntax {
      mnemonic: "UNPCKLPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 14 /r"
    instruction_group_index: 515
  }
  instructions {
    description: "Unpacks and Interleaves double-precision floating-point values from low quadwords of xmm2 and xmm3/m128."
    vendor_syntax {
      mnemonic: "VUNPCKLPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG 14 /r"
    instruction_group_index: 515
  }
  instructions {
    description: "Unpacks and Interleaves double-precision floating-point values from low quadwords of ymm2 and ymm3/m256."
    vendor_syntax {
      mnemonic: "VUNPCKLPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG 14 /r"
    instruction_group_index: 515
  }
  instructions {
    description: "Unpacks and Interleaves double precision floating-point values from low quadwords of xmm2 and xmm3/m128/m64bcst subject to write mask k1."
    vendor_syntax {
      mnemonic: "VUNPCKLPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.W1 14 /r"
    instruction_group_index: 515
  }
  instructions {
    description: "Unpacks and Interleaves double precision floating-point values from low quadwords of ymm2 and ymm3/m256/m64bcst subject to write mask k1."
    vendor_syntax {
      mnemonic: "VUNPCKLPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.W1 14 /r"
    instruction_group_index: 515
  }
  instructions {
    description: "Unpacks and Interleaves double-precision floating-point values from low quadwords of zmm2 and zmm3/m512/m64bcst subject to write mask k1."
    vendor_syntax {
      mnemonic: "VUNPCKLPD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.W1 14 /r"
    instruction_group_index: 515
  }
  instructions {
    description: "Shift r/m16 to right imm8 places while shifting bits from r16 in from the left."
    vendor_syntax {
      mnemonic: "SHRD"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MRI"
    raw_encoding_specification: "0F AC /r ib"
    instruction_group_index: 516
  }
  instructions {
    description: "Shift r/m16 to right CL places while shifting bits from r16 in from the left."
    vendor_syntax {
      mnemonic: "SHRD"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MRC"
    raw_encoding_specification: "0F AD /r"
    instruction_group_index: 516
  }
  instructions {
    description: "Shift r/m32 to right imm8 places while shifting bits from r32 in from the left."
    vendor_syntax {
      mnemonic: "SHRD"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MRI"
    raw_encoding_specification: "0F AC /r ib"
    instruction_group_index: 516
  }
  instructions {
    description: "Shift r/m64 to right imm8 places while shifting bits from r64 in from the left."
    vendor_syntax {
      mnemonic: "SHRD"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MRI"
    raw_encoding_specification: "REX.W + 0F AC /r ib"
    instruction_group_index: 516
  }
  instructions {
    description: "Shift r/m32 to right CL places while shifting bits from r32 in from the left."
    vendor_syntax {
      mnemonic: "SHRD"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MRC"
    raw_encoding_specification: "0F AD /r"
    instruction_group_index: 516
  }
  instructions {
    description: "Shift r/m64 to right CL places while shifting bits from r64 in from the left."
    vendor_syntax {
      mnemonic: "SHRD"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MRC"
    raw_encoding_specification: "REX.W + 0F AD /r"
    instruction_group_index: 516
  }
  instructions {
    description: "Concatenate destination and source operands, extract byte-aligned result shifted to the right by constant value in imm8 into mm1."
    vendor_syntax {
      mnemonic: "PALIGNR"
      operands {
        name: "mm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 3A 0F /r ib"
    instruction_group_index: 517
  }
  instructions {
    description: "Concatenate destination and source operands, extract byte-aligned result shifted to the right by constant value in imm8 into xmm1."
    vendor_syntax {
      mnemonic: "PALIGNR"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 3A 0F /r ib"
    instruction_group_index: 517
  }
  instructions {
    description: "Concatenate xmm2 and xmm3/m128, extract byte aligned result shifted to the right by constant value in imm8 and result is stored in xmm1."
    vendor_syntax {
      mnemonic: "VPALIGNR"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F3A.WIG 0F /r ib"
    instruction_group_index: 517
  }
  instructions {
    description: "Concatenate pairs of 16 bytes in ymm2 and ymm3/m256 into 32-byte intermediate result, extract byte-aligned, 16-byte result shifted to the right by constant values in imm8 from each intermediate result, and two 16-byte results are stored in ymm1."
    vendor_syntax {
      mnemonic: "VPALIGNR"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F3A.WIG 0F /r ib"
    instruction_group_index: 517
  }
  instructions {
    description: "Concatenate xmm2 and xmm3/m128 into a 32- byte intermediate result, extract byte aligned result shifted to the right by constant value in imm8 and result is stored in xmm1."
    vendor_syntax {
      mnemonic: "VPALIGNR"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F3A.WIG 0F /r ib"
    instruction_group_index: 517
  }
  instructions {
    description: "Concatenate pairs of 16 bytes in ymm2 and ymm3/m256 into 32-byte intermediate result, extract byte-aligned, 16-byte result shifted to the right by constant values in imm8 from each intermediate result, and two 16-byte results are stored in ymm1."
    vendor_syntax {
      mnemonic: "VPALIGNR"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F3A.WIG 0F /r ib"
    instruction_group_index: 517
  }
  instructions {
    description: "Concatenate pairs of 16 bytes in zmm2 and zmm3/m512 into 32-byte intermediate result, extract byte-aligned, 16-byte result shifted to the right by constant values in imm8 from each intermediate result, and four 16-byte results are stored in zmm1."
    vendor_syntax {
      mnemonic: "VPALIGNR"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F3A.WIG 0F /r ib"
    instruction_group_index: 517
  }
  instructions {
    description: "Tests the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result."
    vendor_syntax {
      mnemonic: "VFPCLASSPS"
      operands {
        name: "k2"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F3A.W0 66 /r ib"
    instruction_group_index: 518
  }
  instructions {
    description: "Tests the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result."
    vendor_syntax {
      mnemonic: "VFPCLASSPS"
      operands {
        name: "k2"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F3A.W0 66 /r ib"
    instruction_group_index: 518
  }
  instructions {
    description: "Tests the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result."
    vendor_syntax {
      mnemonic: "VFPCLASSPS"
      operands {
        name: "k2"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F3A.W0 66 /r ib"
    instruction_group_index: 518
  }
  instructions {
    description: "Get normalized mantissa from float32 vector xmm2/m128/m32bcst and store the result in xmm1, using imm8 for sign control and mantissa interval normalization, under writemask."
    vendor_syntax {
      mnemonic: "VGETMANTPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F3A.W0 26 /r ib"
    instruction_group_index: 519
  }
  instructions {
    description: "Get normalized mantissa from float32 vector ymm2/m256/m32bcst and store the result in ymm1, using imm8 for sign control and mantissa interval normalization, under writemask."
    vendor_syntax {
      mnemonic: "VGETMANTPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F3A.W0 26 /r ib"
    instruction_group_index: 519
  }
  instructions {
    description: "Get normalized mantissa from float32 vector zmm2/m512/m32bcst and store the result in zmm1, using imm8 for sign control and mantissa interval normalization, under writemask."
    vendor_syntax {
      mnemonic: "VGETMANTPS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F3A.W0 26 /r ib"
    instruction_group_index: 519
  }
  instructions {
    description: "Using signed qword indices, gather dword values from memory using writemask k1 for merging-masking."
    vendor_syntax {
      mnemonic: "VPGATHERQD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "vm64x"
        encoding: VSIB_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 91 /vsib"
    instruction_group_index: 520
  }
  instructions {
    description: "Using signed qword indices, gather dword values from memory using writemask k1 for merging-masking."
    vendor_syntax {
      mnemonic: "VPGATHERQD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "vm64y"
        encoding: VSIB_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 91 /vsib"
    instruction_group_index: 520
  }
  instructions {
    description: "Using signed qword indices, gather dword values from memory using writemask k1 for merging-masking."
    vendor_syntax {
      mnemonic: "VPGATHERQD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "vm64z"
        encoding: VSIB_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 91 /vsib"
    instruction_group_index: 520
  }
  instructions {
    description: "Using signed qword indices, gather quadword values from memory using writemask k1 for merging-masking."
    vendor_syntax {
      mnemonic: "VPGATHERQQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "vm64x"
        encoding: VSIB_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 91 /vsib"
    instruction_group_index: 520
  }
  instructions {
    description: "Using signed qword indices, gather quadword values from memory using writemask k1 for merging-masking."
    vendor_syntax {
      mnemonic: "VPGATHERQQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "vm64y"
        encoding: VSIB_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 91 /vsib"
    instruction_group_index: 520
  }
  instructions {
    description: "Using signed qword indices, gather quadword values from memory using writemask k1 for merging-masking."
    vendor_syntax {
      mnemonic: "VPGATHERQQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "vm64z"
        encoding: VSIB_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 91 /vsib"
    instruction_group_index: 520
  }
  instructions {
    description: "Decrement r/m8 by 1."
    vendor_syntax {
      mnemonic: "DEC"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "FE /1"
    instruction_group_index: 521
  }
  instructions {
    description: "Decrement r/m8 by 1."
    vendor_syntax {
      mnemonic: "DEC"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX + FE /1"
    instruction_group_index: 521
  }
  instructions {
    description: "Decrement r/m16 by 1."
    vendor_syntax {
      mnemonic: "DEC"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "FF /1"
    instruction_group_index: 521
  }
  instructions {
    description: "Decrement r/m32 by 1."
    vendor_syntax {
      mnemonic: "DEC"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "FF /1"
    instruction_group_index: 521
  }
  instructions {
    description: "Decrement r/m64 by 1."
    vendor_syntax {
      mnemonic: "DEC"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX.W + FF /1"
    instruction_group_index: 521
  }
  instructions {
    description: "Decrement r16 by 1."
    vendor_syntax {
      mnemonic: "DEC"
      operands {
        name: "r16"
        encoding: OPCODE_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    legacy_instruction: true
    encoding_scheme: "O"
    raw_encoding_specification: "48+rw"
    instruction_group_index: 521
  }
  instructions {
    description: "Decrement r32 by 1."
    vendor_syntax {
      mnemonic: "DEC"
      operands {
        name: "r32"
        encoding: OPCODE_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    legacy_instruction: true
    encoding_scheme: "O"
    raw_encoding_specification: "48+rd"
    instruction_group_index: 521
  }
  instructions {
    description: "Accumulate CRC32 on r/m8."
    vendor_syntax {
      mnemonic: "CRC32"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "F2 0F 38 F0 /r"
    instruction_group_index: 522
  }
  instructions {
    description: "Accumulate CRC32 on r/m8."
    vendor_syntax {
      mnemonic: "CRC32"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "F2 REX 0F 38 F0 /r"
    instruction_group_index: 522
  }
  instructions {
    description: "Accumulate CRC32 on r/m16."
    vendor_syntax {
      mnemonic: "CRC32"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "F2 0F 38 F1 /r"
    instruction_group_index: 522
  }
  instructions {
    description: "Accumulate CRC32 on r/m32."
    vendor_syntax {
      mnemonic: "CRC32"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "F2 0F 38 F1 /r"
    instruction_group_index: 522
  }
  instructions {
    description: "Accumulate CRC32 on r/m8."
    vendor_syntax {
      mnemonic: "CRC32"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "F2 REX.W 0F 38 F0 /r"
    instruction_group_index: 522
  }
  instructions {
    description: "Accumulate CRC32 on r/m64."
    vendor_syntax {
      mnemonic: "CRC32"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "F2 REX.W 0F 38 F1 /r"
    instruction_group_index: 522
  }
  instructions {
    description: "Load MXCSR register from m32."
    vendor_syntax {
      mnemonic: "LDMXCSR"
      operands {
        name: "m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "NP 0F AE /2"
    instruction_group_index: 523
  }
  instructions {
    description: "Load MXCSR register from m32."
    vendor_syntax {
      mnemonic: "VLDMXCSR"
      operands {
        name: "m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "VEX.LZ.0F.WIG AE /2"
    instruction_group_index: 523
  }
  instructions {
    description: "Converts 4 packed double-word integers from xmm2 into 4 packed byte integers in xmm1/m32 with truncation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVDB"
      operands {
        name: "xmm1/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.F3.0F38.W0 31 /r"
    instruction_group_index: 524
  }
  instructions {
    description: "Converts 4 packed signed double-word integers from xmm2 into 4 packed signed byte integers in xmm1/m32 using signed saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVSDB"
      operands {
        name: "xmm1/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.F3.0F38.W0 21 /r"
    instruction_group_index: 524
  }
  instructions {
    description: "Converts 4 packed unsigned double-word integers from xmm2 into 4 packed unsigned byte integers in xmm1/m32 using unsigned saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVUSDB"
      operands {
        name: "xmm1/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.F3.0F38.W0 11 /r"
    instruction_group_index: 524
  }
  instructions {
    description: "Converts 8 packed double-word integers from ymm2 into 8 packed byte integers in xmm1/m64 with truncation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVDB"
      operands {
        name: "xmm1/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.F3.0F38.W0 31 /r"
    instruction_group_index: 524
  }
  instructions {
    description: "Converts 8 packed signed double-word integers from ymm2 into 8 packed signed byte integers in xmm1/m64 using signed saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVSDB"
      operands {
        name: "xmm1/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.F3.0F38.W0 21 /r"
    instruction_group_index: 524
  }
  instructions {
    description: "Converts 8 packed unsigned double-word integers from ymm2 into 8 packed unsigned byte integers in xmm1/m64 using unsigned saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVUSDB"
      operands {
        name: "xmm1/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.F3.0F38.W0 11 /r"
    instruction_group_index: 524
  }
  instructions {
    description: "Converts 16 packed double-word integers from zmm2 into 16 packed byte integers in xmm1/m128 with truncation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVDB"
      operands {
        name: "xmm1/m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.F3.0F38.W0 31 /r"
    instruction_group_index: 524
  }
  instructions {
    description: "Converts 16 packed signed double-word integers from zmm2 into 16 packed signed byte integers in xmm1/m128 using signed saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVSDB"
      operands {
        name: "xmm1/m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.F3.0F38.W0 21 /r"
    instruction_group_index: 524
  }
  instructions {
    description: "Converts 16 packed unsigned double-word integers from zmm2 into 16 packed unsigned byte integers in xmm1/m128 using unsigned saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVUSDB"
      operands {
        name: "xmm1/m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.F3.0F38.W0 11 /r"
    instruction_group_index: 524
  }
  instructions {
    description: "Bitwise OR 16 bits masks k2 and k3 and place result in k1."
    vendor_syntax {
      mnemonic: "KORW"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "k3"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVR"
    raw_encoding_specification: "VEX.L1.0F.W0 45 /r"
    instruction_group_index: 525
  }
  instructions {
    description: "Bitwise OR 8 bits masks k2 and k3 and place result in k1."
    vendor_syntax {
      mnemonic: "KORB"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "k3"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVR"
    raw_encoding_specification: "VEX.NDS.L1.66.0F.W0 45 /r"
    instruction_group_index: 525
  }
  instructions {
    description: "Bitwise OR 64 bits masks k2 and k3 and place result in k1."
    vendor_syntax {
      mnemonic: "KORQ"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "k3"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVR"
    raw_encoding_specification: "VEX.NDS.L1.0F.W1 45 /r"
    instruction_group_index: 525
  }
  instructions {
    description: "Bitwise OR 32 bits masks k2 and k3 and place result in k1."
    vendor_syntax {
      mnemonic: "KORD"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "k3"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVR"
    raw_encoding_specification: "VEX.NDS.L1.66.0F.W1 45 /r"
    instruction_group_index: 525
  }
  instructions {
    description: "Computes the approximate reciprocal square roots of the packed double-precision floating-point values in xmm2/m128/m64bcst and stores the results in xmm1.\nUnder writemask."
    vendor_syntax {
      mnemonic: "VRSQRT14PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 4E /r"
    instruction_group_index: 526
  }
  instructions {
    description: "Computes the approximate reciprocal square roots of the packed double-precision floating-point values in ymm2/m256/m64bcst and stores the results in ymm1.\nUnder writemask."
    vendor_syntax {
      mnemonic: "VRSQRT14PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 4E /r"
    instruction_group_index: 526
  }
  instructions {
    description: "Computes the approximate reciprocal square roots of the packed double-precision floating-point values in zmm2/m512/m64bcst and stores the results in zmm1 under writemask."
    vendor_syntax {
      mnemonic: "VRSQRT14PD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 4E /r"
    instruction_group_index: 526
  }
  instructions {
    description: "Returns processor identification and feature information to the EAX, EBX, ECX, and EDX registers, as determined by input entered in EAX (in some cases, ECX as well)."
    vendor_syntax {
      mnemonic: "CPUID"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "0F A2"
    instruction_group_index: 527
  }
  instructions {
    description: "Compare signed word integers in mm2/m64 and mm1 and return maximum values."
    vendor_syntax {
      mnemonic: "PMAXSW"
      operands {
        name: "mm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F EE /r"
    instruction_group_index: 528
  }
  instructions {
    description: "Compare packed signed byte integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1."
    vendor_syntax {
      mnemonic: "PMAXSB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 38 3C /r"
    instruction_group_index: 528
  }
  instructions {
    description: "Compare packed signed word integers in xmm2/m128 and xmm1 and stores maximum packed values in xmm1."
    vendor_syntax {
      mnemonic: "PMAXSW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F EE /r"
    instruction_group_index: 528
  }
  instructions {
    description: "Compare packed signed dword integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1."
    vendor_syntax {
      mnemonic: "PMAXSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 38 3D /r"
    instruction_group_index: 528
  }
  instructions {
    description: "Compare packed signed byte integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1."
    vendor_syntax {
      mnemonic: "VPMAXSB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F38.WIG 3C /r"
    instruction_group_index: 528
  }
  instructions {
    description: "Compare packed signed word integers in xmm3/m128 and xmm2 and store packed maximum values in xmm1."
    vendor_syntax {
      mnemonic: "VPMAXSW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG EE /r"
    instruction_group_index: 528
  }
  instructions {
    description: "Compare packed signed dword integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1."
    vendor_syntax {
      mnemonic: "VPMAXSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F38.WIG 3D /r"
    instruction_group_index: 528
  }
  instructions {
    description: "Compare packed signed byte integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1."
    vendor_syntax {
      mnemonic: "VPMAXSB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F38.WIG 3C /r"
    instruction_group_index: 528
  }
  instructions {
    description: "Compare packed signed word integers in ymm3/m256 and ymm2 and store packed maximum values in ymm1."
    vendor_syntax {
      mnemonic: "VPMAXSW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG EE /r"
    instruction_group_index: 528
  }
  instructions {
    description: "Compare packed signed dword integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1."
    vendor_syntax {
      mnemonic: "VPMAXSD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F38.WIG 3D /r"
    instruction_group_index: 528
  }
  instructions {
    description: "Compare packed signed byte integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMAXSB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F38.WIG 3C /r"
    instruction_group_index: 528
  }
  instructions {
    description: "Compare packed signed byte integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMAXSB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38.WIG 3C /r"
    instruction_group_index: 528
  }
  instructions {
    description: "Compare packed signed byte integers in zmm2 and zmm3/m512 and store packed maximum values in zmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMAXSB"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38.WIG 3C /r"
    instruction_group_index: 528
  }
  instructions {
    description: "Compare packed signed word integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMAXSW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.WIG EE /r"
    instruction_group_index: 528
  }
  instructions {
    description: "Compare packed signed word integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMAXSW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.WIG EE /r"
    instruction_group_index: 528
  }
  instructions {
    description: "Compare packed signed word integers in zmm2 and zmm3/m512 and store packed maximum values in zmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMAXSW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.WIG EE /r"
    instruction_group_index: 528
  }
  instructions {
    description: "Compare packed signed dword integers in xmm2 and xmm3/m128/m32bcst and store packed maximum values in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPMAXSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 3D /r"
    instruction_group_index: 528
  }
  instructions {
    description: "Compare packed signed dword integers in ymm2 and ymm3/m256/m32bcst and store packed maximum values in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPMAXSD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 3D /r"
    instruction_group_index: 528
  }
  instructions {
    description: "Compare packed signed dword integers in zmm2 and zmm3/m512/m32bcst and store packed maximum values in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPMAXSD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 3D /r"
    instruction_group_index: 528
  }
  instructions {
    description: "Compare packed signed qword integers in xmm2 and xmm3/m128/m64bcst and store packed maximum values in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPMAXSQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 3D /r"
    instruction_group_index: 528
  }
  instructions {
    description: "Compare packed signed qword integers in ymm2 and ymm3/m256/m64bcst and store packed maximum values in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPMAXSQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 3D /r"
    instruction_group_index: 528
  }
  instructions {
    description: "Compare packed signed qword integers in zmm2 and zmm3/m512/m64bcst and store packed maximum values in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPMAXSQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 3D /r"
    instruction_group_index: 528
  }
  instructions {
    description: "Replace ST(0) with its approximate cosine."
    vendor_syntax {
      mnemonic: "FCOS"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D9 FF"
    instruction_group_index: 529
  }
  instructions {
    description: "Performs an intermediate calculation for the next four SHA256 message dwords using previous message dwords from xmm1 and xmm2/m128, storing the result in xmm1."
    vendor_syntax {
      mnemonic: "SHA256MSG1"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SHA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "NP 0F 38 CC /r"
    instruction_group_index: 530
  }
  instructions {
    description: "Convert two single-precision floating-point values from xmm/m64 to two signed doubleword signed integers in mm using truncation."
    vendor_syntax {
      mnemonic: "CVTTPS2PI"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "NP 0F 2C /r"
    instruction_group_index: 531
  }
  instructions {
    description: "Convert two packer double-precision floatingpoint values from xmm/m128 to two packed signed doubleword integers in mm using truncation."
    vendor_syntax {
      mnemonic: "CVTTPD2PI"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "66 0F 2C /r"
    instruction_group_index: 532
  }
  instructions {
    description: "Permute doublewords in ymm3/m256 using indices in ymm2 and store the result in ymm1."
    vendor_syntax {
      mnemonic: "VPERMD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W0 36 /r"
    instruction_group_index: 533
  }
  instructions {
    description: "Permute doublewords in ymm3/m256/m32bcst using indexes in ymm2 and store the result in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 36 /r"
    instruction_group_index: 533
  }
  instructions {
    description: "Permute doublewords in zmm3/m512/m32bcst using indices in zmm2 and store the result in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 36 /r"
    instruction_group_index: 533
  }
  instructions {
    description: "Permute word integers in xmm3/m128 using indexes in xmm2 and store the result in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 8D /r"
    instruction_group_index: 533
  }
  instructions {
    description: "Permute word integers in ymm3/m256 using indexes in ymm2 and store the result in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 8D /r"
    instruction_group_index: 533
  }
  instructions {
    description: "Permute word integers in zmm3/m512 using indexes in zmm2 and store the result in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 8D /r"
    instruction_group_index: 533
  }
  instructions {
    description: "Convert two packed double-precision floating-point values in xmm2/mem to two signed doubleword integers in xmm1."
    vendor_syntax {
      mnemonic: "CVTPD2DQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F2 0F E6 /r"
    instruction_group_index: 534
  }
  instructions {
    description: "Convert two packed double-precision floating-point values in xmm2/mem to two signed doubleword integers in xmm1."
    vendor_syntax {
      mnemonic: "VCVTPD2DQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.F2.0F.WIG E6 /r"
    instruction_group_index: 534
  }
  instructions {
    description: "Convert four packed double-precision floating-point values in ymm2/mem to four signed doubleword integers in xmm1."
    vendor_syntax {
      mnemonic: "VCVTPD2DQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.F2.0F.WIG E6 /r"
    instruction_group_index: 534
  }
  instructions {
    description: "Convert two packed double-precision floating-point values in xmm2/m128/m64bcst to two signed doubleword integers in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VCVTPD2DQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.F2.0F.W1 E6 /r"
    instruction_group_index: 534
  }
  instructions {
    description: "Convert four packed double-precision floating-point values in ymm2/m256/m64bcst to four signed doubleword integers in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VCVTPD2DQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.F2.0F.W1 E6 /r"
    instruction_group_index: 534
  }
  instructions {
    description: "Convert eight packed double-precision floating-point values in zmm2/m512/m64bcst to eight signed doubleword integers in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VCVTPD2DQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.F2.0F.W1 E6 /r"
    instruction_group_index: 534
  }
  instructions {
    description: "Exchange the contents of ST(0) and ST(i)."
    vendor_syntax {
      mnemonic: "FXCH"
      operands {
        name: "ST(i)"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D9 C8+i"
    instruction_group_index: 535
  }
  instructions {
    description: "Exchange the contents of ST(0) and ST(1)."
    vendor_syntax {
      mnemonic: "FXCH"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D9 C9"
    instruction_group_index: 535
  }
  instructions {
    description: "Using signed dword indices, scatter dword values to memory using writemask k1."
    vendor_syntax {
      mnemonic: "VPSCATTERDD"
      operands {
        name: "vm32x"
        encoding: VSIB_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_READ
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 A0 /vsib"
    instruction_group_index: 536
  }
  instructions {
    description: "Using signed dword indices, scatter dword values to memory using writemask k1."
    vendor_syntax {
      mnemonic: "VPSCATTERDD"
      operands {
        name: "vm32y"
        encoding: VSIB_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_READ
      }
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 A0 /vsib"
    instruction_group_index: 536
  }
  instructions {
    description: "Using signed dword indices, scatter dword values to memory using writemask k1."
    vendor_syntax {
      mnemonic: "VPSCATTERDD"
      operands {
        name: "vm32z"
        encoding: VSIB_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_READ
      }
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 A0 /vsib"
    instruction_group_index: 536
  }
  instructions {
    description: "Using signed dword indices, scatter qword values to memory using writemask k1."
    vendor_syntax {
      mnemonic: "VPSCATTERDQ"
      operands {
        name: "vm32x"
        encoding: VSIB_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_READ
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 A0 /vsib"
    instruction_group_index: 536
  }
  instructions {
    description: "Using signed dword indices, scatter qword values to memory using writemask k1."
    vendor_syntax {
      mnemonic: "VPSCATTERDQ"
      operands {
        name: "vm32x"
        encoding: VSIB_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_READ
      }
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 A0 /vsib"
    instruction_group_index: 536
  }
  instructions {
    description: "Using signed dword indices, scatter qword values to memory using writemask k1."
    vendor_syntax {
      mnemonic: "VPSCATTERDQ"
      operands {
        name: "vm32y"
        encoding: VSIB_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_READ
      }
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 A0 /vsib"
    instruction_group_index: 536
  }
  instructions {
    description: "Using signed qword indices, scatter dword values to memory using writemask k1."
    vendor_syntax {
      mnemonic: "VPSCATTERQD"
      operands {
        name: "vm64x"
        encoding: VSIB_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_READ
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 A1 /vsib"
    instruction_group_index: 536
  }
  instructions {
    description: "Using signed qword indices, scatter dword values to memory using writemask k1."
    vendor_syntax {
      mnemonic: "VPSCATTERQD"
      operands {
        name: "vm64y"
        encoding: VSIB_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_READ
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 A1 /vsib"
    instruction_group_index: 536
  }
  instructions {
    description: "Using signed qword indices, scatter dword values to memory using writemask k1."
    vendor_syntax {
      mnemonic: "VPSCATTERQD"
      operands {
        name: "vm64z"
        encoding: VSIB_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_READ
      }
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 A1 /vsib"
    instruction_group_index: 536
  }
  instructions {
    description: "Using signed qword indices, scatter qword values to memory using writemask k1."
    vendor_syntax {
      mnemonic: "VPSCATTERQQ"
      operands {
        name: "vm64x"
        encoding: VSIB_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_READ
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 A1 /vsib"
    instruction_group_index: 536
  }
  instructions {
    description: "Using signed qword indices, scatter qword values to memory using writemask k1."
    vendor_syntax {
      mnemonic: "VPSCATTERQQ"
      operands {
        name: "vm64y"
        encoding: VSIB_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_READ
      }
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 A1 /vsib"
    instruction_group_index: 536
  }
  instructions {
    description: "Using signed qword indices, scatter qword values to memory using writemask k1."
    vendor_syntax {
      mnemonic: "VPSCATTERQQ"
      operands {
        name: "vm64z"
        encoding: VSIB_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_READ
      }
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 A1 /vsib"
    instruction_group_index: 536
  }
  instructions {
    description: "Fast call to privilege level 0 system procedures."
    vendor_syntax {
      mnemonic: "SYSCALL"
    }
    available_in_64_bit: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "0F 05"
    instruction_group_index: 537
  }
  instructions {
    description: "Set CF flag."
    vendor_syntax {
      mnemonic: "STC"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F9"
    instruction_group_index: 538
  }
  instructions {
    description: "Bitwise NAND of packed byte integers in xmm2 and xmm3/m128 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
    vendor_syntax {
      mnemonic: "VPTESTNMB"
      operands {
        name: "k2"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.F3.0F38.W0 26 /r"
    instruction_group_index: 539
  }
  instructions {
    description: "Bitwise NAND of packed byte integers in ymm2 and ymm3/m256 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
    vendor_syntax {
      mnemonic: "VPTESTNMB"
      operands {
        name: "k2"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.F3.0F38.W0 26 /r"
    instruction_group_index: 539
  }
  instructions {
    description: "Bitwise NAND of packed byte integers in zmm2 and zmm3/m512 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
    vendor_syntax {
      mnemonic: "VPTESTNMB"
      operands {
        name: "k2"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.F3.0F38.W0 26 /r"
    instruction_group_index: 539
  }
  instructions {
    description: "Bitwise NAND of packed word integers in xmm2 and xmm3/m128 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
    vendor_syntax {
      mnemonic: "VPTESTNMW"
      operands {
        name: "k2"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.F3.0F38.W1 26 /r"
    instruction_group_index: 539
  }
  instructions {
    description: "Bitwise NAND of packed word integers in ymm2 and ymm3/m256 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
    vendor_syntax {
      mnemonic: "VPTESTNMW"
      operands {
        name: "k2"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.F3.0F38.W1 26 /r"
    instruction_group_index: 539
  }
  instructions {
    description: "Bitwise NAND of packed word integers in zmm2 and zmm3/m512 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
    vendor_syntax {
      mnemonic: "VPTESTNMW"
      operands {
        name: "k2"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.F3.0F38.W1 26 /r"
    instruction_group_index: 539
  }
  instructions {
    description: "Bitwise NAND of packed doubleword integers in xmm2 and xmm3/m128/m32bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
    vendor_syntax {
      mnemonic: "VPTESTNMD"
      operands {
        name: "k2"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.F3.0F38.W0 27 /r"
    instruction_group_index: 539
  }
  instructions {
    description: "Bitwise NAND of packed doubleword integers in ymm2 and ymm3/m256/m32bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
    vendor_syntax {
      mnemonic: "VPTESTNMD"
      operands {
        name: "k2"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.F3.0F38.W0 27 /r"
    instruction_group_index: 539
  }
  instructions {
    description: "Bitwise NAND of packed doubleword integers in zmm2 and zmm3/m512/m32bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
    vendor_syntax {
      mnemonic: "VPTESTNMD"
      operands {
        name: "k2"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.F3.0F38.W0 27 /r"
    instruction_group_index: 539
  }
  instructions {
    description: "Bitwise NAND of packed quadword integers in xmm2 and xmm3/m128/m64bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
    vendor_syntax {
      mnemonic: "VPTESTNMQ"
      operands {
        name: "k2"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.F3.0F38.W1 27 /r"
    instruction_group_index: 539
  }
  instructions {
    description: "Bitwise NAND of packed quadword integers in ymm2 and ymm3/m256/m64bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
    vendor_syntax {
      mnemonic: "VPTESTNMQ"
      operands {
        name: "k2"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.F3.0F38.W1 27 /r"
    instruction_group_index: 539
  }
  instructions {
    description: "Bitwise NAND of packed quadword integers in zmm2 and zmm3/m512/m64bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
    vendor_syntax {
      mnemonic: "VPTESTNMQ"
      operands {
        name: "k2"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.F3.0F38.W1 27 /r"
    instruction_group_index: 539
  }
  instructions {
    description: "Move aligned packed double-precision floatingpoint values from xmm2/mem to xmm1."
    vendor_syntax {
      mnemonic: "MOVAPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 28 /r"
    instruction_group_index: 540
  }
  instructions {
    description: "Move aligned packed double-precision floatingpoint values from xmm1 to xmm2/mem."
    vendor_syntax {
      mnemonic: "MOVAPD"
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "66 0F 29 /r"
    instruction_group_index: 540
  }
  instructions {
    description: "Move aligned packed double-precision floatingpoint values from xmm2/mem to xmm1."
    vendor_syntax {
      mnemonic: "VMOVAPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F.WIG 28 /r"
    instruction_group_index: 540
  }
  instructions {
    description: "Move aligned packed double-precision floatingpoint values from xmm1 to xmm2/mem."
    vendor_syntax {
      mnemonic: "VMOVAPD"
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG 29 /r"
    instruction_group_index: 540
  }
  instructions {
    description: "Move aligned packed double-precision floatingpoint values from ymm2/mem to ymm1."
    vendor_syntax {
      mnemonic: "VMOVAPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F.WIG 28 /r"
    instruction_group_index: 540
  }
  instructions {
    description: "Move aligned packed double-precision floatingpoint values from ymm1 to ymm2/mem."
    vendor_syntax {
      mnemonic: "VMOVAPD"
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG 29 /r"
    instruction_group_index: 540
  }
  instructions {
    description: "Move aligned packed double-precision floatingpoint values from xmm2/m128 to xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVAPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.W1 28 /r"
    instruction_group_index: 540
  }
  instructions {
    description: "Move aligned packed double-precision floatingpoint values from ymm2/m256 to ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVAPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.W1 28 /r"
    instruction_group_index: 540
  }
  instructions {
    description: "Move aligned packed double-precision floatingpoint values from zmm2/m512 to zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVAPD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.W1 28 /r"
    instruction_group_index: 540
  }
  instructions {
    description: "Move aligned packed double-precision floatingpoint values from xmm1 to xmm2/m128 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVAPD"
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.128.66.0F.W1 29 /r"
    instruction_group_index: 540
  }
  instructions {
    description: "Move aligned packed double-precision floatingpoint values from ymm1 to ymm2/m256 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVAPD"
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.256.66.0F.W1 29 /r"
    instruction_group_index: 540
  }
  instructions {
    description: "Move aligned packed double-precision floatingpoint values from zmm1 to zmm2/m512 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVAPD"
      operands {
        name: "zmm2/m512"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.66.0F.W1 29 /r"
    instruction_group_index: 540
  }
  instructions {
    description: "Multiply groups of 4 pairs signed bytes in xmm3/m128/m32bcst with corresponding unsigned bytes of xmm2, summing those products and adding them to doubleword result, with signed saturation in xmm1, under writemask k1."
    vendor_syntax {
      mnemonic: "VPDPBUSDS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VNNI && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 51 /r"
    instruction_group_index: 541
  }
  instructions {
    description: "Multiply groups of 4 pairs signed bytes in ymm3/m256/m32bcst with corresponding unsigned bytes of ymm2, summing those products and adding them to doubleword result, with signed saturation in ymm1, under writemask k1."
    vendor_syntax {
      mnemonic: "VPDPBUSDS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VNNI && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 51 /r"
    instruction_group_index: 541
  }
  instructions {
    description: "Multiply groups of 4 pairs signed bytes in zmm3/m512/m32bcst with corresponding unsigned bytes of zmm2, summing those products and adding them to doubleword result, with signed saturation in zmm1, under writemask k1."
    vendor_syntax {
      mnemonic: "VPDPBUSDS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VNNI"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 51 /r"
    instruction_group_index: 541
  }
  instructions {
    description: "Convert one double-precision floating-point value in xmm2/m64 to one single-precision floating-point value in xmm1."
    vendor_syntax {
      mnemonic: "CVTSD2SS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F2 0F 5A /r"
    instruction_group_index: 542
  }
  instructions {
    description: "Convert one double-precision floating-point value in xmm3/m64 to one single-precision floating-point value and merge with high bits in xmm2."
    vendor_syntax {
      mnemonic: "VCVTSD2SS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.LIG.F2.0F.WIG 5A /r"
    instruction_group_index: 542
  }
  instructions {
    description: "Convert one double-precision floating-point value in xmm3/m64 to one single-precision floating-point value and merge with high bits in xmm2 under writemask k1."
    vendor_syntax {
      mnemonic: "VCVTSD2SS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.LIG.F2.0F.W1 5A /r"
    instruction_group_index: 542
  }
  instructions {
    description: "Compare AL with r/m8. If equal, ZF is set and r8 is loaded into r/m8. Else, clear ZF and load r/m8 into AL."
    vendor_syntax {
      mnemonic: "CMPXCHG"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "0F B0/r"
    instruction_group_index: 543
  }
  instructions {
    description: "Compare AL with r/m8. If equal, ZF is set and r8 is loaded into r/m8. Else, clear ZF and load r/m8 into AL."
    vendor_syntax {
      mnemonic: "CMPXCHG"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MR"
    raw_encoding_specification: "REX + 0F B0/r"
    instruction_group_index: 543
  }
  instructions {
    description: "Compare AX with r/m16. If equal, ZF is set and r16 is loaded into r/m16. Else, clear ZF and load r/m16 into AX."
    vendor_syntax {
      mnemonic: "CMPXCHG"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "0F B1/r"
    instruction_group_index: 543
  }
  instructions {
    description: "Compare EAX with r/m32. If equal, ZF is set and r32 is loaded into r/m32. Else, clear ZF and load r/m32 into EAX."
    vendor_syntax {
      mnemonic: "CMPXCHG"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "0F B1/r"
    instruction_group_index: 543
  }
  instructions {
    description: "Compare RAX with r/m64. If equal, ZF is set and r64 is loaded into r/m64. Else, clear ZF and load r/m64 into RAX."
    vendor_syntax {
      mnemonic: "CMPXCHG"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MR"
    raw_encoding_specification: "REX.W + 0F B1/r"
    instruction_group_index: 543
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from xmm1 and xmm3/mem, negate the multiplication result and subtract xmm2 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMSUB132PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W1 9E /r"
    instruction_group_index: 544
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from xmm1 and xmm2, negate the multiplication result and subtract xmm3/mem and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMSUB213PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W1 AE /r"
    instruction_group_index: 544
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from xmm2 and xmm3/mem, negate the multiplication result and subtract xmm1 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMSUB231PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W1 BE /r"
    instruction_group_index: 544
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from ymm1 and ymm3/mem, negate the multiplication result and subtract ymm2 and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFNMSUB132PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W1 9E /r"
    instruction_group_index: 544
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from ymm1 and ymm2, negate the multiplication result and subtract ymm3/mem and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFNMSUB213PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W1 AE /r"
    instruction_group_index: 544
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from ymm2 and ymm3/mem, negate the multiplication result and subtract ymm1 and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFNMSUB231PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W1 BE /r"
    instruction_group_index: 544
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from xmm1 and xmm3/m128/m64bcst, negate the multiplication result and subtract xmm2 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMSUB132PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 9E /r"
    instruction_group_index: 544
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from xmm1 and xmm2, negate the multiplication result and subtract xmm3/m128/m64bcst and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMSUB213PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 AE /r"
    instruction_group_index: 544
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from xmm2 and xmm3/m128/m64bcst, negate the multiplication result and subtract xmm1 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMSUB231PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 BE /r"
    instruction_group_index: 544
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from ymm1 and ymm3/m256/m64bcst, negate the multiplication result and subtract ymm2 and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFNMSUB132PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 9E /r"
    instruction_group_index: 544
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from ymm1 and ymm2, negate the multiplication result and subtract ymm3/m256/m64bcst and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFNMSUB213PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 AE /r"
    instruction_group_index: 544
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from ymm2 and ymm3/m256/m64bcst, negate the multiplication result and subtract ymm1 and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFNMSUB231PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 BE /r"
    instruction_group_index: 544
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from zmm1 and zmm3/m512/m64bcst, negate the multiplication result and subtract zmm2 and put result in zmm1."
    vendor_syntax {
      mnemonic: "VFNMSUB132PD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 9E /r"
    instruction_group_index: 544
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from zmm1 and zmm2, negate the multiplication result and subtract zmm3/m512/m64bcst and put result in zmm1."
    vendor_syntax {
      mnemonic: "VFNMSUB213PD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 AE /r"
    instruction_group_index: 544
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from zmm2 and zmm3/m512/m64bcst, negate the multiplication result and subtract zmm1 and put result in zmm1."
    vendor_syntax {
      mnemonic: "VFNMSUB231PD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 BE /r"
    instruction_group_index: 544
  }
  instructions {
    description: "Unpacks and Interleaves single-precision floating-point values from low quadwords of xmm1 and xmm2/m128."
    vendor_syntax {
      mnemonic: "UNPCKLPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 14 /r"
    instruction_group_index: 545
  }
  instructions {
    description: "Unpacks and Interleaves single-precision floating-point values from low quadwords of xmm2 and xmm3/m128."
    vendor_syntax {
      mnemonic: "VUNPCKLPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.0F.WIG 14 /r"
    instruction_group_index: 545
  }
  instructions {
    description: "Unpacks and Interleaves single-precision floating-point values from low quadwords of ymm2 and ymm3/m256."
    vendor_syntax {
      mnemonic: "VUNPCKLPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.0F.WIG 14 /r"
    instruction_group_index: 545
  }
  instructions {
    description: "Unpacks and Interleaves single-precision floating-point values from low quadwords of xmm2 and xmm3/mem and write result to xmm1 subject to write mask k1."
    vendor_syntax {
      mnemonic: "VUNPCKLPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.0F.W0 14 /r"
    instruction_group_index: 545
  }
  instructions {
    description: "Unpacks and Interleaves single-precision floating-point values from low quadwords of ymm2 and ymm3/mem and write result to ymm1 subject to write mask k1."
    vendor_syntax {
      mnemonic: "VUNPCKLPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.0F.W0 14 /r"
    instruction_group_index: 545
  }
  instructions {
    description: "Unpacks and Interleaves single-precision floating-point values from low quadwords of zmm2 and zmm3/m512/m32bcst and write result to zmm1 subject to write mask k1."
    vendor_syntax {
      mnemonic: "VUNPCKLPS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.0F.W0 14 /r"
    instruction_group_index: 545
  }
  instructions {
    description: "Move r8 to r/m8."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "88 /r"
    instruction_group_index: 546
  }
  instructions {
    description: "Move r8 to r/m8."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MR"
    raw_encoding_specification: "REX + 88 /r"
    instruction_group_index: 546
  }
  instructions {
    description: "Move r16 to r/m16."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "89 /r"
    instruction_group_index: 546
  }
  instructions {
    description: "Move r32 to r/m32."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "89 /r"
    instruction_group_index: 546
  }
  instructions {
    description: "Move r64 to r/m64."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MR"
    raw_encoding_specification: "REX.W + 89 /r"
    instruction_group_index: 546
  }
  instructions {
    description: "Move r/m8 to r8."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "8A /r"
    instruction_group_index: 546
  }
  instructions {
    description: "Move r/m8 to r8."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX + 8A /r"
    instruction_group_index: 546
  }
  instructions {
    description: "Move r/m16 to r16."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "8B /r"
    instruction_group_index: 546
  }
  instructions {
    description: "Move r/m32 to r32."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "8B /r"
    instruction_group_index: 546
  }
  instructions {
    description: "Move r/m64 to r64."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 8B /r"
    instruction_group_index: 546
  }
  instructions {
    description: "Move segment register to r/m16."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "Sreg"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "8C /r"
    instruction_group_index: 546
  }
  instructions {
    description: "Move zero extended 16-bit segment register to r16/r32/m16."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "r16/r32/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "Sreg"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "8C /r"
    instruction_group_index: 546
  }
  instructions {
    description: "Move zero extended 16-bit segment register to r64/m16."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "r64/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "Sreg"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "REX.W + 8C /r"
    instruction_group_index: 546
  }
  instructions {
    description: "Move r/m16 to segment register."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "Sreg"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "8E /r"
    instruction_group_index: 546
  }
  instructions {
    description: "Move lower 16 bits of r/m64 to segment register."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "Sreg"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 8E /r"
    instruction_group_index: 546
  }
  instructions {
    description: "Move byte at (seg:offset) to AL."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "AL"
        encoding: IMPLICIT_ENCODING
      }
      operands {
        name: "moffs8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "FD"
    raw_encoding_specification: "A0"
    instruction_group_index: 546
  }
  instructions {
    description: "Move byte at (offset) to AL."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "AL"
        encoding: IMPLICIT_ENCODING
      }
      operands {
        name: "moffs8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "FD"
    raw_encoding_specification: "REX.W + A0"
    instruction_group_index: 546
  }
  instructions {
    description: "Move word at (seg:offset) to AX."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "AX"
        encoding: IMPLICIT_ENCODING
      }
      operands {
        name: "moffs16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "FD"
    raw_encoding_specification: "A1"
    instruction_group_index: 546
  }
  instructions {
    description: "Move doubleword at (seg:offset) to EAX."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "EAX"
        encoding: IMPLICIT_ENCODING
      }
      operands {
        name: "moffs32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "FD"
    raw_encoding_specification: "A1"
    instruction_group_index: 546
  }
  instructions {
    description: "Move quadword at (offset) to RAX."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "RAX"
        encoding: IMPLICIT_ENCODING
      }
      operands {
        name: "moffs64"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "FD"
    raw_encoding_specification: "REX.W + A1"
    instruction_group_index: 546
  }
  instructions {
    description: "Move AL to (seg:offset)."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "moffs8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "AL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "TD"
    raw_encoding_specification: "A2"
    instruction_group_index: 546
  }
  instructions {
    description: "Move AL to (offset)."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "moffs8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "AL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    encoding_scheme: "TD"
    raw_encoding_specification: "REX.W + A2"
    instruction_group_index: 546
  }
  instructions {
    description: "Move AX to (seg:offset)."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "moffs16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "AX"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "TD"
    raw_encoding_specification: "A3"
    instruction_group_index: 546
  }
  instructions {
    description: "Move EAX to (seg:offset)."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "moffs32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "EAX"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "TD"
    raw_encoding_specification: "A3"
    instruction_group_index: 546
  }
  instructions {
    description: "Move RAX to (offset)."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "moffs64"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "RAX"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    encoding_scheme: "TD"
    raw_encoding_specification: "REX.W + A3"
    instruction_group_index: 546
  }
  instructions {
    description: "Move imm8 to r8."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "r8"
        encoding: OPCODE_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "OI"
    raw_encoding_specification: "B0+ rb ib"
    instruction_group_index: 546
  }
  instructions {
    description: "Move imm8 to r8."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "r8"
        encoding: OPCODE_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "OI"
    raw_encoding_specification: "REX + B0+ rb ib"
    instruction_group_index: 546
  }
  instructions {
    description: "Move imm16 to r16."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "r16"
        encoding: OPCODE_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "imm16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "OI"
    raw_encoding_specification: "B8+ rw iw"
    instruction_group_index: 546
  }
  instructions {
    description: "Move imm32 to r32."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "r32"
        encoding: OPCODE_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "OI"
    raw_encoding_specification: "B8+ rd id"
    instruction_group_index: 546
  }
  instructions {
    description: "Move imm64 to r64."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "r64"
        encoding: OPCODE_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "imm64"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "OI"
    raw_encoding_specification: "REX.W + B8+ rd io"
    instruction_group_index: 546
  }
  instructions {
    description: "Move imm8 to r/m8."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "C6 /0 ib"
    instruction_group_index: 546
  }
  instructions {
    description: "Move imm8 to r/m8."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX + C6 /0 ib"
    instruction_group_index: 546
  }
  instructions {
    description: "Move imm16 to r/m16."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "imm16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "C7 /0 iw"
    instruction_group_index: 546
  }
  instructions {
    description: "Move imm32 to r/m32."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "C7 /0 id"
    instruction_group_index: 546
  }
  instructions {
    description: "Move imm32 sign extended to 64-bits to r/m64."
    vendor_syntax {
      mnemonic: "MOV"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX.W + C7 /0 id"
    instruction_group_index: 546
  }
  instructions {
    description: "Scale ST(0) by ST(1)."
    vendor_syntax {
      mnemonic: "FSCALE"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D9 FD"
    instruction_group_index: 547
  }
  instructions {
    description: "Perform a packed comparison of string data with implicit lengths, generating a mask, and storing the result in XMM0."
    vendor_syntax {
      mnemonic: "PCMPISTRM"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "66 0F 3A 62 /r imm8"
    instruction_group_index: 548
  }
  instructions {
    description: "Perform a packed comparison of string data with implicit lengths, generating a Mask, and storing the result in XMM0."
    vendor_syntax {
      mnemonic: "VPCMPISTRM"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "VEX.128.66.0F3A.WIG 62 /r ib"
    instruction_group_index: 548
  }
  instructions {
    description: "Performs the final calculation for the next four SHA1 message dwords using intermediate results from xmm1 and the previous message dwords from xmm2/m128, storing the result in xmm1."
    vendor_syntax {
      mnemonic: "SHA1MSG2"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SHA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "NP 0F 38 CA /r"
    instruction_group_index: 549
  }
  instructions {
    description: "Causes an RTM abort if in RTM execution"
    vendor_syntax {
      mnemonic: "XABORT"
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "RTM"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "C6 F8 ib"
    instruction_group_index: 550
  }
  instructions {
    description: "Exchange r16 with AX."
    vendor_syntax {
      mnemonic: "XCHG"
      operands {
        name: "AX"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r16"
        encoding: OPCODE_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "O1"
    raw_encoding_specification: "90+rw"
    instruction_group_index: 551
  }
  instructions {
    description: "Exchange AX with r16."
    vendor_syntax {
      mnemonic: "XCHG"
      operands {
        name: "r16"
        encoding: OPCODE_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "AX"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "O2"
    raw_encoding_specification: "90+rw"
    instruction_group_index: 551
  }
  instructions {
    description: "Exchange r32 with EAX."
    vendor_syntax {
      mnemonic: "XCHG"
      operands {
        name: "EAX"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r32"
        encoding: OPCODE_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "O1"
    raw_encoding_specification: "90+rd"
    instruction_group_index: 551
  }
  instructions {
    description: "Exchange r64 with RAX."
    vendor_syntax {
      mnemonic: "XCHG"
      operands {
        name: "RAX"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r64"
        encoding: OPCODE_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    encoding_scheme: "O1"
    raw_encoding_specification: "REX.W + 90+rd"
    instruction_group_index: 551
  }
  instructions {
    description: "Exchange EAX with r32."
    vendor_syntax {
      mnemonic: "XCHG"
      operands {
        name: "r32"
        encoding: OPCODE_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "EAX"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "O2"
    raw_encoding_specification: "90+rd"
    instruction_group_index: 551
  }
  instructions {
    description: "Exchange RAX with r64."
    vendor_syntax {
      mnemonic: "XCHG"
      operands {
        name: "r64"
        encoding: OPCODE_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "RAX"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    encoding_scheme: "O2"
    raw_encoding_specification: "REX.W + 90+rd"
    instruction_group_index: 551
  }
  instructions {
    description: "Exchange r8 (byte register) with byte from r/m8."
    vendor_syntax {
      mnemonic: "XCHG"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "86 /r"
    instruction_group_index: 551
  }
  instructions {
    description: "Exchange r8 (byte register) with byte from r/m8."
    vendor_syntax {
      mnemonic: "XCHG"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MR"
    raw_encoding_specification: "REX + 86 /r"
    instruction_group_index: 551
  }
  instructions {
    description: "Exchange byte from r/m8 with r8 (byte register)."
    vendor_syntax {
      mnemonic: "XCHG"
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "86 /r"
    instruction_group_index: 551
  }
  instructions {
    description: "Exchange byte from r/m8 with r8 (byte register)."
    vendor_syntax {
      mnemonic: "XCHG"
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX + 86 /r"
    instruction_group_index: 551
  }
  instructions {
    description: "Exchange r16 with word from r/m16."
    vendor_syntax {
      mnemonic: "XCHG"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "87 /r"
    instruction_group_index: 551
  }
  instructions {
    description: "Exchange word from r/m16 with r16."
    vendor_syntax {
      mnemonic: "XCHG"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "87 /r"
    instruction_group_index: 551
  }
  instructions {
    description: "Exchange r32 with doubleword from r/m32."
    vendor_syntax {
      mnemonic: "XCHG"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "87 /r"
    instruction_group_index: 551
  }
  instructions {
    description: "Exchange r64 with quadword from r/m64."
    vendor_syntax {
      mnemonic: "XCHG"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MR"
    raw_encoding_specification: "REX.W + 87 /r"
    instruction_group_index: 551
  }
  instructions {
    description: "Exchange doubleword from r/m32 with r32."
    vendor_syntax {
      mnemonic: "XCHG"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "87 /r"
    instruction_group_index: 551
  }
  instructions {
    description: "Exchange quadword from r/m64 with r64."
    vendor_syntax {
      mnemonic: "XCHG"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 87 /r"
    instruction_group_index: 551
  }
  instructions {
    description: "Push m16int onto the FPU register stack."
    vendor_syntax {
      mnemonic: "FILD"
      operands {
        name: "m16int"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DF /0"
    instruction_group_index: 552
  }
  instructions {
    description: "Push m32int onto the FPU register stack."
    vendor_syntax {
      mnemonic: "FILD"
      operands {
        name: "m32int"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DB /0"
    instruction_group_index: 552
  }
  instructions {
    description: "Push m64int onto the FPU register stack."
    vendor_syntax {
      mnemonic: "FILD"
      operands {
        name: "m64int"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DF /5"
    instruction_group_index: 552
  }
  instructions {
    description: "Round packed single precision floating-point values in xmm2/m128 and place the result in xmm1.  The rounding mode is determined by imm8."
    vendor_syntax {
      mnemonic: "ROUNDPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMI"
    raw_encoding_specification: "66 0F 3A 08 /r ib"
    instruction_group_index: 553
  }
  instructions {
    description: "Round packed single-precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by imm8."
    vendor_syntax {
      mnemonic: "VROUNDPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMI"
    raw_encoding_specification: "VEX.128.66.0F3A.WIG 08 /r ib"
    instruction_group_index: 553
  }
  instructions {
    description: "Round packed single-precision floating-point values in ymm2/m256 and place the result in ymm1. The rounding mode is determined by imm8."
    vendor_syntax {
      mnemonic: "VROUNDPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMI"
    raw_encoding_specification: "VEX.256.66.0F3A.WIG 08 /r ib"
    instruction_group_index: 553
  }
  instructions {
    description: "Insert 128 bits of packed floating-point values from xmm3/m128 and the remaining values from ymm2 into ymm1."
    vendor_syntax {
      mnemonic: "VINSERTF128"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F3A.W0 18 /r ib"
    instruction_group_index: 554
  }
  instructions {
    description: "Insert 128 bits of packed single-precision floatingpoint values from xmm3/m128 and the remaining values from ymm2 into ymm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VINSERTF32X4"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F3A.W0 18 /r ib"
    instruction_group_index: 554
  }
  instructions {
    description: "Insert 128 bits of packed single-precision floatingpoint values from xmm3/m128 and the remaining values from zmm2 into zmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VINSERTF32X4"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F3A.W0 18 /r ib"
    instruction_group_index: 554
  }
  instructions {
    description: "Insert 128 bits of packed double-precision floatingpoint values from xmm3/m128 and the remaining values from ymm2 into ymm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VINSERTF64X2"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F3A.W1 18 /r ib"
    instruction_group_index: 554
  }
  instructions {
    description: "Insert 128 bits of packed double-precision floatingpoint values from xmm3/m128 and the remaining values from zmm2 into zmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VINSERTF64X2"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F3A.W1 18 /r ib"
    instruction_group_index: 554
  }
  instructions {
    description: "Insert 256 bits of packed single-precision floatingpoint values from ymm3/m256 and the remaining values from zmm2 into zmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VINSERTF32X8"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.66.0F3A.W0 1A /r ib"
    instruction_group_index: 554
  }
  instructions {
    description: "Insert 256 bits of packed double-precision floatingpoint values from ymm3/m256 and the remaining values from zmm2 into zmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VINSERTF64X4"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F3A.W1 1A /r ib"
    instruction_group_index: 554
  }
  instructions {
    description: "Flushes cache line containing m8."
    vendor_syntax {
      mnemonic: "CLFLUSH"
      operands {
        name: "m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "NP 0F AE /7"
    instruction_group_index: 555
  }
  instructions {
    description: "Read performance-monitoring counter specified by ECX into EDX:EAX."
    vendor_syntax {
      mnemonic: "RDPMC"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "0F 33"
    instruction_group_index: 556
  }
  instructions {
    description: "Broadcast an 8-bit value from a GPR to all bytes in the 128-bit destination subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPBROADCASTB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "reg"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 7A /r"
    instruction_group_index: 557
  }
  instructions {
    description: "Broadcast an 8-bit value from a GPR to all bytes in the 256-bit destination subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPBROADCASTB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "reg"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 7A /r"
    instruction_group_index: 557
  }
  instructions {
    description: "Broadcast an 8-bit value from a GPR to all bytes in the 512-bit destination subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPBROADCASTB"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "reg"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 7A /r"
    instruction_group_index: 557
  }
  instructions {
    description: "Broadcast a 16-bit value from a GPR to all words in the 128-bit destination subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPBROADCASTW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "reg"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 7B /r"
    instruction_group_index: 557
  }
  instructions {
    description: "Broadcast a 16-bit value from a GPR to all words in the 256-bit destination subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPBROADCASTW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "reg"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 7B /r"
    instruction_group_index: 557
  }
  instructions {
    description: "Broadcast a 16-bit value from a GPR to all words in the 512-bit destination subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPBROADCASTW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "reg"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 7B /r"
    instruction_group_index: 557
  }
  instructions {
    description: "Broadcast a 32-bit value from a GPR to all double-words in the 128-bit destination subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPBROADCASTD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "r32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 7C /r"
    instruction_group_index: 557
  }
  instructions {
    description: "Broadcast a 32-bit value from a GPR to all double-words in the 256-bit destination subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPBROADCASTD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "r32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 7C /r"
    instruction_group_index: 557
  }
  instructions {
    description: "Broadcast a 32-bit value from a GPR to all double-words in the 512-bit destination subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPBROADCASTD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "r32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 7C /r"
    instruction_group_index: 557
  }
  instructions {
    description: "Broadcast a 64-bit value from a GPR to all quad-words in the 128-bit destination subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPBROADCASTQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "r64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 7C /r"
    instruction_group_index: 557
  }
  instructions {
    description: "Broadcast a 64-bit value from a GPR to all quad-words in the 256-bit destination subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPBROADCASTQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "r64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 7C /r"
    instruction_group_index: 557
  }
  instructions {
    description: "Broadcast a 64-bit value from a GPR to all quad-words in the 512-bit destination subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPBROADCASTQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "r64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 7C /r"
    instruction_group_index: 557
  }
  instructions {
    description: "Extract the normalized mantissa of the low float64 element in xmm3/m64 using imm8 for sign control and mantissa interval normalization. Store the mantissa to xmm1 under the writemask k1 and merge with the other elements of xmm2."
    vendor_syntax {
      mnemonic: "VGETMANTSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.LIG.66.0F3A.W1 27 /r ib"
    instruction_group_index: 558
  }
  instructions {
    description: "Move low quadword from xmm to mmx register."
    vendor_syntax {
      mnemonic: "MOVDQ2Q"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "F2 0F D6 /r"
    instruction_group_index: 559
  }
  instructions {
    description: "Compress packed quadword integer values from xmm2 to xmm1/m128 using controlmask k1."
    vendor_syntax {
      mnemonic: "VPCOMPRESSQ"
      operands {
        name: "xmm1/m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 8B /r"
    instruction_group_index: 560
  }
  instructions {
    description: "Compress packed quadword integer values from ymm2 to ymm1/m256 using controlmask k1."
    vendor_syntax {
      mnemonic: "VPCOMPRESSQ"
      operands {
        name: "ymm1/m256"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 8B /r"
    instruction_group_index: 560
  }
  instructions {
    description: "Compress packed quadword integer values from zmm2 to zmm1/m512 using controlmask k1."
    vendor_syntax {
      mnemonic: "VPCOMPRESSQ"
      operands {
        name: "zmm1/m512"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 8B /r"
    instruction_group_index: 560
  }
  instructions {
    description: "Calculate four RANGE operation output value from 4 pairs of single-precision floating-point values in xmm2 and xmm3/m128/m32bcst, store the results to xmm1 under the writemask k1. Imm8 specifies the comparison and sign of the range operation."
    vendor_syntax {
      mnemonic: "VRANGEPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F3A.W0 50 /r ib"
    instruction_group_index: 561
  }
  instructions {
    description: "Calculate eight RANGE operation output value from 8 pairs of single-precision floating-point values in ymm2 and ymm3/m256/m32bcst, store the results to ymm1 under the writemask k1. Imm8 specifies the comparison and sign of the range operation."
    vendor_syntax {
      mnemonic: "VRANGEPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F3A.W0 50 /r ib"
    instruction_group_index: 561
  }
  instructions {
    description: "Calculate 16 RANGE operation output value from 16 pairs of single-precision floating-point values in zmm2 and zmm3/m512/m32bcst, store the results to zmm1 under the writemask k1. Imm8 specifies the comparison and sign of the range operation."
    vendor_syntax {
      mnemonic: "VRANGEPS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F3A.W0 50 /r ib"
    instruction_group_index: 561
  }
  instructions {
    description: "Computes the approximate reciprocal of the scalar singleprecision floating-point value in xmm3/m32 and stores the results in xmm1 using writemask k1. Also, upper doubleprecision floating-point value (bits[127:32]) from xmm2 is copied to xmm1[127:32]."
    vendor_syntax {
      mnemonic: "VRCP14SS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.LIG.66.0F38.W0 4D /r"
    instruction_group_index: 562
  }
  instructions {
    description: "Performs four rounds of SHA1 operation operating on SHA1 state (A,B,C,D) from xmm1, with a pre-computed sum of the next 4 round message dwords and state variable E from xmm2/m128.\nThe immediate byte controls logic functions and round constants."
    vendor_syntax {
      mnemonic: "SHA1RNDS4"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SHA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMI"
    raw_encoding_specification: "NP 0F 3A CC /r ib"
    instruction_group_index: 563
  }
  instructions {
    description: "Selectively write bytes from xmm1 to memory location using the byte mask in xmm2. The default memory location is specified by DS:DI/EDI/RDI."
    vendor_syntax {
      mnemonic: "MASKMOVDQU"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "66 0F F7 /r"
    instruction_group_index: 564
  }
  instructions {
    description: "Selectively write bytes from xmm1 to memory location using the byte mask in xmm2. The default memory location is specified by DS:DI/EDI/RDI."
    vendor_syntax {
      mnemonic: "VMASKMOVDQU"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "VEX.128.66.0F.WIG F7 /r"
    instruction_group_index: 564
  }
  instructions {
    description: "Push r/m16."
    vendor_syntax {
      mnemonic: "PUSH"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "FF /6"
    instruction_group_index: 565
  }
  instructions {
    description: "Push r/m32."
    vendor_syntax {
      mnemonic: "PUSH"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "FF /6"
    instruction_group_index: 565
  }
  instructions {
    description: "Push r/m64."
    vendor_syntax {
      mnemonic: "PUSH"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "FF /6"
    instruction_group_index: 565
  }
  instructions {
    description: "Push r16."
    vendor_syntax {
      mnemonic: "PUSH"
      operands {
        name: "r16"
        encoding: OPCODE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "O"
    raw_encoding_specification: "50+rw"
    instruction_group_index: 565
  }
  instructions {
    description: "Push r32."
    vendor_syntax {
      mnemonic: "PUSH"
      operands {
        name: "r32"
        encoding: OPCODE_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "O"
    raw_encoding_specification: "50+rd"
    instruction_group_index: 565
  }
  instructions {
    description: "Push r64."
    vendor_syntax {
      mnemonic: "PUSH"
      operands {
        name: "r64"
        encoding: OPCODE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "O"
    raw_encoding_specification: "50+rd"
    instruction_group_index: 565
  }
  instructions {
    description: "Push imm8."
    vendor_syntax {
      mnemonic: "PUSH"
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "I"
    raw_encoding_specification: "6A ib"
    instruction_group_index: 565
  }
  instructions {
    description: "Push imm16."
    vendor_syntax {
      mnemonic: "PUSH"
      operands {
        name: "imm16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "I"
    raw_encoding_specification: "68 iw"
    instruction_group_index: 565
  }
  instructions {
    description: "Push imm32."
    vendor_syntax {
      mnemonic: "PUSH"
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "I"
    raw_encoding_specification: "68 id"
    instruction_group_index: 565
  }
  instructions {
    description: "Push CS."
    vendor_syntax {
      mnemonic: "PUSH"
      operands {
        name: "CS"
      }
    }
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "0E"
    instruction_group_index: 565
  }
  instructions {
    description: "Push SS."
    vendor_syntax {
      mnemonic: "PUSH"
      operands {
        name: "SS"
      }
    }
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "16"
    instruction_group_index: 565
  }
  instructions {
    description: "Push DS."
    vendor_syntax {
      mnemonic: "PUSH"
      operands {
        name: "DS"
      }
    }
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "1E"
    instruction_group_index: 565
  }
  instructions {
    description: "Push ES."
    vendor_syntax {
      mnemonic: "PUSH"
      operands {
        name: "ES"
      }
    }
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "06"
    instruction_group_index: 565
  }
  instructions {
    description: "Push FS."
    vendor_syntax {
      mnemonic: "PUSH"
      operands {
        name: "FS"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "0F A0"
    instruction_group_index: 565
  }
  instructions {
    description: "Push GS."
    vendor_syntax {
      mnemonic: "PUSH"
      operands {
        name: "GS"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "0F A8"
    instruction_group_index: 565
  }
  instructions {
    description: "Convert four packed single precision floating-point values from xmm2/m128/m32bcst to four packed unsigned doubleword values in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VCVTPS2UDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.0F.W0 79 /r"
    instruction_group_index: 566
  }
  instructions {
    description: "Convert eight packed single precision floating-point values from ymm2/m256/m32bcst to eight packed unsigned doubleword values in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VCVTPS2UDQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.0F.W0 79 /r"
    instruction_group_index: 566
  }
  instructions {
    description: "Convert sixteen packed single-precision floating-point values from zmm2/m512/m32bcst to sixteen packed unsigned doubleword values in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VCVTPS2UDQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.0F.W0 79 /r"
    instruction_group_index: 566
  }
  instructions {
    description: "Concatenate xmm1 and xmm2, extract result shifted to the left by value in xmm3/m128 into xmm1."
    vendor_syntax {
      mnemonic: "VPSHLDVW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2 && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 70 /r"
    instruction_group_index: 567
  }
  instructions {
    description: "Concatenate ymm1 and ymm2, extract result shifted to the left by value in xmm3/m256 into ymm1."
    vendor_syntax {
      mnemonic: "VPSHLDVW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2 && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 70 /r"
    instruction_group_index: 567
  }
  instructions {
    description: "Concatenate zmm1 and zmm2, extract result shifted to the left by value in zmm3/m512 into zmm1."
    vendor_syntax {
      mnemonic: "VPSHLDVW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 70 /r"
    instruction_group_index: 567
  }
  instructions {
    description: "Concatenate xmm1 and xmm2, extract result shifted to the left by value in xmm3/m128 into xmm1."
    vendor_syntax {
      mnemonic: "VPSHLDVD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2 && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 71 /r"
    instruction_group_index: 567
  }
  instructions {
    description: "Concatenate ymm1 and ymm2, extract result shifted to the left by value in xmm3/m256 into ymm1."
    vendor_syntax {
      mnemonic: "VPSHLDVD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2 && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 71 /r"
    instruction_group_index: 567
  }
  instructions {
    description: "Concatenate zmm1 and zmm2, extract result shifted to the left by value in zmm3/m512 into zmm1."
    vendor_syntax {
      mnemonic: "VPSHLDVD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 71 /r"
    instruction_group_index: 567
  }
  instructions {
    description: "Concatenate xmm1 and xmm2, extract result shifted to the left by value in xmm3/m128 into xmm1."
    vendor_syntax {
      mnemonic: "VPSHLDVQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2 && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 71 /r"
    instruction_group_index: 567
  }
  instructions {
    description: "Concatenate ymm1 and ymm2, extract result shifted to the left by value in xmm3/m256 into ymm1."
    vendor_syntax {
      mnemonic: "VPSHLDVQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2 && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 71 /r"
    instruction_group_index: 567
  }
  instructions {
    description: "Concatenate zmm1 and zmm2, extract result shifted to the left by value in zmm3/m512 into zmm1."
    vendor_syntax {
      mnemonic: "VPSHLDVQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 71 /r"
    instruction_group_index: 567
  }
  instructions {
    description: "Initialize FPU after checking for pending unmasked floating-point exceptions."
    vendor_syntax {
      mnemonic: "FINIT"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "9B DB E3"
    instruction_group_index: 568
  }
  instructions {
    description: "Initialize FPU without checking for pending unmasked floating-point exceptions."
    vendor_syntax {
      mnemonic: "FNINIT"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DB E3"
    instruction_group_index: 568
  }
  instructions {
    description: "Rounds scalar single-precision floating-point value in xmm3/m32 to a number of fraction bits specified by the imm8 field. Stores the result in xmm1 register under writemask."
    vendor_syntax {
      mnemonic: "VRNDSCALESS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.LIG.66.0F3A.W0 0A /r ib"
    instruction_group_index: 569
  }
  instructions {
    description: "Input byte from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.*"
    vendor_syntax {
      mnemonic: "INS"
      operands {
        name: "m8"
      }
      operands {
        name: "DX"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "6C"
    instruction_group_index: 570
  }
  instructions {
    description: "Input word from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1"
    vendor_syntax {
      mnemonic: "INS"
      operands {
        name: "m16"
      }
      operands {
        name: "DX"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "6D"
    instruction_group_index: 570
  }
  instructions {
    description: "Input doubleword from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1"
    vendor_syntax {
      mnemonic: "INS"
      operands {
        name: "m32"
      }
      operands {
        name: "DX"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "6D"
    instruction_group_index: 570
  }
  instructions {
    description: "Input byte from I/O port specified in DX into memory location specified with ES:(E)DI or RDI.1"
    vendor_syntax {
      mnemonic: "INSB"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "6C"
    instruction_group_index: 570
  }
  instructions {
    description: "Input word from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1"
    vendor_syntax {
      mnemonic: "INSW"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "6D"
    instruction_group_index: 570
  }
  instructions {
    description: "Input doubleword from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1"
    vendor_syntax {
      mnemonic: "INSD"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "6D"
    instruction_group_index: 570
  }
  instructions {
    description: "Set interrupt flag; external, maskable interrupts enabled at the end of the next instruction."
    vendor_syntax {
      mnemonic: "STI"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "FB"
    instruction_group_index: 571
  }
  instructions {
    description: "Computes approximations to the exponential 2^x (with less than 2^-23 of maximum relative error) of the packed singleprecision floating-point values from zmm2/m512/m32bcst and stores the floating-point result in zmm1with writemask k1."
    vendor_syntax {
      mnemonic: "VEXP2PS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512ER"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 C8 /r"
    instruction_group_index: 572
  }
  instructions {
    description: "Leaves VMX operation."
    vendor_syntax {
      mnemonic: "VMXOFF"
    }
    feature_name: "VMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "0F 01 C4"
    instruction_group_index: 573
  }
  instructions {
    description: "This instruction is used to execute privileged Intel SGX leaf functions that are used for managing and debugging the enclaves."
    vendor_syntax {
      mnemonic: "ENCLS"
    }
    feature_name: "<UNKNOWN>"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "NP 0F 01 CF"
    instruction_group_index: 574
    leaf_instructions {
      description: "This leaf function initializes the enclave and makes it ready to execute enclave code."
      llvm_mnemonic: "EINIT"
      vendor_syntax {
        mnemonic: "EINIT"
        operands {
          name: "EAX"
          description: "EINIT (In); Error code (Out)"
          value: "\002"
          encoding: X86_REGISTER_EAX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RBX"
          description: "Address of SIGSTRUCT (In)"
          encoding: X86_REGISTER_RBX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RCX"
          description: "Address of SECS (In)"
          encoding: X86_REGISTER_RCX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RDX"
          description: "Address of EINITTOKEN (In)"
          encoding: X86_REGISTER_RDX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
      }
      feature_name: "SGX1"
      available_in_64_bit: true
      legacy_instruction: true
      encoding_scheme: "IR"
      instruction_group_index: 0
    }
    leaf_instructions {
      description: "This leaf function returns type and status information about an EPC page."
      llvm_mnemonic: "ERDINFO"
      vendor_syntax {
        mnemonic: "ERDINFO"
        operands {
          name: "EAX"
          description: "ERDINFO (In); Return error code \n(Out)"
          value: "\020"
          encoding: X86_REGISTER_EAX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RBX"
          description: "Address of a RDINFO structure (In)"
          encoding: X86_REGISTER_RBX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RCX"
          description: "Address of the destination EPC page \n(In)"
          encoding: X86_REGISTER_RCX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
      }
      feature_name: "<UNKNOWN>"
      available_in_64_bit: true
      legacy_instruction: true
      encoding_scheme: "IR"
      instruction_group_index: 0
    }
    leaf_instructions {
      description: "This leaf function changes the type of an existing EPC page."
      llvm_mnemonic: "EMODT"
      vendor_syntax {
        mnemonic: "EMODT"
        operands {
          name: "EAX"
          description: "EMODT (In); Return Error Code (Out)"
          value: "\017"
          encoding: X86_REGISTER_EAX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RBX"
          description: "Address of a SECINFO (In)"
          encoding: X86_REGISTER_RBX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RCX"
          description: "Address of the destination EPC page (In)"
          encoding: X86_REGISTER_RCX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
      }
      feature_name: "SGX2"
      available_in_64_bit: true
      legacy_instruction: true
      encoding_scheme: "IR"
      instruction_group_index: 0
    }
    leaf_instructions {
      description: "This leaf function loads, verifies an EPC page and marks the page as unblocked."
      llvm_mnemonic: "ELDU"
      vendor_syntax {
        mnemonic: "ELDU"
        operands {
          name: "EAX"
          description: "ELDB/ELDU \n(In); Return error \ncode (Out)"
          value: "\010"
          encoding: X86_REGISTER_EAX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RBX"
          description: "Address of the PAGEINFO \n(In)"
          encoding: X86_REGISTER_RBX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RCX"
          description: "Address of the EPC page \n(In)"
          encoding: X86_REGISTER_RCX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RDX"
          description: "Address of the version-\narray slot (In)"
          encoding: X86_REGISTER_RDX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
      }
      feature_name: "SGX1"
      available_in_64_bit: true
      legacy_instruction: true
      encoding_scheme: "IR"
      instruction_group_index: 0
    }
    leaf_instructions {
      description: "This leaf function adds a page to an initialized enclave."
      llvm_mnemonic: "EAUG"
      vendor_syntax {
        mnemonic: "EAUG"
        operands {
          name: "EAX"
          description: "EAUG (In)"
          value: "\r"
          encoding: X86_REGISTER_EAX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RBX"
          description: "Address of a SECINFO (In)"
          encoding: X86_REGISTER_RBX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RCX"
          description: "Address of the destination EPC page (In)"
          encoding: X86_REGISTER_RCX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
      }
      feature_name: "SGX2"
      available_in_64_bit: true
      legacy_instruction: true
      encoding_scheme: "IR"
      instruction_group_index: 0
    }
    leaf_instructions {
      description: "This leaf function begins an enclave build by creating an SECS page in EPC."
      llvm_mnemonic: "ECREATE"
      vendor_syntax {
        mnemonic: "ECREATE"
        operands {
          name: "EAX"
          description: "ECREATE (In)"
          value: "\000"
          encoding: X86_REGISTER_EAX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RBX"
          description: "Address of a PAGEINFO (In)"
          encoding: X86_REGISTER_RBX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RCX"
          description: "Address of the destination SECS page (In)"
          encoding: X86_REGISTER_RCX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
      }
      feature_name: "SGX1"
      available_in_64_bit: true
      legacy_instruction: true
      encoding_scheme: "IR"
      instruction_group_index: 0
    }
    leaf_instructions {
      description: "This leaf function restricts the access rights associated with a EPC page in an initialized enclave."
      llvm_mnemonic: "EMODPR"
      vendor_syntax {
        mnemonic: "EMODPR"
        operands {
          name: "EAX"
          description: "EMODPR (In); Return Error Code (Out)"
          value: "\016"
          encoding: X86_REGISTER_EAX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RBX"
          description: "Address of a SECINFO (In)"
          encoding: X86_REGISTER_RBX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RCX"
          description: "Address of the destination EPC page (In)"
          encoding: X86_REGISTER_RCX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
      }
      feature_name: "SGX2"
      available_in_64_bit: true
      legacy_instruction: true
      encoding_scheme: "IR"
      instruction_group_index: 0
    }
    leaf_instructions {
      description: "This leaf function loads, verifies an EPC page and marks the page as blocked."
      llvm_mnemonic: "ELDB"
      vendor_syntax {
        mnemonic: "ELDB"
        operands {
          name: "EAX"
          description: "ELDB/ELDU \n(In); Return error \ncode (Out)"
          value: "\007"
          encoding: X86_REGISTER_EAX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RBX"
          description: "Address of the PAGEINFO \n(In)"
          encoding: X86_REGISTER_RBX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RCX"
          description: "Address of the EPC page \n(In)"
          encoding: X86_REGISTER_RCX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RDX"
          description: "Address of the version-\narray slot (In)"
          encoding: X86_REGISTER_RDX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
      }
      feature_name: "SGX1"
      available_in_64_bit: true
      legacy_instruction: true
      encoding_scheme: "IR"
      instruction_group_index: 0
    }
    leaf_instructions {
      description: "This leaf function activates EBLOCK checks."
      llvm_mnemonic: "ETRACK"
      vendor_syntax {
        mnemonic: "ETRACK"
        operands {
          name: "EAX"
          description: "ETRACK (In); Return error code (Out)"
          value: "\014"
          encoding: X86_REGISTER_EAX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RCX"
          description: "Pointer to the SECS of the EPC page (In)"
          encoding: X86_REGISTER_RCX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
      }
      feature_name: "SGX1"
      available_in_64_bit: true
      legacy_instruction: true
      encoding_scheme: "IR"
      instruction_group_index: 0
    }
    leaf_instructions {
      description: "This leaf function adds a Version Array to the EPC."
      llvm_mnemonic: "EPA"
      vendor_syntax {
        mnemonic: "EPA"
        operands {
          name: "EAX"
          description: "EPA (In)"
          value: "\n"
          encoding: X86_REGISTER_EAX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RBX"
          description: "PT_VA (In, Constant)"
          encoding: X86_REGISTER_RBX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RCX"
          description: "Effective address of the EPC page (In)"
          encoding: X86_REGISTER_RCX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
      }
      feature_name: "SGX1"
      available_in_64_bit: true
      legacy_instruction: true
      encoding_scheme: "IR"
      instruction_group_index: 0
    }
    leaf_instructions {
      description: "This leaf function marks a page in the EPC as blocked."
      llvm_mnemonic: "EBLOCK"
      vendor_syntax {
        mnemonic: "EBLOCK"
        operands {
          name: "EAX"
          description: "EBLOCK (In); Return error code (Out)"
          value: "\t"
          encoding: X86_REGISTER_EAX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RCX"
          description: "Effective address of the EPC page (In)"
          encoding: X86_REGISTER_RCX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
      }
      feature_name: "SGX1"
      available_in_64_bit: true
      legacy_instruction: true
      encoding_scheme: "IR"
      instruction_group_index: 0
    }
    leaf_instructions {
      description: "This leaf function activates EBLOCK checks."
      llvm_mnemonic: "ETRACKC"
      vendor_syntax {
        mnemonic: "ETRACKC"
        operands {
          name: "EAX"
          description: "ETRACK \n(In); Return error code (Out)"
          value: "\021"
          encoding: X86_REGISTER_EAX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RCX"
          description: "Address of the destination EPC page (In, EA); Address of the SECS page (In, EA)"
          encoding: X86_REGISTER_RCX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
      }
      feature_name: "<UNKNOWN>"
      available_in_64_bit: true
      legacy_instruction: true
      encoding_scheme: "IR"
      instruction_group_index: 0
    }
    leaf_instructions {
      description: "This leaf function behaves lie ELDB but with improved conflict handling for oversubscription."
      llvm_mnemonic: "ELDBC"
      vendor_syntax {
        mnemonic: "ELDBC"
        operands {
          name: "EAX"
          description: "ELDB/ELDU \n(In); Return error \ncode (Out)"
          value: "\022"
          encoding: X86_REGISTER_EAX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RBX"
          description: "Address of the PAGEINFO \n(In)"
          encoding: X86_REGISTER_RBX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RCX"
          description: "Address of the EPC page \n(In)"
          encoding: X86_REGISTER_RCX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RDX"
          description: "Address of the version-\narray slot (In)"
          encoding: X86_REGISTER_RDX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
      }
      feature_name: "<UNKNOWN>"
      available_in_64_bit: true
      legacy_instruction: true
      encoding_scheme: "IR"
      instruction_group_index: 0
    }
    leaf_instructions {
      description: "This leaf function behaves like ELDU but with improved conflict handling for oversubscription."
      llvm_mnemonic: "ELDUC"
      vendor_syntax {
        mnemonic: "ELDUC"
        operands {
          name: "EAX"
          description: "ELDB/ELDU \n(In); Return error \ncode (Out)"
          value: "\023"
          encoding: X86_REGISTER_EAX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RBX"
          description: "Address of the PAGEINFO \n(In)"
          encoding: X86_REGISTER_RBX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RCX"
          description: "Address of the EPC page \n(In)"
          encoding: X86_REGISTER_RCX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RDX"
          description: "Address of the version-\narray slot (In)"
          encoding: X86_REGISTER_RDX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
      }
      feature_name: "<UNKNOWN>"
      available_in_64_bit: true
      legacy_instruction: true
      encoding_scheme: "IR"
      instruction_group_index: 0
    }
    leaf_instructions {
      description: "This leaf function adds a page to an uninitialized enclave."
      llvm_mnemonic: "EADD"
      vendor_syntax {
        mnemonic: "EADD"
        operands {
          name: "EAX"
          description: "EADD (In)"
          value: "\001"
          encoding: X86_REGISTER_EAX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RBX"
          description: "Address of a PAGEINFO (In)"
          encoding: X86_REGISTER_RBX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RCX"
          description: "Address of the destination EPC page (In)"
          encoding: X86_REGISTER_RCX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
      }
      feature_name: "SGX1"
      available_in_64_bit: true
      legacy_instruction: true
      encoding_scheme: "IR"
      instruction_group_index: 0
    }
    leaf_instructions {
      description: "This leaf function removes a page from the EPC."
      llvm_mnemonic: "EREMOVE"
      vendor_syntax {
        mnemonic: "EREMOVE"
        operands {
          name: "EAX"
          description: "EREMOVE (In); Return error code (Out)"
          value: "\003"
          encoding: X86_REGISTER_EAX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RCX"
          description: "Effective address of the EPC page (In)"
          encoding: X86_REGISTER_RCX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
      }
      feature_name: "SGX1"
      available_in_64_bit: true
      legacy_instruction: true
      encoding_scheme: "IR"
      instruction_group_index: 0
    }
    leaf_instructions {
      description: "This leaf function invalidates an EPC page and writes it out to main memory."
      llvm_mnemonic: "EWB"
      vendor_syntax {
        mnemonic: "EWB"
        operands {
          name: "EAX"
          description: "EWB (In); Error code (Out)"
          value: "\013"
          encoding: X86_REGISTER_EAX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RBX"
          description: "Address of an PAGEINFO (In)"
          encoding: X86_REGISTER_RBX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RCX"
          description: "Address of the EPC page (In)"
          encoding: X86_REGISTER_RCX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RDX"
          description: "Address of a VA slot (In)"
          encoding: X86_REGISTER_RDX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
      }
      feature_name: "SGX1"
      available_in_64_bit: true
      legacy_instruction: true
      encoding_scheme: "IR"
      instruction_group_index: 0
    }
    leaf_instructions {
      description: "This leaf function writes a dword/quadword to a debug enclave."
      llvm_mnemonic: "EDBGWR"
      vendor_syntax {
        mnemonic: "EDBGWR"
        operands {
          name: "EAX"
          description: "EDBGWR (In); Return error \ncode (Out)"
          value: "\005"
          encoding: X86_REGISTER_EAX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RBX"
          description: "Data to be written to a debug enclave (In)"
          encoding: X86_REGISTER_RBX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RCX"
          description: "Address of Target memory in the EPC (In)"
          encoding: X86_REGISTER_RCX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
      }
      feature_name: "SGX1"
      available_in_64_bit: true
      legacy_instruction: true
      encoding_scheme: "IR"
      instruction_group_index: 0
    }
    leaf_instructions {
      description: "This leaf function measures 256 bytes of an uninitialized enclave page."
      llvm_mnemonic: "EEXTEND"
      vendor_syntax {
        mnemonic: "EEXTEND"
        operands {
          name: "EAX"
          description: "EEXTEND (In)"
          value: "\006"
          encoding: X86_REGISTER_EAX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "EBX"
          description: "Effective address of the SECS of the \ndata chunk (In)"
          encoding: X86_REGISTER_EBX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RCX"
          description: "Effective address of a 256-byte chunk in the EPC (In)"
          encoding: X86_REGISTER_RCX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
      }
      feature_name: "SGX1"
      available_in_64_bit: true
      legacy_instruction: true
      encoding_scheme: "IR"
      instruction_group_index: 0
    }
    leaf_instructions {
      description: "This leaf function reads a dword/quadword from a debug enclave."
      llvm_mnemonic: "EDBGRD"
      vendor_syntax {
        mnemonic: "EDBGRD"
        operands {
          name: "EAX"
          description: "EDBGRD (In); Return error \ncode (Out)"
          value: "\004"
          encoding: X86_REGISTER_EAX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RBX"
          description: "Data read from a debug enclave (Out)"
          encoding: X86_REGISTER_RBX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
        operands {
          name: "RCX"
          description: "Address of source memory in the EPC (In)"
          encoding: X86_REGISTER_RCX
          data_type {
            kind: INTEGER
            bit_width: 64
          }
        }
      }
      feature_name: "SGX1"
      available_in_64_bit: true
      legacy_instruction: true
      encoding_scheme: "IR"
      instruction_group_index: 0
    }
  }
  instructions {
    description: "Set busy flag in supervisor shadow stack token reference by IA32_PL0_SSP."
    vendor_syntax {
      mnemonic: "SETSSBSY"
    }
    feature_name: "CET_SS"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F3 0F 01 E8"
    instruction_group_index: 576
  }
  instructions {
    description: "Extract one single-precision floating-point value from xmm1 at the offset specified by imm8 and store the result in reg or m32. Zero extend the results in 64-bit register if applicable."
    vendor_syntax {
      mnemonic: "EXTRACTPS"
      operands {
        name: "reg/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 3A 17 /r ib"
    instruction_group_index: 577
  }
  instructions {
    description: "Extract one single-precision floating-point value from xmm1 at the offset specified by imm8 and store the result in reg or m32. Zero extend the results in 64-bit register if applicable."
    vendor_syntax {
      mnemonic: "VEXTRACTPS"
      operands {
        name: "reg/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F3A.WIG 17 /r ib"
    instruction_group_index: 577
  }
  instructions {
    description: "Extract one single-precision floating-point value from xmm1 at the offset specified by imm8 and store the result in reg or m32. Zero extend the results in 64-bit register if applicable."
    vendor_syntax {
      mnemonic: "VEXTRACTPS"
      operands {
        name: "reg/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F3A.WIG 17 /r ib"
    instruction_group_index: 577
  }
  instructions {
    description: "Compare EDX:EAX with m64. If equal, set ZF and load ECX:EBX into m64. Else, clear ZF and load m64 into EDX:EAX."
    vendor_syntax {
      mnemonic: "CMPXCHG8B"
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F C7 /1"
    instruction_group_index: 578
  }
  instructions {
    description: "Compare RDX:RAX with m128. If equal, set ZF and load RCX:RBX into m128. Else, clear ZF and load m128 into RDX:RAX."
    vendor_syntax {
      mnemonic: "CMPXCHG16B"
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX.W + 0F C7 /1"
    instruction_group_index: 578
  }
  instructions {
    description: "Compare imm8 with AL."
    vendor_syntax {
      mnemonic: "CMP"
      operands {
        name: "AL"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "I"
    raw_encoding_specification: "3C ib"
    instruction_group_index: 579
  }
  instructions {
    description: "Compare imm16 with AX."
    vendor_syntax {
      mnemonic: "CMP"
      operands {
        name: "AX"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "I"
    raw_encoding_specification: "3D iw"
    instruction_group_index: 579
  }
  instructions {
    description: "Compare imm32 with EAX."
    vendor_syntax {
      mnemonic: "CMP"
      operands {
        name: "EAX"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "I"
    raw_encoding_specification: "3D id"
    instruction_group_index: 579
  }
  instructions {
    description: "Compare imm32 sign-extended to 64-bits with RAX."
    vendor_syntax {
      mnemonic: "CMP"
      operands {
        name: "RAX"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "I"
    raw_encoding_specification: "REX.W + 3D id"
    instruction_group_index: 579
  }
  instructions {
    description: "Compare imm8 with r/m8."
    vendor_syntax {
      mnemonic: "CMP"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "80 /7 ib"
    instruction_group_index: 579
  }
  instructions {
    description: "Compare imm8 with r/m8."
    vendor_syntax {
      mnemonic: "CMP"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX + 80 /7 ib"
    instruction_group_index: 579
  }
  instructions {
    description: "Compare imm16 with r/m16."
    vendor_syntax {
      mnemonic: "CMP"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "81 /7 iw"
    instruction_group_index: 579
  }
  instructions {
    description: "Compare imm32 with r/m32."
    vendor_syntax {
      mnemonic: "CMP"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "81 /7 id"
    instruction_group_index: 579
  }
  instructions {
    description: "Compare imm32 sign-extended to 64-bits with r/m64."
    vendor_syntax {
      mnemonic: "CMP"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX.W + 81 /7 id"
    instruction_group_index: 579
  }
  instructions {
    description: "Compare imm8 with r/m16."
    vendor_syntax {
      mnemonic: "CMP"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "83 /7 ib"
    instruction_group_index: 579
  }
  instructions {
    description: "Compare imm8 with r/m32."
    vendor_syntax {
      mnemonic: "CMP"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "83 /7 ib"
    instruction_group_index: 579
  }
  instructions {
    description: "Compare imm8 with r/m64."
    vendor_syntax {
      mnemonic: "CMP"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX.W + 83 /7 ib"
    instruction_group_index: 579
  }
  instructions {
    description: "Compare r8 with r/m8."
    vendor_syntax {
      mnemonic: "CMP"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "38 /r"
    instruction_group_index: 579
  }
  instructions {
    description: "Compare r8 with r/m8."
    vendor_syntax {
      mnemonic: "CMP"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MR"
    raw_encoding_specification: "REX + 38 /r"
    instruction_group_index: 579
  }
  instructions {
    description: "Compare r16 with r/m16."
    vendor_syntax {
      mnemonic: "CMP"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "39 /r"
    instruction_group_index: 579
  }
  instructions {
    description: "Compare r32 with r/m32."
    vendor_syntax {
      mnemonic: "CMP"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "39 /r"
    instruction_group_index: 579
  }
  instructions {
    description: "Compare r64 with r/m64."
    vendor_syntax {
      mnemonic: "CMP"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MR"
    raw_encoding_specification: "REX.W + 39 /r"
    instruction_group_index: 579
  }
  instructions {
    description: "Compare r/m8 with r8."
    vendor_syntax {
      mnemonic: "CMP"
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "3A /r"
    instruction_group_index: 579
  }
  instructions {
    description: "Compare r/m8 with r8."
    vendor_syntax {
      mnemonic: "CMP"
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX + 3A /r"
    instruction_group_index: 579
  }
  instructions {
    description: "Compare r/m16 with r16."
    vendor_syntax {
      mnemonic: "CMP"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "3B /r"
    instruction_group_index: 579
  }
  instructions {
    description: "Compare r/m32 with r32."
    vendor_syntax {
      mnemonic: "CMP"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "3B /r"
    instruction_group_index: 579
  }
  instructions {
    description: "Compare r/m64 with r64."
    vendor_syntax {
      mnemonic: "CMP"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 3B /r"
    instruction_group_index: 579
  }
  instructions {
    description: "Load FPU control word from m2byte."
    vendor_syntax {
      mnemonic: "FLDCW"
      operands {
        name: "m2byte"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D9 /5"
    instruction_group_index: 580
  }
  instructions {
    description: "Horizontal add packed double-precision floating-point values from xmm2/m128 to xmm1."
    vendor_syntax {
      mnemonic: "HADDPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "66 0F 7C /r"
    instruction_group_index: 581
  }
  instructions {
    description: "Horizontal add packed double-precision floating-point values from xmm2 and xmm3/mem."
    vendor_syntax {
      mnemonic: "VHADDPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.128.66.0F.WIG 7C /r"
    instruction_group_index: 581
  }
  instructions {
    description: "Horizontal add packed double-precision floating-point values from ymm2 and ymm3/mem."
    vendor_syntax {
      mnemonic: "VHADDPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.256.66.0F.WIG 7C /r"
    instruction_group_index: 581
  }
  instructions {
    description: "AX:= AL \342\210\227 r/m byte."
    vendor_syntax {
      mnemonic: "IMUL"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "F6 /5"
    instruction_group_index: 582
  }
  instructions {
    description: "DX:AX := AX \342\210\227 r/m word."
    vendor_syntax {
      mnemonic: "IMUL"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "F7 /5"
    instruction_group_index: 582
  }
  instructions {
    description: "EDX:EAX := EAX \342\210\227 r/m32."
    vendor_syntax {
      mnemonic: "IMUL"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "F7 /5"
    instruction_group_index: 582
  }
  instructions {
    description: "RDX:RAX := RAX \342\210\227 r/m64."
    vendor_syntax {
      mnemonic: "IMUL"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX.W + F7 /5"
    instruction_group_index: 582
  }
  instructions {
    description: "word register := word register \342\210\227 r/m16."
    vendor_syntax {
      mnemonic: "IMUL"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F AF /r"
    instruction_group_index: 582
  }
  instructions {
    description: "doubleword register := doubleword register \342\210\227 r/m32."
    vendor_syntax {
      mnemonic: "IMUL"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F AF /r"
    instruction_group_index: 582
  }
  instructions {
    description: "Quadword register := Quadword register \342\210\227 r/m64."
    vendor_syntax {
      mnemonic: "IMUL"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 0F AF /r"
    instruction_group_index: 582
  }
  instructions {
    description: "word register := r/m16 \342\210\227 sign-extended immediate byte."
    vendor_syntax {
      mnemonic: "IMUL"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMI"
    raw_encoding_specification: "6B /r ib"
    instruction_group_index: 582
  }
  instructions {
    description: "doubleword register := r/m32 \342\210\227 signextended immediate byte."
    vendor_syntax {
      mnemonic: "IMUL"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMI"
    raw_encoding_specification: "6B /r ib"
    instruction_group_index: 582
  }
  instructions {
    description: "Quadword register := r/m64 \342\210\227 sign-extended immediate byte."
    vendor_syntax {
      mnemonic: "IMUL"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RMI"
    raw_encoding_specification: "REX.W + 6B /r ib"
    instruction_group_index: 582
  }
  instructions {
    description: "word register := r/m16 \342\210\227 immediate word."
    vendor_syntax {
      mnemonic: "IMUL"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMI"
    raw_encoding_specification: "69 /r iw"
    instruction_group_index: 582
  }
  instructions {
    description: "doubleword register := r/m32 \342\210\227 immediate doubleword."
    vendor_syntax {
      mnemonic: "IMUL"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMI"
    raw_encoding_specification: "69 /r id"
    instruction_group_index: 582
  }
  instructions {
    description: "Quadword register := r/m64 \342\210\227 immediate doubleword."
    vendor_syntax {
      mnemonic: "IMUL"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RMI"
    raw_encoding_specification: "REX.W + 69 /r id"
    instruction_group_index: 582
  }
  instructions {
    description: "Asserts LOCK# signal for duration of the accompanying instruction."
    vendor_syntax {
      mnemonic: "LOCK"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "F0"
    instruction_group_index: 583
  }
  instructions {
    description: "Store FPU environment to m14byte or m28byte after checking for pending unmasked floating-point exceptions. Then mask all floating-pointexceptions."
    vendor_syntax {
      mnemonic: "FSTENV"
      operands {
        name: "m14/28byte"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "9B D9 /6"
    instruction_group_index: 584
  }
  instructions {
    description: "Store FPU environment to m14byte or m28byte without checking for pending unmasked floatingpoint exceptions. Then mask all floatingpointexceptions."
    vendor_syntax {
      mnemonic: "FNSTENV"
      operands {
        name: "m14/28byte"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D9 /6"
    instruction_group_index: 584
  }
  instructions {
    description: "Store FPU control word to m2byte after checking for pending unmasked floating-point exceptions."
    vendor_syntax {
      mnemonic: "FSTCW"
      operands {
        name: "m2byte"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "9B D9 /7"
    instruction_group_index: 585
  }
  instructions {
    description: "Store FPU control word to m2byte without checking for pending unmasked floating-point exceptions."
    vendor_syntax {
      mnemonic: "FNSTCW"
      operands {
        name: "m2byte"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D9 /7"
    instruction_group_index: 585
  }
  instructions {
    description: "Subtract 16-bit signed integer horizontally, pack saturated integers to mm1."
    vendor_syntax {
      mnemonic: "PHSUBSW"
      operands {
        name: "mm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "NP 0F 38 07 /r"
    instruction_group_index: 586
  }
  instructions {
    description: "Subtract 16-bit signed integer horizontally, pack saturated integers to xmm1."
    vendor_syntax {
      mnemonic: "PHSUBSW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "66 0F 38 07 /r"
    instruction_group_index: 586
  }
  instructions {
    description: "Subtract 16-bit signed integer horizontally, pack saturated integers to xmm1."
    vendor_syntax {
      mnemonic: "VPHSUBSW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.128.66.0F38.WIG 07 /r"
    instruction_group_index: 586
  }
  instructions {
    description: "Subtract 16-bit signed integer horizontally, pack saturated integers to ymm1."
    vendor_syntax {
      mnemonic: "VPHSUBSW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.256.66.0F38.WIG 07 /r"
    instruction_group_index: 586
  }
  instructions {
    description: "Select packed single precision floating-point values from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1."
    vendor_syntax {
      mnemonic: "BLENDPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMI"
    raw_encoding_specification: "66 0F 3A 0C /r ib"
    instruction_group_index: 587
  }
  instructions {
    description: "Select packed single-precision floating-point values from xmm2 and xmm3/m128 from mask in imm8 and store the values in xmm1."
    vendor_syntax {
      mnemonic: "VBLENDPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVMI"
    raw_encoding_specification: "VEX.128.66.0F3A.WIG 0C /r ib"
    instruction_group_index: 587
  }
  instructions {
    description: "Select packed single-precision floating-point values from ymm2 and ymm3/m256 from mask in imm8 and store the values in ymm1."
    vendor_syntax {
      mnemonic: "VBLENDPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVMI"
    raw_encoding_specification: "VEX.256.66.0F3A.WIG 0C /r ib"
    instruction_group_index: 587
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from xmm1 and xmm3/mem, add/subtract elements in xmm2 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMADDSUB132PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W0 96 /r"
    instruction_group_index: 588
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from xmm1 and xmm2, add/subtract elements in xmm3/mem and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMADDSUB213PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W0 A6 /r"
    instruction_group_index: 588
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from xmm2 and xmm3/mem, add/subtract elements in xmm1 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMADDSUB231PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W0 B6 /r"
    instruction_group_index: 588
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from ymm1 and ymm3/mem, add/subtract elements in ymm2 and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFMADDSUB132PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W0 96 /r"
    instruction_group_index: 588
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from ymm1 and ymm2, add/subtract elements in ymm3/mem and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFMADDSUB213PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W0 A6 /r"
    instruction_group_index: 588
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from ymm2 and ymm3/mem, add/subtract elements in ymm1 and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFMADDSUB231PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W0 B6 /r"
    instruction_group_index: 588
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from xmm1 and xmm2, add/subtract elements in xmm3/m128/m32bcst and put result in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMADDSUB213PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 A6 /r"
    instruction_group_index: 588
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from xmm2 and xmm3/m128/m32bcst, add/subtract elements in xmm1 and put result in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMADDSUB231PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 B6 /r"
    instruction_group_index: 588
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from xmm1 and xmm3/m128/m32bcst, add/subtract elements in zmm2 and put result in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMADDSUB132PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 96 /r"
    instruction_group_index: 588
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from ymm1 and ymm2, add/subtract elements in ymm3/m256/m32bcst and put result in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMADDSUB213PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 A6 /r"
    instruction_group_index: 588
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from ymm2 and ymm3/m256/m32bcst, add/subtract elements in ymm1 and put result in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMADDSUB231PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 B6 /r"
    instruction_group_index: 588
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from ymm1 and ymm3/m256/m32bcst, add/subtract elements in ymm2 and put result in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMADDSUB132PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 96 /r"
    instruction_group_index: 588
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from zmm1 and zmm2, add/subtract elements in zmm3/m512/m32bcst and put result in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMADDSUB213PS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 A6 /r"
    instruction_group_index: 588
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from zmm2 and zmm3/m512/m32bcst, add/subtract elements in zmm1 and put result in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMADDSUB231PS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 B6 /r"
    instruction_group_index: 588
  }
  instructions {
    description: "Multiply packed single-precision floating-point values from zmm1 and zmm3/m512/m32bcst, add/subtract elements in zmm2 and put result in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMADDSUB132PS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 96 /r"
    instruction_group_index: 588
  }
  instructions {
    description: "Using signed dword indices, scatter single-precision floating-point values to memory using writemask k1."
    vendor_syntax {
      mnemonic: "VSCATTERDPS"
      operands {
        name: "vm32x"
        encoding: VSIB_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_READ
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 A2 /vsib"
    instruction_group_index: 589
  }
  instructions {
    description: "Using signed dword indices, scatter single-precision floating-point values to memory using writemask k1."
    vendor_syntax {
      mnemonic: "VSCATTERDPS"
      operands {
        name: "vm32y"
        encoding: VSIB_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_READ
      }
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 A2 /vsib"
    instruction_group_index: 589
  }
  instructions {
    description: "Using signed dword indices, scatter single-precision floating-point values to memory using writemask k1."
    vendor_syntax {
      mnemonic: "VSCATTERDPS"
      operands {
        name: "vm32z"
        encoding: VSIB_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_READ
      }
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 A2 /vsib"
    instruction_group_index: 589
  }
  instructions {
    description: "Using signed dword indices, scatter double-precision floating-point values to memory using writemask k1."
    vendor_syntax {
      mnemonic: "VSCATTERDPD"
      operands {
        name: "vm32x"
        encoding: VSIB_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_READ
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 A2 /vsib"
    instruction_group_index: 589
  }
  instructions {
    description: "Using signed dword indices, scatter double-precision floating-point values to memory using writemask k1."
    vendor_syntax {
      mnemonic: "VSCATTERDPD"
      operands {
        name: "vm32x"
        encoding: VSIB_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_READ
      }
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 A2 /vsib"
    instruction_group_index: 589
  }
  instructions {
    description: "Using signed dword indices, scatter double-precision floating-point values to memory using writemask k1."
    vendor_syntax {
      mnemonic: "VSCATTERDPD"
      operands {
        name: "vm32y"
        encoding: VSIB_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_READ
      }
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 A2 /vsib"
    instruction_group_index: 589
  }
  instructions {
    description: "Using signed qword indices, scatter single-precision floating-point values to memory using writemask k1."
    vendor_syntax {
      mnemonic: "VSCATTERQPS"
      operands {
        name: "vm64x"
        encoding: VSIB_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_READ
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 A3 /vsib"
    instruction_group_index: 589
  }
  instructions {
    description: "Using signed qword indices, scatter single-precision floating-point values to memory using writemask k1."
    vendor_syntax {
      mnemonic: "VSCATTERQPS"
      operands {
        name: "vm64y"
        encoding: VSIB_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_READ
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 A3 /vsib"
    instruction_group_index: 589
  }
  instructions {
    description: "Using signed qword indices, scatter single-precision floating-point values to memory using writemask k1."
    vendor_syntax {
      mnemonic: "VSCATTERQPS"
      operands {
        name: "vm64z"
        encoding: VSIB_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_READ
      }
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 A3 /vsib"
    instruction_group_index: 589
  }
  instructions {
    description: "Using signed qword indices, scatter double-precision floating-point values to memory using writemask k1."
    vendor_syntax {
      mnemonic: "VSCATTERQPD"
      operands {
        name: "vm64x"
        encoding: VSIB_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_READ
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 A3 /vsib"
    instruction_group_index: 589
  }
  instructions {
    description: "Using signed qword indices, scatter double-precision floating-point values to memory using writemask k1."
    vendor_syntax {
      mnemonic: "VSCATTERQPD"
      operands {
        name: "vm64y"
        encoding: VSIB_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_READ
      }
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 A3 /vsib"
    instruction_group_index: 589
  }
  instructions {
    description: "Using signed qword indices, scatter double-precision floating-point values to memory using writemask k1."
    vendor_syntax {
      mnemonic: "VSCATTERQPD"
      operands {
        name: "vm64z"
        encoding: VSIB_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_READ
      }
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 A3 /vsib"
    instruction_group_index: 589
  }
  instructions {
    description: "Load the 32-bit destination register with the FS base address."
    vendor_syntax {
      mnemonic: "RDFSBASE"
      operands {
        name: "r32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    feature_name: "FSGSBASE"
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "F3 0F AE /0"
    instruction_group_index: 590
  }
  instructions {
    description: "Load the 64-bit destination register with the FS base address."
    vendor_syntax {
      mnemonic: "RDFSBASE"
      operands {
        name: "r64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    feature_name: "FSGSBASE"
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "F3 REX.W 0F AE /0"
    instruction_group_index: 590
  }
  instructions {
    description: "Load the 32-bit destination register with the GS base address."
    vendor_syntax {
      mnemonic: "RDGSBASE"
      operands {
        name: "r32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    feature_name: "FSGSBASE"
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "F3 0F AE /1"
    instruction_group_index: 590
  }
  instructions {
    description: "Load the 64-bit destination register with the GS base address."
    vendor_syntax {
      mnemonic: "RDGSBASE"
      operands {
        name: "r64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    feature_name: "FSGSBASE"
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "F3 REX.W 0F AE /1"
    instruction_group_index: 590
  }
  instructions {
    description: "Enter VMX root operation."
    vendor_syntax {
      mnemonic: "VMXON"
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "VMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "F3 0F C7 /6"
    instruction_group_index: 591
  }
  instructions {
    description: "Replace ST(0) with its approximate tangent and push 1 onto the FPU stack."
    vendor_syntax {
      mnemonic: "FPTAN"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D9 F2"
    instruction_group_index: 592
  }
  instructions {
    description: "Loads r/m16 in machine status word of CR0."
    vendor_syntax {
      mnemonic: "LMSW"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 01 /6"
    instruction_group_index: 593
  }
  instructions {
    description: "Bit scan reverse on r/m16."
    vendor_syntax {
      mnemonic: "BSR"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F BD /r"
    instruction_group_index: 594
  }
  instructions {
    description: "Bit scan reverse on r/m32."
    vendor_syntax {
      mnemonic: "BSR"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F BD /r"
    instruction_group_index: 594
  }
  instructions {
    description: "Bit scan reverse on r/m64."
    vendor_syntax {
      mnemonic: "BSR"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 0F BD /r"
    instruction_group_index: 594
  }
  instructions {
    description: "Add packed unsigned byte integers from mm/m64 and mm and saturate the results."
    vendor_syntax {
      mnemonic: "PADDUSB"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F DC /r"
    instruction_group_index: 595
  }
  instructions {
    description: "Add packed unsigned byte integers from xmm2/m128 and xmm1 saturate the results."
    vendor_syntax {
      mnemonic: "PADDUSB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F DC /r"
    instruction_group_index: 595
  }
  instructions {
    description: "Add packed unsigned word integers from mm/m64 and mm and saturate the results."
    vendor_syntax {
      mnemonic: "PADDUSW"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F DD /r"
    instruction_group_index: 595
  }
  instructions {
    description: "Add packed unsigned word integers from xmm2/m128 to xmm1 and saturate the results."
    vendor_syntax {
      mnemonic: "PADDUSW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F DD /r"
    instruction_group_index: 595
  }
  instructions {
    description: "Add packed unsigned byte integers from xmm3/m128 to xmm2 and saturate the results."
    vendor_syntax {
      mnemonic: "VPADDUSB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.NDS.128.66.0F.WIG DC /r"
    instruction_group_index: 595
  }
  instructions {
    description: "Add packed unsigned word integers from xmm3/m128 to xmm2 and saturate the results."
    vendor_syntax {
      mnemonic: "VPADDUSW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG DD /r"
    instruction_group_index: 595
  }
  instructions {
    description: "Add packed unsigned byte integers from ymm2, and ymm3/m256 and store the saturated results in ymm1."
    vendor_syntax {
      mnemonic: "VPADDUSB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG DC /r"
    instruction_group_index: 595
  }
  instructions {
    description: "Add packed unsigned word integers from ymm2, and ymm3/m256 and store the saturated results in ymm1."
    vendor_syntax {
      mnemonic: "VPADDUSW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG DD /r"
    instruction_group_index: 595
  }
  instructions {
    description: "Add packed unsigned byte integers from xmm2, and xmm3/m128 and store the saturated results in xmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPADDUSB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.WIG DC /r"
    instruction_group_index: 595
  }
  instructions {
    description: "Add packed unsigned byte integers from ymm2, and ymm3/m256 and store the saturated results in ymm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPADDUSB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.WIG DC /r"
    instruction_group_index: 595
  }
  instructions {
    description: "Add packed unsigned byte integers from zmm2, and zmm3/m512 and store the saturated results in zmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPADDUSB"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.WIG DC /r"
    instruction_group_index: 595
  }
  instructions {
    description: "Add packed unsigned word integers from xmm2, and xmm3/m128 and store the saturated results in xmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPADDUSW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.WIG DD /r"
    instruction_group_index: 595
  }
  instructions {
    description: "Add packed unsigned word integers from ymm2, and ymm3/m256 and store the saturated results in ymm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPADDUSW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.WIG DD /r"
    instruction_group_index: 595
  }
  instructions {
    description: "Add packed unsigned word integers from zmm2, and zmm3/m512 and store the saturated results in zmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPADDUSW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.WIG DD /r"
    instruction_group_index: 595
  }
  instructions {
    description: "Convert two packed double-precision floating-point values in xmm2/mem to two single-precision floating-point values in xmm1."
    vendor_syntax {
      mnemonic: "CVTPD2PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 5A /r"
    instruction_group_index: 596
  }
  instructions {
    description: "Convert two packed double-precision floating-point values in xmm2/mem to two single-precision floating-point values in xmm1."
    vendor_syntax {
      mnemonic: "VCVTPD2PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F.WIG 5A /r"
    instruction_group_index: 596
  }
  instructions {
    description: "Convert four packed double-precision floating-point values in ymm2/mem to four single-precision floating-point values in xmm1."
    vendor_syntax {
      mnemonic: "VCVTPD2PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F.WIG 5A /r"
    instruction_group_index: 596
  }
  instructions {
    description: "Convert two packed double-precision floating-point values in xmm2/m128/m64bcst to two singleprecision floating-point values in xmm1with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTPD2PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F.W1 5A /r"
    instruction_group_index: 596
  }
  instructions {
    description: "Convert four packed double-precision floating-point values in ymm2/m256/m64bcst to four singleprecision floating-point values in xmm1with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTPD2PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F.W1 5A /r"
    instruction_group_index: 596
  }
  instructions {
    description: "Convert eight packed double-precision floating-point values in zmm2/m512/m64bcst to eight singleprecision floating-point values in ymm1with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTPD2PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F.W1 5A /r"
    instruction_group_index: 596
  }
  instructions {
    description: "Loads SF, ZF, AF, PF, and CF from AH into EFLAGS register."
    vendor_syntax {
      mnemonic: "SAHF"
    }
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "9E"
    instruction_group_index: 597
  }
  instructions {
    description: "Reverses the byte order of a 32-bit register."
    vendor_syntax {
      mnemonic: "BSWAP"
      operands {
        name: "r32"
        encoding: OPCODE_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "O"
    raw_encoding_specification: "0F C8+rd"
    instruction_group_index: 598
  }
  instructions {
    description: "Reverses the byte order of a 64-bit register."
    vendor_syntax {
      mnemonic: "BSWAP"
      operands {
        name: "r64"
        encoding: OPCODE_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    encoding_scheme: "O"
    raw_encoding_specification: "REX.W + 0F C8+rd"
    instruction_group_index: 598
  }
  instructions {
    description: "Move unaligned packed integer values from xmm2/m128 to xmm1."
    vendor_syntax {
      mnemonic: "MOVDQU"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F3 0F 6F /r"
    instruction_group_index: 599
  }
  instructions {
    description: "Move unaligned packed integer values from xmm1 to xmm2/m128."
    vendor_syntax {
      mnemonic: "MOVDQU"
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "F3 0F 7F /r"
    instruction_group_index: 599
  }
  instructions {
    description: "Move unaligned packed integer values from xmm2/m128 to xmm1."
    vendor_syntax {
      mnemonic: "VMOVDQU"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.F3.0F.WIG 6F /r"
    instruction_group_index: 599
  }
  instructions {
    description: "Move unaligned packed integer values from xmm1 to xmm2/m128."
    vendor_syntax {
      mnemonic: "VMOVDQU"
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.F3.0F.WIG 7F /r"
    instruction_group_index: 599
  }
  instructions {
    description: "Move unaligned packed integer values from ymm2/m256 to ymm1."
    vendor_syntax {
      mnemonic: "VMOVDQU"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.F3.0F.WIG 6F /r"
    instruction_group_index: 599
  }
  instructions {
    description: "Move unaligned packed integer values from ymm1 to ymm2/m256."
    vendor_syntax {
      mnemonic: "VMOVDQU"
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.F3.0F.WIG 7F /r"
    instruction_group_index: 599
  }
  instructions {
    description: "Move unaligned packed byte integer values from xmm2/m128 to xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVDQU8"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.F2.0F.W0 6F /r"
    instruction_group_index: 599
  }
  instructions {
    description: "Move unaligned packed byte integer values from ymm2/m256 to ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVDQU8"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.F2.0F.W0 6F /r"
    instruction_group_index: 599
  }
  instructions {
    description: "Move unaligned packed byte integer values from zmm2/m512 to zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVDQU8"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.F2.0F.W0 6F /r"
    instruction_group_index: 599
  }
  instructions {
    description: "Move unaligned packed byte integer values from xmm1 to xmm2/m128 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVDQU8"
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.128.F2.0F.W0 7F /r"
    instruction_group_index: 599
  }
  instructions {
    description: "Move unaligned packed byte integer values from ymm1 to ymm2/m256 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVDQU8"
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.256.F2.0F.W0 7F /r"
    instruction_group_index: 599
  }
  instructions {
    description: "Move unaligned packed byte integer values from zmm1 to zmm2/m512 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVDQU8"
      operands {
        name: "zmm2/m512"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.F2.0F.W0 7F /r"
    instruction_group_index: 599
  }
  instructions {
    description: "Move unaligned packed word integer values from xmm2/m128 to xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVDQU16"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.F2.0F.W1 6F /r"
    instruction_group_index: 599
  }
  instructions {
    description: "Move unaligned packed word integer values from ymm2/m256 to ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVDQU16"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.F2.0F.W1 6F /r"
    instruction_group_index: 599
  }
  instructions {
    description: "Move unaligned packed word integer values from zmm2/m512 to zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVDQU16"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.F2.0F.W1 6F /r"
    instruction_group_index: 599
  }
  instructions {
    description: "Move unaligned packed word integer values from xmm1 to xmm2/m128 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVDQU16"
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.128.F2.0F.W1 7F /r"
    instruction_group_index: 599
  }
  instructions {
    description: "Move unaligned packed word integer values from ymm1 to ymm2/m256 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVDQU16"
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.256.F2.0F.W1 7F /r"
    instruction_group_index: 599
  }
  instructions {
    description: "Move unaligned packed word integer values from zmm1 to zmm2/m512 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVDQU16"
      operands {
        name: "zmm2/m512"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.F2.0F.W1 7F /r"
    instruction_group_index: 599
  }
  instructions {
    description: "Move unaligned packed doubleword integer values from xmm2/m128 to xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVDQU32"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.F3.0F.W0 6F /r"
    instruction_group_index: 599
  }
  instructions {
    description: "Move unaligned packed doubleword integer values from ymm2/m256 to ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVDQU32"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.F3.0F.W0 6F /r"
    instruction_group_index: 599
  }
  instructions {
    description: "Move unaligned packed doubleword integer values from zmm2/m512 to zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVDQU32"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.F3.0F.W0 6F /r"
    instruction_group_index: 599
  }
  instructions {
    description: "Move unaligned packed doubleword integer values from xmm1 to xmm2/m128 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVDQU32"
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.128.F3.0F.W0 7F /r"
    instruction_group_index: 599
  }
  instructions {
    description: "Move unaligned packed doubleword integer values from ymm1 to ymm2/m256 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVDQU32"
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.256.F3.0F.W0 7F /r"
    instruction_group_index: 599
  }
  instructions {
    description: "Move unaligned packed doubleword integer values from zmm1 to zmm2/m512 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVDQU32"
      operands {
        name: "zmm2/m512"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.F3.0F.W0 7F /r"
    instruction_group_index: 599
  }
  instructions {
    description: "Move unaligned packed quadword integer values from xmm2/m128 to xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVDQU64"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.F3.0F.W1 6F /r"
    instruction_group_index: 599
  }
  instructions {
    description: "Move unaligned packed quadword integer values from ymm2/m256 to ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVDQU64"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.F3.0F.W1 6F /r"
    instruction_group_index: 599
  }
  instructions {
    description: "Move unaligned packed quadword integer values from zmm2/m512 to zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVDQU64"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.F3.0F.W1 6F /r"
    instruction_group_index: 599
  }
  instructions {
    description: "Move unaligned packed quadword integer values from xmm1 to xmm2/m128 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVDQU64"
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.128.F3.0F.W1 7F /r"
    instruction_group_index: 599
  }
  instructions {
    description: "Move unaligned packed quadword integer values from ymm1 to ymm2/m256 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVDQU64"
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.256.F3.0F.W1 7F /r"
    instruction_group_index: 599
  }
  instructions {
    description: "Move unaligned packed quadword integer values from zmm1 to zmm2/m512 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVDQU64"
      operands {
        name: "zmm2/m512"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.F3.0F.W1 7F /r"
    instruction_group_index: 599
  }
  instructions {
    description: "Set ZF if xmm2/m128 AND xmm1 result is all 0s. Set CF if xmm2/m128 AND NOT xmm1 result is all 0s."
    vendor_syntax {
      mnemonic: "PTEST"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "66 0F 38 17 /r"
    instruction_group_index: 600
  }
  instructions {
    description: "Set ZF and CF depending on bitwise AND and ANDN of sources."
    vendor_syntax {
      mnemonic: "VPTEST"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "VEX.128.66.0F38.WIG 17 /r"
    instruction_group_index: 600
  }
  instructions {
    description: "Set ZF and CF depending on bitwise AND and ANDN of sources."
    vendor_syntax {
      mnemonic: "VPTEST"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "VEX.256.66.0F38.WIG 17 /r"
    instruction_group_index: 600
  }
  instructions {
    description: "Decrement TOP field in FPU status word."
    vendor_syntax {
      mnemonic: "FDECSTP"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D9 F6"
    instruction_group_index: 601
  }
  instructions {
    description: "Add m32fp to ST(0) and store result in ST(0)."
    vendor_syntax {
      mnemonic: "FADD"
      operands {
        name: "m32fp"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D8 /0"
    instruction_group_index: 602
  }
  instructions {
    description: "Add m64fp to ST(0) and store result in ST(0)."
    vendor_syntax {
      mnemonic: "FADD"
      operands {
        name: "m64fp"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DC /0"
    instruction_group_index: 602
  }
  instructions {
    description: "Add ST(0) to ST(i) and store result in ST(0)."
    vendor_syntax {
      mnemonic: "FADD"
      operands {
        name: "ST(0)"
      }
      operands {
        name: "ST(i)"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D8 C0+i"
    instruction_group_index: 602
  }
  instructions {
    description: "Add ST(i) to ST(0) and store result in ST(i)."
    vendor_syntax {
      mnemonic: "FADD"
      operands {
        name: "ST(i)"
      }
      operands {
        name: "ST(0)"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DC C0+i"
    instruction_group_index: 602
  }
  instructions {
    description: "Add ST(0) to ST(i), store result in ST(i), and pop the register stack."
    vendor_syntax {
      mnemonic: "FADDP"
      operands {
        name: "ST(i)"
      }
      operands {
        name: "ST(0)"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DE C0+i"
    instruction_group_index: 602
  }
  instructions {
    description: "Add ST(0) to ST(1), store result in ST(1), and pop the register stack."
    vendor_syntax {
      mnemonic: "FADDP"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DE C1"
    instruction_group_index: 602
  }
  instructions {
    description: "Add m32int to ST(0) and store result in ST(0)."
    vendor_syntax {
      mnemonic: "FIADD"
      operands {
        name: "m32int"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DA /0"
    instruction_group_index: 602
  }
  instructions {
    description: "Add m16int to ST(0) and store result in ST(0)."
    vendor_syntax {
      mnemonic: "FIADD"
      operands {
        name: "m16int"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DE /0"
    instruction_group_index: 602
  }
  instructions {
    description: "Compare low single-precision floating-point value in xmm2/m32 and xmm1 using bits 2:0 of imm8 as comparison predicate."
    vendor_syntax {
      mnemonic: "CMPSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F3 0F C2 /r ib"
    instruction_group_index: 604
  }
  instructions {
    description: "Compare low single-precision floating-point value in xmm3/m32 and xmm2 using bits 4:0 of imm8 as comparison predicate."
    vendor_syntax {
      mnemonic: "VCMPSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.LIG.F3.0F.WIG C2 /r ib"
    instruction_group_index: 604
  }
  instructions {
    description: "Compare low single-precision floating-point value in xmm3/m32 and xmm2 using bits 4:0 of imm8 as comparison predicate with writemask k2 and leave the result in mask register k1."
    vendor_syntax {
      mnemonic: "VCMPSS"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.LIG.F3.0F.W0 C2 /r ib"
    instruction_group_index: 604
  }
  instructions {
    description: "Adjust RPL of r/m16 to not less than RPL of r16."
    vendor_syntax {
      mnemonic: "ARPL"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "63 /r"
    instruction_group_index: 606
  }
  instructions {
    description: "Copy low 32 bits of shadow stack pointer (SSP) to r32."
    vendor_syntax {
      mnemonic: "RDSSPD"
      operands {
        name: "r32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    feature_name: "CET_SS"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "R"
    raw_encoding_specification: "F3 0F 1E /1 (mod=11)"
    instruction_group_index: 607
  }
  instructions {
    description: "Copies shadow stack pointer (SSP) to r64."
    vendor_syntax {
      mnemonic: "RDSSPQ"
      operands {
        name: "r64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    feature_name: "CET_SS"
    available_in_64_bit: true
    encoding_scheme: "R"
    raw_encoding_specification: "F3 REX.W 0F 1E /1 (mod=11)"
    instruction_group_index: 607
  }
  instructions {
    description: "Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1."
    vendor_syntax {
      mnemonic: "PMOVZXBW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0f 38 30 /r"
    instruction_group_index: 608
  }
  instructions {
    description: "Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1."
    vendor_syntax {
      mnemonic: "PMOVZXBD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0f 38 31 /r"
    instruction_group_index: 608
  }
  instructions {
    description: "Zero extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1."
    vendor_syntax {
      mnemonic: "PMOVZXBQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0f 38 32 /r"
    instruction_group_index: 608
  }
  instructions {
    description: "Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1."
    vendor_syntax {
      mnemonic: "PMOVZXWD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0f 38 33 /r"
    instruction_group_index: 608
  }
  instructions {
    description: "Zero extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1."
    vendor_syntax {
      mnemonic: "PMOVZXWQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0f 38 34 /r"
    instruction_group_index: 608
  }
  instructions {
    description: "Zero extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1."
    vendor_syntax {
      mnemonic: "PMOVZXDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0f 38 35 /r"
    instruction_group_index: 608
  }
  instructions {
    description: "Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1."
    vendor_syntax {
      mnemonic: "VPMOVZXBW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.WIG 30 /r"
    instruction_group_index: 608
  }
  instructions {
    description: "Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1."
    vendor_syntax {
      mnemonic: "VPMOVZXBD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.WIG 31 /r"
    instruction_group_index: 608
  }
  instructions {
    description: "Zero extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1."
    vendor_syntax {
      mnemonic: "VPMOVZXBQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.WIG 32 /r"
    instruction_group_index: 608
  }
  instructions {
    description: "Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1."
    vendor_syntax {
      mnemonic: "VPMOVZXWD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.WIG 33 /r"
    instruction_group_index: 608
  }
  instructions {
    description: "Zero extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1."
    vendor_syntax {
      mnemonic: "VPMOVZXWQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.WIG 34 /r"
    instruction_group_index: 608
  }
  instructions {
    description: "Zero extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1."
    vendor_syntax {
      mnemonic: "VPMOVZXDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.WIG 35 /r"
    instruction_group_index: 608
  }
  instructions {
    description: "Zero extend 16 packed 8-bit integers in xmm2/m128 to 16 packed 16-bit integers in ymm1."
    vendor_syntax {
      mnemonic: "VPMOVZXBW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.WIG 30 /r"
    instruction_group_index: 608
  }
  instructions {
    description: "Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 32-bit integers in ymm1."
    vendor_syntax {
      mnemonic: "VPMOVZXBD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.WIG 31 /r"
    instruction_group_index: 608
  }
  instructions {
    description: "Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 64-bit integers in ymm1."
    vendor_syntax {
      mnemonic: "VPMOVZXBQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.WIG 32 /r"
    instruction_group_index: 608
  }
  instructions {
    description: "Zero extend 8 packed 16-bit integers xmm2/m128 to 8 packed 32-bit integers in ymm1."
    vendor_syntax {
      mnemonic: "VPMOVZXWD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.WIG 33 /r"
    instruction_group_index: 608
  }
  instructions {
    description: "Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 64-bit integers in xmm1."
    vendor_syntax {
      mnemonic: "VPMOVZXWQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.WIG 34 /r"
    instruction_group_index: 608
  }
  instructions {
    description: "Zero extend 4 packed 32-bit integers in xmm2/m128 to 4 packed 64-bit integers in ymm1."
    vendor_syntax {
      mnemonic: "VPMOVZXDQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.WIG 35 /r"
    instruction_group_index: 608
  }
  instructions {
    description: "Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1."
    vendor_syntax {
      mnemonic: "VPMOVZXBW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.WIG 30 /r"
    instruction_group_index: 608
  }
  instructions {
    description: "Zero extend 16 packed 8-bit integers in xmm2/m128 to 16 packed 16-bit integers in ymm1."
    vendor_syntax {
      mnemonic: "VPMOVZXBW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.WIG 30 /r"
    instruction_group_index: 608
  }
  instructions {
    description: "Zero extend 32 packed 8-bit integers in ymm2/m256 to 32 packed 16-bit integers in zmm1."
    vendor_syntax {
      mnemonic: "VPMOVZXBW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.WIG 30 /r"
    instruction_group_index: 608
  }
  instructions {
    description: "Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVZXBD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F38.WIG 31 /r"
    instruction_group_index: 608
  }
  instructions {
    description: "Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 32-bit integers in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVZXBD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38.WIG 31 /r"
    instruction_group_index: 608
  }
  instructions {
    description: "Zero extend 16 packed 8-bit integers in xmm2/m128 to 16 packed 32-bit integers in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVZXBD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38.WIG 31 /r"
    instruction_group_index: 608
  }
  instructions {
    description: "Zero extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVZXBQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.128.66.0F38.WIG 32 /r"
    instruction_group_index: 608
  }
  instructions {
    description: "Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 64-bit integers in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVZXBQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.256.66.0F38.WIG 32 /r"
    instruction_group_index: 608
  }
  instructions {
    description: "Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 64-bit integers in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVZXBQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.66.0F38.WIG 32 /r"
    instruction_group_index: 608
  }
  instructions {
    description: "Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVZXWD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.WIG 33 /r"
    instruction_group_index: 608
  }
  instructions {
    description: "Zero extend 8 packed 16-bit integers in xmm2/m128 to 8 packed 32-bit integers in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVZXWD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.WIG 33 /r"
    instruction_group_index: 608
  }
  instructions {
    description: "Zero extend 16 packed 16-bit integers in ymm2/m256 to 16 packed 32-bit integers in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVZXWD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.WIG 33 /r"
    instruction_group_index: 608
  }
  instructions {
    description: "Zero extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVZXWQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F38.WIG 34 /r"
    instruction_group_index: 608
  }
  instructions {
    description: "Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 64-bit integers in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVZXWQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38.WIG 34 /r"
    instruction_group_index: 608
  }
  instructions {
    description: "Zero extend 8 packed 16-bit integers in xmm2/m128 to 8 packed 64-bit integers in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVZXWQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38.WIG 34 /r"
    instruction_group_index: 608
  }
  instructions {
    description: "Zero extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVZXDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 35 /r"
    instruction_group_index: 608
  }
  instructions {
    description: "Zero extend 4 packed 32-bit integers in xmm2/m128 to 4 packed 64-bit integers in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVZXDQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 35 /r"
    instruction_group_index: 608
  }
  instructions {
    description: "Zero extend 8 packed 32-bit integers in ymm2/m256 to 8 packed 64-bit integers in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVZXDQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 35 /r"
    instruction_group_index: 608
  }
  instructions {
    description: "Store GDTR to m."
    vendor_syntax {
      mnemonic: "SGDT"
      operands {
        name: "m"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 01 /0"
    instruction_group_index: 609
  }
  instructions {
    description: "Add packed byte integers from mm/m64 and mm."
    vendor_syntax {
      mnemonic: "PADDB"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F FC /r"
    instruction_group_index: 610
  }
  instructions {
    description: "Add packed word integers from mm/m64 and mm."
    vendor_syntax {
      mnemonic: "PADDW"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F FD /r"
    instruction_group_index: 610
  }
  instructions {
    description: "Add packed doubleword integers from mm/m64 and mm."
    vendor_syntax {
      mnemonic: "PADDD"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F FE /r"
    instruction_group_index: 610
  }
  instructions {
    description: "Add packed quadword integers from mm/m64 and mm."
    vendor_syntax {
      mnemonic: "PADDQ"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F D4 /r"
    instruction_group_index: 610
  }
  instructions {
    description: "Add packed byte integers from xmm2/m128 and xmm1."
    vendor_syntax {
      mnemonic: "PADDB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F FC /r"
    instruction_group_index: 610
  }
  instructions {
    description: "Add packed word integers from xmm2/m128 and xmm1."
    vendor_syntax {
      mnemonic: "PADDW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F FD /r"
    instruction_group_index: 610
  }
  instructions {
    description: "Add packed doubleword integers from xmm2/m128 and xmm1."
    vendor_syntax {
      mnemonic: "PADDD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F FE /r"
    instruction_group_index: 610
  }
  instructions {
    description: "Add packed quadword integers from xmm2/m128 and xmm1."
    vendor_syntax {
      mnemonic: "PADDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F D4 /r"
    instruction_group_index: 610
  }
  instructions {
    description: "Add packed byte integers from xmm2, and xmm3/m128 and store in xmm1."
    vendor_syntax {
      mnemonic: "VPADDB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG FC /r"
    instruction_group_index: 610
  }
  instructions {
    description: "Add packed word integers from xmm2, xmm3/m128 and store in xmm1."
    vendor_syntax {
      mnemonic: "VPADDW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG FD /r"
    instruction_group_index: 610
  }
  instructions {
    description: "Add packed doubleword integers from xmm2, xmm3/m128 and store in xmm1."
    vendor_syntax {
      mnemonic: "VPADDD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG FE /r"
    instruction_group_index: 610
  }
  instructions {
    description: "Add packed quadword integers from xmm2, xmm3/m128 and store in xmm1."
    vendor_syntax {
      mnemonic: "VPADDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG D4 /r"
    instruction_group_index: 610
  }
  instructions {
    description: "Add packed byte integers from ymm2, and ymm3/m256 and store in ymm1."
    vendor_syntax {
      mnemonic: "VPADDB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG FC /r"
    instruction_group_index: 610
  }
  instructions {
    description: "Add packed word integers from ymm2, ymm3/m256 and store in ymm1."
    vendor_syntax {
      mnemonic: "VPADDW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG FD /r"
    instruction_group_index: 610
  }
  instructions {
    description: "Add packed doubleword integers from ymm2, ymm3/m256 and store in ymm1."
    vendor_syntax {
      mnemonic: "VPADDD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG FE /r"
    instruction_group_index: 610
  }
  instructions {
    description: "Add packed quadword integers from ymm2, ymm3/m256 and store in ymm1."
    vendor_syntax {
      mnemonic: "VPADDQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG D4 /r"
    instruction_group_index: 610
  }
  instructions {
    description: "Add packed byte integers from xmm2, and xmm3/m128 and store in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPADDB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.WIG FC /r"
    instruction_group_index: 610
  }
  instructions {
    description: "Add packed word integers from xmm2, and xmm3/m128 and store in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPADDW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.WIG FD /r"
    instruction_group_index: 610
  }
  instructions {
    description: "Add packed doubleword integers from xmm2, and xmm3/m128/m32bcst and store in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPADDD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.128.66.0F.W0 FE /r"
    instruction_group_index: 610
  }
  instructions {
    description: "Add packed quadword integers from xmm2, and xmm3/m128/m64bcst and store in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPADDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.128.66.0F.W1 D4 /r"
    instruction_group_index: 610
  }
  instructions {
    description: "Add packed byte integers from ymm2, and ymm3/m256 and store in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPADDB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.WIG FC /r"
    instruction_group_index: 610
  }
  instructions {
    description: "Add packed word integers from ymm2, and ymm3/m256 and store in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPADDW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.WIG FD /r"
    instruction_group_index: 610
  }
  instructions {
    description: "Add packed doubleword integers from ymm2, ymm3/m256/m32bcst and store in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPADDD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.256.66.0F.W0 FE /r"
    instruction_group_index: 610
  }
  instructions {
    description: "Add packed quadword integers from ymm2, ymm3/m256/m64bcst and store in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPADDQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.256.66.0F.W1 D4 /r"
    instruction_group_index: 610
  }
  instructions {
    description: "Add packed byte integers from zmm2, and zmm3/m512 and store in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPADDB"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.WIG FC /r"
    instruction_group_index: 610
  }
  instructions {
    description: "Add packed word integers from zmm2, and zmm3/m512 and store in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPADDW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.WIG FD /r"
    instruction_group_index: 610
  }
  instructions {
    description: "Add packed doubleword integers from zmm2, zmm3/m512/m32bcst and store in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPADDD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.66.0F.W0 FE /r"
    instruction_group_index: 610
  }
  instructions {
    description: "Add packed quadword integers from zmm2, zmm3/m512/m64bcst and store in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPADDQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.66.0F.W1 D4 /r"
    instruction_group_index: 610
  }
  instructions {
    description: "Replace ST(1) with ST(1) \342\210\227 log2 (ST(0) + 1.0) and pop the"
    vendor_syntax {
      mnemonic: "FYL2XP1"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D9 F9"
    instruction_group_index: 611
  }
  instructions {
    description: "Clear the AC flag in the EFLAGS register."
    vendor_syntax {
      mnemonic: "CLAC"
    }
    feature_name: "SMAP"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "NP 0F 01 CA"
    instruction_group_index: 612
  }
  instructions {
    description: "Convert the biased exponent (bits 30:23) of the low singleprecision floating-point value in xmm3/m32 to a SP FP value representing unbiased integer exponent. Stores the result to xmm1 under the writemask k1 and merge with the other elements of xmm2."
    vendor_syntax {
      mnemonic: "VGETEXPSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.LIG.66.0F38.W0 43 /r"
    instruction_group_index: 613
  }
  instructions {
    description: "Expand packed quad-word integer values from xmm2/m128 to xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPEXPANDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 89 /r"
    instruction_group_index: 614
  }
  instructions {
    description: "Expand packed quad-word integer values from ymm2/m256 to ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPEXPANDQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 89 /r"
    instruction_group_index: 614
  }
  instructions {
    description: "Expand packed quad-word integer values from zmm2/m512 to zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPEXPANDQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 89 /r"
    instruction_group_index: 614
  }
  instructions {
    description: "Counts the number of bits set to one in xmm2/m128 and puts the result in xmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VPOPCNTB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_BITALG && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 54 /r"
    instruction_group_index: 615
  }
  instructions {
    description: "Counts the number of bits set to one in ymm2/m256 and puts the result in ymm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VPOPCNTB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_BITALG && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 54 /r"
    instruction_group_index: 615
  }
  instructions {
    description: "Counts the number of bits set to one in zmm2/m512 and puts the result in zmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VPOPCNTB"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_BITALG"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 54 /r"
    instruction_group_index: 615
  }
  instructions {
    description: "Counts the number of bits set to one in xmm2/m128 and puts the result in xmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VPOPCNTW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_BITALG && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 54 /r"
    instruction_group_index: 615
  }
  instructions {
    description: "Counts the number of bits set to one in ymm2/m256 and puts the result in ymm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VPOPCNTW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_BITALG && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 54 /r"
    instruction_group_index: 615
  }
  instructions {
    description: "Counts the number of bits set to one in zmm2/m512 and puts the result in zmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VPOPCNTW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_BITALG"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 54 /r"
    instruction_group_index: 615
  }
  instructions {
    description: "Counts the number of bits set to one in xmm2/m128/m32bcst and puts the result in xmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VPOPCNTD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VPOPCNTDQ && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 55 /r"
    instruction_group_index: 615
  }
  instructions {
    description: "Counts the number of bits set to one in ymm2/m256/m32bcst and puts the result in ymm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VPOPCNTD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VPOPCNTDQ && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 55 /r"
    instruction_group_index: 615
  }
  instructions {
    description: "Counts the number of bits set to one in zmm2/m512/m32bcst and puts the result in zmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VPOPCNTD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VPOPCNTDQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 55 /r"
    instruction_group_index: 615
  }
  instructions {
    description: "Counts the number of bits set to one in xmm2/m128/m32bcst and puts the result in xmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VPOPCNTQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VPOPCNTDQ && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 55 /r"
    instruction_group_index: 615
  }
  instructions {
    description: "Counts the number of bits set to one in ymm2/m256/m32bcst and puts the result in ymm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VPOPCNTQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VPOPCNTDQ && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 55 /r"
    instruction_group_index: 615
  }
  instructions {
    description: "Counts the number of bits set to one in zmm2/m512/m64bcst and puts the result in zmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VPOPCNTQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VPOPCNTDQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 55 /r"
    instruction_group_index: 615
  }
  instructions {
    description: "Unpack 8-bit masks in k2 and k3 and write word result in k1."
    vendor_syntax {
      mnemonic: "KUNPCKBW"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "k3"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVR"
    raw_encoding_specification: "VEX.L1.66.0F.W0 4B /r"
    instruction_group_index: 616
  }
  instructions {
    description: "Unpack 16-bit masks in k2 and k3 and write doubleword result in k1."
    vendor_syntax {
      mnemonic: "KUNPCKWD"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "k3"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVR"
    raw_encoding_specification: "VEX.L1.0F.W0 4B /r"
    instruction_group_index: 616
  }
  instructions {
    description: "Unpack 32-bit masks in k2 and k3 and write quadword result in k1."
    vendor_syntax {
      mnemonic: "KUNPCKDQ"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "k3"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVR"
    raw_encoding_specification: "VEX.L1.0F.W1 4B /r"
    instruction_group_index: 616
  }
  instructions {
    description: "Round ST(0) to an integer."
    vendor_syntax {
      mnemonic: "FRNDINT"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D9 FC"
    instruction_group_index: 617
  }
  instructions {
    description: "Reads PKRU into EAX."
    vendor_syntax {
      mnemonic: "RDPKRU"
    }
    feature_name: "OSPKE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "NP 0F 01 EE"
    instruction_group_index: 619
  }
  instructions {
    description: "Select packed DP FP values from xmm1 and xmm2 from mask specified in XMM0 and store the values in xmm1."
    vendor_syntax {
      mnemonic: "BLENDVPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "<XMM0>"
        encoding: IMPLICIT_ENCODING
      }
    }
    feature_name: "SSE4_1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM0"
    raw_encoding_specification: "66 0F 38 15 /r"
    instruction_group_index: 620
  }
  instructions {
    description: "Conditionally copy double-precision floatingpoint values from xmm2 or xmm3/m128 to xmm1, based on mask bits in the mask operand, xmm4."
    vendor_syntax {
      mnemonic: "VBLENDVPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm4"
        encoding: VEX_SUFFIX_ENCODING
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVMR"
    raw_encoding_specification: "VEX.128.66.0F3A.W0 4B /r /is4"
    instruction_group_index: 620
  }
  instructions {
    description: "Conditionally copy double-precision floatingpoint values from ymm2 or ymm3/m256 to ymm1, based on mask bits in the mask operand, ymm4."
    vendor_syntax {
      mnemonic: "VBLENDVPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm4"
        encoding: VEX_SUFFIX_ENCODING
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVMR"
    raw_encoding_specification: "VEX.256.66.0F3A.W0 4B /r /is4"
    instruction_group_index: 620
  }
  instructions {
    description: "Convert one double-precision floating-point value from xmm1/m64 to one signed doubleword integer in r32 using truncation."
    vendor_syntax {
      mnemonic: "CVTTSD2SI"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F2 0F 2C /r"
    instruction_group_index: 621
  }
  instructions {
    description: "Convert one double-precision floating-point value from xmm1/m64 to one signed quadword integer in r64 using truncation."
    vendor_syntax {
      mnemonic: "CVTTSD2SI"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    encoding_scheme: "A"
    raw_encoding_specification: "F2 REX.W 0F 2C /r"
    instruction_group_index: 621
  }
  instructions {
    description: "Convert one double-precision floating-point value from xmm1/m64 to one signed doubleword integer in r32 using truncation."
    vendor_syntax {
      mnemonic: "VCVTTSD2SI"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.LIG.F2.0F.W0 2C /r"
    instruction_group_index: 621
  }
  instructions {
    description: "Convert one double-precision floating-point value from xmm1/m64 to one signed quadword integer in r64 using truncation."
    vendor_syntax {
      mnemonic: "VCVTTSD2SI"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.LIG.F2.0F.W1 2C /r"
    instruction_group_index: 621
  }
  instructions {
    description: "Convert one double-precision floating-point value from xmm1/m64 to one signed doubleword integer in r32 using truncation."
    vendor_syntax {
      mnemonic: "VCVTTSD2SI"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.LIG.F2.0F.W0 2C /r"
    instruction_group_index: 621
  }
  instructions {
    description: "Convert one double-precision floating-point value from xmm1/m64 to one signed quadword integer in r64 using truncation."
    vendor_syntax {
      mnemonic: "VCVTTSD2SI"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.LIG.F2.0F.W1 2C /r"
    instruction_group_index: 621
  }
  instructions {
    description: "Parallel extract of bits from r32b using mask in r/m32, result is written to r32a."
    vendor_syntax {
      mnemonic: "PEXT"
      operands {
        name: "r32a"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r32b"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "BMI2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.LZ.F3.0F38.W0 F5 /r"
    instruction_group_index: 622
  }
  instructions {
    description: "Parallel extract of bits from r64b using mask in r/m64, result is written to r64a."
    vendor_syntax {
      mnemonic: "PEXT"
      operands {
        name: "r64a"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r64b"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "BMI2"
    available_in_64_bit: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.LZ.F3.0F38.W1 F5 /r"
    instruction_group_index: 622
  }
  instructions {
    description: "Clear busy flag in supervisor shadow stack token reference by m64."
    vendor_syntax {
      mnemonic: "CLRSSBSY"
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    feature_name: "CET_SS"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "F3 0F AE /6"
    instruction_group_index: 623
  }
  instructions {
    description: "Multiply r/m8 by 2, once."
    vendor_syntax {
      mnemonic: "SAL"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "1"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M1"
    raw_encoding_specification: "D0 /4"
    instruction_group_index: 624
  }
  instructions {
    description: "Multiply r/m8 by 2, once."
    vendor_syntax {
      mnemonic: "SAL"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "1"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M1"
    raw_encoding_specification: "REX + D0 /4"
    instruction_group_index: 624
  }
  instructions {
    description: "Multiply r/m8 by 2, CL times."
    vendor_syntax {
      mnemonic: "SAL"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MC"
    raw_encoding_specification: "D2 /4"
    instruction_group_index: 624
  }
  instructions {
    description: "Multiply r/m8 by 2, CL times."
    vendor_syntax {
      mnemonic: "SAL"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MC"
    raw_encoding_specification: "REX + D2 /4"
    instruction_group_index: 624
  }
  instructions {
    description: "Multiply r/m8 by 2, imm8 times."
    vendor_syntax {
      mnemonic: "SAL"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "C0 /4 ib"
    instruction_group_index: 624
  }
  instructions {
    description: "Multiply r/m8 by 2, imm8 times."
    vendor_syntax {
      mnemonic: "SAL"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX + C0 /4 ib"
    instruction_group_index: 624
  }
  instructions {
    description: "Multiply r/m16 by 2, once."
    vendor_syntax {
      mnemonic: "SAL"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "1"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M1"
    raw_encoding_specification: "D1 /4"
    instruction_group_index: 624
  }
  instructions {
    description: "Multiply r/m16 by 2, CL times."
    vendor_syntax {
      mnemonic: "SAL"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MC"
    raw_encoding_specification: "D3 /4"
    instruction_group_index: 624
  }
  instructions {
    description: "Multiply r/m16 by 2, imm8 times."
    vendor_syntax {
      mnemonic: "SAL"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "C1 /4 ib"
    instruction_group_index: 624
  }
  instructions {
    description: "Multiply r/m32 by 2, once."
    vendor_syntax {
      mnemonic: "SAL"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "1"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M1"
    raw_encoding_specification: "D1 /4"
    instruction_group_index: 624
  }
  instructions {
    description: "Multiply r/m64 by 2, once."
    vendor_syntax {
      mnemonic: "SAL"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "1"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M1"
    raw_encoding_specification: "REX.W + D1 /4"
    instruction_group_index: 624
  }
  instructions {
    description: "Multiply r/m32 by 2, CL times."
    vendor_syntax {
      mnemonic: "SAL"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MC"
    raw_encoding_specification: "D3 /4"
    instruction_group_index: 624
  }
  instructions {
    description: "Multiply r/m64 by 2, CL times."
    vendor_syntax {
      mnemonic: "SAL"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MC"
    raw_encoding_specification: "REX.W + D3 /4"
    instruction_group_index: 624
  }
  instructions {
    description: "Multiply r/m32 by 2, imm8 times."
    vendor_syntax {
      mnemonic: "SAL"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "C1 /4 ib"
    instruction_group_index: 624
  }
  instructions {
    description: "Multiply r/m64 by 2, imm8 times."
    vendor_syntax {
      mnemonic: "SAL"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX.W + C1 /4 ib"
    instruction_group_index: 624
  }
  instructions {
    description: "Signed divide* r/m8 by 2, once."
    vendor_syntax {
      mnemonic: "SAR"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "1"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M1"
    raw_encoding_specification: "D0 /7"
    instruction_group_index: 624
  }
  instructions {
    description: "Signed divide* r/m8 by 2, once."
    vendor_syntax {
      mnemonic: "SAR"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "1"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M1"
    raw_encoding_specification: "REX + D0 /7"
    instruction_group_index: 624
  }
  instructions {
    description: "Signed divide* r/m8 by 2, CL times."
    vendor_syntax {
      mnemonic: "SAR"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MC"
    raw_encoding_specification: "D2 /7"
    instruction_group_index: 624
  }
  instructions {
    description: "Signed divide* r/m8 by 2, CL times."
    vendor_syntax {
      mnemonic: "SAR"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MC"
    raw_encoding_specification: "REX + D2 /7"
    instruction_group_index: 624
  }
  instructions {
    description: "Signed divide* r/m8 by 2, imm8 time."
    vendor_syntax {
      mnemonic: "SAR"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "C0 /7 ib"
    instruction_group_index: 624
  }
  instructions {
    description: "Signed divide* r/m8 by 2, imm8 times."
    vendor_syntax {
      mnemonic: "SAR"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX + C0 /7 ib"
    instruction_group_index: 624
  }
  instructions {
    description: "Signed divide* r/m16 by 2, once."
    vendor_syntax {
      mnemonic: "SAR"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "1"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M1"
    raw_encoding_specification: "D1 /7"
    instruction_group_index: 624
  }
  instructions {
    description: "Signed divide* r/m16 by 2, CL times."
    vendor_syntax {
      mnemonic: "SAR"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MC"
    raw_encoding_specification: "D3 /7"
    instruction_group_index: 624
  }
  instructions {
    description: "Signed divide* r/m16 by 2, imm8 times."
    vendor_syntax {
      mnemonic: "SAR"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "C1 /7 ib"
    instruction_group_index: 624
  }
  instructions {
    description: "Signed divide* r/m32 by 2, once."
    vendor_syntax {
      mnemonic: "SAR"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "1"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M1"
    raw_encoding_specification: "D1 /7"
    instruction_group_index: 624
  }
  instructions {
    description: "Signed divide* r/m64 by 2, once."
    vendor_syntax {
      mnemonic: "SAR"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "1"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M1"
    raw_encoding_specification: "REX.W + D1 /7"
    instruction_group_index: 624
  }
  instructions {
    description: "Signed divide* r/m32 by 2, CL times."
    vendor_syntax {
      mnemonic: "SAR"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MC"
    raw_encoding_specification: "D3 /7"
    instruction_group_index: 624
  }
  instructions {
    description: "Signed divide* r/m64 by 2, CL times."
    vendor_syntax {
      mnemonic: "SAR"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MC"
    raw_encoding_specification: "REX.W + D3 /7"
    instruction_group_index: 624
  }
  instructions {
    description: "Signed divide* r/m32 by 2, imm8 times."
    vendor_syntax {
      mnemonic: "SAR"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "C1 /7 ib"
    instruction_group_index: 624
  }
  instructions {
    description: "Signed divide* r/m64 by 2, imm8 times"
    vendor_syntax {
      mnemonic: "SAR"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX.W + C1 /7 ib"
    instruction_group_index: 624
  }
  instructions {
    description: "Multiply r/m8 by 2, once."
    vendor_syntax {
      mnemonic: "SHL"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "1"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M1"
    raw_encoding_specification: "D0 /4"
    instruction_group_index: 624
  }
  instructions {
    description: "Multiply r/m8 by 2, once."
    vendor_syntax {
      mnemonic: "SHL"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "1"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M1"
    raw_encoding_specification: "REX + D0 /4"
    instruction_group_index: 624
  }
  instructions {
    description: "Multiply r/m8 by 2, CL times."
    vendor_syntax {
      mnemonic: "SHL"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MC"
    raw_encoding_specification: "D2 /4"
    instruction_group_index: 624
  }
  instructions {
    description: "Multiply r/m8 by 2, CL times."
    vendor_syntax {
      mnemonic: "SHL"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MC"
    raw_encoding_specification: "REX + D2 /4"
    instruction_group_index: 624
  }
  instructions {
    description: "Multiply r/m8 by 2, imm8 times."
    vendor_syntax {
      mnemonic: "SHL"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "C0 /4 ib"
    instruction_group_index: 624
  }
  instructions {
    description: "Multiply r/m8 by 2, imm8 times."
    vendor_syntax {
      mnemonic: "SHL"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX + C0 /4 ib"
    instruction_group_index: 624
  }
  instructions {
    description: "Multiply r/m16 by 2, once."
    vendor_syntax {
      mnemonic: "SHL"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "1"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M1"
    raw_encoding_specification: "D1 /4"
    instruction_group_index: 624
  }
  instructions {
    description: "Multiply r/m16 by 2, CL times."
    vendor_syntax {
      mnemonic: "SHL"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MC"
    raw_encoding_specification: "D3 /4"
    instruction_group_index: 624
  }
  instructions {
    description: "Multiply r/m16 by 2, imm8 times."
    vendor_syntax {
      mnemonic: "SHL"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "C1 /4 ib"
    instruction_group_index: 624
  }
  instructions {
    description: "Multiply r/m32 by 2, once."
    vendor_syntax {
      mnemonic: "SHL"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "1"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M1"
    raw_encoding_specification: "D1 /4"
    instruction_group_index: 624
  }
  instructions {
    description: "Multiply r/m64 by 2, once."
    vendor_syntax {
      mnemonic: "SHL"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "1"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M1"
    raw_encoding_specification: "REX.W + D1 /4"
    instruction_group_index: 624
  }
  instructions {
    description: "Multiply r/m32 by 2, CL times."
    vendor_syntax {
      mnemonic: "SHL"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MC"
    raw_encoding_specification: "D3 /4"
    instruction_group_index: 624
  }
  instructions {
    description: "Multiply r/m64 by 2, CL times."
    vendor_syntax {
      mnemonic: "SHL"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MC"
    raw_encoding_specification: "REX.W + D3 /4"
    instruction_group_index: 624
  }
  instructions {
    description: "Multiply r/m32 by 2, imm8 times."
    vendor_syntax {
      mnemonic: "SHL"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "C1 /4 ib"
    instruction_group_index: 624
  }
  instructions {
    description: "Multiply r/m64 by 2, imm8 times."
    vendor_syntax {
      mnemonic: "SHL"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX.W + C1 /4 ib"
    instruction_group_index: 624
  }
  instructions {
    description: "Unsigned divide r/m8 by 2, once."
    vendor_syntax {
      mnemonic: "SHR"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "1"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M1"
    raw_encoding_specification: "D0 /5"
    instruction_group_index: 624
  }
  instructions {
    description: "Unsigned divide r/m8 by 2, once."
    vendor_syntax {
      mnemonic: "SHR"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "1"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M1"
    raw_encoding_specification: "REX + D0 /5"
    instruction_group_index: 624
  }
  instructions {
    description: "Unsigned divide r/m8 by 2, CL times."
    vendor_syntax {
      mnemonic: "SHR"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MC"
    raw_encoding_specification: "D2 /5"
    instruction_group_index: 624
  }
  instructions {
    description: "Unsigned divide r/m8 by 2, CL times."
    vendor_syntax {
      mnemonic: "SHR"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MC"
    raw_encoding_specification: "REX + D2 /5"
    instruction_group_index: 624
  }
  instructions {
    description: "Unsigned divide r/m8 by 2, imm8 times."
    vendor_syntax {
      mnemonic: "SHR"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "C0 /5 ib"
    instruction_group_index: 624
  }
  instructions {
    description: "Unsigned divide r/m8 by 2, imm8 times."
    vendor_syntax {
      mnemonic: "SHR"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX + C0 /5 ib"
    instruction_group_index: 624
  }
  instructions {
    description: "Unsigned divide r/m16 by 2, once."
    vendor_syntax {
      mnemonic: "SHR"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "1"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M1"
    raw_encoding_specification: "D1 /5"
    instruction_group_index: 624
  }
  instructions {
    description: "Unsigned divide r/m16 by 2, CL times"
    vendor_syntax {
      mnemonic: "SHR"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MC"
    raw_encoding_specification: "D3 /5"
    instruction_group_index: 624
  }
  instructions {
    description: "Unsigned divide r/m16 by 2, imm8 times."
    vendor_syntax {
      mnemonic: "SHR"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "C1 /5 ib"
    instruction_group_index: 624
  }
  instructions {
    description: "Unsigned divide r/m32 by 2, once."
    vendor_syntax {
      mnemonic: "SHR"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "1"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M1"
    raw_encoding_specification: "D1 /5"
    instruction_group_index: 624
  }
  instructions {
    description: "Unsigned divide r/m64 by 2, once."
    vendor_syntax {
      mnemonic: "SHR"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "1"
        encoding: IMPLICIT_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M1"
    raw_encoding_specification: "REX.W + D1 /5"
    instruction_group_index: 624
  }
  instructions {
    description: "Unsigned divide r/m32 by 2, CL times."
    vendor_syntax {
      mnemonic: "SHR"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MC"
    raw_encoding_specification: "D3 /5"
    instruction_group_index: 624
  }
  instructions {
    description: "Unsigned divide r/m64 by 2, CL times."
    vendor_syntax {
      mnemonic: "SHR"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "CL"
        encoding: IMPLICIT_ENCODING
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MC"
    raw_encoding_specification: "REX.W + D3 /5"
    instruction_group_index: 624
  }
  instructions {
    description: "Unsigned divide r/m32 by 2, imm8 times."
    vendor_syntax {
      mnemonic: "SHR"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "C1 /5 ib"
    instruction_group_index: 624
  }
  instructions {
    description: "Unsigned divide r/m64 by 2, imm8 times."
    vendor_syntax {
      mnemonic: "SHR"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX.W + C1 /5 ib"
    instruction_group_index: 624
  }
  instructions {
    description: "Perform one round of an AES encryption flow, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128."
    vendor_syntax {
      mnemonic: "AESENC"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AES"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 38 DC /r"
    instruction_group_index: 625
  }
  instructions {
    description: "Perform one round of an AES encryption flow, operating on a 128-bit data (state) from xmm2 with a 128-bit round key from the xmm3/m128; store the result in xmm1."
    vendor_syntax {
      mnemonic: "VAESENC"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AES && AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F38.WIG DC /r"
    instruction_group_index: 625
  }
  instructions {
    description: "Perform one round of an AES encryption flow, operating on a 128-bit data (state) from ymm2 with a 128-bit round key from the ymm3/m256; store the result in ymm1."
    vendor_syntax {
      mnemonic: "VAESENC"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "VAES"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "VEX.256.66.0F38.WIG DC /r"
    instruction_group_index: 625
  }
  instructions {
    description: "Perform one round of an AES encryption flow, operating on a 128-bit data (state) from xmm2 with a 128-bit round key from the xmm3/m128; store the result in xmm1."
    vendor_syntax {
      mnemonic: "VAESENC"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "VAES && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.128.66.0F38.WIG DC /r"
    instruction_group_index: 625
  }
  instructions {
    description: "Perform one round of an AES encryption flow, operating on a 128-bit data (state) from ymm2 with a 128-bit round key from the ymm3/m256; store the result in ymm1."
    vendor_syntax {
      mnemonic: "VAESENC"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "VAES && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.256.66.0F38.WIG DC /r"
    instruction_group_index: 625
  }
  instructions {
    description: "Perform one round of an AES encryption flow, operating on a 128-bit data (state) from zmm2 with a 128-bit round key from the zmm3/m512; store the result in zmm1."
    vendor_syntax {
      mnemonic: "VAESENC"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "VAES && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.66.0F38.WIG DC /r"
    instruction_group_index: 625
  }
  instructions {
    description: "Computes the approximate reciprocal of the square root of the low single-precision floating-point value in xmm2/m32 and stores the results in xmm1."
    vendor_syntax {
      mnemonic: "RSQRTSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "F3 0F 52 /r"
    instruction_group_index: 627
  }
  instructions {
    description: "Computes the approximate reciprocal of the square root of the low single precision floating-point value in xmm3/m32 and stores the results in xmm1. Also, upper single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32]."
    vendor_syntax {
      mnemonic: "VRSQRTSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.LIG.F3.0F.WIG 52 /r"
    instruction_group_index: 627
  }
  instructions {
    description: "Subtract ST(0) from m32fp and store result in ST(0)."
    vendor_syntax {
      mnemonic: "FSUBR"
      operands {
        name: "m32fp"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D8 /5"
    instruction_group_index: 629
  }
  instructions {
    description: "Subtract ST(0) from m64fp and store result in ST(0)."
    vendor_syntax {
      mnemonic: "FSUBR"
      operands {
        name: "m64fp"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DC /5"
    instruction_group_index: 629
  }
  instructions {
    description: "Subtract ST(0) from ST(i) and store result in ST(0)."
    vendor_syntax {
      mnemonic: "FSUBR"
      operands {
        name: "ST(0)"
      }
      operands {
        name: "ST(i)"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D8 E8+i"
    instruction_group_index: 629
  }
  instructions {
    description: "Subtract ST(i) from ST(0) and store result in ST(i)."
    vendor_syntax {
      mnemonic: "FSUBR"
      operands {
        name: "ST(i)"
      }
      operands {
        name: "ST(0)"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DC E0+i"
    instruction_group_index: 629
  }
  instructions {
    description: "Subtract ST(i) from ST(0), store result in ST(i), and pop register stack."
    vendor_syntax {
      mnemonic: "FSUBRP"
      operands {
        name: "ST(i)"
      }
      operands {
        name: "ST(0)"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DE E0+i"
    instruction_group_index: 629
  }
  instructions {
    description: "Subtract ST(1) from ST(0), store result in ST(1), and pop register stack."
    vendor_syntax {
      mnemonic: "FSUBRP"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DE E1"
    instruction_group_index: 629
  }
  instructions {
    description: "Subtract ST(0) from m32int and store result in ST(0)."
    vendor_syntax {
      mnemonic: "FISUBR"
      operands {
        name: "m32int"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DA /5"
    instruction_group_index: 629
  }
  instructions {
    description: "Subtract ST(0) from m16int and store result in ST(0)."
    vendor_syntax {
      mnemonic: "FISUBR"
      operands {
        name: "m16int"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DE /5"
    instruction_group_index: 629
  }
  instructions {
    description: "Move packed single-precision values xmm1 to mem using non-temporal hint."
    vendor_syntax {
      mnemonic: "MOVNTPS"
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 2B /r"
    instruction_group_index: 630
  }
  instructions {
    description: "Move packed single-precision values xmm1 to mem using non-temporal hint."
    vendor_syntax {
      mnemonic: "VMOVNTPS"
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.0F.WIG 2B /r"
    instruction_group_index: 630
  }
  instructions {
    description: "Move packed single-precision values ymm1 to mem using non-temporal hint."
    vendor_syntax {
      mnemonic: "VMOVNTPS"
      operands {
        name: "m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.0F.WIG 2B /r"
    instruction_group_index: 630
  }
  instructions {
    description: "Move packed single-precision values in xmm1 to m128 using non-temporal hint."
    vendor_syntax {
      mnemonic: "VMOVNTPS"
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.0F.W0 2B /r"
    instruction_group_index: 630
  }
  instructions {
    description: "Move packed single-precision values in ymm1 to m256 using non-temporal hint."
    vendor_syntax {
      mnemonic: "VMOVNTPS"
      operands {
        name: "m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.0F.W0 2B /r"
    instruction_group_index: 630
  }
  instructions {
    description: "Move packed single-precision values in zmm1 to m512 using non-temporal hint."
    vendor_syntax {
      mnemonic: "VMOVNTPS"
      operands {
        name: "m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.0F.W0 2B /r"
    instruction_group_index: 630
  }
  instructions {
    description: "Move unaligned packed double-precision floatingpoint from xmm2/mem to xmm1."
    vendor_syntax {
      mnemonic: "MOVUPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 10 /r"
    instruction_group_index: 631
  }
  instructions {
    description: "Move unaligned packed double-precision floatingpoint from xmm1 to xmm2/mem."
    vendor_syntax {
      mnemonic: "MOVUPD"
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "66 0F 11 /r"
    instruction_group_index: 631
  }
  instructions {
    description: "Move unaligned packed double-precision floatingpoint from xmm2/mem to xmm1."
    vendor_syntax {
      mnemonic: "VMOVUPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F.WIG 10 /r"
    instruction_group_index: 631
  }
  instructions {
    description: "Move unaligned packed double-precision floatingpoint from xmm1 to xmm2/mem."
    vendor_syntax {
      mnemonic: "VMOVUPD"
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG 11 /r"
    instruction_group_index: 631
  }
  instructions {
    description: "Move unaligned packed double-precision floatingpoint from ymm2/mem to ymm1."
    vendor_syntax {
      mnemonic: "VMOVUPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F.WIG 10 /r"
    instruction_group_index: 631
  }
  instructions {
    description: "Move unaligned packed double-precision floatingpoint from ymm1 to ymm2/mem."
    vendor_syntax {
      mnemonic: "VMOVUPD"
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG 11 /r"
    instruction_group_index: 631
  }
  instructions {
    description: "Move unaligned packed double-precision floatingpoint from xmm2/m128 to xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVUPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.W1 10 /r"
    instruction_group_index: 631
  }
  instructions {
    description: "Move unaligned packed double-precision floatingpoint from xmm1 to xmm2/m128 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVUPD"
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.128.66.0F.W1 11 /r"
    instruction_group_index: 631
  }
  instructions {
    description: "Move unaligned packed double-precision floatingpoint from ymm2/m256 to ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVUPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.W1 10 /r"
    instruction_group_index: 631
  }
  instructions {
    description: "Move unaligned packed double-precision floatingpoint from ymm1 to ymm2/m256 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVUPD"
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.256.66.0F.W1 11 /r"
    instruction_group_index: 631
  }
  instructions {
    description: "Move unaligned packed double-precision floatingpoint values from zmm2/m512 to zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVUPD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.W1 10 /r"
    instruction_group_index: 631
  }
  instructions {
    description: "Move unaligned packed double-precision floatingpoint values from zmm1 to zmm2/m512 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVUPD"
      operands {
        name: "zmm2/m512"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.66.0F.W1 11 /r"
    instruction_group_index: 631
  }
  instructions {
    description: "Multiply signed words from source register block indicated by zmm2 by signed words from m128 and accumulate resulting signed dwords in zmm1."
    vendor_syntax {
      mnemonic: "VP4DPWSSD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2+3"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_4VNNIW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.F2.0F38.W0 52 /r"
    instruction_group_index: 632
  }
  instructions {
    description: "Move if below (CF=1)."
    vendor_syntax {
      mnemonic: "FCMOVB"
      operands {
        name: "ST(0)"
      }
      operands {
        name: "ST(i)"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DA C0+i"
    instruction_group_index: 633
  }
  instructions {
    description: "Move if equal (ZF=1)."
    vendor_syntax {
      mnemonic: "FCMOVE"
      operands {
        name: "ST(0)"
      }
      operands {
        name: "ST(i)"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DA C8+i"
    instruction_group_index: 633
  }
  instructions {
    description: "Move if below or equal (CF=1 or ZF=1)."
    vendor_syntax {
      mnemonic: "FCMOVBE"
      operands {
        name: "ST(0)"
      }
      operands {
        name: "ST(i)"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DA D0+i"
    instruction_group_index: 633
  }
  instructions {
    description: "Move if unordered (PF=1)."
    vendor_syntax {
      mnemonic: "FCMOVU"
      operands {
        name: "ST(0)"
      }
      operands {
        name: "ST(i)"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DA D8+i"
    instruction_group_index: 633
  }
  instructions {
    description: "Move if not below (CF=0)."
    vendor_syntax {
      mnemonic: "FCMOVNB"
      operands {
        name: "ST(0)"
      }
      operands {
        name: "ST(i)"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DB C0+i"
    instruction_group_index: 633
  }
  instructions {
    description: "Move if not equal (ZF=0)."
    vendor_syntax {
      mnemonic: "FCMOVNE"
      operands {
        name: "ST(0)"
      }
      operands {
        name: "ST(i)"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DB C8+i"
    instruction_group_index: 633
  }
  instructions {
    description: "Move if not below or equal (CF=0 and ZF=0)."
    vendor_syntax {
      mnemonic: "FCMOVNBE"
      operands {
        name: "ST(0)"
      }
      operands {
        name: "ST(i)"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DB D0+i"
    instruction_group_index: 633
  }
  instructions {
    description: "Move if not unordered (PF=0)."
    vendor_syntax {
      mnemonic: "FCMOVNU"
      operands {
        name: "ST(0)"
      }
      operands {
        name: "ST(i)"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DB D8+i"
    instruction_group_index: 633
  }
  instructions {
    description: "Convert four packed signed doubleword integers from xmm2/mem to four packed single-precision floatingpoint values in xmm1."
    vendor_syntax {
      mnemonic: "CVTDQ2PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 5B /r"
    instruction_group_index: 634
  }
  instructions {
    description: "Convert four packed signed doubleword integers from xmm2/mem to four packed single-precision floatingpoint values in xmm1."
    vendor_syntax {
      mnemonic: "VCVTDQ2PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.0F.WIG 5B /r"
    instruction_group_index: 634
  }
  instructions {
    description: "Convert eight packed signed doubleword integers from ymm2/mem to eight packed single-precision floatingpoint values in ymm1."
    vendor_syntax {
      mnemonic: "VCVTDQ2PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.0F.WIG 5B /r"
    instruction_group_index: 634
  }
  instructions {
    description: "Convert four packed signed doubleword integers from xmm2/m128/m32bcst to four packed single-precision floating-point values in xmm1with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTDQ2PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.0F.W0 5B /r"
    instruction_group_index: 634
  }
  instructions {
    description: "Convert eight packed signed doubleword integers from ymm2/m256/m32bcst to eight packed single-precision floating-point values in ymm1with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTDQ2PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.0F.W0 5B /r"
    instruction_group_index: 634
  }
  instructions {
    description: "Convert sixteen packed signed doubleword integers from zmm2/m512/m32bcst to sixteen packed singleprecision floating-point values in zmm1with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTDQ2PS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.0F.W0 5B /r"
    instruction_group_index: 634
  }
  instructions {
    description: "Convert two packed double-precision floating-point values from xmm2/m128/m64bcst to two packed unsigned quadword integers in xmm1 using truncation with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTTPD2UQQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F.W1 78 /r"
    instruction_group_index: 635
  }
  instructions {
    description: "Convert four packed double-precision floating-point values from ymm2/m256/m64bcst to four packed unsigned quadword integers in ymm1 using truncation with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTTPD2UQQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F.W1 78 /r"
    instruction_group_index: 635
  }
  instructions {
    description: "Convert eight packed double-precision floating-point values from zmm2/mem to eight packed unsigned quadword integers in zmm1 using truncation with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTTPD2UQQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F.W1 78 /r"
    instruction_group_index: 635
  }
  instructions {
    description: "Using dword indices specified in vm32x, gather single-precision FP values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."
    vendor_syntax {
      mnemonic: "VGATHERDPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "vm32x"
        encoding: VSIB_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W0 92 /r"
    instruction_group_index: 636
  }
  instructions {
    description: "Using qword indices specified in vm64x, gather single-precision FP values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."
    vendor_syntax {
      mnemonic: "VGATHERQPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "vm64x"
        encoding: VSIB_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W0 93 /r"
    instruction_group_index: 636
  }
  instructions {
    description: "Using dword indices specified in vm32y, gather single-precision FP values from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1."
    vendor_syntax {
      mnemonic: "VGATHERDPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "vm32y"
        encoding: VSIB_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W0 92 /r"
    instruction_group_index: 636
  }
  instructions {
    description: "Using qword indices specified in vm64y, gather single-precision FP values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."
    vendor_syntax {
      mnemonic: "VGATHERQPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "vm64y"
        encoding: VSIB_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W0 93 /r"
    instruction_group_index: 636
  }
  instructions {
    description: "Permute single-precision floating-point values in xmm2 using controls from xmm3/m128 and store result in xmm1."
    vendor_syntax {
      mnemonic: "VPERMILPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W0 0C /r"
    instruction_group_index: 637
  }
  instructions {
    description: "Permute single-precision floating-point values in xmm2/m128 using controls from imm8 and store result in xmm1."
    vendor_syntax {
      mnemonic: "VPERMILPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F3A.W0 04 /r ib"
    instruction_group_index: 637
  }
  instructions {
    description: "Permute single-precision floating-point values in ymm2 using controls from ymm3/m256 and store result in ymm1."
    vendor_syntax {
      mnemonic: "VPERMILPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W0 0C /r"
    instruction_group_index: 637
  }
  instructions {
    description: "Permute single-precision floating-point values in ymm2/m256 using controls from imm8 and store result in ymm1."
    vendor_syntax {
      mnemonic: "VPERMILPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F3A.W0 04 /r ib"
    instruction_group_index: 637
  }
  instructions {
    description: "Permute single-precision floating-point values xmm2 using control from xmm3/m128/m32bcst and store the result in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMILPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 0C /r"
    instruction_group_index: 637
  }
  instructions {
    description: "Permute single-precision floating-point values ymm2 using control from ymm3/m256/m32bcst and store the result in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMILPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 0C /r"
    instruction_group_index: 637
  }
  instructions {
    description: "Permute single-precision floating-point values zmm2 using control from zmm3/m512/m32bcst and store the result in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMILPS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 0C /r"
    instruction_group_index: 637
  }
  instructions {
    description: "Permute single-precision floating-point values xmm2/m128/m32bcst using controls from imm8 and store the result in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMILPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.128.66.0F3A.W0 04 /r ib"
    instruction_group_index: 637
  }
  instructions {
    description: "Permute single-precision floating-point values ymm2/m256/m32bcst using controls from imm8 and store the result in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMILPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.256.66.0F3A.W0 04 /r ib"
    instruction_group_index: 637
  }
  instructions {
    description: "Permute single-precision floating-point values zmm2/m512/m32bcst using controls from imm8 and store the result in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMILPS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.66.0F3A.W0 04 /r ib"
    instruction_group_index: 637
  }
  instructions {
    description: "Return the minimum single-precision floating-point values between xmm1 and xmm2/mem."
    vendor_syntax {
      mnemonic: "MINPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 5D /r"
    instruction_group_index: 638
  }
  instructions {
    description: "Return the minimum single-precision floating-point values between xmm2 and xmm3/mem."
    vendor_syntax {
      mnemonic: "VMINPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.0F.WIG 5D /r"
    instruction_group_index: 638
  }
  instructions {
    description: "Return the minimum single double-precision floating-point values between ymm2 and ymm3/mem."
    vendor_syntax {
      mnemonic: "VMINPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.0F.WIG 5D /r"
    instruction_group_index: 638
  }
  instructions {
    description: "Return the minimum packed single-precision floating-point values between xmm2 and xmm3/m128/m32bcst and store result in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VMINPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.0F.W0 5D /r"
    instruction_group_index: 638
  }
  instructions {
    description: "Return the minimum packed single-precision floating-point values between ymm2 and ymm3/m256/m32bcst and store result in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VMINPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.0F.W0 5D /r"
    instruction_group_index: 638
  }
  instructions {
    description: "Return the minimum packed single-precision floating-point values between zmm2 and zmm3/m512/m32bcst and store result in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VMINPS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.0F.W0 5D /r"
    instruction_group_index: 638
  }
  instructions {
    description: "Directs the processor to enter an implementationdependent optimized state until the TSC reaches the value in EDX:EAX."
    vendor_syntax {
      mnemonic: "TPAUSE"
      operands {
        name: "r32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "WAITPKG"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F AE /6"
    instruction_group_index: 639
  }
  instructions {
    description: "Set the x87 FPU tag word to empty."
    vendor_syntax {
      mnemonic: "EMMS"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "NP 0F 77"
    instruction_group_index: 640
  }
  instructions {
    description: "Invalidate TLB entries for page containing m."
    vendor_syntax {
      mnemonic: "INVLPG"
      operands {
        name: "m"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 01/7"
    instruction_group_index: 641
  }
  instructions {
    description: "Move quadword from mm/m64 to mm."
    vendor_syntax {
      mnemonic: "MOVQ"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 6F /r"
    instruction_group_index: 642
  }
  instructions {
    description: "Move quadword from mm to mm/m64."
    vendor_syntax {
      mnemonic: "MOVQ"
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "NP 0F 7F /r"
    instruction_group_index: 642
  }
  instructions {
    description: "Move quadword from xmm2/mem64 to xmm1."
    vendor_syntax {
      mnemonic: "MOVQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F3 0F 7E /r"
    instruction_group_index: 642
  }
  instructions {
    description: "Move quadword from xmm2 to xmm1."
    vendor_syntax {
      mnemonic: "VMOVQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.F3.0F.WIG 7E /r"
    instruction_group_index: 642
  }
  instructions {
    description: "Move quadword from xmm2/m64 to xmm1."
    vendor_syntax {
      mnemonic: "VMOVQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.F3.0F.W1 7E /r"
    instruction_group_index: 642
  }
  instructions {
    description: "Move quadword from xmm1 to xmm2/mem64."
    vendor_syntax {
      mnemonic: "MOVQ"
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "66 0F D6 /r"
    instruction_group_index: 642
  }
  instructions {
    description: "Move quadword from xmm2 register to xmm1/m64."
    vendor_syntax {
      mnemonic: "VMOVQ"
      operands {
        name: "xmm1/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG D6 /r"
    instruction_group_index: 642
  }
  instructions {
    description: "Move quadword from xmm2 register to xmm1/m64."
    vendor_syntax {
      mnemonic: "VMOVQ"
      operands {
        name: "xmm1/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.128.66.0F.W1 D6 /r"
    instruction_group_index: 642
  }
  instructions {
    description: "Calculate two RANGE operation output value from 2 pairs of double-precision floating-point values in xmm2 and xmm3/m128/m32bcst, store the results to xmm1 under the writemask k1. Imm8 specifies the comparison and sign of the range operation."
    vendor_syntax {
      mnemonic: "VRANGEPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F3A.W1 50 /r ib"
    instruction_group_index: 643
  }
  instructions {
    description: "Calculate four RANGE operation output value from 4pairs of double-precision floating-point values in ymm2 and ymm3/m256/m32bcst, store the results to ymm1 under the writemask k1. Imm8 specifies the comparison and sign of the range operation."
    vendor_syntax {
      mnemonic: "VRANGEPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F3A.W1 50 /r ib"
    instruction_group_index: 643
  }
  instructions {
    description: "Calculate eight RANGE operation output value from 8 pairs of double-precision floating-point values in zmm2 and zmm3/m512/m32bcst, store the results to zmm1 under the writemask k1. Imm8 specifies the comparison and sign of the range operation."
    vendor_syntax {
      mnemonic: "VRANGEPD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F3A.W1 50 /r ib"
    instruction_group_index: 643
  }
  instructions {
    description: "Writes back modified cache line containing m8, and may retain the line in cache hierarchy in non-modified state."
    vendor_syntax {
      mnemonic: "CLWB"
      operands {
        name: "m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    feature_name: "CLWB"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "66 0F AE /6"
    instruction_group_index: 644
  }
  instructions {
    description: "Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128."
    vendor_syntax {
      mnemonic: "AESDEC"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AES"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 38 DE /r"
    instruction_group_index: 645
  }
  instructions {
    description: "Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm2 with a 128-bit round key from xmm3/m128; store the result in xmm1."
    vendor_syntax {
      mnemonic: "VAESDEC"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AES && AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F38.WIG DE /r"
    instruction_group_index: 645
  }
  instructions {
    description: "Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from ymm2 with a 128-bit round key from ymm3/m256; store the result in ymm1."
    vendor_syntax {
      mnemonic: "VAESDEC"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "VAES"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "VEX.256.66.0F38.WIG DE /r"
    instruction_group_index: 645
  }
  instructions {
    description: "Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm2 with a 128-bit round key from xmm3/m128; store the result in xmm1."
    vendor_syntax {
      mnemonic: "VAESDEC"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "VAES && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.128.66.0F38.WIG DE /r"
    instruction_group_index: 645
  }
  instructions {
    description: "Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from ymm2 with a 128-bit round key from ymm3/m256; store the result in ymm1."
    vendor_syntax {
      mnemonic: "VAESDEC"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "VAES && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.256.66.0F38.WIG DE /r"
    instruction_group_index: 645
  }
  instructions {
    description: "Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from zmm2 with a 128-bit round key from zmm3/m512; store the result in zmm1."
    vendor_syntax {
      mnemonic: "VAESDEC"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "VAES && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.66.0F38.WIG DE /r"
    instruction_group_index: 645
  }
  instructions {
    description: "Increment the TOP field in the FPU status register."
    vendor_syntax {
      mnemonic: "FINCSTP"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D9 F7"
    instruction_group_index: 646
  }
  instructions {
    description: "Contiguous bitwise extract from r/m32 using r32b as control; store result in r32a."
    vendor_syntax {
      mnemonic: "BEXTR"
      operands {
        name: "r32a"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r32b"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "BMI1"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMV"
    raw_encoding_specification: "VEX.LZ.0F38.W0 F7 /r"
    instruction_group_index: 647
  }
  instructions {
    description: "Contiguous bitwise extract from r/m64 using r64b as control; store result in r64a"
    vendor_syntax {
      mnemonic: "BEXTR"
      operands {
        name: "r64a"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "r64b"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "BMI1"
    available_in_64_bit: true
    encoding_scheme: "RMV"
    raw_encoding_specification: "VEX.LZ.0F38.W1 F7 /r"
    instruction_group_index: 647
  }
  instructions {
    description: "Move aligned packed single-precision floating-point values from xmm2/mem to xmm1."
    vendor_syntax {
      mnemonic: "MOVAPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 28 /r"
    instruction_group_index: 648
  }
  instructions {
    description: "Move aligned packed single-precision floating-point values from xmm1 to xmm2/mem."
    vendor_syntax {
      mnemonic: "MOVAPS"
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "NP 0F 29 /r"
    instruction_group_index: 648
  }
  instructions {
    description: "Move aligned packed single-precision floating-point values from xmm2/mem to xmm1."
    vendor_syntax {
      mnemonic: "VMOVAPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.0F.WIG 28 /r"
    instruction_group_index: 648
  }
  instructions {
    description: "Move aligned packed single-precision floating-point values from xmm1 to xmm2/mem."
    vendor_syntax {
      mnemonic: "VMOVAPS"
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.0F.WIG 29 /r"
    instruction_group_index: 648
  }
  instructions {
    description: "Move aligned packed single-precision floating-point values from ymm2/mem to ymm1."
    vendor_syntax {
      mnemonic: "VMOVAPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.0F.WIG 28 /r"
    instruction_group_index: 648
  }
  instructions {
    description: "Move aligned packed single-precision floating-point values from ymm1 to ymm2/mem."
    vendor_syntax {
      mnemonic: "VMOVAPS"
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.0F.WIG 29 /r"
    instruction_group_index: 648
  }
  instructions {
    description: "Move aligned packed single-precision floating-point values from xmm2/m128 to xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVAPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.0F.W0 28 /r"
    instruction_group_index: 648
  }
  instructions {
    description: "Move aligned packed single-precision floating-point values from ymm2/m256 to ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVAPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.0F.W0 28 /r"
    instruction_group_index: 648
  }
  instructions {
    description: "Move aligned packed single-precision floating-point values from zmm2/m512 to zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVAPS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.0F.W0 28 /r"
    instruction_group_index: 648
  }
  instructions {
    description: "Move aligned packed single-precision floating-point values from xmm1 to xmm2/m128 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVAPS"
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.128.0F.W0 29 /r"
    instruction_group_index: 648
  }
  instructions {
    description: "Move aligned packed single-precision floating-point values from ymm1 to ymm2/m256 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVAPS"
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.256.0F.W0 29 /r"
    instruction_group_index: 648
  }
  instructions {
    description: "Move aligned packed single-precision floating-point values from zmm1 to zmm2/m512 using writemask k1."
    vendor_syntax {
      mnemonic: "VMOVAPS"
      operands {
        name: "zmm2/m512"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.0F.W0 29 /r"
    instruction_group_index: 648
  }
  instructions {
    description: "Unsigned divide AX by r/m8, with result stored in AL := Quotient, AH := Remainder."
    vendor_syntax {
      mnemonic: "DIV"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "F6 /6"
    instruction_group_index: 649
  }
  instructions {
    description: "Unsigned divide AX by r/m8, with result stored in AL := Quotient, AH := Remainder."
    vendor_syntax {
      mnemonic: "DIV"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX + F6 /6"
    instruction_group_index: 649
  }
  instructions {
    description: "Unsigned divide DX:AX by r/m16, with result stored in AX := Quotient, DX := Remainder."
    vendor_syntax {
      mnemonic: "DIV"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "F7 /6"
    instruction_group_index: 649
  }
  instructions {
    description: "Unsigned divide EDX:EAX by r/m32, with result stored in EAX := Quotient, EDX := Remainder."
    vendor_syntax {
      mnemonic: "DIV"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "F7 /6"
    instruction_group_index: 649
  }
  instructions {
    description: "Unsigned divide RDX:RAX by r/m64, with result stored in RAX := Quotient, RDX := Remainder."
    vendor_syntax {
      mnemonic: "DIV"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX.W + F7 /6"
    instruction_group_index: 649
  }
  instructions {
    description: "Using signed dword indices, gather single-precision floatingpoint values from memory using k1 as completion mask."
    vendor_syntax {
      mnemonic: "VGATHERDPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "vm32x"
        encoding: VSIB_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 92 /vsib"
    instruction_group_index: 650
  }
  instructions {
    description: "Using signed dword indices, gather single-precision floatingpoint values from memory using k1 as completion mask."
    vendor_syntax {
      mnemonic: "VGATHERDPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "vm32y"
        encoding: VSIB_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 92 /vsib"
    instruction_group_index: 650
  }
  instructions {
    description: "Using signed dword indices, gather single-precision floatingpoint values from memory using k1 as completion mask."
    vendor_syntax {
      mnemonic: "VGATHERDPS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "vm32z"
        encoding: VSIB_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 92 /vsib"
    instruction_group_index: 650
  }
  instructions {
    description: "Using signed dword indices, gather float64 vector into float64 vector xmm1 using k1 as completion mask."
    vendor_syntax {
      mnemonic: "VGATHERDPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "vm32x"
        encoding: VSIB_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 92 /vsib"
    instruction_group_index: 650
  }
  instructions {
    description: "Using signed dword indices, gather float64 vector into float64 vector ymm1 using k1 as completion mask."
    vendor_syntax {
      mnemonic: "VGATHERDPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "vm32x"
        encoding: VSIB_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 92 /vsib"
    instruction_group_index: 650
  }
  instructions {
    description: "Using signed dword indices, gather float64 vector into float64 vector zmm1 using k1 as completion mask."
    vendor_syntax {
      mnemonic: "VGATHERDPD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "vm32y"
        encoding: VSIB_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 92 /vsib"
    instruction_group_index: 650
  }
  instructions {
    description: "Subtract unsigned packed bytes in mm/m64 from unsigned packed bytes in mm and saturate result."
    vendor_syntax {
      mnemonic: "PSUBUSB"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F D8 /r"
    instruction_group_index: 651
  }
  instructions {
    description: "Subtract packed unsigned byte integers in xmm2/m128 from packed unsigned byte integers in xmm1 and saturate result."
    vendor_syntax {
      mnemonic: "PSUBUSB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F D8 /r"
    instruction_group_index: 651
  }
  instructions {
    description: "Subtract unsigned packed words in mm/m64 from unsigned packed words in mm and saturate result."
    vendor_syntax {
      mnemonic: "PSUBUSW"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F D9 /r"
    instruction_group_index: 651
  }
  instructions {
    description: "Subtract packed unsigned word integers in xmm2/m128 from packed unsigned word integers in xmm1 and saturate result."
    vendor_syntax {
      mnemonic: "PSUBUSW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F D9 /r"
    instruction_group_index: 651
  }
  instructions {
    description: "Subtract packed unsigned byte integers in xmm3/m128 from packed unsigned byte integers in xmm2 and saturate result."
    vendor_syntax {
      mnemonic: "VPSUBUSB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG D8 /r"
    instruction_group_index: 651
  }
  instructions {
    description: "Subtract packed unsigned word integers in xmm3/m128 from packed unsigned word integers in xmm2 and saturate result."
    vendor_syntax {
      mnemonic: "VPSUBUSW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG D9 /r"
    instruction_group_index: 651
  }
  instructions {
    description: "Subtract packed unsigned byte integers in ymm3/m256 from packed unsigned byte integers in ymm2 and saturate result."
    vendor_syntax {
      mnemonic: "VPSUBUSB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG D8 /r"
    instruction_group_index: 651
  }
  instructions {
    description: "Subtract packed unsigned word integers in ymm3/m256 from packed unsigned word integers in ymm2 and saturate result."
    vendor_syntax {
      mnemonic: "VPSUBUSW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG D9 /r"
    instruction_group_index: 651
  }
  instructions {
    description: "Subtract packed unsigned byte integers in xmm3/m128 from packed unsigned byte integers in xmm2, saturate results and store in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPSUBUSB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.WIG D8 /r"
    instruction_group_index: 651
  }
  instructions {
    description: "Subtract packed unsigned byte integers in ymm3/m256 from packed unsigned byte integers in ymm2, saturate results and store in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPSUBUSB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.WIG D8 /r"
    instruction_group_index: 651
  }
  instructions {
    description: "Subtract packed unsigned byte integers in zmm3/m512 from packed unsigned byte integers in zmm2, saturate results and store in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPSUBUSB"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.WIG D8 /r"
    instruction_group_index: 651
  }
  instructions {
    description: "Subtract packed unsigned word integers in xmm3/m128 from packed unsigned word integers in xmm2 and saturate results and store in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPSUBUSW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.WIG D9 /r"
    instruction_group_index: 651
  }
  instructions {
    description: "Subtract packed unsigned word integers in ymm3/m256 from packed unsigned word integers in ymm2, saturate results and store in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPSUBUSW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.WIG D9 /r"
    instruction_group_index: 651
  }
  instructions {
    description: "Subtract packed unsigned word integers in zmm3/m512 from packed unsigned word integers in zmm2, saturate results and store in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPSUBUSW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.WIG D9 /r"
    instruction_group_index: 651
  }
  instructions {
    description: "Return the bitwise logical AND NOT of packed single-precision floating-point values in xmm1 and xmm2/mem."
    vendor_syntax {
      mnemonic: "ANDNPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 55 /r"
    instruction_group_index: 652
  }
  instructions {
    description: "Return the bitwise logical AND NOT of packed single-precision floating-point values in xmm2 and xmm3/mem."
    vendor_syntax {
      mnemonic: "VANDNPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.0F 55 /r"
    instruction_group_index: 652
  }
  instructions {
    description: "Return the bitwise logical AND NOT of packed single-precision floating-point values in ymm2 and ymm3/mem."
    vendor_syntax {
      mnemonic: "VANDNPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.0F 55 /r"
    instruction_group_index: 652
  }
  instructions {
    description: "Return the bitwise logical AND of packed single-precision floating-point values in xmm2 and xmm3/m128/m32bcst subject to writemask k1."
    vendor_syntax {
      mnemonic: "VANDNPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.0F.W0 55 /r"
    instruction_group_index: 652
  }
  instructions {
    description: "Return the bitwise logical AND of packed single-precision floating-point values in ymm2 and ymm3/m256/m32bcst subject to writemask k1."
    vendor_syntax {
      mnemonic: "VANDNPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.0F.W0 55 /r"
    instruction_group_index: 652
  }
  instructions {
    description: "Return the bitwise logical AND of packed single-precision floating-point values in zmm2 and zmm3/m512/m32bcst subject to writemask k1."
    vendor_syntax {
      mnemonic: "VANDNPS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.0F.W0 55 /r"
    instruction_group_index: 652
  }
  instructions {
    description: "Decrement count; jump short if count \342\211\240 0."
    vendor_syntax {
      mnemonic: "LOOP"
      operands {
        name: "rel8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "E2 cb"
    instruction_group_index: 653
  }
  instructions {
    description: "Decrement count; jump short if count \342\211\240 0 and ZF = 1."
    vendor_syntax {
      mnemonic: "LOOPE"
      operands {
        name: "rel8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "E1 cb"
    instruction_group_index: 653
  }
  instructions {
    description: "Decrement count; jump short if count \342\211\240 0 and ZF = 0."
    vendor_syntax {
      mnemonic: "LOOPNE"
      operands {
        name: "rel8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "E0 cb"
    instruction_group_index: 653
  }
  instructions {
    description: "Multiply scalar double-precision floating-point value from xmm1 and xmm3/mem, negate the multiplication result and subtract xmm2 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMSUB132SD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.LIG.66.0F38.W1 9F /r"
    instruction_group_index: 654
  }
  instructions {
    description: "Multiply scalar double-precision floating-point value from xmm1 and xmm2, negate the multiplication result and subtract xmm3/mem and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMSUB213SD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.LIG.66.0F38.W1 AF /r"
    instruction_group_index: 654
  }
  instructions {
    description: "Multiply scalar double-precision floating-point value from xmm2 and xmm3/mem, negate the multiplication result and subtract xmm1 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMSUB231SD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.LIG.66.0F38.W1 BF /r"
    instruction_group_index: 654
  }
  instructions {
    description: "Multiply scalar double-precision floating-point value from xmm1 and xmm3/m64, negate the multiplication result and subtract xmm2 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMSUB132SD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.LIG.66.0F38.W1 9F /r"
    instruction_group_index: 654
  }
  instructions {
    description: "Multiply scalar double-precision floating-point value from xmm1 and xmm2, negate the multiplication result and subtract xmm3/m64 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMSUB213SD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.LIG.66.0F38.W1 AF /r"
    instruction_group_index: 654
  }
  instructions {
    description: "Multiply scalar double-precision floating-point value from xmm2 and xmm3/m64, negate the multiplication result and subtract xmm1 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFNMSUB231SD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.LIG.66.0F38.W1 BF /r"
    instruction_group_index: 654
  }
  instructions {
    description: "Add the low single-precision floating-point value from xmm2/mem to xmm1 and store the result in xmm1."
    vendor_syntax {
      mnemonic: "ADDSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F3 0F 58 /r"
    instruction_group_index: 655
  }
  instructions {
    description: "Add the low single-precision floating-point value from xmm3/mem to xmm2 and store the result in xmm1."
    vendor_syntax {
      mnemonic: "VADDSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.LIG.F3.0F.WIG 58 /r"
    instruction_group_index: 655
  }
  instructions {
    description: "Add the low single-precision floating-point value from xmm3/m32 to xmm2 and store the result in xmm1with writemask k1."
    vendor_syntax {
      mnemonic: "VADDSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.LIG.F3.0F.W0 58 /r"
    instruction_group_index: 655
  }
  instructions {
    description: "Flushes cache line containing m8."
    vendor_syntax {
      mnemonic: "CLFLUSHOPT"
      operands {
        name: "m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "NFx 66 0F AE /7"
    instruction_group_index: 656
  }
  instructions {
    description: "Reverse each bit of r/m8."
    vendor_syntax {
      mnemonic: "NOT"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "F6 /2"
    instruction_group_index: 657
  }
  instructions {
    description: "Reverse each bit of r/m8."
    vendor_syntax {
      mnemonic: "NOT"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX + F6 /2"
    instruction_group_index: 657
  }
  instructions {
    description: "Reverse each bit of r/m16."
    vendor_syntax {
      mnemonic: "NOT"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "F7 /2"
    instruction_group_index: 657
  }
  instructions {
    description: "Reverse each bit of r/m32."
    vendor_syntax {
      mnemonic: "NOT"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "F7 /2"
    instruction_group_index: 657
  }
  instructions {
    description: "Reverse each bit of r/m64."
    vendor_syntax {
      mnemonic: "NOT"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX.W + F7 /2"
    instruction_group_index: 657
  }
  instructions {
    description: "Classify value or number in ST(0)."
    vendor_syntax {
      mnemonic: "FXAM"
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D9 E5"
    instruction_group_index: 658
  }
  instructions {
    description: "Permute qwords in ymm2/m256 using indices in imm8 and store the result in ymm1."
    vendor_syntax {
      mnemonic: "VPERMQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F3A.W1 00 /r ib"
    instruction_group_index: 659
  }
  instructions {
    description: "Permute qwords in ymm2/m256/m64bcst using indexes in imm8 and store the result in ymm1."
    vendor_syntax {
      mnemonic: "VPERMQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F3A.W1 00 /r ib"
    instruction_group_index: 659
  }
  instructions {
    description: "Permute qwords in zmm2/m512/m64bcst using indices in imm8 and store the result in zmm1."
    vendor_syntax {
      mnemonic: "VPERMQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F3A.W1 00 /r ib"
    instruction_group_index: 659
  }
  instructions {
    description: "Permute qwords in ymm3/m256/m64bcst using indexes in ymm2 and store the result in ymm1."
    vendor_syntax {
      mnemonic: "VPERMQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 36 /r"
    instruction_group_index: 659
  }
  instructions {
    description: "Permute qwords in zmm3/m512/m64bcst using indices in zmm2 and store the result in zmm1."
    vendor_syntax {
      mnemonic: "VPERMQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 36 /r"
    instruction_group_index: 659
  }
  instructions {
    description: "Rounds packed double-precision floating point values in xmm2/m128/m64bcst to a number of fraction bits specified by the imm8 field. Stores the result in xmm1 register. Under writemask."
    vendor_syntax {
      mnemonic: "VRNDSCALEPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F3A.W1 09 /r ib"
    instruction_group_index: 660
  }
  instructions {
    description: "Rounds packed double-precision floating point values in ymm2/m256/m64bcst to a number of fraction bits specified by the imm8 field. Stores the result in ymm1 register. Under writemask."
    vendor_syntax {
      mnemonic: "VRNDSCALEPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F3A.W1 09 /r ib"
    instruction_group_index: 660
  }
  instructions {
    description: "Rounds packed double-precision floating-point values in zmm2/m512/m64bcst to a number of fraction bits specified by the imm8 field. Stores the result in zmm1 register using writemask k1."
    vendor_syntax {
      mnemonic: "VRNDSCALEPD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F3A.W1 09 /r ib"
    instruction_group_index: 660
  }
  instructions {
    description: "Stores the current VMCS pointer into memory."
    vendor_syntax {
      mnemonic: "VMPTRST"
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
    }
    feature_name: "VMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "NP 0F C7 /7"
    instruction_group_index: 661
  }
  instructions {
    description: "Computes square root of the low single-precision floating-point value in xmm2/m32 and stores the results in xmm1."
    vendor_syntax {
      mnemonic: "SQRTSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F3 0F 51 /r"
    instruction_group_index: 662
  }
  instructions {
    description: "Computes square root of the low single-precision floating-point value in xmm3/m32 and stores the results in xmm1. Also, upper single-precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32]."
    vendor_syntax {
      mnemonic: "VSQRTSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.LIG.F3.0F.WIG 51 /r"
    instruction_group_index: 662
  }
  instructions {
    description: "Computes square root of the low single-precision floating-point value in xmm3/m32 and stores the results in xmm1 under writemask k1. Also, upper single-precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32]."
    vendor_syntax {
      mnemonic: "VSQRTSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.LIG.F3.0F.W0 51 /r"
    instruction_group_index: 662
  }
  instructions {
    description: "Store FPU state to m94byte or m108byte after checking for pending unmasked floating-point exceptions. Then re-initialize the FPU."
    vendor_syntax {
      mnemonic: "FSAVE"
      operands {
        name: "m94/108byte"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "9B DD /6"
    instruction_group_index: 663
  }
  instructions {
    description: "Store FPU environment to m94byte or m108byte without checking for pending unmasked floatingpoint exceptions. Then re-initialize the FPU."
    vendor_syntax {
      mnemonic: "FNSAVE"
      operands {
        name: "m94/108byte"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DD /6"
    instruction_group_index: 663
  }
  instructions {
    description: "Copy ST(0) to m32fp."
    vendor_syntax {
      mnemonic: "FST"
      operands {
        name: "m32fp"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D9 /2"
    instruction_group_index: 664
  }
  instructions {
    description: "Copy ST(0) to m64fp."
    vendor_syntax {
      mnemonic: "FST"
      operands {
        name: "m64fp"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DD /2"
    instruction_group_index: 664
  }
  instructions {
    description: "Copy ST(0) to ST(i)."
    vendor_syntax {
      mnemonic: "FST"
      operands {
        name: "ST(i)"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DD D0+i"
    instruction_group_index: 664
  }
  instructions {
    description: "Copy ST(0) to m32fp and pop register stack."
    vendor_syntax {
      mnemonic: "FSTP"
      operands {
        name: "m32fp"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "D9 /3"
    instruction_group_index: 664
  }
  instructions {
    description: "Copy ST(0) to m64fp and pop register stack."
    vendor_syntax {
      mnemonic: "FSTP"
      operands {
        name: "m64fp"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DD /3"
    instruction_group_index: 664
  }
  instructions {
    description: "Copy ST(0) to m80fp and pop register stack."
    vendor_syntax {
      mnemonic: "FSTP"
      operands {
        name: "m80fp"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DB /7"
    instruction_group_index: 664
  }
  instructions {
    description: "Copy ST(0) to ST(i) and pop register stack."
    vendor_syntax {
      mnemonic: "FSTP"
      operands {
        name: "ST(i)"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "DD D8+i"
    instruction_group_index: 664
  }
  instructions {
    description: "Converts 2 packed quad-word integers from xmm2 into 2 packed byte integers in xmm1/m16 with truncation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVQB"
      operands {
        name: "xmm1/m16"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.F3.0F38.W0 32 /r"
    instruction_group_index: 665
  }
  instructions {
    description: "Converts 2 packed signed quad-word integers from xmm2 into 2 packed signed byte integers in xmm1/m16 using signed saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVSQB"
      operands {
        name: "xmm1/m16"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.F3.0F38.W0 22 /r"
    instruction_group_index: 665
  }
  instructions {
    description: "Converts 2 packed unsigned quad-word integers from xmm2 into 2 packed unsigned byte integers in xmm1/m16 using unsigned saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVUSQB"
      operands {
        name: "xmm1/m16"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.F3.0F38.W0 12 /r"
    instruction_group_index: 665
  }
  instructions {
    description: "Converts 4 packed quad-word integers from ymm2 into 4 packed byte integers in xmm1/m32 with truncation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVQB"
      operands {
        name: "xmm1/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.F3.0F38.W0 32 /r"
    instruction_group_index: 665
  }
  instructions {
    description: "Converts 4 packed signed quad-word integers from ymm2 into 4 packed signed byte integers in xmm1/m32 using signed saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVSQB"
      operands {
        name: "xmm1/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.F3.0F38.W0 22 /r"
    instruction_group_index: 665
  }
  instructions {
    description: "Converts 4 packed unsigned quad-word integers from ymm2 into 4 packed unsigned byte integers in xmm1/m32 using unsigned saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVUSQB"
      operands {
        name: "xmm1/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.F3.0F38.W0 12 /r"
    instruction_group_index: 665
  }
  instructions {
    description: "Converts 8 packed quad-word integers from zmm2 into 8 packed byte integers in xmm1/m64 with truncation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVQB"
      operands {
        name: "xmm1/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.F3.0F38.W0 32 /r"
    instruction_group_index: 665
  }
  instructions {
    description: "Converts 8 packed signed quad-word integers from zmm2 into 8 packed signed byte integers in xmm1/m64 using signed saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVSQB"
      operands {
        name: "xmm1/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.F3.0F38.W0 22 /r"
    instruction_group_index: 665
  }
  instructions {
    description: "Converts 8 packed unsigned quad-word integers from zmm2 into 8 packed unsigned byte integers in xmm1/m64 using unsigned saturation under writemask k1."
    vendor_syntax {
      mnemonic: "VPMOVUSQB"
      operands {
        name: "xmm1/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.F3.0F38.W0 12 /r"
    instruction_group_index: 665
  }
  instructions {
    description: "Multiply the packed unsigned word integers in mm1 register and mm2/m64, and store the high 16 bits of the results in mm1."
    vendor_syntax {
      mnemonic: "PMULHUW"
      operands {
        name: "mm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F E4 /r"
    instruction_group_index: 666
  }
  instructions {
    description: "Multiply the packed unsigned word integers in xmm1 and xmm2/m128, and store the high 16 bits of the results in xmm1."
    vendor_syntax {
      mnemonic: "PMULHUW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F E4 /r"
    instruction_group_index: 666
  }
  instructions {
    description: "Multiply the packed unsigned word integers in xmm2 and xmm3/m128, and store the high 16 bits of the results in xmm1."
    vendor_syntax {
      mnemonic: "VPMULHUW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG E4 /r"
    instruction_group_index: 666
  }
  instructions {
    description: "Multiply the packed unsigned word integers in ymm2 and ymm3/m256, and store the high 16 bits of the results in ymm1."
    vendor_syntax {
      mnemonic: "VPMULHUW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG E4 /r"
    instruction_group_index: 666
  }
  instructions {
    description: "Multiply the packed unsigned word integers in xmm2 and xmm3/m128, and store the high 16 bits of the results in xmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMULHUW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.WIG E4 /r"
    instruction_group_index: 666
  }
  instructions {
    description: "Multiply the packed unsigned word integers in ymm2 and ymm3/m256, and store the high 16 bits of the results in ymm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMULHUW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.WIG E4 /r"
    instruction_group_index: 666
  }
  instructions {
    description: "Multiply the packed unsigned word integers in zmm2 and zmm3/m512, and store the high 16 bits of the results in zmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPMULHUW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.WIG E4 /r"
    instruction_group_index: 666
  }
  instructions {
    description: "Bitwise OR 16 bits masks k1 and k2 and update ZF and CF accordingly."
    vendor_syntax {
      mnemonic: "KORTESTW"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RR"
    raw_encoding_specification: "VEX.L0.0F.W0 98 /r"
    instruction_group_index: 667
  }
  instructions {
    description: "Bitwise OR 8 bits masks k1 and k2 and update ZF and CF accordingly."
    vendor_syntax {
      mnemonic: "KORTESTB"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RR"
    raw_encoding_specification: "VEX.L0.66.0F.W0 98 /r"
    instruction_group_index: 667
  }
  instructions {
    description: "Bitwise OR 64 bits masks k1 and k2 and update ZF and CF accordingly."
    vendor_syntax {
      mnemonic: "KORTESTQ"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RR"
    raw_encoding_specification: "VEX.L0.0F.W1 98 /r"
    instruction_group_index: 667
  }
  instructions {
    description: "Bitwise OR 32 bits masks k1 and k2 and update ZF and CF accordingly."
    vendor_syntax {
      mnemonic: "KORTESTD"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RR"
    raw_encoding_specification: "VEX.L0.66.0F.W1 98 /r"
    instruction_group_index: 667
  }
  instructions {
    description: "Return the maximum scalar single-precision floating-point value between xmm2/m32 and xmm1."
    vendor_syntax {
      mnemonic: "MAXSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F3 0F 5F /r"
    instruction_group_index: 668
  }
  instructions {
    description: "Return the maximum scalar single-precision floating-point value between xmm3/m32 and xmm2."
    vendor_syntax {
      mnemonic: "VMAXSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.LIG.F3.0F.WIG 5F /r"
    instruction_group_index: 668
  }
  instructions {
    description: "Return the maximum scalar single-precision floating-point value between xmm3/m32 and xmm2."
    vendor_syntax {
      mnemonic: "VMAXSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.LIG.F3.0F.W0 5F /r"
    instruction_group_index: 668
  }
  instructions {
    description: "Move packed integer values in xmm1 to m128 using nontemporal hint."
    vendor_syntax {
      mnemonic: "MOVNTDQ"
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F E7 /r"
    instruction_group_index: 669
  }
  instructions {
    description: "Move packed integer values in xmm1 to m128 using nontemporal hint."
    vendor_syntax {
      mnemonic: "VMOVNTDQ"
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F.WIG E7 /r"
    instruction_group_index: 669
  }
  instructions {
    description: "Move packed integer values in ymm1 to m256 using nontemporal hint."
    vendor_syntax {
      mnemonic: "VMOVNTDQ"
      operands {
        name: "m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F.WIG E7 /r"
    instruction_group_index: 669
  }
  instructions {
    description: "Move packed integer values in xmm1 to m128 using nontemporal hint."
    vendor_syntax {
      mnemonic: "VMOVNTDQ"
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F.W0 E7 /r"
    instruction_group_index: 669
  }
  instructions {
    description: "Move packed integer values in zmm1 to m256 using nontemporal hint."
    vendor_syntax {
      mnemonic: "VMOVNTDQ"
      operands {
        name: "m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F.W0 E7 /r"
    instruction_group_index: 669
  }
  instructions {
    description: "Move packed integer values in zmm1 to m512 using nontemporal hint."
    vendor_syntax {
      mnemonic: "VMOVNTDQ"
      operands {
        name: "m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F.W0 E7 /r"
    instruction_group_index: 669
  }
  instructions {
    description: "A hint used with an \342\200\234XACQUIRE-enabled\342\200\234 instruction to start lock elision on the instruction memory operand address."
    vendor_syntax {
      mnemonic: "XACQUIRE"
    }
    feature_name: "HLE"
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "F2"
    instruction_group_index: 670
  }
  instructions {
    description: "A hint used with an \342\200\234XRELEASE-enabled\342\200\234 instruction to end lock elision on the instruction memory operand address."
    vendor_syntax {
      mnemonic: "XRELEASE"
    }
    feature_name: "HLE"
    available_in_64_bit: true
    legacy_instruction: true
    raw_encoding_specification: "F3"
    instruction_group_index: 670
  }
  instructions {
    description: "Output byte in AL to I/O port address imm8."
    vendor_syntax {
      mnemonic: "OUT"
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "AL"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "I"
    raw_encoding_specification: "E6 ib"
    instruction_group_index: 671
  }
  instructions {
    description: "Output word in AX to I/O port address imm8."
    vendor_syntax {
      mnemonic: "OUT"
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "AX"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "I"
    raw_encoding_specification: "E7 ib"
    instruction_group_index: 671
  }
  instructions {
    description: "Output doubleword in EAX to I/O port address imm8."
    vendor_syntax {
      mnemonic: "OUT"
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "EAX"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "I"
    raw_encoding_specification: "E7 ib"
    instruction_group_index: 671
  }
  instructions {
    description: "Output byte in AL to I/O port address in DX."
    vendor_syntax {
      mnemonic: "OUT"
      operands {
        name: "DX"
      }
      operands {
        name: "AL"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "EE"
    instruction_group_index: 671
  }
  instructions {
    description: "Output word in AX to I/O port address in DX."
    vendor_syntax {
      mnemonic: "OUT"
      operands {
        name: "DX"
      }
      operands {
        name: "AX"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "EF"
    instruction_group_index: 671
  }
  instructions {
    description: "Output doubleword in EAX to I/O port address in DX."
    vendor_syntax {
      mnemonic: "OUT"
      operands {
        name: "DX"
      }
      operands {
        name: "EAX"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "EF"
    instruction_group_index: 671
  }
  instructions {
    description: "Rotate 32-bit r/m32 right imm8 times without affecting arithmetic flags."
    vendor_syntax {
      mnemonic: "RORX"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "BMI2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMI"
    raw_encoding_specification: "VEX.LZ.F2.0F3A.W0 F0 /r ib"
    instruction_group_index: 672
  }
  instructions {
    description: "Rotate 64-bit r/m64 right imm8 times without affecting arithmetic flags."
    vendor_syntax {
      mnemonic: "RORX"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "BMI2"
    available_in_64_bit: true
    encoding_scheme: "RMI"
    raw_encoding_specification: "VEX.LZ.F2.0F3A.W1 F0 /r ib"
    instruction_group_index: 672
  }
  instructions {
    description: "Check pending unmasked floating-point exceptions."
    vendor_syntax {
      mnemonic: "WAIT"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "9B"
    instruction_group_index: 673
  }
  instructions {
    description: "Check pending unmasked floating-point exceptions."
    vendor_syntax {
      mnemonic: "FWAIT"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "9B"
    instruction_group_index: 673
  }
  instructions {
    description: "Convert two packed single-precision floating-point values in xmm2/m64 to two packed double-precision floating-point values in xmm1."
    vendor_syntax {
      mnemonic: "CVTPS2PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 5A /r"
    instruction_group_index: 674
  }
  instructions {
    description: "Convert two packed single-precision floating-point values in xmm2/m64 to two packed double-precision floating-point values in xmm1."
    vendor_syntax {
      mnemonic: "VCVTPS2PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.0F.WIG 5A /r"
    instruction_group_index: 674
  }
  instructions {
    description: "Convert four packed single-precision floating-point values in xmm2/m128 to four packed double-precision floatingpoint values in ymm1."
    vendor_syntax {
      mnemonic: "VCVTPS2PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.0F.WIG 5A /r"
    instruction_group_index: 674
  }
  instructions {
    description: "Convert two packed single-precision floating-point values in xmm2/m64/m32bcst to packed double-precision floatingpoint values in xmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTPS2PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.0F.W0 5A /r"
    instruction_group_index: 674
  }
  instructions {
    description: "Convert four packed single-precision floating-point values in xmm2/m128/m32bcst to packed double-precision floating-point values in ymm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTPS2PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.0F.W0 5A /r"
    instruction_group_index: 674
  }
  instructions {
    description: "Convert eight packed single-precision floating-point values in ymm2/m256/b32bcst to eight packed double-precision floating-point values in zmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VCVTPS2PD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.0F.W0 5A /r"
    instruction_group_index: 674
  }
  instructions {
    description: "Move double-precision floating-point value from m64 to low quadword of xmm1."
    vendor_syntax {
      mnemonic: "MOVLPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 12 /r"
    instruction_group_index: 675
  }
  instructions {
    description: "Merge double-precision floating-point value from m64 and the high quadword of xmm1."
    vendor_syntax {
      mnemonic: "VMOVLPD"
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG 12 /r"
    instruction_group_index: 675
  }
  instructions {
    description: "Merge double-precision floating-point value from m64 and the high quadword of xmm1."
    vendor_syntax {
      mnemonic: "VMOVLPD"
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.128.66.0F.W1 12 /r"
    instruction_group_index: 675
  }
  instructions {
    description: "Move double-precision floating-point value from low quadword of xmm1 to m64."
    vendor_syntax {
      mnemonic: "MOVLPD"
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "66 0F 13/r"
    instruction_group_index: 675
  }
  instructions {
    description: "Move double-precision floating-point value from low quadword of xmm1 to m64."
    vendor_syntax {
      mnemonic: "VMOVLPD"
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "VEX.128.66.0F.WIG 13/r"
    instruction_group_index: 675
  }
  instructions {
    description: "Move double-precision floating-point value from low quadword of xmm1 to m64."
    vendor_syntax {
      mnemonic: "VMOVLPD"
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "E"
    raw_encoding_specification: "EVEX.128.66.0F.W1 13/r"
    instruction_group_index: 675
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from xmm1 and xmm3/mem, subtract/add elements in xmm2 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMSUBADD132PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W1 97 /r"
    instruction_group_index: 676
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from xmm1 and xmm2, subtract/add elements in xmm3/mem and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMSUBADD213PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W1 A7 /r"
    instruction_group_index: 676
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from xmm2 and xmm3/mem, subtract/add elements in xmm1 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMSUBADD231PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W1 B7 /r"
    instruction_group_index: 676
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from ymm1 and ymm3/mem, subtract/add elements in ymm2 and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFMSUBADD132PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W1 97 /r"
    instruction_group_index: 676
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from ymm1 and ymm2, subtract/add elements in ymm3/mem and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFMSUBADD213PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W1 A7 /r"
    instruction_group_index: 676
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from ymm2 and ymm3/mem, subtract/add elements in ymm1 and put result in ymm1."
    vendor_syntax {
      mnemonic: "VFMSUBADD231PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W1 B7 /r"
    instruction_group_index: 676
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from xmm1 and xmm3/m128/m64bcst, subtract/add elements in xmm2 and put result in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMSUBADD132PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 97 /r"
    instruction_group_index: 676
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from xmm1 and xmm2, subtract/add elements in xmm3/m128/m64bcst and put result in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMSUBADD213PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 A7 /r"
    instruction_group_index: 676
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from xmm2 and xmm3/m128/m64bcst, subtract/add elements in xmm1 and put result in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMSUBADD231PD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 B7 /r"
    instruction_group_index: 676
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from ymm1 and ymm3/m256/m64bcst, subtract/add elements in ymm2 and put result in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMSUBADD132PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 97 /r"
    instruction_group_index: 676
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from ymm1 and ymm2, subtract/add elements in ymm3/m256/m64bcst and put result in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMSUBADD213PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 A7 /r"
    instruction_group_index: 676
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from ymm2 and ymm3/m256/m64bcst, subtract/add elements in ymm1 and put result in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMSUBADD231PD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 B7 /r"
    instruction_group_index: 676
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from zmm1 and zmm3/m512/m64bcst, subtract/add elements in zmm2 and put result in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMSUBADD132PD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 97 /r"
    instruction_group_index: 676
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from zmm1 and zmm2, subtract/add elements in zmm3/m512/m64bcst and put result in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMSUBADD213PD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 A7 /r"
    instruction_group_index: 676
  }
  instructions {
    description: "Multiply packed double-precision floating-point values from zmm2 and zmm3/m512/m64bcst, subtract/add elements in zmm1 and put result in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VFMSUBADD231PD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 B7 /r"
    instruction_group_index: 676
  }
  instructions {
    description: "Convert the exponent of packed single-precision floating-point values in the source operand to SP FP results representing unbiased integer exponents and stores the results in the destination register."
    vendor_syntax {
      mnemonic: "VGETEXPPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 42 /r"
    instruction_group_index: 677
  }
  instructions {
    description: "Convert the exponent of packed single-precision floating-point values in the source operand to SP FP results representing unbiased integer exponents and stores the results in the destination register."
    vendor_syntax {
      mnemonic: "VGETEXPPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 42 /r"
    instruction_group_index: 677
  }
  instructions {
    description: "Convert the exponent of packed single-precision floating-point values in the source operand to SP FP results representing unbiased integer exponents and stores the results in the destination register."
    vendor_syntax {
      mnemonic: "VGETEXPPS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 42 /r"
    instruction_group_index: 677
  }
  instructions {
    description: "Load m into GDTR."
    vendor_syntax {
      mnemonic: "LGDT"
      operands {
        name: "m16&32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 01 /2"
    instruction_group_index: 678
  }
  instructions {
    description: "Load m into IDTR."
    vendor_syntax {
      mnemonic: "LIDT"
      operands {
        name: "m16&32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 01 /3"
    instruction_group_index: 678
  }
  instructions {
    description: "Load m into GDTR."
    vendor_syntax {
      mnemonic: "LGDT"
      operands {
        name: "m16&64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 01 /2"
    instruction_group_index: 678
  }
  instructions {
    description: "Load m into IDTR."
    vendor_syntax {
      mnemonic: "LIDT"
      operands {
        name: "m16&64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "0F 01 /3"
    instruction_group_index: 678
  }
  instructions {
    description: "Conditionally load packed single-precision values from m128 using mask in xmm2 and store in xmm1."
    vendor_syntax {
      mnemonic: "VMASKMOVPS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.128.66.0F38.W0 2C /r"
    instruction_group_index: 679
  }
  instructions {
    description: "Conditionally load packed single-precision values from m256 using mask in ymm2 and store in ymm1."
    vendor_syntax {
      mnemonic: "VMASKMOVPS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.256.66.0F38.W0 2C /r"
    instruction_group_index: 679
  }
  instructions {
    description: "Conditionally load packed double-precision values from m128 using mask in xmm2 and store in xmm1."
    vendor_syntax {
      mnemonic: "VMASKMOVPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.128.66.0F38.W0 2D /r"
    instruction_group_index: 679
  }
  instructions {
    description: "Conditionally load packed double-precision values from m256 using mask in ymm2 and store in ymm1."
    vendor_syntax {
      mnemonic: "VMASKMOVPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.256.66.0F38.W0 2D /r"
    instruction_group_index: 679
  }
  instructions {
    description: "Conditionally store packed single-precision values from xmm2 using mask in xmm1."
    vendor_syntax {
      mnemonic: "VMASKMOVPS"
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MVR"
    raw_encoding_specification: "VEX.128.66.0F38.W0 2E /r"
    instruction_group_index: 679
  }
  instructions {
    description: "Conditionally store packed single-precision values from ymm2 using mask in ymm1."
    vendor_syntax {
      mnemonic: "VMASKMOVPS"
      operands {
        name: "m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm1"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MVR"
    raw_encoding_specification: "VEX.256.66.0F38.W0 2E /r"
    instruction_group_index: 679
  }
  instructions {
    description: "Conditionally store packed double-precision values from xmm2 using mask in xmm1."
    vendor_syntax {
      mnemonic: "VMASKMOVPD"
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MVR"
    raw_encoding_specification: "VEX.128.66.0F38.W0 2F /r"
    instruction_group_index: 679
  }
  instructions {
    description: "Conditionally store packed double-precision values from ymm2 using mask in ymm1."
    vendor_syntax {
      mnemonic: "VMASKMOVPD"
      operands {
        name: "m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm1"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MVR"
    raw_encoding_specification: "VEX.256.66.0F38.W0 2F /r"
    instruction_group_index: 679
  }
  instructions {
    description: "Perform reduction transformation on packed double-precision floating point values in xmm2/m128/m32bcst by subtracting a number of fraction bits specified by the imm8 field. Stores the result in xmm1 register under writemask k1."
    vendor_syntax {
      mnemonic: "VREDUCEPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F3A.W1 56 /r ib"
    instruction_group_index: 680
  }
  instructions {
    description: "Perform reduction transformation on packed double-precision floating point values in ymm2/m256/m32bcst by subtracting a number of fraction bits specified by the imm8 field. Stores the result in ymm1 register under writemask k1."
    vendor_syntax {
      mnemonic: "VREDUCEPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F3A.W1 56 /r ib"
    instruction_group_index: 680
  }
  instructions {
    description: "Perform reduction transformation on double-precision floating point values in zmm2/m512/m32bcst by subtracting a number of fraction bits specified by the imm8 field. Stores the result in zmm1 register under writemask k1."
    vendor_syntax {
      mnemonic: "VREDUCEPD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F3A.W1 56 /r ib"
    instruction_group_index: 680
  }
  instructions {
    description: "Return the bitwise logical OR of packed double-precision floating-point values in xmm1 and xmm2/mem."
    vendor_syntax {
      mnemonic: "ORPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 56/r"
    instruction_group_index: 681
  }
  instructions {
    description: "Return the bitwise logical OR of packed double-precision floating-point values in xmm2 and xmm3/mem."
    vendor_syntax {
      mnemonic: "VORPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F 56 /r"
    instruction_group_index: 681
  }
  instructions {
    description: "Return the bitwise logical OR of packed double-precision floating-point values in ymm2 and ymm3/mem."
    vendor_syntax {
      mnemonic: "VORPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F 56 /r"
    instruction_group_index: 681
  }
  instructions {
    description: "Return the bitwise logical OR of packed double-precision floating-point values in xmm2 and xmm3/m128/m64bcst subject to writemask k1."
    vendor_syntax {
      mnemonic: "VORPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.W1 56 /r"
    instruction_group_index: 681
  }
  instructions {
    description: "Return the bitwise logical OR of packed double-precision floating-point values in ymm2 and ymm3/m256/m64bcst subject to writemask k1."
    vendor_syntax {
      mnemonic: "VORPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.W1 56 /r"
    instruction_group_index: 681
  }
  instructions {
    description: "Return the bitwise logical OR of packed double-precision floating-point values in zmm2 and zmm3/m512/m64bcst subject to writemask k1."
    vendor_syntax {
      mnemonic: "VORPD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.W1 56 /r"
    instruction_group_index: 681
  }
  instructions {
    description: "Computes inverse affine transformation in the finite field GF(2^8)."
    vendor_syntax {
      mnemonic: "GF2P8AFFINEINVQB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "GFNI"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F3A CF /r /ib"
    instruction_group_index: 682
  }
  instructions {
    description: "Computes inverse affine transformation in the finite field GF(2^8)."
    vendor_syntax {
      mnemonic: "VGF2P8AFFINEINVQB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX && GFNI"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F3A.W1 CF /r /ib"
    instruction_group_index: 682
  }
  instructions {
    description: "Computes inverse affine transformation in the finite field GF(2^8)."
    vendor_syntax {
      mnemonic: "VGF2P8AFFINEINVQB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX && GFNI"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F3A.W1 CF /r /ib"
    instruction_group_index: 682
  }
  instructions {
    description: "Computes inverse affine transformation in the finite field GF(2^8)."
    vendor_syntax {
      mnemonic: "VGF2P8AFFINEINVQB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && GFNI"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F3A.W1 CF /r /ib"
    instruction_group_index: 682
  }
  instructions {
    description: "Computes inverse affine transformation in the finite field GF(2^8)."
    vendor_syntax {
      mnemonic: "VGF2P8AFFINEINVQB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && GFNI"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F3A.W1 CF /r /ib"
    instruction_group_index: 682
  }
  instructions {
    description: "Computes inverse affine transformation in the finite field GF(2^8)."
    vendor_syntax {
      mnemonic: "VGF2P8AFFINEINVQB"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F && GFNI"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F3A.W1 CF /r /ib"
    instruction_group_index: 682
  }
  instructions {
    description: "Using dword indices specified in vm32x, gather double-precision FP values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."
    vendor_syntax {
      mnemonic: "VGATHERDPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "vm32x"
        encoding: VSIB_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMV"
    raw_encoding_specification: "VEX.128.66.0F38.W1 92 /r"
    instruction_group_index: 683
  }
  instructions {
    description: "Using qword indices specified in vm64x, gather double-precision FP values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."
    vendor_syntax {
      mnemonic: "VGATHERQPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "vm64x"
        encoding: VSIB_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMV"
    raw_encoding_specification: "VEX.128.66.0F38.W1 93 /r"
    instruction_group_index: 683
  }
  instructions {
    description: "Using dword indices specified in vm32x, gather double-precision FP values from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1."
    vendor_syntax {
      mnemonic: "VGATHERDPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "vm32x"
        encoding: VSIB_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMV"
    raw_encoding_specification: "VEX.256.66.0F38.W1 92 /r"
    instruction_group_index: 683
  }
  instructions {
    description: "Using qword indices specified in vm64y, gather double-precision FP values from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1."
    vendor_syntax {
      mnemonic: "VGATHERQPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "vm64y"
        encoding: VSIB_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMV"
    raw_encoding_specification: "VEX.256.66.0F38.W1 93 /r"
    instruction_group_index: 683
  }
  instructions {
    description: "Convert two packed double-precision floatingpoint values from xmm/m128 to two packed signed doubleword integers in mm."
    vendor_syntax {
      mnemonic: "CVTPD2PI"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "66 0F 2D /r"
    instruction_group_index: 684
  }
  instructions {
    description: "Compare packed signed quadword integer values in xmm3/m128/m64bcst and xmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
    vendor_syntax {
      mnemonic: "VPCMPQ"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F3A.W1 1F /r ib"
    instruction_group_index: 685
  }
  instructions {
    description: "Compare packed signed quadword integer values in ymm3/m256/m64bcst and ymm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
    vendor_syntax {
      mnemonic: "VPCMPQ"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F3A.W1 1F /r ib"
    instruction_group_index: 685
  }
  instructions {
    description: "Compare packed signed quadword integer values in zmm3/m512/m64bcst and zmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
    vendor_syntax {
      mnemonic: "VPCMPQ"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F3A.W1 1F /r ib"
    instruction_group_index: 685
  }
  instructions {
    description: "Compare packed unsigned quadword integer values in xmm3/m128/m64bcst and xmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
    vendor_syntax {
      mnemonic: "VPCMPUQ"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F3A.W1 1E /r ib"
    instruction_group_index: 685
  }
  instructions {
    description: "Compare packed unsigned quadword integer values in ymm3/m256/m64bcst and ymm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
    vendor_syntax {
      mnemonic: "VPCMPUQ"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F3A.W1 1E /r ib"
    instruction_group_index: 685
  }
  instructions {
    description: "Compare packed unsigned quadword integer values in zmm3/m512/m64bcst and zmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
    vendor_syntax {
      mnemonic: "VPCMPUQ"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F3A.W1 1E /r ib"
    instruction_group_index: 685
  }
  instructions {
    description: "Move scalar double-precision floating-point value from xmm2 to xmm1 register."
    vendor_syntax {
      mnemonic: "MOVSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F2 0F 10 /r"
    instruction_group_index: 686
  }
  instructions {
    description: "Load scalar double-precision floating-point value from m64 to xmm1 register."
    vendor_syntax {
      mnemonic: "MOVSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F2 0F 10 /r"
    instruction_group_index: 686
  }
  instructions {
    description: "Move scalar double-precision floating-point value from xmm2 register to xmm1/m64."
    vendor_syntax {
      mnemonic: "MOVSD"
      operands {
        name: "xmm1/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "F2 0F 11 /r"
    instruction_group_index: 686
  }
  instructions {
    description: "Merge scalar double-precision floating-point value from xmm2 and xmm3 to xmm1 register."
    vendor_syntax {
      mnemonic: "VMOVSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.LIG.F2.0F.WIG 10 /r"
    instruction_group_index: 686
  }
  instructions {
    description: "Load scalar double-precision floating-point value from m64 to xmm1 register."
    vendor_syntax {
      mnemonic: "VMOVSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "VEX.LIG.F2.0F.WIG 10 /r"
    instruction_group_index: 686
  }
  instructions {
    description: "Merge scalar double-precision floating-point value from xmm2 and xmm3 registers to xmm1."
    vendor_syntax {
      mnemonic: "VMOVSD"
      operands {
        name: "xmm1"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "E"
    raw_encoding_specification: "VEX.LIG.F2.0F.WIG 11 /r"
    instruction_group_index: 686
  }
  instructions {
    description: "Store scalar double-precision floating-point value from xmm1 register to m64."
    vendor_syntax {
      mnemonic: "VMOVSD"
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "VEX.LIG.F2.0F.WIG 11 /r"
    instruction_group_index: 686
  }
  instructions {
    description: "Merge scalar double-precision floating-point value from xmm2 and xmm3 registers to xmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VMOVSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.LIG.F2.0F.W1 10 /r"
    instruction_group_index: 686
  }
  instructions {
    description: "Load scalar double-precision floating-point value from m64 to xmm1 register under writemask k1."
    vendor_syntax {
      mnemonic: "VMOVSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "F"
    raw_encoding_specification: "EVEX.LIG.F2.0F.W1 10 /r"
    instruction_group_index: 686
  }
  instructions {
    description: "Merge scalar double-precision floating-point value from xmm2 and xmm3 registers to xmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VMOVSD"
      operands {
        name: "xmm1"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "E"
    raw_encoding_specification: "EVEX.LIG.F2.0F.W1 11 /r"
    instruction_group_index: 686
  }
  instructions {
    description: "Store scalar double-precision floating-point value from xmm1 register to m64 under writemask k1."
    vendor_syntax {
      mnemonic: "VMOVSD"
      operands {
        name: "m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "G"
    raw_encoding_specification: "EVEX.LIG.F2.0F.W1 11 /r"
    instruction_group_index: 686
  }
  instructions {
    description: "Multiply the low single-precision floating-point value in xmm2/m32 by the low single-precision floating-point value in xmm1."
    vendor_syntax {
      mnemonic: "MULSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F3 0F 59 /r"
    instruction_group_index: 687
  }
  instructions {
    description: "Multiply the low single-precision floating-point value in xmm3/m32 by the low single-precision floating-point value in xmm2."
    vendor_syntax {
      mnemonic: "VMULSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.LIG.F3.0F.WIG 59 /r"
    instruction_group_index: 687
  }
  instructions {
    description: "Multiply the low single-precision floating-point value in xmm3/m32 by the low single-precision floating-point value in xmm2."
    vendor_syntax {
      mnemonic: "VMULSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.LIG.F3.0F.W0 59 /r"
    instruction_group_index: 687
  }
  instructions {
    description: "Multiply groups of 4 pairs of signed bytes in xmm3/m128/m32bcst with corresponding unsigned bytes of xmm2, summing those products and adding them to doubleword result in xmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPDPBUSD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VNNI && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 50 /r"
    instruction_group_index: 688
  }
  instructions {
    description: "Multiply groups of 4 pairs of signed bytes in ymm3/m256/m32bcst with corresponding unsigned bytes of ymm2, summing those products and adding them to doubleword result in ymm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPDPBUSD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VNNI && AVX512VL"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 50 /r"
    instruction_group_index: 688
  }
  instructions {
    description: "Multiply groups of 4 pairs of signed bytes in zmm3/m512/m32bcst with corresponding unsigned bytes of zmm2, summing those products and adding them to doubleword result in zmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPDPBUSD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VNNI"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 50 /r"
    instruction_group_index: 688
  }
  instructions {
    description: "Set AL to memory byte DS:[(E)BX + unsigned AL]."
    vendor_syntax {
      mnemonic: "XLAT"
      operands {
        name: "m8"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "D7"
    instruction_group_index: 689
  }
  instructions {
    description: "Set AL to memory byte DS:[(E)BX + unsigned AL]."
    vendor_syntax {
      mnemonic: "XLATB"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "D7"
    instruction_group_index: 689
  }
  instructions {
    description: "Set AL to memory byte [RBX + unsigned AL]."
    vendor_syntax {
      mnemonic: "XLATB"
    }
    available_in_64_bit: true
    encoding_scheme: "ZO"
    raw_encoding_specification: "REX.W + D7"
    instruction_group_index: 689
  }
  instructions {
    description: "Using signed dword indices, prefetch sparse byte memory locations containing single-precision data using opmask k1 and T0 hint."
    vendor_syntax {
      mnemonic: "VGATHERPF0DPS"
      operands {
        name: "vm32z"
        encoding: VSIB_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512PF"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 C6 /1 /vsib"
    instruction_group_index: 690
  }
  instructions {
    description: "Using signed qword indices, prefetch sparse byte memory locations containing single-precision data using opmask k1 and T0 hint."
    vendor_syntax {
      mnemonic: "VGATHERPF0QPS"
      operands {
        name: "vm64z"
        encoding: VSIB_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512PF"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 C7 /1 /vsib"
    instruction_group_index: 690
  }
  instructions {
    description: "Using signed dword indices, prefetch sparse byte memory locations containing double-precision data using opmask k1 and T0 hint."
    vendor_syntax {
      mnemonic: "VGATHERPF0DPD"
      operands {
        name: "vm32y"
        encoding: VSIB_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512PF"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 C6 /1 /vsib"
    instruction_group_index: 690
  }
  instructions {
    description: "Using signed qword indices, prefetch sparse byte memory locations containing double-precision data using opmask k1 and T0 hint."
    vendor_syntax {
      mnemonic: "VGATHERPF0QPD"
      operands {
        name: "vm64z"
        encoding: VSIB_ENCODING
        tags {
          name: "k1"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512PF"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 C7 /1 /vsib"
    instruction_group_index: 690
  }
  instructions {
    description: "Convert four packed half precision (16-bit) floatingpoint values in xmm2/m64 to packed single-precision floating-point value in xmm1."
    vendor_syntax {
      mnemonic: "VCVTPH2PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "F16C"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W0 13 /r"
    instruction_group_index: 691
  }
  instructions {
    description: "Convert eight packed half precision (16-bit) floatingpoint values in xmm2/m128 to packed singleprecision floating-point value in ymm1."
    vendor_syntax {
      mnemonic: "VCVTPH2PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "F16C"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W0 13 /r"
    instruction_group_index: 691
  }
  instructions {
    description: "Convert four packed half precision (16-bit) floatingpoint values in xmm2/m64 to packed single-precision floating-point values in xmm1."
    vendor_syntax {
      mnemonic: "VCVTPH2PS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 13 /r"
    instruction_group_index: 691
  }
  instructions {
    description: "Convert eight packed half precision (16-bit) floatingpoint values in xmm2/m128 to packed singleprecision floating-point values in ymm1."
    vendor_syntax {
      mnemonic: "VCVTPH2PS"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 13 /r"
    instruction_group_index: 691
  }
  instructions {
    description: "Convert sixteen packed half precision (16-bit) floating-point values in ymm2/m256 to packed single-precision floating-point values in zmm1."
    vendor_syntax {
      mnemonic: "VCVTPH2PS"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 13 /r"
    instruction_group_index: 691
  }
  instructions {
    description: "Move if above (CF=0 and ZF=0)."
    vendor_syntax {
      mnemonic: "CMOVA"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 47 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if above (CF=0 and ZF=0)."
    vendor_syntax {
      mnemonic: "CMOVA"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 47 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if above (CF=0 and ZF=0)."
    vendor_syntax {
      mnemonic: "CMOVA"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 0F 47 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if above or equal (CF=0)."
    vendor_syntax {
      mnemonic: "CMOVAE"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 43 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if above or equal (CF=0)."
    vendor_syntax {
      mnemonic: "CMOVAE"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 43 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if above or equal (CF=0)."
    vendor_syntax {
      mnemonic: "CMOVAE"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 0F 43 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if below (CF=1)."
    vendor_syntax {
      mnemonic: "CMOVB"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 42 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if below (CF=1)."
    vendor_syntax {
      mnemonic: "CMOVB"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 42 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if below (CF=1)."
    vendor_syntax {
      mnemonic: "CMOVB"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 0F 42 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if below or equal (CF=1 or ZF=1)."
    vendor_syntax {
      mnemonic: "CMOVBE"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 46 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if below or equal (CF=1 or ZF=1)."
    vendor_syntax {
      mnemonic: "CMOVBE"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 46 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if below or equal (CF=1 or ZF=1)."
    vendor_syntax {
      mnemonic: "CMOVBE"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 0F 46 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if carry (CF=1)."
    vendor_syntax {
      mnemonic: "CMOVC"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 42 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if carry (CF=1)."
    vendor_syntax {
      mnemonic: "CMOVC"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 42 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if carry (CF=1)."
    vendor_syntax {
      mnemonic: "CMOVC"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 0F 42 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if equal (ZF=1)."
    vendor_syntax {
      mnemonic: "CMOVE"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 44 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if equal (ZF=1)."
    vendor_syntax {
      mnemonic: "CMOVE"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 44 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if equal (ZF=1)."
    vendor_syntax {
      mnemonic: "CMOVE"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 0F 44 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if greater (ZF=0 and SF=OF)."
    vendor_syntax {
      mnemonic: "CMOVG"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 4F /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if greater (ZF=0 and SF=OF)."
    vendor_syntax {
      mnemonic: "CMOVG"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 4F /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if greater (ZF=0 and SF=OF)."
    vendor_syntax {
      mnemonic: "CMOVG"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 0F 4F /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if greater or equal (SF=OF)."
    vendor_syntax {
      mnemonic: "CMOVGE"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 4D /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if greater or equal (SF=OF)."
    vendor_syntax {
      mnemonic: "CMOVGE"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 4D /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if greater or equal (SF=OF)."
    vendor_syntax {
      mnemonic: "CMOVGE"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 0F 4D /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if less (SF\342\211\240 OF)."
    vendor_syntax {
      mnemonic: "CMOVL"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 4C /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if less (SF\342\211\240 OF)."
    vendor_syntax {
      mnemonic: "CMOVL"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 4C /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if less (SF\342\211\240 OF)."
    vendor_syntax {
      mnemonic: "CMOVL"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 0F 4C /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if less or equal (ZF=1 or SF\342\211\240 OF)."
    vendor_syntax {
      mnemonic: "CMOVLE"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 4E /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if less or equal (ZF=1 or SF\342\211\240 OF)."
    vendor_syntax {
      mnemonic: "CMOVLE"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 4E /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if less or equal (ZF=1 or SF\342\211\240 OF)."
    vendor_syntax {
      mnemonic: "CMOVLE"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 0F 4E /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not above (CF=1 or ZF=1)."
    vendor_syntax {
      mnemonic: "CMOVNA"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 46 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not above (CF=1 or ZF=1)."
    vendor_syntax {
      mnemonic: "CMOVNA"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 46 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not above (CF=1 or ZF=1)."
    vendor_syntax {
      mnemonic: "CMOVNA"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 0F 46 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not above or equal (CF=1)."
    vendor_syntax {
      mnemonic: "CMOVNAE"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 42 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not above or equal (CF=1)."
    vendor_syntax {
      mnemonic: "CMOVNAE"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 42 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not above or equal (CF=1)."
    vendor_syntax {
      mnemonic: "CMOVNAE"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 0F 42 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not below (CF=0)."
    vendor_syntax {
      mnemonic: "CMOVNB"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 43 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not below (CF=0)."
    vendor_syntax {
      mnemonic: "CMOVNB"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 43 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not below (CF=0)."
    vendor_syntax {
      mnemonic: "CMOVNB"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 0F 43 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not below or equal (CF=0 and ZF=0)."
    vendor_syntax {
      mnemonic: "CMOVNBE"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 47 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not below or equal (CF=0 and ZF=0)."
    vendor_syntax {
      mnemonic: "CMOVNBE"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 47 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not below or equal (CF=0 and ZF=0)."
    vendor_syntax {
      mnemonic: "CMOVNBE"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 0F 47 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not carry (CF=0)."
    vendor_syntax {
      mnemonic: "CMOVNC"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 43 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not carry (CF=0)."
    vendor_syntax {
      mnemonic: "CMOVNC"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 43 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not carry (CF=0)."
    vendor_syntax {
      mnemonic: "CMOVNC"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 0F 43 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not equal (ZF=0)."
    vendor_syntax {
      mnemonic: "CMOVNE"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 45 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not equal (ZF=0)."
    vendor_syntax {
      mnemonic: "CMOVNE"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 45 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not equal (ZF=0)."
    vendor_syntax {
      mnemonic: "CMOVNE"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 0F 45 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not greater (ZF=1 or SF\342\211\240 OF)."
    vendor_syntax {
      mnemonic: "CMOVNG"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 4E /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not greater (ZF=1 or SF\342\211\240 OF)."
    vendor_syntax {
      mnemonic: "CMOVNG"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 4E /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not greater (ZF=1 or SF\342\211\240 OF)."
    vendor_syntax {
      mnemonic: "CMOVNG"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 0F 4E /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not greater or equal (SF\342\211\240 OF)."
    vendor_syntax {
      mnemonic: "CMOVNGE"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 4C /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not greater or equal (SF\342\211\240 OF)."
    vendor_syntax {
      mnemonic: "CMOVNGE"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 4C /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not greater or equal (SF\342\211\240 OF)."
    vendor_syntax {
      mnemonic: "CMOVNGE"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 0F 4C /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not less (SF=OF)."
    vendor_syntax {
      mnemonic: "CMOVNL"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 4D /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not less (SF=OF)."
    vendor_syntax {
      mnemonic: "CMOVNL"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 4D /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not less (SF=OF)."
    vendor_syntax {
      mnemonic: "CMOVNL"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 0F 4D /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not less or equal (ZF=0 and SF=OF)."
    vendor_syntax {
      mnemonic: "CMOVNLE"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 4F /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not less or equal (ZF=0 and SF=OF)."
    vendor_syntax {
      mnemonic: "CMOVNLE"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 4F /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not less or equal (ZF=0 and SF=OF)."
    vendor_syntax {
      mnemonic: "CMOVNLE"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 0F 4F /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not overflow (OF=0)."
    vendor_syntax {
      mnemonic: "CMOVNO"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 41 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not overflow (OF=0)."
    vendor_syntax {
      mnemonic: "CMOVNO"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 41 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not overflow (OF=0)."
    vendor_syntax {
      mnemonic: "CMOVNO"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 0F 41 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not parity (PF=0)."
    vendor_syntax {
      mnemonic: "CMOVNP"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 4B /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not parity (PF=0)."
    vendor_syntax {
      mnemonic: "CMOVNP"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 4B /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not parity (PF=0)."
    vendor_syntax {
      mnemonic: "CMOVNP"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 0F 4B /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not sign (SF=0)."
    vendor_syntax {
      mnemonic: "CMOVNS"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 49 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not sign (SF=0)."
    vendor_syntax {
      mnemonic: "CMOVNS"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 49 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not sign (SF=0)."
    vendor_syntax {
      mnemonic: "CMOVNS"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 0F 49 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not zero (ZF=0)."
    vendor_syntax {
      mnemonic: "CMOVNZ"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 45 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not zero (ZF=0)."
    vendor_syntax {
      mnemonic: "CMOVNZ"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 45 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if not zero (ZF=0)."
    vendor_syntax {
      mnemonic: "CMOVNZ"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 0F 45 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if overflow (OF=1)."
    vendor_syntax {
      mnemonic: "CMOVO"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 40 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if overflow (OF=1)."
    vendor_syntax {
      mnemonic: "CMOVO"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 40 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if overflow (OF=1)."
    vendor_syntax {
      mnemonic: "CMOVO"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 0F 40 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if parity (PF=1)."
    vendor_syntax {
      mnemonic: "CMOVP"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 4A /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if parity (PF=1)."
    vendor_syntax {
      mnemonic: "CMOVP"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 4A /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if parity (PF=1)."
    vendor_syntax {
      mnemonic: "CMOVP"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 0F 4A /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if parity even (PF=1)."
    vendor_syntax {
      mnemonic: "CMOVPE"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 4A /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if parity even (PF=1)."
    vendor_syntax {
      mnemonic: "CMOVPE"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 4A /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if parity even (PF=1)."
    vendor_syntax {
      mnemonic: "CMOVPE"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 0F 4A /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if parity odd (PF=0)."
    vendor_syntax {
      mnemonic: "CMOVPO"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 4B /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if parity odd (PF=0)."
    vendor_syntax {
      mnemonic: "CMOVPO"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 4B /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if parity odd (PF=0)."
    vendor_syntax {
      mnemonic: "CMOVPO"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 0F 4B /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if sign (SF=1)."
    vendor_syntax {
      mnemonic: "CMOVS"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 48 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if sign (SF=1)."
    vendor_syntax {
      mnemonic: "CMOVS"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 48 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if sign (SF=1)."
    vendor_syntax {
      mnemonic: "CMOVS"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 0F 48 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if zero (ZF=1)."
    vendor_syntax {
      mnemonic: "CMOVZ"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 44 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if zero (ZF=1)."
    vendor_syntax {
      mnemonic: "CMOVZ"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F 44 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Move if zero (ZF=1)."
    vendor_syntax {
      mnemonic: "CMOVZ"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 0F 44 /r"
    instruction_group_index: 692
  }
  instructions {
    description: "Add packed double-precision floating-point values from xmm2/mem to xmm1 and store result in xmm1."
    vendor_syntax {
      mnemonic: "ADDPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 58 /r"
    instruction_group_index: 693
  }
  instructions {
    description: "Add packed double-precision floating-point values from xmm3/mem to xmm2 and store result in xmm1."
    vendor_syntax {
      mnemonic: "VADDPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG 58 /r"
    instruction_group_index: 693
  }
  instructions {
    description: "Add packed double-precision floating-point values from ymm3/mem to ymm2 and store result in ymm1."
    vendor_syntax {
      mnemonic: "VADDPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG 58 /r"
    instruction_group_index: 693
  }
  instructions {
    description: "Add packed double-precision floating-point values from xmm3/m128/m64bcst to xmm2 and store result in xmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VADDPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.W1 58 /r"
    instruction_group_index: 693
  }
  instructions {
    description: "Add packed double-precision floating-point values from ymm3/m256/m64bcst to ymm2 and store result in ymm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VADDPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.W1 58 /r"
    instruction_group_index: 693
  }
  instructions {
    description: "Add packed double-precision floating-point values from zmm3/m512/m64bcst to zmm2 and store result in zmm1 with writemask k1."
    vendor_syntax {
      mnemonic: "VADDPD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.W1 58 /r"
    instruction_group_index: 693
  }
  instructions {
    description: "Average packed unsigned byte integers from mm2/m64 and mm1 with rounding."
    vendor_syntax {
      mnemonic: "PAVGB"
      operands {
        name: "mm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F E0 /r"
    instruction_group_index: 694
  }
  instructions {
    description: "Average packed unsigned byte integers from xmm2/m128 and xmm1 with rounding."
    vendor_syntax {
      mnemonic: "PAVGB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F E0 /r"
    instruction_group_index: 694
  }
  instructions {
    description: "Average packed unsigned word integers from mm2/m64 and mm1 with rounding."
    vendor_syntax {
      mnemonic: "PAVGW"
      operands {
        name: "mm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F E3 /r"
    instruction_group_index: 694
  }
  instructions {
    description: "Average packed unsigned word integers from xmm2/m128 and xmm1 with rounding."
    vendor_syntax {
      mnemonic: "PAVGW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F E3 /r"
    instruction_group_index: 694
  }
  instructions {
    description: "Average packed unsigned byte integers from xmm3/m128 and xmm2 with rounding."
    vendor_syntax {
      mnemonic: "VPAVGB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG E0 /r"
    instruction_group_index: 694
  }
  instructions {
    description: "Average packed unsigned word integers from xmm3/m128 and xmm2 with rounding."
    vendor_syntax {
      mnemonic: "VPAVGW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG E3 /r"
    instruction_group_index: 694
  }
  instructions {
    description: "Average packed unsigned byte integers from ymm2, and ymm3/m256 with rounding and store to ymm1."
    vendor_syntax {
      mnemonic: "VPAVGB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG E0 /r"
    instruction_group_index: 694
  }
  instructions {
    description: "Average packed unsigned word integers from ymm2, ymm3/m256 with rounding to ymm1."
    vendor_syntax {
      mnemonic: "VPAVGW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG E3 /r"
    instruction_group_index: 694
  }
  instructions {
    description: "Average packed unsigned byte integers from xmm2, and xmm3/m128 with rounding and store to xmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPAVGB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.WIG E0 /r"
    instruction_group_index: 694
  }
  instructions {
    description: "Average packed unsigned byte integers from ymm2, and ymm3/m256 with rounding and store to ymm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPAVGB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.WIG E0 /r"
    instruction_group_index: 694
  }
  instructions {
    description: "Average packed unsigned byte integers from zmm2, and zmm3/m512 with rounding and store to zmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPAVGB"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.WIG E0 /r"
    instruction_group_index: 694
  }
  instructions {
    description: "Average packed unsigned word integers from xmm2, xmm3/m128 with rounding to xmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPAVGW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.WIG E3 /r"
    instruction_group_index: 694
  }
  instructions {
    description: "Average packed unsigned word integers from ymm2, ymm3/m256 with rounding to ymm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPAVGW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.WIG E3 /r"
    instruction_group_index: 694
  }
  instructions {
    description: "Average packed unsigned word integers from zmm2, zmm3/m512 with rounding to zmm1 under writemask k1."
    vendor_syntax {
      mnemonic: "VPAVGW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.WIG E3 /r"
    instruction_group_index: 694
  }
  instructions {
    description: "Perform a packed comparison of string data with explicit lengths, generating an index, and storing the result in ECX."
    vendor_syntax {
      mnemonic: "PCMPESTRI"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE4_2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMI"
    raw_encoding_specification: "66 0F 3A 61 /r imm8"
    instruction_group_index: 695
  }
  instructions {
    description: "Perform a packed comparison of string data with explicit lengths, generating an index, and storing the result in ECX."
    vendor_syntax {
      mnemonic: "VPCMPESTRI"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RMI"
    raw_encoding_specification: "VEX.128.66.0F3A 61 /r ib"
    instruction_group_index: 695
  }
  instructions {
    description: "Shuffle bytes in mm1 according to contents of mm2/m64."
    vendor_syntax {
      mnemonic: "PSHUFB"
      operands {
        name: "mm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 38 00 /r"
    instruction_group_index: 696
  }
  instructions {
    description: "Shuffle bytes in xmm1 according to contents of xmm2/m128."
    vendor_syntax {
      mnemonic: "PSHUFB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 38 00 /r"
    instruction_group_index: 696
  }
  instructions {
    description: "Shuffle bytes in xmm2 according to contents of xmm3/m128."
    vendor_syntax {
      mnemonic: "VPSHUFB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F38.WIG 00 /r"
    instruction_group_index: 696
  }
  instructions {
    description: "Shuffle bytes in ymm2 according to contents of ymm3/m256."
    vendor_syntax {
      mnemonic: "VPSHUFB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F38.WIG 00 /r"
    instruction_group_index: 696
  }
  instructions {
    description: "Shuffle bytes in xmm2 according to contents of xmm3/m128 under write mask k1."
    vendor_syntax {
      mnemonic: "VPSHUFB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F38.WIG 00 /r"
    instruction_group_index: 696
  }
  instructions {
    description: "Shuffle bytes in ymm2 according to contents of ymm3/m256 under write mask k1."
    vendor_syntax {
      mnemonic: "VPSHUFB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38.WIG 00 /r"
    instruction_group_index: 696
  }
  instructions {
    description: "Shuffle bytes in zmm2 according to contents of zmm3/m512 under write mask k1."
    vendor_syntax {
      mnemonic: "VPSHUFB"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38.WIG 00 /r"
    instruction_group_index: 696
  }
  instructions {
    description: "Bitwise XOR 16-bit masks k2 and k3 and place result in k1."
    vendor_syntax {
      mnemonic: "KXORW"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "k3"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVR"
    raw_encoding_specification: "VEX.L1.0F.W0 47 /r"
    instruction_group_index: 697
  }
  instructions {
    description: "Bitwise XOR 8-bit masks k2 and k3 and place result in k1."
    vendor_syntax {
      mnemonic: "KXORB"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "k3"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVR"
    raw_encoding_specification: "VEX.NDS.L1.66.0F.W0 47 /r"
    instruction_group_index: 697
  }
  instructions {
    description: "Bitwise XOR 64-bit masks k2 and k3 and place result in k1."
    vendor_syntax {
      mnemonic: "KXORQ"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "k3"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVR"
    raw_encoding_specification: "VEX.NDS.L1.0F.W1 47 /r"
    instruction_group_index: 697
  }
  instructions {
    description: "Bitwise XOR 32-bit masks k2 and k3 and place result in k1."
    vendor_syntax {
      mnemonic: "KXORD"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "k2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "k3"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVR"
    raw_encoding_specification: "VEX.NDS.L1.66.0F.W1 47 /r"
    instruction_group_index: 697
  }
  instructions {
    description: "Compare packed signed word integers in xmm3/m128 and xmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
    vendor_syntax {
      mnemonic: "VPCMPW"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F3A.W1 3F /r ib"
    instruction_group_index: 698
  }
  instructions {
    description: "Compare packed signed word integers in ymm3/m256 and ymm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
    vendor_syntax {
      mnemonic: "VPCMPW"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F3A.W1 3F /r ib"
    instruction_group_index: 698
  }
  instructions {
    description: "Compare packed signed word integers in zmm3/m512 and zmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
    vendor_syntax {
      mnemonic: "VPCMPW"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F3A.W1 3F /r ib"
    instruction_group_index: 698
  }
  instructions {
    description: "Compare packed unsigned word integers in xmm3/m128 and xmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
    vendor_syntax {
      mnemonic: "VPCMPUW"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F3A.W1 3E /r ib"
    instruction_group_index: 698
  }
  instructions {
    description: "Compare packed unsigned word integers in ymm3/m256 and ymm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
    vendor_syntax {
      mnemonic: "VPCMPUW"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F3A.W1 3E /r ib"
    instruction_group_index: 698
  }
  instructions {
    description: "Compare packed unsigned word integers in zmm3/m512 and zmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
    vendor_syntax {
      mnemonic: "VPCMPUW"
      operands {
        name: "k1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k2"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "imm8"
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.NDS.512.66.0F3A.W1 3E /r ib"
    instruction_group_index: 698
  }
  instructions {
    description: "Permute bytes in xmm3/m128 using byte indexes in xmm2 and store the result in xmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512_VBMI"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 8D /r"
    instruction_group_index: 699
  }
  instructions {
    description: "Permute bytes in ymm3/m256 using byte indexes in ymm2 and store the result in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512_VBMI"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 8D /r"
    instruction_group_index: 699
  }
  instructions {
    description: "Permute bytes in zmm3/m512 using byte indexes in zmm2 and store the result in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VPERMB"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512_VBMI"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 8D /r"
    instruction_group_index: 699
  }
  instructions {
    description: "AL XOR imm8."
    vendor_syntax {
      mnemonic: "XOR"
      operands {
        name: "AL"
        encoding: IMPLICIT_ENCODING
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "I"
    raw_encoding_specification: "34 ib"
    instruction_group_index: 700
  }
  instructions {
    description: "AX XOR imm16."
    vendor_syntax {
      mnemonic: "XOR"
      operands {
        name: "AX"
        encoding: IMPLICIT_ENCODING
      }
      operands {
        name: "imm16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "I"
    raw_encoding_specification: "35 iw"
    instruction_group_index: 700
  }
  instructions {
    description: "EAX XOR imm32."
    vendor_syntax {
      mnemonic: "XOR"
      operands {
        name: "EAX"
        encoding: IMPLICIT_ENCODING
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "I"
    raw_encoding_specification: "35 id"
    instruction_group_index: 700
  }
  instructions {
    description: "RAX XOR imm32 (sign-extended)."
    vendor_syntax {
      mnemonic: "XOR"
      operands {
        name: "RAX"
        encoding: IMPLICIT_ENCODING
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "I"
    raw_encoding_specification: "REX.W + 35 id"
    instruction_group_index: 700
  }
  instructions {
    description: "r/m8 XOR imm8."
    vendor_syntax {
      mnemonic: "XOR"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "80 /6 ib"
    instruction_group_index: 700
  }
  instructions {
    description: "r/m8 XOR imm8."
    vendor_syntax {
      mnemonic: "XOR"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX + 80 /6 ib"
    instruction_group_index: 700
  }
  instructions {
    description: "r/m16 XOR imm16."
    vendor_syntax {
      mnemonic: "XOR"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "81 /6 iw"
    instruction_group_index: 700
  }
  instructions {
    description: "r/m32 XOR imm32."
    vendor_syntax {
      mnemonic: "XOR"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "81 /6 id"
    instruction_group_index: 700
  }
  instructions {
    description: "r/m64 XOR imm32 (sign-extended)."
    vendor_syntax {
      mnemonic: "XOR"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX.W + 81 /6 id"
    instruction_group_index: 700
  }
  instructions {
    description: "r/m16 XOR imm8 (sign-extended)."
    vendor_syntax {
      mnemonic: "XOR"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "83 /6 ib"
    instruction_group_index: 700
  }
  instructions {
    description: "r/m32 XOR imm8 (sign-extended)."
    vendor_syntax {
      mnemonic: "XOR"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MI"
    raw_encoding_specification: "83 /6 ib"
    instruction_group_index: 700
  }
  instructions {
    description: "r/m64 XOR imm8 (sign-extended)."
    vendor_syntax {
      mnemonic: "XOR"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "imm8"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MI"
    raw_encoding_specification: "REX.W + 83 /6 ib"
    instruction_group_index: 700
  }
  instructions {
    description: "r/m8 XOR r8."
    vendor_syntax {
      mnemonic: "XOR"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "30 /r"
    instruction_group_index: 700
  }
  instructions {
    description: "r/m8 XOR r8."
    vendor_syntax {
      mnemonic: "XOR"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MR"
    raw_encoding_specification: "REX + 30 /r"
    instruction_group_index: 700
  }
  instructions {
    description: "r/m16 XOR r16."
    vendor_syntax {
      mnemonic: "XOR"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "31 /r"
    instruction_group_index: 700
  }
  instructions {
    description: "r/m32 XOR r32."
    vendor_syntax {
      mnemonic: "XOR"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "MR"
    raw_encoding_specification: "31 /r"
    instruction_group_index: 700
  }
  instructions {
    description: "r/m64 XOR r64."
    vendor_syntax {
      mnemonic: "XOR"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "MR"
    raw_encoding_specification: "REX.W + 31 /r"
    instruction_group_index: 700
  }
  instructions {
    description: "r8 XOR r/m8."
    vendor_syntax {
      mnemonic: "XOR"
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "32 /r"
    instruction_group_index: 700
  }
  instructions {
    description: "r8 XOR r/m8."
    vendor_syntax {
      mnemonic: "XOR"
      operands {
        name: "r8"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX + 32 /r"
    instruction_group_index: 700
  }
  instructions {
    description: "r16 XOR r/m16."
    vendor_syntax {
      mnemonic: "XOR"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "33 /r"
    instruction_group_index: 700
  }
  instructions {
    description: "r32 XOR r/m32."
    vendor_syntax {
      mnemonic: "XOR"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "33 /r"
    instruction_group_index: 700
  }
  instructions {
    description: "r64 XOR r/m64."
    vendor_syntax {
      mnemonic: "XOR"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX.W + 33 /r"
    instruction_group_index: 700
  }
  instructions {
    description: "Bitwise XOR of mm/m64 and mm."
    vendor_syntax {
      mnemonic: "PXOR"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F EF /r"
    instruction_group_index: 702
  }
  instructions {
    description: "Bitwise XOR of xmm2/m128 and xmm1."
    vendor_syntax {
      mnemonic: "PXOR"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F EF /r"
    instruction_group_index: 702
  }
  instructions {
    description: "Bitwise XOR of xmm3/m128 and xmm2."
    vendor_syntax {
      mnemonic: "VPXOR"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG EF /r"
    instruction_group_index: 702
  }
  instructions {
    description: "Bitwise XOR of ymm3/m256 and ymm2."
    vendor_syntax {
      mnemonic: "VPXOR"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG EF /r"
    instruction_group_index: 702
  }
  instructions {
    description: "Bitwise XOR of packed doubleword integers in xmm2 and xmm3/m128 using writemask k1."
    vendor_syntax {
      mnemonic: "VPXORD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.W0 EF /r"
    instruction_group_index: 702
  }
  instructions {
    description: "Bitwise XOR of packed doubleword integers in ymm2 and ymm3/m256 using writemask k1."
    vendor_syntax {
      mnemonic: "VPXORD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.W0 EF /r"
    instruction_group_index: 702
  }
  instructions {
    description: "Bitwise XOR of packed doubleword integers in zmm2 and zmm3/m512/m32bcst using writemask k1."
    vendor_syntax {
      mnemonic: "VPXORD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.W0 EF /r"
    instruction_group_index: 702
  }
  instructions {
    description: "Bitwise XOR of packed quadword integers in xmm2 and xmm3/m128 using writemask k1."
    vendor_syntax {
      mnemonic: "VPXORQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.W1 EF /r"
    instruction_group_index: 702
  }
  instructions {
    description: "Bitwise XOR of packed quadword integers in ymm2 and ymm3/m256 using writemask k1."
    vendor_syntax {
      mnemonic: "VPXORQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.W1 EF /r"
    instruction_group_index: 702
  }
  instructions {
    description: "Bitwise XOR of packed quadword integers in zmm2 and zmm3/m512/m64bcst using writemask k1."
    vendor_syntax {
      mnemonic: "VPXORQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.W1 EF /r"
    instruction_group_index: 702
  }
  instructions {
    description: "Divide low single-precision floating-point value in xmm1 by low single-precision floating-point value in xmm2/m32."
    vendor_syntax {
      mnemonic: "DIVSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "F3 0F 5E /r"
    instruction_group_index: 703
  }
  instructions {
    description: "Divide low single-precision floating-point value in xmm2 by low single-precision floating-point value in xmm3/m32."
    vendor_syntax {
      mnemonic: "VDIVSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.LIG.F3.0F.WIG 5E /r"
    instruction_group_index: 703
  }
  instructions {
    description: "Divide low single-precision floating-point value in xmm2 by low single-precision floating-point value in xmm3/m32."
    vendor_syntax {
      mnemonic: "VDIVSS"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
      }
      operands {
        name: "xmm3/m32"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.LIG.F3.0F.W0 5E /r"
    instruction_group_index: 703
  }
  instructions {
    description: "Add/subtract double-precision floating-point values from xmm2/m128 to xmm1."
    vendor_syntax {
      mnemonic: "ADDSUBPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE3"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "66 0F D0 /r"
    instruction_group_index: 704
  }
  instructions {
    description: "Add/subtract packed double-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1."
    vendor_syntax {
      mnemonic: "VADDSUBPD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.128.66.0F.WIG D0 /r"
    instruction_group_index: 704
  }
  instructions {
    description: "Add / subtract packed double-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1."
    vendor_syntax {
      mnemonic: "VADDSUBPD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RVM"
    raw_encoding_specification: "VEX.256.66.0F.WIG D0 /r"
    instruction_group_index: 704
  }
  instructions {
    description: "Load DS:r16 with far pointer from memory."
    vendor_syntax {
      mnemonic: "LDS"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "m16:16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "C5 /r"
    instruction_group_index: 705
  }
  instructions {
    description: "Load DS:r32 with far pointer from memory."
    vendor_syntax {
      mnemonic: "LDS"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "m16:32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "C5 /r"
    instruction_group_index: 705
  }
  instructions {
    description: "Load SS:r16 with far pointer from memory."
    vendor_syntax {
      mnemonic: "LSS"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "m16:16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F B2 /r"
    instruction_group_index: 705
  }
  instructions {
    description: "Load SS:r32 with far pointer from memory."
    vendor_syntax {
      mnemonic: "LSS"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "m16:32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F B2 /r"
    instruction_group_index: 705
  }
  instructions {
    description: "Load SS:r64 with far pointer from memory."
    vendor_syntax {
      mnemonic: "LSS"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "m16:64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX + 0F B2 /r"
    instruction_group_index: 705
  }
  instructions {
    description: "Load ES:r16 with far pointer from memory."
    vendor_syntax {
      mnemonic: "LES"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "m16:16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "C4 /r"
    instruction_group_index: 705
  }
  instructions {
    description: "Load ES:r32 with far pointer from memory."
    vendor_syntax {
      mnemonic: "LES"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "m16:32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "C4 /r"
    instruction_group_index: 705
  }
  instructions {
    description: "Load FS:r16 with far pointer from memory."
    vendor_syntax {
      mnemonic: "LFS"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "m16:16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F B4 /r"
    instruction_group_index: 705
  }
  instructions {
    description: "Load FS:r32 with far pointer from memory."
    vendor_syntax {
      mnemonic: "LFS"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "m16:32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F B4 /r"
    instruction_group_index: 705
  }
  instructions {
    description: "Load FS:r64 with far pointer from memory."
    vendor_syntax {
      mnemonic: "LFS"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "m16:64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX + 0F B4 /r"
    instruction_group_index: 705
  }
  instructions {
    description: "Load GS:r16 with far pointer from memory."
    vendor_syntax {
      mnemonic: "LGS"
      operands {
        name: "r16"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "m16:16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F B5 /r"
    instruction_group_index: 705
  }
  instructions {
    description: "Load GS:r32 with far pointer from memory."
    vendor_syntax {
      mnemonic: "LGS"
      operands {
        name: "r32"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "m16:32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "RM"
    raw_encoding_specification: "0F B5 /r"
    instruction_group_index: 705
  }
  instructions {
    description: "Load GS:r64 with far pointer from memory."
    vendor_syntax {
      mnemonic: "LGS"
      operands {
        name: "r64"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "m16:64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "RM"
    raw_encoding_specification: "REX + 0F B5 /r"
    instruction_group_index: 705
  }
  instructions {
    description: "Unpack and interleave high-order bytes from mm and mm/m64 into mm."
    vendor_syntax {
      mnemonic: "PUNPCKHBW"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 68 /r"
    instruction_group_index: 706
  }
  instructions {
    description: "Unpack and interleave high-order bytes from xmm1 and xmm2/m128 into xmm1."
    vendor_syntax {
      mnemonic: "PUNPCKHBW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 68 /r"
    instruction_group_index: 706
  }
  instructions {
    description: "Unpack and interleave high-order words from mm and mm/m64 into mm."
    vendor_syntax {
      mnemonic: "PUNPCKHWD"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 69 /r"
    instruction_group_index: 706
  }
  instructions {
    description: "Unpack and interleave high-order words from xmm1 and xmm2/m128 into xmm1."
    vendor_syntax {
      mnemonic: "PUNPCKHWD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 69 /r"
    instruction_group_index: 706
  }
  instructions {
    description: "Unpack and interleave high-order doublewords from mm and mm/m64 into mm."
    vendor_syntax {
      mnemonic: "PUNPCKHDQ"
      operands {
        name: "mm"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "mm/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "MMX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "NP 0F 6A /r"
    instruction_group_index: 706
  }
  instructions {
    description: "Unpack and interleave high-order doublewords from xmm1 and xmm2/m128 into xmm1."
    vendor_syntax {
      mnemonic: "PUNPCKHDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 6A /r"
    instruction_group_index: 706
  }
  instructions {
    description: "Unpack and interleave high-order quadwords from xmm1 and xmm2/m128 into xmm1."
    vendor_syntax {
      mnemonic: "PUNPCKHQDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "SSE2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "66 0F 6D /r"
    instruction_group_index: 706
  }
  instructions {
    description: "Interleave high-order bytes from xmm2 and xmm3/m128 into xmm1."
    vendor_syntax {
      mnemonic: "VPUNPCKHBW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG 68/r"
    instruction_group_index: 706
  }
  instructions {
    description: "Interleave high-order words from xmm2 and xmm3/m128 into xmm1."
    vendor_syntax {
      mnemonic: "VPUNPCKHWD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG 69/r"
    instruction_group_index: 706
  }
  instructions {
    description: "Interleave high-order doublewords from xmm2 and xmm3/m128 into xmm1."
    vendor_syntax {
      mnemonic: "VPUNPCKHDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG 6A/r"
    instruction_group_index: 706
  }
  instructions {
    description: "Interleave high-order quadword from xmm2 and xmm3/m128 into xmm1 register."
    vendor_syntax {
      mnemonic: "VPUNPCKHQDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.128.66.0F.WIG 6D/r"
    instruction_group_index: 706
  }
  instructions {
    description: "Interleave high-order bytes from ymm2 and ymm3/m256 into ymm1 register."
    vendor_syntax {
      mnemonic: "VPUNPCKHBW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG 68 /r"
    instruction_group_index: 706
  }
  instructions {
    description: "Interleave high-order words from ymm2 and ymm3/m256 into ymm1 register."
    vendor_syntax {
      mnemonic: "VPUNPCKHWD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG 69 /r"
    instruction_group_index: 706
  }
  instructions {
    description: "Interleave high-order doublewords from ymm2 and ymm3/m256 into ymm1 register."
    vendor_syntax {
      mnemonic: "VPUNPCKHDQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG 6A /r"
    instruction_group_index: 706
  }
  instructions {
    description: "Interleave high-order quadword from ymm2 and ymm3/m256 into ymm1 register."
    vendor_syntax {
      mnemonic: "VPUNPCKHQDQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "VEX.256.66.0F.WIG 6D /r"
    instruction_group_index: 706
  }
  instructions {
    description: "Interleave high-order bytes from xmm2 and xmm3/m128 into xmm1 register using k1 write mask."
    vendor_syntax {
      mnemonic: "VPUNPCKHBW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.WIG 68 /r"
    instruction_group_index: 706
  }
  instructions {
    description: "Interleave high-order words from xmm2 and xmm3/m128 into xmm1 register using k1 write mask."
    vendor_syntax {
      mnemonic: "VPUNPCKHWD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F.WIG 69 /r"
    instruction_group_index: 706
  }
  instructions {
    description: "Interleave high-order doublewords from xmm2 and xmm3/m128/m32bcst into xmm1 register using k1 write mask."
    vendor_syntax {
      mnemonic: "VPUNPCKHDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.128.66.0F.W0 6A /r"
    instruction_group_index: 706
  }
  instructions {
    description: "Interleave high-order quadword from xmm2 and xmm3/m128/m64bcst into xmm1 register using k1 write mask."
    vendor_syntax {
      mnemonic: "VPUNPCKHQDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m128/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.128.66.0F.W1 6D /r"
    instruction_group_index: 706
  }
  instructions {
    description: "Interleave high-order bytes from ymm2 and ymm3/m256 into ymm1 register using k1 write mask."
    vendor_syntax {
      mnemonic: "VPUNPCKHBW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.WIG 68 /r"
    instruction_group_index: 706
  }
  instructions {
    description: "Interleave high-order words from ymm2 and ymm3/m256 into ymm1 register using k1 write mask."
    vendor_syntax {
      mnemonic: "VPUNPCKHWD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F.WIG 69 /r"
    instruction_group_index: 706
  }
  instructions {
    description: "Interleave high-order doublewords from ymm2 and ymm3/m256/m32bcst into ymm1 register using k1 write mask."
    vendor_syntax {
      mnemonic: "VPUNPCKHDQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.256.66.0F.W0 6A /r"
    instruction_group_index: 706
  }
  instructions {
    description: "Interleave high-order quadword from ymm2 and ymm3/m256/m64bcst into ymm1 register using k1 write mask."
    vendor_syntax {
      mnemonic: "VPUNPCKHQDQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "ymm3/m256/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.256.66.0F.W1 6D /r"
    instruction_group_index: 706
  }
  instructions {
    description: "Interleave high-order bytes from zmm2 and zmm3/m512 into zmm1 register."
    vendor_syntax {
      mnemonic: "VPUNPCKHBW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.WIG 68/r"
    instruction_group_index: 706
  }
  instructions {
    description: "Interleave high-order words from zmm2 and zmm3/m512 into zmm1 register."
    vendor_syntax {
      mnemonic: "VPUNPCKHWD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F.WIG 69/r"
    instruction_group_index: 706
  }
  instructions {
    description: "Interleave high-order doublewords from zmm2 and zmm3/m512/m32bcst into zmm1 register using k1 write mask."
    vendor_syntax {
      mnemonic: "VPUNPCKHDQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.66.0F.W0 6A /r"
    instruction_group_index: 706
  }
  instructions {
    description: "Interleave high-order quadword from zmm2 and zmm3/m512/m64bcst into zmm1 register using k1 write mask."
    vendor_syntax {
      mnemonic: "VPUNPCKHQDQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "zmm3/m512/m64bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.66.0F.W1 6D /r"
    instruction_group_index: 706
  }
  instructions {
    description: "Convert four packed single precision floating-point values from xmm2/m128/m32bcst to four packed unsigned doubleword values in xmm1 using truncation subject to writemask k1."
    vendor_syntax {
      mnemonic: "VCVTTPS2UDQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m128/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.128.0F.W0 78 /r"
    instruction_group_index: 707
  }
  instructions {
    description: "Convert eight packed single precision floating-point values from ymm2/m256/m32bcst to eight packed unsigned doubleword values in ymm1 using truncation subject to writemask k1."
    vendor_syntax {
      mnemonic: "VCVTTPS2UDQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "ymm2/m256/m32bcst"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.256.0F.W0 78 /r"
    instruction_group_index: 707
  }
  instructions {
    description: "Convert sixteen packed single-precision floatingpoint values from zmm2/m512/m32bcst to sixteen packed unsigned doubleword values in zmm1 using truncation subject to writemask k1."
    vendor_syntax {
      mnemonic: "VCVTTPS2UDQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "zmm2/m512/m32bcst"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "sae"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "EVEX.512.0F.W0 78 /r"
    instruction_group_index: 707
  }
  instructions {
    description: "Multiply scalar double-precision floating-point value from xmm1 and xmm3/m64, add to xmm2 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMADD132SD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.LIG.66.0F38.W1 99 /r"
    instruction_group_index: 708
  }
  instructions {
    description: "Multiply scalar double-precision floating-point value from xmm1 and xmm2, add to xmm3/m64 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMADD213SD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.LIG.66.0F38.W1 A9 /r"
    instruction_group_index: 708
  }
  instructions {
    description: "Multiply scalar double-precision floating-point value from xmm2 and xmm3/m64, add to xmm1 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMADD231SD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "FMA"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.LIG.66.0F38.W1 B9 /r"
    instruction_group_index: 708
  }
  instructions {
    description: "Multiply scalar double-precision floating-point value from xmm1 and xmm3/m64, add to xmm2 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMADD132SD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.LIG.66.0F38.W1 99 /r"
    instruction_group_index: 708
  }
  instructions {
    description: "Multiply scalar double-precision floating-point value from xmm1 and xmm2, add to xmm3/m64 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMADD213SD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.LIG.66.0F38.W1 A9 /r"
    instruction_group_index: 708
  }
  instructions {
    description: "Multiply scalar double-precision floating-point value from xmm2 and xmm3/m64, add to xmm1 and put result in xmm1."
    vendor_syntax {
      mnemonic: "VFMADD231SD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_READ_WRITE
      }
      operands {
        name: "xmm2"
        encoding: VEX_V_ENCODING
        usage: USAGE_READ
      }
      operands {
        name: "xmm3/m64"
        encoding: MODRM_RM_ENCODING
        tags {
          name: "er"
        }
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.LIG.66.0F38.W1 B9 /r"
    instruction_group_index: 708
  }
  instructions {
    description: "Broadcast a byte integer in the source operand to sixteen locations in xmm1."
    vendor_syntax {
      mnemonic: "VPBROADCASTB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W0 78 /r"
    instruction_group_index: 709
  }
  instructions {
    description: "Broadcast a byte integer in the source operand to thirty-two locations in ymm1."
    vendor_syntax {
      mnemonic: "VPBROADCASTB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W0 78 /r"
    instruction_group_index: 709
  }
  instructions {
    description: "Broadcast a byte integer in the source operand to locations in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPBROADCASTB"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 78 /r"
    instruction_group_index: 709
  }
  instructions {
    description: "Broadcast a byte integer in the source operand to locations in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPBROADCASTB"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 78 /r"
    instruction_group_index: 709
  }
  instructions {
    description: "Broadcast a byte integer in the source operand to 64 locations in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPBROADCASTB"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 78 /r"
    instruction_group_index: 709
  }
  instructions {
    description: "Broadcast a word integer in the source operand to eight locations in xmm1."
    vendor_syntax {
      mnemonic: "VPBROADCASTW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W0 79 /r"
    instruction_group_index: 709
  }
  instructions {
    description: "Broadcast a word integer in the source operand to sixteen locations in ymm1."
    vendor_syntax {
      mnemonic: "VPBROADCASTW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W0 79 /r"
    instruction_group_index: 709
  }
  instructions {
    description: "Broadcast a word integer in the source operand to locations in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPBROADCASTW"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 79 /r"
    instruction_group_index: 709
  }
  instructions {
    description: "Broadcast a word integer in the source operand to locations in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPBROADCASTW"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 79 /r"
    instruction_group_index: 709
  }
  instructions {
    description: "Broadcast a word integer in the source operand to 32 locations in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPBROADCASTW"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512BW"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 79 /r"
    instruction_group_index: 709
  }
  instructions {
    description: "Broadcast a dword integer in the source operand to four locations in xmm1."
    vendor_syntax {
      mnemonic: "VPBROADCASTD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W0 58 /r"
    instruction_group_index: 709
  }
  instructions {
    description: "Broadcast a dword integer in the source operand to eight locations in ymm1."
    vendor_syntax {
      mnemonic: "VPBROADCASTD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W0 58 /r"
    instruction_group_index: 709
  }
  instructions {
    description: "Broadcast a dword integer in the source operand to locations in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPBROADCASTD"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 58 /r"
    instruction_group_index: 709
  }
  instructions {
    description: "Broadcast a dword integer in the source operand to locations in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPBROADCASTD"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 58 /r"
    instruction_group_index: 709
  }
  instructions {
    description: "Broadcast a dword integer in the source operand to locations in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPBROADCASTD"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 58 /r"
    instruction_group_index: 709
  }
  instructions {
    description: "Broadcast a qword element in source operand to two locations in xmm1."
    vendor_syntax {
      mnemonic: "VPBROADCASTQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.128.66.0F38.W0 59 /r"
    instruction_group_index: 709
  }
  instructions {
    description: "Broadcast a qword element in source operand to four locations in ymm1."
    vendor_syntax {
      mnemonic: "VPBROADCASTQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W0 59 /r"
    instruction_group_index: 709
  }
  instructions {
    description: "Broadcast a qword element in source operand to locations in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPBROADCASTQ"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.128.66.0F38.W1 59 /r"
    instruction_group_index: 709
  }
  instructions {
    description: "Broadcast a qword element in source operand to locations in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPBROADCASTQ"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 59 /r"
    instruction_group_index: 709
  }
  instructions {
    description: "Broadcast a qword element in source operand to locations in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VPBROADCASTQ"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "B"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 59 /r"
    instruction_group_index: 709
  }
  instructions {
    description: "Broadcast two dword elements in source operand to locations in xmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VBROADCASTI32x2"
      operands {
        name: "xmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.128.66.0F38.W0 59 /r"
    instruction_group_index: 709
  }
  instructions {
    description: "Broadcast two dword elements in source operand to locations in ymm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VBROADCASTI32x2"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 59 /r"
    instruction_group_index: 709
  }
  instructions {
    description: "Broadcast two dword elements in source operand to locations in zmm1 subject to writemask k1."
    vendor_syntax {
      mnemonic: "VBROADCASTI32x2"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "xmm2/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 59 /r"
    instruction_group_index: 709
  }
  instructions {
    description: "Broadcast 128 bits of integer data in mem to low and high 128-bits in ymm1."
    vendor_syntax {
      mnemonic: "VBROADCASTI128"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        usage: USAGE_WRITE
      }
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX2"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "A"
    raw_encoding_specification: "VEX.256.66.0F38.W0 5A /r"
    instruction_group_index: 709
  }
  instructions {
    description: "Broadcast 128 bits of 4 doubleword integer data in mem to locations in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VBROADCASTI32X4"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.256.66.0F38.W0 5A /r"
    instruction_group_index: 709
  }
  instructions {
    description: "Broadcast 128 bits of 4 doubleword integer data in mem to locations in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VBROADCASTI32X4"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 5A /r"
    instruction_group_index: 709
  }
  instructions {
    description: "Broadcast 128 bits of 2 quadword integer data in mem to locations in ymm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VBROADCASTI64X2"
      operands {
        name: "ymm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512VL && AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.256.66.0F38.W1 5A /r"
    instruction_group_index: 709
  }
  instructions {
    description: "Broadcast 128 bits of 2 quadword integer data in mem to locations in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VBROADCASTI64X2"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "m128"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "C"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 5A /r"
    instruction_group_index: 709
  }
  instructions {
    description: "Broadcast 256 bits of 8 doubleword integer data in mem to locations in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VBROADCASTI32X8"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512DQ"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "E"
    raw_encoding_specification: "EVEX.512.66.0F38.W0 5B /r"
    instruction_group_index: 709
  }
  instructions {
    description: "Broadcast 256 bits of 4 quadword integer data in mem to locations in zmm1 using writemask k1."
    vendor_syntax {
      mnemonic: "VBROADCASTI64X4"
      operands {
        name: "zmm1"
        encoding: MODRM_REG_ENCODING
        tags {
          name: "k1"
        }
        tags {
          name: "z"
        }
        usage: USAGE_WRITE
      }
      operands {
        name: "m256"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    feature_name: "AVX512F"
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "EVEX.512.66.0F38.W1 5B /r"
    instruction_group_index: 709
  }
  instructions {
    description: "For legacy mode, store AL at address ES:(E)DI; For 64-bit mode store AL at address RDI or EDI."
    vendor_syntax {
      mnemonic: "STOS"
      operands {
        name: "m8"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "NA"
    raw_encoding_specification: "AA"
    instruction_group_index: 710
  }
  instructions {
    description: "For legacy mode, store AX at address ES:(E)DI; For 64-bit mode store AX at address RDI or EDI."
    vendor_syntax {
      mnemonic: "STOS"
      operands {
        name: "m16"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "NA"
    raw_encoding_specification: "AB"
    instruction_group_index: 710
  }
  instructions {
    description: "For legacy mode, store EAX at address ES:(E)DI; For 64-bit mode store EAX at address RDI or EDI."
    vendor_syntax {
      mnemonic: "STOS"
      operands {
        name: "m32"
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "NA"
    raw_encoding_specification: "AB"
    instruction_group_index: 710
  }
  instructions {
    description: "Store RAX at address RDI or EDI."
    vendor_syntax {
      mnemonic: "STOS"
      operands {
        name: "m64"
      }
    }
    available_in_64_bit: true
    encoding_scheme: "NA"
    raw_encoding_specification: "REX.W + AB"
    instruction_group_index: 710
  }
  instructions {
    description: "For legacy mode, store AL at address ES:(E)DI; For 64-bit mode store AL at address RDI or EDI."
    vendor_syntax {
      mnemonic: "STOSB"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "NA"
    raw_encoding_specification: "AA"
    instruction_group_index: 710
  }
  instructions {
    description: "For legacy mode, store AX at address ES:(E)DI; For 64-bit mode store AX at address RDI or EDI."
    vendor_syntax {
      mnemonic: "STOSW"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "NA"
    raw_encoding_specification: "AB"
    instruction_group_index: 710
  }
  instructions {
    description: "For legacy mode, store EAX at address ES:(E)DI; For 64-bit mode store EAX at address RDI or EDI."
    vendor_syntax {
      mnemonic: "STOSD"
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "NA"
    raw_encoding_specification: "AB"
    instruction_group_index: 710
  }
  instructions {
    description: "Store RAX at address RDI or EDI."
    vendor_syntax {
      mnemonic: "STOSQ"
    }
    available_in_64_bit: true
    encoding_scheme: "NA"
    raw_encoding_specification: "REX.W + AB"
    instruction_group_index: 710
  }
  instructions {
    description: "Call near, relative, displacement relative to next instruction."
    vendor_syntax {
      mnemonic: "CALL"
      operands {
        name: "rel16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "E8 cw"
    instruction_group_index: 711
  }
  instructions {
    description: "Call near, relative, displacement relative to next instruction. 32-bit displacement sign extended to 64-bits in 64-bit mode."
    vendor_syntax {
      mnemonic: "CALL"
      operands {
        name: "rel32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "E8 cd"
    instruction_group_index: 711
  }
  instructions {
    description: "Call near, absolute indirect, address given in r/m16."
    vendor_syntax {
      mnemonic: "CALL"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "FF /2"
    instruction_group_index: 711
  }
  instructions {
    description: "Call near, absolute indirect, address given in r/m32."
    vendor_syntax {
      mnemonic: "CALL"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "FF /2"
    instruction_group_index: 711
  }
  instructions {
    description: "Call near, absolute indirect, address given in r/m64."
    vendor_syntax {
      mnemonic: "CALL"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "FF /2"
    instruction_group_index: 711
  }
  instructions {
    description: "Call far, absolute, address given in operand."
    vendor_syntax {
      mnemonic: "CALL"
      operands {
        name: "ptr16:16"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "9A cd"
    instruction_group_index: 711
  }
  instructions {
    description: "Call far, absolute, address given in operand."
    vendor_syntax {
      mnemonic: "CALL"
      operands {
        name: "ptr16:32"
        encoding: IMMEDIATE_VALUE_ENCODING
        usage: USAGE_READ
      }
    }
    legacy_instruction: true
    encoding_scheme: "D"
    raw_encoding_specification: "9A cp"
    instruction_group_index: 711
  }
  instructions {
    description: "Call far, absolute indirect address given in m16:16.\nIn 32-bit mode: if selector points to a gate, then RIP = 32-bit zero extended displacement taken from gate; else RIP = zero extended 16-bit offset from far pointer referenced in the instruction."
    vendor_syntax {
      mnemonic: "CALL"
      operands {
        name: "m16:16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "FF /3"
    instruction_group_index: 711
  }
  instructions {
    description: "In 64-bit mode: If selector points to a gate, then RIP = 64-bit displacement taken from gate; else RIP = zero extended 32-bit offset from far pointer referenced in the instruction."
    vendor_syntax {
      mnemonic: "CALL"
      operands {
        name: "m16:32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "FF /3"
    instruction_group_index: 711
  }
  instructions {
    description: "In 64-bit mode: If selector points to a gate, then RIP = 64-bit displacement taken from gate; else RIP = 64-bit offset from far pointer referenced in the instruction."
    vendor_syntax {
      mnemonic: "CALL"
      operands {
        name: "m16:64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX.W FF /3"
    instruction_group_index: 711
  }
  instructions {
    description: "Increment r/m byte by 1."
    vendor_syntax {
      mnemonic: "INC"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "FE /0"
    instruction_group_index: 712
  }
  instructions {
    description: "Increment r/m byte by 1."
    vendor_syntax {
      mnemonic: "INC"
      operands {
        name: "r/m8"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX + FE /0"
    instruction_group_index: 712
  }
  instructions {
    description: "Increment r/m word by 1."
    vendor_syntax {
      mnemonic: "INC"
      operands {
        name: "r/m16"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "FF /0"
    instruction_group_index: 712
  }
  instructions {
    description: "Increment r/m doubleword by 1."
    vendor_syntax {
      mnemonic: "INC"
      operands {
        name: "r/m32"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    legacy_instruction: true
    encoding_scheme: "M"
    raw_encoding_specification: "FF /0"
    instruction_group_index: 712
  }
  instructions {
    description: "Increment r/m quadword by 1."
    vendor_syntax {
      mnemonic: "INC"
      operands {
        name: "r/m64"
        encoding: MODRM_RM_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    available_in_64_bit: true
    encoding_scheme: "M"
    raw_encoding_specification: "REX.W + FF /0"
    instruction_group_index: 712
  }
  instructions {
    description: "Increment word register by 1."
    vendor_syntax {
      mnemonic: "INC"
      operands {
        name: "r16"
        encoding: OPCODE_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    legacy_instruction: true
    encoding_scheme: "O"
    raw_encoding_specification: "40+ rw"
    instruction_group_index: 712
  }
  instructions {
    description: "Increment doubleword register by 1."
    vendor_syntax {
      mnemonic: "INC"
      operands {
        name: "r32"
        encoding: OPCODE_ENCODING
        usage: USAGE_READ_WRITE
      }
    }
    legacy_instruction: true
    encoding_scheme: "O"
    raw_encoding_specification: "40+ rd"
    instruction_group_index: 712
  }
  instruction_groups {
    name: "SHA1NEXTE"
    short_description: "Calculate SHA1 State Variable E after Four Rounds"
  }
  instruction_groups {
    name: "VINSERTI128/VINSERTI32x4/VINSERTI64x2/VINSERTI32x8/VINSERTI64x4"
    short_description: "Insert Packed Integer Values"
  }
  instruction_groups {
    name: "VPERMPS"
    short_description: "Permute Single-Precision Floating-Point Elements"
  }
  instruction_groups {
    name: "VRNDSCALEPS"
    short_description: "Round Packed Float32 Values To Include A Given Number Of Fraction Bits"
  }
  instruction_groups {
    name: "PUNPCKLBW/PUNPCKLWD/PUNPCKLDQ/PUNPCKLQDQ"
    short_description: "Unpack Low Data"
    description: "Unpacks and interleaves the low-order data elements (bytes, words, doublewords, and quadwords) of the destination operand (first operand) and source operand (second operand) into the destination operand. (Figure 4-22\nshows the unpack operation for bytes in 64-bit operands.). The high-order data elements are ignored.\nSRC\tY7\tY6\tY5\tY4\tY3\tY2\tY1\tY0\tX7\tX6\tX5\tX4\tX3\tX2\tX1\tX0\tDEST\nDEST\tY3\tX3\tY2\tX2\tY1\tX1\tY0\tX0\nFigure 4-22.  PUNPCKLBW Instruction Operation Using 64-bit Operands\n255\t31\t0\t255\t31\t0\nSRC\tY7\tY6\tY5\tY4\tY3\tY2\tY1\tY0\tX7\tX6\tX5\tX4\tX3\tX2\tX1\tX0\n255\t0\nDEST\tY5\tX5\tY4\tX4\tY1\tX1\tY0\tX0\nFigure 4-23.  256-bit VPUNPCKLDQ Instruction Operation\nWhen the source data comes from a 128-bit memory operand, an implementation may fetch only the appropriate 64 bits; however, alignment to a 16-byte boundary and normal segment checking will still be enforced.\nThe (V)PUNPCKLBW instruction interleaves the low-order bytes of the source and destination operands, the (V)PUNPCKLWD instruction interleaves the low-order words of the source and destination operands, the (V)PUNPCKLDQ instruction interleaves the low-order doubleword (or doublewords) of the source and destination operands, and the (V)PUNPCKLQDQ instruction interleaves the low-order quadwords of the source and destination operands.\nThese instructions can be used to convert bytes to words, words to doublewords, doublewords to quadwords, and quadwords to double quadwords, respectively, by placing all 0s in the source operand. Here, if the source operand contains all 0s, the result (stored in the destination operand) contains zero extensions of the high-order data elements from the original value in the destination operand. For example, with the (V)PUNPCKLBW instruction the high-order bytes are zero extended (that is, unpacked into unsigned word integers), and with the (V)PUNPCKLWD instruction, the high-order words are zero extended (unpacked into unsigned doubleword integers).\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE versions 64-bit operand: The source operand can be an MMX technology register or a 32-bit memory location. The destination operand is an MMX technology register.\n128-bit Legacy SSE versions: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded versions: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded version: The second source operand is an YMM register or an 256-bit memory location. The first source operand and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.\nEVEX encoded VPUNPCKLDQ/QDQ: The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1.\nEVEX encoded VPUNPCKLWD/BW: The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "VCVTPS2UQQ"
    short_description: "Convert Packed Single Precision Floating-Point Values to Packed Unsigned Quadword Integer Values"
  }
  instruction_groups {
    name: "MOVSHDUP"
    short_description: "Replicate Single FP Values"
  }
  instruction_groups {
    name: "VFNMADD132SD/VFNMADD213SD/VFNMADD231SD"
    short_description: "Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "FYL2X"
    short_description: "Compute y * log2x"
    description: "Computes (ST(1) \342\210\227 log2 (ST(0))), stores the result in register ST(1), and pops the FPU register stack. The source operand in ST(0) must be a non-zero positive number.\nThe following table shows the results obtained when taking the log of various classes of numbers, assuming that neither overflow nor underflow occurs.\nTable 3-48.  FYL2X Results\nST(0)\n\342\210\222 \342\210\236\t\342\210\222 F\t\302\2610\t+0<+F<+1\t+ 1\t+ F > + 1\t+ \342\210\236\tNaN\n\342\210\222 \342\210\236\t*\t*\t+ \342\210\236\t+ \342\210\236\t*\t\342\210\222 \342\210\236\t\342\210\222 \342\210\236\tNaN\nST(1)\t\342\210\222 F\t*\t*\t**\t+ F\t\342\210\222 0\t\342\210\222 F\t\342\210\222 \342\210\236\tNaN\n\342\210\222 0\t*\t*\t*\t+ 0\t\342\210\222 0\t\342\210\222 0\t*\tNaN\n+ 0\t*\t*\t*\t\342\210\222 0\t+ 0\t+ 0\t*\tNaN\n+ F\t*\t*\t**\t\342\210\222 F\t+ 0\t+ F\t+ \342\210\236\tNaN\n+ \342\210\236\t*\t*\t\342\210\222 \342\210\236\t\342\210\222 \342\210\236\t*\t+ \342\210\236\t+ \342\210\236\tNaN\nNaN\tNaN\tNaN\tNaN\tNaN\tNaN\tNaN\tNaN\tNaN\nNOTES:\nF\tMeans finite floating-point value.\n* Indicates floating-point invalid-operation (#IA) exception.\n**Indicates floating-point zero-divide (#Z) exception.\nIf the divide-by-zero exception is masked and register ST(0) contains \302\2610, the instruction returns \342\210\236 with a sign that is the opposite of the sign of the source operand in register ST(1).\nThe FYL2X instruction is designed with a built-in multiplication to optimize the calculation of logarithms with an arbitrary positive base (b):\nlogbx := (log2b)-1 \342\210\227 log2x This instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C1\tSet to 0 if stack underflow occurred.\nSet if result was rounded up; cleared otherwise.\nC0, C2, C3\tUndefined."
    }
  }
  instruction_groups {
    name: "VRCP28PS"
    short_description: "Approximation to the Reciprocal of Packed Single-Precision Floating-Point Values with Less Than 2^-28 Relative Error"
  }
  instruction_groups {
    name: "KADDW/KADDB/KADDQ/KADDD"
    short_description: "ADD Two Masks"
    description: "Adds the vector mask k2 and the vector mask k3, and writes the result into vector mask k1."
  }
  instruction_groups {
    name: "PMAXUB/PMAXUW"
    short_description: "Maximum of Packed Unsigned Integers"
  }
  instruction_groups {
    name: "XSAVEC"
    short_description: "Save Processor Extended States with Compaction"
    description: "Performs a full or partial save of processor state components to the XSAVE area located at the memory address specified by the destination operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components saved correspond to the bits set in the requested-feature bitmap (RFBM), which is the logical-AND of EDX:EAX and XCR0.\nThe format of the XSAVE area is detailed in Section 13.4, \342\200\234XSAVE Area,\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1. Like FXRSTOR and FXSAVE, the memory format used for x87 state depends on a REX.W prefix; see Section 13.5.1, \342\200\234x87 State\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1.\nSection 13.10, \342\200\234Operation of XSAVEC,\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1 provides a detailed description of the operation of the XSAVEC instruction. The following items provide a highlevel outline:\n\342\200\242\tExecution of XSAVEC is similar to that of XSAVE. XSAVEC differs from XSAVE in that it uses compaction and that it may use the init optimization.\n\342\200\242\t= 1.1 (XINUSE is a bitmap by which the processor tracks the status of various state components. See Section 13.6, \342\200\234Processor Tracking of XSAVEManaged State\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1.) XSAVEC saves state component i if and only if RFBM[i] = 1 and XINUSE[i]\n\342\200\242\tXSAVEC does not modify bytes 511:464 of the legacy region of the XSAVE area (see Section 13.4.1, \342\200\234Legacy Region of an XSAVE Area\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1).\n\342\200\242\tXSAVEC writes the logical AND of RFBM and XINUSE to the XSTATE_BV field of the XSAVE header.2,3 (See Section 13.4.2, \342\200\234XSAVE Header\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1.) XSAVEC sets bit63 of the XCOMP_BV field and sets bits\n62:0 of that field to RFBM[62:0]. XSAVEC does not write to any parts of the XSAVE header other than the XSTATE_BV and XCOMP_BV fields.\n\342\200\242\tXSAVEC always uses the compacted format of the extended region of the XSAVE area (see Section 13.4.3, \342\200\234Extended Region of an XSAVE Area\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1).\nUse of a destination operand not aligned to 64-byte boundary (in either 64-bit or 32-bit modes) results in a general-protection (#GP) exception. In 64-bit mode, the upper 32 bits of RDX and RAX are ignored.\n1.\tThere is an exception for state component 1 (SSE). MXCSR is part of SSE state, but XINUSE[1] may be 0 even if MXCSR does not have its initial value of 1F80H. In this case, XSAVEC saves SSE state as long as RFBM[1]= 1.\n2.\tUnlike XSAVE and XSAVEOPT, XSAVEC clears bits in the XSTATE_BV field that correspond to bits that are clear in RFBM.\n3.\tThere is an exception for state component 1 (SSE). MXCSR is part of SSE state, but XINUSE[1] may be 0 even if MXCSR does not have its initial value of 1F80H. In this case, XSAVEC sets XSTATE_BV[1] to 1 as long as RFBM[1]= 1."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "PSHUFLW"
    short_description: "Shuffle Packed Low Words"
    description: "Copies words from the low quadword of a 128-bit lane of the source operand and inserts them in the low quadword of the destination operand at word locations (of the respective lane) selected with the im\nmediate operand. The 256-bit operation is similar to the in-lane operation used by the 256-bit VPSHUFD instruction, which is illustrated in Figure 4-16. For 128-bit operation, only the low 128-bit lane is operative. Each 2-bit field in the im\nmediate operand selects the contents of one word location in the low quadword of the destination operand. The binary encodings of the im\nmediate operand fields select words (0, 1, 2 or 3) from the low quadword of the source operand to be copied to the destination operand. The high quadword of the source operand is copied to the high quadword of the destination operand, for each 128-bit lane.\nNote that this instruction permits a word in the low quadword of the source operand to be copied to more than one word location in the low quadword of the destination operand.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n128-bit Legacy SSE version: The destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded version: The destination operand is an YMM register. The source operand can be an YMM register or a 256-bit memory location.\nEVEX encoded version: The destination operand is a ZMM/YMM/XMM registers. The source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination is updated according to the writemask.\nNote: In VEX encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
    flags_affected {
      content: "None.\nSIMD Floating-Point Exceptions\nNone."
    }
  }
  instruction_groups {
    name: "SUBPD"
    short_description: "Subtract Packed Double-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "INSERTPS"
    short_description: "Insert Scalar Single-Precision Floating-Point Value"
    description: "(register source form) Copy a single-precision scalar floating-point element into a 128-bit vector register. The im\nmediate operand has three fields, where the ZMask bits specify which elements of the destination will be set to zero, the Count_D bits specify which element of the destination will be overwritten with the scalar value, and for vector register sources the Count_S bits specify which element of the source will be copied. When the scalar source is a memory operand the Count_S bits are ignored.\n(memory source form) Load a floating-point element from a 32-bit memory location and destination operand it into the first source at the location indicated by the Count_D bits of the im mediate operand. Store in the destination and zero out destination\nelements based on the ZMask bits of the im mediate operand.\n128-bit Legacy SSE version: The first source register is an XMM register. The second source operand is either an XMM register or a 32-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified.\nVEX.128 and EVEX encoded version: The destination and first source register is an XMM register. The second source operand is either an XMM register or a 32-bit memory location. The upper bits (MAXVL-1:128) of the corresponding register destination are zeroed.\nIf VINSERTPS is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception."
  }
  instruction_groups {
    name: "FPATAN"
    short_description: "Partial Arctangent"
    description: "Computes the arctangent of the source operand in register ST(1) divided by the source operand in register ST(0), stores the result in ST(1), and pops the FPU register stack. The result in register ST(0) has the same sign as the source operand ST(1) and a magnitude less than +\317\200.\nThe FPATAN instruction returns the angle between the X axis and the line from the origin to the point (X,Y), where Y (the ordinate) is ST(1) and X (the abscissa) is ST(0). The angle depends on the sign of X and Y independently, not just on the sign of the ratio Y/X. This is because a point (\342\210\222X,Y) is in the second quadrant, resulting in an angle between \317\200/2 and \317\200, while a point (X,\342\210\222Y) is in the fourth quadrant, resulting in an angle between 0 and \342\210\222\317\200/2. A point (\342\210\222X,\342\210\222Y) is in the third quadrant, giving an angle between \342\210\222\317\200/2 and \342\210\222\317\200.\nThe following table shows the results obtained when computing the arctangent of various classes of numbers, assuming that underflow does not occur.\nTable 3-30.  FPATAN Results\nST(0)\n\342\210\222 \342\210\236\t\342\210\222 F\t\342\210\222 0\t+ 0\t+ F\t+ \342\210\236\tNaN\n\342\210\222 \342\210\236\t\342\210\222 3\317\200/4*\t\342\210\222 \317\200/2\t\342\210\222 \317\200/2\t\342\210\222 \317\200/2\t\342\210\222 \317\200/2\t\342\210\222 \317\200/4*\tNaN\nST(1)\t\342\210\222 F\t-p\t\342\210\222\317\200 to \342\210\222\317\200/2\t\342\210\222\317\200/2\t\342\210\222\317\200/2\t\342\210\222\317\200/2 to \342\210\2220\t- 0\tNaN\n\342\210\222 0\t-p\t-p\t-p*\t\342\210\222 0*\t\342\210\222 0\t\342\210\222 0\tNaN\n+ 0\t+p\t+ p\t+ \317\200*\t+ 0*\t+ 0\t+ 0\tNaN\n+ F\t+p\t+\317\200 to +\317\200/2\t+ \317\200/2\t+\317\200/2\t+\317\200/2 to +0\t+ 0\tNaN\n+ \342\210\236\t+3\317\200/4*\t+\317\200/2\t+\317\200/2\t+\317\200/2\t+ \317\200/2\t+ \317\200/4*\tNaN\nNaN\tNaN\tNaN\tNaN\tNaN\tNaN\tNaN\tNaN\nNOTES:\nF\tMeans finite floating-point value.\n*\tTable 8-10 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1, specifies that the ratios 0/0 and \342\210\236/\342\210\236 generate the floating-point invalid arithmetic-operation exception and, if this exception is masked, the floating-point QNaN indefinite value is returned. With the FPATAN instruction, the 0/0 or \342\210\236/\342\210\236 value is actually not calculated using division. Instead, the arctangent of the two variables is derived from a standard mathematical formulation that is generalized to allow complex numbers as arguments. In this complex variable formulation, arctangent(0,0) etc. has well defined values. These values are needed to develop a library to compute transcendental functions with complex arguments, based on the FPU functions that only allow floating-point values as arguments.\nThere is no restriction on the range of source operands that FPATAN can accept.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C1\tSet to 0 if stack underflow occurred.\nSet if result was rounded up; cleared otherwise.\nC0, C2, C3\tUndefined."
    }
  }
  instruction_groups {
    name: "MOVNTDQA"
    short_description: "Load Double Quadword Non-Temporal Aligned Hint"
  }
  instruction_groups {
    name: "MFENCE"
    short_description: "Memory Fence"
    description: "Performs a serializing operation on all load-from-memory and store-to-memory instructions that were issued prior the MFENCE instruction. This serializing operation guarantees that every load and store instruction that precedes the MFENCE instruction in program order becomes globally visible before any load or store instruction that follows the MFENCE instruction.1 The MFENCE instruction is ordered with respect to all load and store instructions, other MFENCE instructions, any LFENCE and SFENCE instructions, and any serializing instructions (such as the CPUID instruction). MFENCE does not serialize the instruction stream.\nWeakly ordered memory types can be used to achieve higher processor performance through such techniques as out-of-order issue, speculative reads, write-combining, and write-collapsing. The degree to which a consumer of data recognizes or knows that the data is weakly ordered varies among applications and may be unknown to the producer of this data. The MFENCE instruction provides a performance-efficient way of ensuring load and store ordering between routines that produce weakly-ordered results and routines that consume that data.\nProcessors are free to fetch and cache data speculatively from regions of system memory that use the WB, WC, and WT memory types. This speculative fetching can occur at any time and is not tied to instruction execution. Thus, it is not ordered with respect to executions of the MFENCE instruction; data can be brought into the caches speculatively just before, during, or after the execution of an MFENCE instruction.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode.\nSpecification of the instruction\'s opcode above indicates a ModR/M byte of F0. For this instruction, the processor ignores the r/m field of the ModR/M byte. Thus, MFENCE is encoded by any opcode of the form 0F AE Fx, where x is in the range 0-7."
  }
  instruction_groups {
    name: "SHA256RNDS2"
    short_description: "Perform Two Rounds of SHA256 Operation"
  }
  instruction_groups {
    name: "VZEROUPPER"
    short_description: "Zero Upper Bits of YMM and ZMM Registers"
    description: "In 64-bit mode, the instruction zeroes the bits in positions 128 and higher in YMM0-YMM15 and ZMM0-ZMM15.\nOutside 64-bit mode, it zeroes those bits only in YMM0-YMM7 and ZMM0-ZMM7. VZEROUPPER does not modify the lower 128 bits of these registers and it does not modify ZMM16-ZMM31.\nThis instruction is recom\nmended when transitioning between AVX and legacy SSE code; it will eliminate performance penalties caused by false dependencies.\nNote: VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD. In Compatibility and legacy 32-bit mode only the lower 8 registers are modified."
  }
  instruction_groups {
    name: "DPPD"
    short_description: "Dot Product of Packed Double Precision Floating-Point Values"
    description: "Conditionally multiplies the packed double-precision floating-point values in the destination operand (first operand) with the packed double-precision floating-point values in the source (second operand) depending on a mask extracted from bits [5:4] of the im\nmediate operand (third operand). If a condition mask bit is zero, the corresponding multiplication is replaced by a value of 0.0 in the manner described by Section 12.8.4 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1.\nThe two resulting double-precision values are sum med into an intermediate result. The intermediate result is conditionally broadcasted to the destination using a broadcast mask specified by bits [1:0] of the im mediate byte.\nIf a broadcast mask bit is \342\200\2341\342\200\235, the intermediate result is copied to the corresponding qword element in the destination operand. If a broadcast mask bit is zero, the corresponding element in the destination is set to zero.\nDPPD follows the NaN forwarding rules stated in the Software Developer\342\200\231s Manual, vol. 1, table 4.7. These rules do not cover horizontal prioritization of NaNs. Horizontal propagation of NaNs to the destination and the positioning of those NaNs in the destination is implementation dependent. NaNs on the input sources or computationally generated NaNs will have at least one NaN propagated to the destination.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.\nVEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.\nIf VDPPD is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception."
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "XGETBV"
    short_description: "Get Value of Extended Control Register"
    description: "Reads the contents of the extended control register (XCR) specified in the ECX register into registers EDX:EAX. (On processors that support the Intel64 architecture, the high-order 32 bits of RCX are ignored.) The EDX register is loaded with the high-order 32 bits of the XCR and the EAX register is loaded with the low-order 32 bits. (On processors that support the Intel64 architecture, the high-order 32 bits of each of RAX and RDX are cleared.) If fewer than 64 bits are implemented in the XCR being read, the values returned to EDX:EAX in unimplemented bit locations are undefined.\nXCR0 is supported on any processor that supports the XGETBV instruction. If CPUID.(EAX=0DH,ECX=1):EAX.XG1[bit2] = 1, executing XGETBV with ECX = 1 returns in EDX:EAX the logicalAND of XCR0 and the current value of the XINUSE state-component bitmap. This allows software to discover the state of the init optimization used by XSAVEOPT and XSAVES. See Chapter 13, \342\200\234Managing State Using the XSAVE Feature Set\342\200\232\342\200\235 in Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1.\nUse of any other value for ECX results in a general-protection (#GP) exception."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "VCOMPRESSPD"
    short_description: "Store Sparse Packed Double-Precision Floating-Point Values into Dense Memory"
  }
  instruction_groups {
    name: "BLENDVPS"
    short_description: "Variable Blend Packed Single Precision Floating-Point Values"
    description: "Conditionally copy each dword data element of single-precision floating-point value from the second source operand and the first source operand depending on mask bits defined in the mask register operand. The mask bits are the most significant bit in each dword element of the mask register.\nEach quadword element of the destination operand is copied from:\n\342\200\242\tthe corresponding dword element in the second source operand, if a mask bit is \342\200\2341\342\200\235; or\n\342\200\242 the corresponding dword element in the first source operand, if a mask bit is \342\200\2340\342\200\235 The register assignment of the implicit mask operand for BLENDVPS is defined to be the architectural register XMM0.\n128-bit Legacy SSE version: The first source operand and the destination operand is the same. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged. The mask register operand is implicitly defined to be the architectural register XMM0. An attempt to execute BLENDVPS with a VEX prefix will cause #UD.\nVEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second source operand is an XMM register or 128-bit memory location. The mask operand is the third source register, and encoded in bits[7:4] of the im mediate byte(im m8). The bits[3:0] of im m8 are ignored. In 32-bit mode, im m8[7] is ignored. The upper bits (MAXVL-1:128) of the corresponding YMM register (destination register) are zeroed.\nVEX.W must be 0, otherwise, the instruction will #UD.\nVEX.256 encoded version: The first source operand and destination operand are YMM registers. The second source operand can be a YMM register or a 256-bit memory location. The mask operand is the third source register, and encoded in bits[7:4] of the im mediate byte(im m8). The bits[3:0] of im m8 are ignored. In 32-bit mode, im m8[7] is\nignored. VEX.W must be 0, otherwise, the instruction will #UD.\nVBLENDVPS permits the mask to be any XMM or YMM register. In contrast, BLENDVPS treats XMM0 implicitly as the mask and do not support non-destructive destination operation."
  }
  instruction_groups {
    name: "VRSQRT28PS"
    short_description: "Approximation to the Reciprocal Square Root of Packed Single-Precision Floating-Point Values with Less Than 2^-28"
  }
  instruction_groups {
    name: "VRNDSCALESD"
    short_description: "Round Scalar Float64 Value To Include A Given Number Of Fraction Bits"
  }
  instruction_groups {
    name: "ERESUME"
  }
  instruction_groups {
    name: "ENDBR32"
    short_description: "Terminate an Indirect Branch in 32-bit and Compatibility Mode"
    description: "Terminate an indirect branch in 32 bit and compatibility mode."
    flags_affected {
      content: "None.\nExceptions\nNone."
    }
  }
  instruction_groups {
    name: "VALIGND/VALIGNQ"
    short_description: "Align Doubleword/Quadword Vectors"
  }
  instruction_groups {
    name: "POP"
    short_description: "Pop a Value from the Stack"
    description: "Loads the value from the top of the stack to the location specified with the destination operand (or explicit opcode) and then increments the stack pointer. The destination operand can be a general-purpose register, memory location, or segment register.\nAddress and operand sizes are determined and used as follows:\n\342\200\242\tAddress size. The D flag in the current code-segment descriptor determines the default address size; it may be overridden by an instruction prefix (67H).\nThe address size is used only when writing to a destination operand in memory.\n\342\200\242\tOperand size. The D flag in the current code-segment descriptor determines the default operand size; it may be overridden by instruction prefixes (66H or REX.W).\nThe operand size (16, 32, or 64 bits) determines the amount by which the stack pointer is incremented (2, 4 or 8).\n\342\200\242\tStack-address size. Outside of 64-bit mode, the B flag in the current stack-segment descriptor determines the size of the stack pointer (16 or 32 bits); in 64-bit mode, the size of the stack pointer is always 64 bits.\nThe stack-address size determines the width of the stack pointer when reading from the stack in memory and when incrementing the stack pointer. (As stated above, the amount by which the stack pointer is incremented is determined by the operand size.)\nIf the destination operand is one of the segment registers DS, ES, FS, GS, or SS, the value loaded into the register must be a valid segment selector. In protected mode, popping a segment selector into a segment register automatically causes the descriptor information associated with that segment selector to be loaded into the hidden (shadow) part of the segment register and causes the selector and the descriptor information to be validated (see the \342\200\234Operation\342\200\235 section below).\nA NULL value (0000-0003) may be popped into the DS, ES, FS, or GS register without causing a general protection fault. However, any subsequent attempt to reference a segment whose corresponding segment register is loaded with a NULL value causes a general protection exception (#GP). In this situation, no memory reference occurs and the saved value of the segment register is NULL.\nThe POP instruction cannot pop a value into the CS register. To load the CS register from the stack, use the RET instruction.\nIf the ESP register is used as a base register for addressing a destination operand in memory, the POP instruction computes the effective address of the operand after it increments the ESP register. For the case of a 16-bit stack where ESP wraps to 0H as a result of the POP instruction, the resulting location of the memory write is processorfamily-specific.\nThe POP ESP instruction increments the stack pointer (ESP) before data at the old top of stack is written into the destination.\nLoading the SS register with a POP instruction suppresses or inhibits some debug exceptions and inhibits interrupts on the following instruction boundary. (The inhibition ends after delivery of an exception or the execution of the next instruction.) This behavior allows a stack pointer to be loaded into the ESP register with the next instruction (POP ESP) before an event can be delivered. See Section 6.8.3, \342\200\234Masking Exceptions and Interrupts When Switching Stacks,\342\200\235 in Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3A. Intel recommends that software use the LSS instruction to load the SS register and ESP together.\nIn 64-bit mode, using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). When in 64-bit mode, POPs using 32-bit operands are not encodable and POPs to DS, ES, SS are not valid. See the sum mary chart at the beginning of this section for encoding data and limits."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "VPDPWSSD"
    short_description: "Multiply and Add Signed Word Integers"
  }
  instruction_groups {
    name: "VPMOVB2M/VPMOVW2M/VPMOVD2M/VPMOVQ2M"
    short_description: "Convert a Vector Register to a Mask"
  }
  instruction_groups {
    name: "VEXTRACTF128/VEXTRACTF32x4/VEXTRACTF64x2/VEXTRACTF32x8/VEXTRACTF64x4"
    short_description: "Extract Packed Floating-Point Values"
  }
  instruction_groups {
    name: "PMINUD/PMINUQ"
    short_description: "Minimum of Packed Unsigned Integers"
  }
  instruction_groups {
    name: "KANDW/KANDB/KANDQ/KANDD"
    short_description: "Bitwise Logical AND Masks"
    description: "Performs a bitwise AND between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1."
    flags_affected {
      content: "None\nSIMD Floating-Point Exceptions\nNone"
    }
  }
  instruction_groups {
    name: "CMC"
    short_description: "Complement Carry Flag"
    description: "Complements the CF flag in the EFLAGS register. CMC operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "The CF flag contains the complement of its original value. The OF, ZF, SF, AF, and PF flags are unaffected."
    }
  }
  instruction_groups {
    name: "RDRAND"
    short_description: "Read Random Number"
    description: "Loads a hardware generated random value and store it in the destination register. The size of the random value is determined by the destination register size and operating mode. The Carry Flag indicates whether a random value is available at the time the instruction is executed. CF=1 indicates that the data in the destination is valid. Otherwise CF=0 and the data in the destination operand will be returned as zeros for the specified width. All other flags are forced to 0 in either situation. Software must check the state of CF=1 for determining if a valid random value has been returned, otherwise it is expected to loop and retry execution of RDRAND (see Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1, Section 7.3.17, \342\200\234Random Number Generator Instructions\342\200\235).\nThis instruction is available at all privilege levels.\nIn 64-bit mode, the instruction\'s default operation size is 32 bits. Using a REX prefix in the form of REX.B permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bit operands. See the sum mary chart at the beginning of this section for encoding data and limits."
    flags_affected {
      content: "The CF flag is set according to the result (see the \342\200\234Operation\342\200\235 section above). The OF, SF, ZF, AF, and PF flags are set to 0."
    }
  }
  instruction_groups {
    name: "VPCMPB/VPCMPUB"
    short_description: "Compare Packed Byte Values Into Mask"
  }
  instruction_groups {
    name: "VPMOVM2B/VPMOVM2W/VPMOVM2D/VPMOVM2Q"
    short_description: "Convert a Mask Register to a Vector Register"
  }
  instruction_groups {
    name: "VMFUNC"
    description: "This instruction allows software in VMX non-root operation to invoke a VM function, which is processor functionality enabled and configured by software in VMX root operation. The value of EAX selects the specific VM function being\ninvoked.\nThe behavior of each VM\tfunction (including any additional fault checking) is specified in Section 25.5.6,\n\342\200\234VM\tFunctions\342\200\235."
    flags_affected {
      content: "Depends on the VM\tfunction specified in EAX. See Section 25.5.6, \342\200\234VM\tFunctions\342\200\235.\nProtected Mode Exceptions (not including those defined by specific VMfunctions)\n#UD\tIf executed outside VMX non-root operation.\nIf \342\200\234enable VM functions\342\200\235 VM-execution control is 0.\nIf EAX \342\211\245 64."
    }
  }
  instruction_groups {
    name: "CVTPI2PD"
    short_description: "Convert Packed Dword Integers to Packed Double-Precision FP Values"
    description: "Converts two packed signed doubleword integers in the source operand (second operand) to two packed doubleprecision floating-point values in the destination operand (first operand).\nThe source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an XMM register. In addition, depending on the operand configuration:\n\342\200\242\tFor operands xm m, m m: the instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the CVTPI2PD instruction is executed.\n\342\200\242\tFor operands xm m, m64: the instruction does not cause a transition to MMX technology and does not take x87 FPU exceptions.\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15)."
  }
  instruction_groups {
    name: "AND"
    short_description: "Logical AND"
    description: "Performs a bitwise AND operation on the destination (first) and source (second) operands and stores the result in the destination operand location. The source operand can be an im\nmediate, a register, or a memory location; the destination operand can be a register or a memory location. (However, two memory operands cannot be used in one instruction.) Each bit of the result is set to 1 if both corresponding bits of the first and second operands are 1; otherwise, it is set to 0.\nThis instruction can be used with a LOCK prefix to allow the it to be executed atomically.\nIn 64-bit mode, the instruction\342\200\231s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the sum mary chart at the beginning of this section for encoding data and limits."
    flags_affected {
      content: "The OF and CF flags are cleared; the SF, ZF, and PF flags are set according to the result. The state of the AF flag is undefined."
    }
  }
  instruction_groups {
    name: "IN"
    short_description: "Input from Port"
    description: "Copies the value from the I/O port specified with the second operand (source operand) to the destination operand (first operand). The source operand can be a byte-im\nmediate or the DX register; the destination operand can be register AL, AX, or EAX, depending on the size of the port being accessed (8, 16, or 32 bits, respectively). Using the DX register as a source operand allows I/O port addresses from 0 to 65,535 to be accessed; using a byte im me-\ndiate allows I/O port addresses 0 to 255 to be accessed.\nWhen accessing an 8-bit I/O port, the opcode determines the port size; when accessing a 16- and 32-bit I/O port, the operand-size attribute determines the port size. At the machine code level, I/O instructions are shorter when accessing 8-bit I/O ports. Here, the upper eight bits of the port address will be 0.\nThis instruction is only useful for accessing I/O ports located in the processor\342\200\231s I/O address space. See Chapter 19, \342\200\234Input/Output,\342\200\235 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1, for more information on accessing I/O ports in the I/O address space.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "PCMPEQQ"
    short_description: "Compare Packed Qword Data for Equal"
    description: "Performs an SIMD compare for equality of the packed quadwords in the destination operand (first operand) and the source operand (second operand).  If a pair of data elements is equal, the corresponding data element in the destination is set to all 1s; otherwise, it is set to 0s.\n128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.\nEVEX encoded VPCMPEQQ: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2."
    flags_affected {
      content: "None.\nSIMD Floating-Point Exceptions\nNone."
    }
  }
  instruction_groups {
    name: "EACCEPTCOPY"
  }
  instruction_groups {
    name: "PMULLD/PMULLQ"
    short_description: "Multiply Packed Integers and Store Low Result"
  }
  instruction_groups {
    name: "VPMULTISHIFTQB"
    short_description: "Select Packed Unaligned Bytes from Quadword Sources"
  }
  instruction_groups {
    name: "ERDINFO"
  }
  instruction_groups {
    name: "FMUL/FMULP/FIMUL"
    short_description: "Multiply"
    description: "Multiplies the destination and source operands and stores the product in the destination location. The destination operand is always an FPU data register; the source operand can be an FPU data register or a memory location.\nSource operands in memory can be in single-precision or double-precision floating-point format or in word or doubleword integer format.\nThe no-operand version of the instruction multiplies the contents of the ST(1) register by the contents of the ST(0) register and stores the product in the ST(1) register. The one-operand version multiplies the contents of the ST(0) register by the contents of a memory location (either a floating point or an integer value) and stores the product in the ST(0) register. The two-operand version, multiplies the contents of the ST(0) register by the contents of the ST(i) register, or vice versa, with the result being stored in the register specified with the first operand (the destination operand).\nThe FMULP instructions perform the additional operation of popping the FPU register stack after storing the product. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point multiply instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FMUL rather than FMULP.\nThe FIMUL instructions convert an integer source operand to double extendedprecision floating-point format before performing the multiplication.\nThe sign of the result is always the exclusive-OR of the source signs, even if one or more of the values being multiplied is 0 or \342\210\236. When the source operand is an integer 0, it is treated as a +0.\nThe following table shows the results obtained when multiplying various classes of numbers, assuming that neither overflow nor underflow occurs.\nTable 3-29.  FMUL/FMULP/FIMUL Results\nDEST\n\342\210\222 \342\210\236\t\342\210\222 F\t\342\210\222 0\t+ 0\t+ F\t+ \342\210\236\tNaN\n\342\210\222 \342\210\236\t+ \342\210\236\t+ \342\210\236\t*\t*\t\342\210\222 \342\210\236\t\342\210\222 \342\210\236\tNaN\n\342\210\222 F\t+ \342\210\236\t+ F\t+ 0\t\342\210\222 0\t\342\210\222 F\t\342\210\222 \342\210\236\tNaN\n\342\210\222 I\t+ \342\210\236\t+ F\t+ 0\t\342\210\222 0\t\342\210\222 F\t\342\210\222 \342\210\236\tNaN\nSRC\t\342\210\222 0\t*\t+ 0\t+ 0\t\342\210\222 0\t\342\210\222 0\t*\tNaN\n+ 0\t*\t\342\210\222 0\t\342\210\222 0\t+ 0\t+ 0\t*\tNaN\n+ I\t\342\210\222 \342\210\236\t\342\210\222 F\t\342\210\222 0\t+ 0\t+ F\t+ \342\210\236\tNaN\n+ F\t\342\210\222 \342\210\236\t\342\210\222 F\t\342\210\222 0\t+ 0\t+ F\t+ \342\210\236\tNaN\n+ \342\210\236\t\342\210\222 \342\210\236\t\342\210\222 \342\210\236\t*\t*\t+ \342\210\236\t+ \342\210\236\tNaN\nNaN\tNaN\tNaN\tNaN\tNaN\tNaN\tNaN\tNaN\nNOTES:\nF\tMeans finite floating-point value.\nI\tMeans Integer.\n*\tIndicates invalid-arithmetic-operand (#IA) exception.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C1\tSet to 0 if stack underflow occurred.\nSet if result was rounded up; cleared otherwise.\nC0, C2, C3\tUndefined."
    }
  }
  instruction_groups {
    name: "ROUNDSD"
    short_description: "Round Scalar Double Precision Floating-Point Values"
    description: "Round the DP FP value in the lower qword of the source operand (second operand) using the rounding mode specified in the im\nmediate operand (third operand) and place the result in the destination operand (first operand). The rounding process rounds a double-precision floating-point input to an integer value and returns the integer result as a double precision floating-point value in the lowest position. The upper double precision floating-point value in the destination is retained.\nThe im mediate operand specifies control fields for the rounding operation, three bit fields are defined and shown in\nFigure 4-24. Bit 3 of the im mediate byte controls processor behavior for a precision exception, bit 2 selects the source of rounding mode control. Bits 1:0 specify a non-sticky rounding-mode value (Table 4-17 lists the encoded values for rounding-mode field).\nThe Precision Floating-Point Exception is signaled according to the im mediate operand. If any source operand is an SNaN then it will be converted to a QNaN. If DAZ is set to \342\200\2301 then denormals will be converted to zero before rounding.\n128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL- 1:64) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: Bits (MAXVL-1:128) of the destination YMM register are zeroed."
  }
  instruction_groups {
    name: "VDBPSADBW"
    short_description: "Double Block Packed Sum-Absolute-Differences (SAD) on Unsigned Bytes"
  }
  instruction_groups {
    name: "EAUG"
  }
  instruction_groups {
    name: "FDIVR/FDIVRP/FIDIVR"
    short_description: "Reverse Divide"
    description: "Divides the source operand by the destination operand and stores the result in the destination location. The destination operand (divisor) is always in an FPU register; the source operand (dividend) can be a register or a memory location. Source operands in memory can be in single-precision or double-precision floating-point format, word or doubleword integer format.\nThese instructions perform the reverse operations of the FDIV, FDIVP, and FIDIV instructions. They are provided to support more efficient coding.\nThe no-operand version of the instruction divides the contents of the ST(0) register by the contents of the ST(1) register. The one-operand version divides the contents of a memory location (either a floating-point or an integer value) by the contents of the ST(0) register. The two-operand version, divides the contents of the ST(i) register by the contents of the ST(0) register or vice versa.\nThe FDIVRP instructions perform the additional operation of popping the FPU register stack after storing the result.\nTo pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point divide instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FDIVR rather than FDIVRP.\nThe FIDIVR instructions convert an integer source operand to double extended-precision floating-point format before performing the division.\nIf an unmasked divide-by-zero exception (#Z) is generated, no result is stored; if the exception is masked, an \342\210\236 of the appropriate sign is stored in the destination operand.\nThe following table shows the results obtained when dividing various classes of numbers, assuming that neither overflow nor underflow occurs.\nTable 3-25.  FDIVR/FDIVRP/FIDIVR Results\nDEST\n\342\210\222 \342\210\236\t\342\210\222 F\t\342\210\222 0\t+ 0\t+ F\t+ \342\210\236\tNaN\n\342\210\222 \342\210\236\t*\t+ \342\210\236\t+ \342\210\236\t\342\210\222 \342\210\236\t\342\210\222 \342\210\236\t*\tNaN\nSRC\t\342\210\222 F\t+ 0\t+ F\t**\t**\t\342\210\222 F\t\342\210\222 0\tNaN\n\342\210\222 I\t+ 0\t+ F\t**\t**\t\342\210\222 F\t\342\210\222 0\tNaN\n\342\210\222 0\t+ 0\t+ 0\t*\t*\t\342\210\222 0\t\342\210\222 0\tNaN\n+ 0\t\342\210\222 0\t\342\210\222 0\t*\t*\t+ 0\t+ 0\tNaN\n+ I\t\342\210\222 0\t\342\210\222 F\t**\t**\t+ F\t+ 0\tNaN\n+ F\t\342\210\222 0\t\342\210\222 F\t**\t**\t+ F\t+ 0\tNaN\n+ \342\210\236\t*\t\342\210\222 \342\210\236\t\342\210\222 \342\210\236\t+ \342\210\236\t+ \342\210\236\t*\tNaN\nNaN\tNaN\tNaN\tNaN\tNaN\tNaN\tNaN\tNaN\nNOTES:\nF\tMeans finite floating-point value.\nI\tMeans integer.\n* Indicates floating-point invalid-arithmetic-operand (#IA) exception.\n** Indicates floating-point zero-divide (#Z) exception.\nWhen the source operand is an integer 0, it is treated as a +0. This instruction\342\200\231s operation is the same in non-64- bit modes and 64-bit mode."
    flags_affected {
      content: "C1\tSet to 0 if stack underflow occurred.\nSet if result was rounded up; cleared otherwise.\nC0, C2, C3\tUndefined."
    }
  }
  instruction_groups {
    name: "VEXP2PD"
    short_description: "Approximation to the Exponential 2^x of Packed Double-Precision Floating-Point Values with Less Than 2^-23 Relative Er-"
  }
  instruction_groups {
    name: "KANDNW/KANDNB/KANDNQ/KANDND"
    short_description: "Bitwise Logical AND NOT Masks"
    description: "Performs a bitwise AND NOT between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1."
    flags_affected {
      content: "None\nSIMD Floating-Point Exceptions\nNone"
    }
  }
  instruction_groups {
    name: "ADC"
    short_description: "Add with Carry"
    description: "Adds the destination operand (first operand), the source operand (second operand), and the carry (CF) flag and stores the result in the destination operand. The destination operand can be a register or a memory location; the source operand can be an im\nmediate, a register, or a memory location. (However, two memory operands cannot be used in one instruction.) The state of the CF flag represents a carry from a previous addition. When an im mediate\nvalue is used as an operand, it is sign-extended to the length of the destination operand format.\nThe ADC instruction does not distinguish between signed or unsigned operands. Instead, the processor evaluates the result for both data types and sets the OF and CF flags to indicate a carry in the signed or unsigned result, respectively. The SF flag indicates the sign of the signed result.\nThe ADC instruction is usually executed as part of a multibyte or multiword addition in which an ADD instruction is followed by an ADC instruction.\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.\nIn 64-bit mode, the instruction\342\200\231s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the sum mary chart at the beginning of this section for encoding data and limits."
    flags_affected {
      content: "The OF, SF, ZF, AF, CF, and PF flags are set according to the result."
    }
  }
  instruction_groups {
    name: "VCVTPS2PH"
    short_description: "Convert Single-Precision FP value to 16-bit FP value"
  }
  instruction_groups {
    name: "BNDCU/BNDCN"
    short_description: "Check Upper Bound"
    description: "Compare the address in the second operand with the upper bound in bnd. The second operand can be either a register or a memory operand. If the address is higher than the upper bound in bnd.UB, it will set BNDSTATUS to 01H and signal a #BR exception.\nBNDCU perform 1\342\200\231s complement operation on the upper bound of bnd first before proceeding with address comparison. BNDCN perform address comparison directly using the upper bound in bnd that is already reverted out of 1\342\200\231s complement form.\nThis instruction does not cause any memory access, and does not read or write any flags.\nEffective address computation of m32/64 has identical behavior to LEA"
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "NEG"
    short_description: "Two\'s Complement Negation"
    description: "Replaces the value of operand (the destination operand) with its two\'s complement. (This operation is equivalent to subtracting the operand from 0.) The destination operand is located in a general-purpose register or a memory location.\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.\nIn 64-bit mode, the instruction\342\200\231s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the sum mary chart at the beginning of this section for encoding data and limits."
    flags_affected {
      content: "The CF flag set to 0 if the source operand is 0; otherwise it is set to 1. The OF, SF, ZF, AF, and PF flags are set according to the result."
    }
  }
  instruction_groups {
    name: "MOVDIR64B"
    short_description: "Move 64 Bytes as Direct Store"
    description: "Moves 64-bytes as direct-store with 64-byte write atomicity from source memory address to destination memory address. The source operand is a normal memory operand. The destination operand is a memory location specified in a general-purpose register. The register content is interpreted as an offset into ES segment without any segment override. In 64-bit mode, the register operand width is 64-bits (32-bits with 67H prefix). Outside of 64-bit mode, the register width is 32-bits when CS.D=1 (16-bits with 67H prefix), and 16-bits when CS.D=0 (32-bits with 67H prefix). MOVDIR64B requires the destination address to be 64-byte aligned. No alignment restriction is enforced for source operand.\nMOVDIR64B first reads 64-bytes from the source memory address. It then performs a 64-byte direct-store operation to the destination address. The load operation follows normal read ordering based on source address memorytype. The direct-store is implemented by using the write combining (WC) memory type protocol for writing data.\nUsing this protocol, the processor does not write the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. If the destination address is cached, the line is writtenback (if modified) and invalidated from the cache, before the direct-store.\nUnlike stores with non-temporal hint which allow UC/WP memory-type for destination to override the non-temporal hint, direct-stores always follow WC memory type protocol irrespective of destination address memory type (including UC/WP types). Unlike WC stores and stores with non-temporal hint, direct-stores are eligible for im\nmediate eviction from the write-combining buffer, and thus not combined with younger stores (including direct-stores) to the same address. Older WC and non-temporal stores held in the write-combing buffer may be combined with younger direct stores to the same address. Direct stores are weakly ordered relative to other stores. Software that desires stronger ordering should use a fencing instruction (MFENCE or SFENCE) before or after a direct store to enforce the ordering desired.\nThere is no atomicity guarantee provided for the 64-byte load operation from source address, and processor implementations may use multiple load operations to read the 64-bytes. The 64-byte direct-store issued by MOVDIR64B guarantees 64-byte write-completion atomicity. This means that the data arrives at the destination in a single undivided 64-byte write transaction.\nAvailability of the MOVDIR64B instruction is indicated by the presence of the CPUID feature flag MOVDIR64B (bit 28 of the ECX register in leaf 07H, see \342\200\234CPUID-CPU Identification\342\200\235 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 2A)."
  }
  instruction_groups {
    name: "VZEROALL"
    short_description: "Zero XMM, YMM and ZMM Registers"
    description: "In 64-bit mode, the instruction zeroes XMM0-XMM15, YMM0-YMM15, and ZMM0-ZMM15. Outside 64-bit mode, it zeroes only XMM0-XMM7, YMM0-YMM7, and ZMM0-ZMM7. VZEROALL does not modify ZMM16-ZMM31.\nNote: VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD. In Compatibility and legacy 32-bit mode only the lower 8 registers are modified."
  }
  instruction_groups {
    name: "VPMOVQW/VPMOVSQW/VPMOVUSQW"
    short_description: "Down Convert QWord to Word"
  }
  instruction_groups {
    name: "VPCONFLICTD/Q"
    short_description: "Detect Conflicts Within a Vector of Packed Dword/Qword Values into Dense Memory/ Register"
  }
  instruction_groups {
    name: "MINSD"
    short_description: "Return Minimum Scalar Double-Precision Floating-Point Value"
  }
  instruction_groups {
    name: "VPERMPD"
    short_description: "Permute Double-Precision Floating-Point Elements"
  }
  instruction_groups {
    name: "VPMOVWB/VPMOVSWB/VPMOVUSWB"
    short_description: "Down Convert Word to Byte"
  }
  instruction_groups {
    name: "ELDB/ELDU/ELDBC/ELDUC"
  }
  instruction_groups {
    name: "ANDNPD"
    short_description: "Bitwise Logical AND NOT of Packed Double Precision Floating-Point Values"
    description: "Performs a bitwise logical AND NOT of the two, four or eight packed double-precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand.\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\nVEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified."
  }
  instruction_groups {
    name: "XORPD"
    short_description: "Bitwise Logical XOR of Packed Double Precision Floating-Point Values"
  }
  instruction_groups {
    name: "FISTTP"
    short_description: "Store Integer with Truncation"
    description: "FISTTP converts the value in ST into a signed integer using truncation (chop) as rounding mode, transfers the result to the destination, and pop ST. FISTTP accepts word, short integer, and long integer destinations.\nThe following table shows the results obtained when storing various classes of numbers in integer format.\nTable 3-28.  FISTTP Results\nST(0)\tDEST\n\342\210\222 \342\210\236 or Value Too Large for DEST Format\t*\nF\342\211\244 \342\210\222 1\t\342\210\222 I\n\342\210\222 1<F<+ 1\t0\nF\305\240+ 1\t+ I\n+ \342\210\236 or Value Too Large for DEST Format\t*\nNaN\t*\nNOTES:\nF\tMeans finite floating-point value.\n\316\231\tMeans integer.\n\342\210\227Indicates floating-point invalid-operation (#IA) exception.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C1 is cleared; C0, C2, C3 undefined."
    }
  }
  instruction_groups {
    name: "CBW/CWDE/CDQE"
    short_description: "Convert Byte to Word/Convert Word to Doubleword/Convert Doubleword to Quadword"
    description: "Double the size of the source operand by means of sign extension. The CBW (convert byte to word) instruction copies the sign (bit 7) in the source operand into every bit in the AH register. The CWDE (convert word to doubleword) instruction copies the sign (bit 15) of the word in the AX register into the high 16 bits of the EAX register.\nCBW and CWDE reference the same opcode. The CBW instruction is intended for use when the operand-size attribute is 16; CWDE is intended for use when the operand-size attribute is 32. Some assemblers may force the operand size. Others may treat these two mnemonics as synonyms (CBW/CWDE) and use the setting of the operand-size attribute to determine the size of values to be converted.\nIn 64-bit mode, the default operation size is the size of the destination register. Use of the REX.W prefix promotes this instruction (CDQE when promoted) to operate on 64-bit operands. In which case, CDQE copies the sign (bit 31) of the doubleword in the EAX register into the high 32 bits of RAX."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "MASKMOVQ"
    short_description: "Store Selected Bytes of Quadword"
    description: "Stores selected bytes from the source operand (first operand) into a 64-bit memory location. The mask operand (second operand) selects which bytes from the source operand are written to memory. The source and mask operands are MMX technology registers. The memory location specified by the effective address in the DI/EDI/RDI register (the default segment register is DS, but this may be overridden with a segment-override prefix). The memory location does not need to be aligned on a natural boundary. (The size of the store address depends on the address-size attribute.)\nThe most significant bit in each byte of the mask operand determines whether the corresponding byte in the source operand is written to the corresponding byte location in memory: 0 indicates no write and 1 indicates write.\nThe MASKMOVQ instruction generates a non-temporal hint to the processor to minimize cache pollution. The nontemporal hint is implemented by using a write combining (WC) memory type protocol (see \342\200\234Caching of Temporal vs. Non-Temporal Data\342\200\235 in Chapter 10, of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1). Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with the SFENCE or MFENCE instruction should be used in conjunction with MASKMOVQ instructions if multiple processors might use different memory types to read/write the destination memory locations.\nThis instruction causes a transition from x87 FPU to MMX technology state (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]).\nThe behavior of the MASKMOVQ instruction with a mask of all 0s is as follows:\n\342\200\242\tNo data will be written to memory.\n\342\200\242\tTransition from x87 FPU to MMX technology state will occur.\n\342\200\242\tExceptions associated with addressing memory and page faults may still be signaled (implementation dependent).\n\342\200\242\tSignaling of breakpoints (code or data) is not guaranteed (implementation dependent).\n\342\200\242\tIf the destination memory region is mapped as UC or WP, enforcement of associated semantics for these memory types is not guaranteed (that is, is reserved) and is implementation-specific.\nThe MASKMOVQ instruction can be used to improve performance for algorithms that need to merge data on a byteby-byte basis. It should not cause a read for ownership; doing so generates unnecessary bandwidth since data is to be written directly using the byte-mask without allocating old data prior to the store.\nIn 64-bit mode, the memory address is specified by DS:RDI."
  }
  instruction_groups {
    name: "VFMADDSUB132PD/VFMADDSUB213PD/VFMADDSUB231PD"
    short_description: "Fused Multiply-Alternating Add/Subtract of Packed Double-Precision"
  }
  instruction_groups {
    name: "LDDQU"
    short_description: "Load Unaligned Integer 128 Bits"
    description: "The instruction is functionally similar to (V)MOVDQU ym m/xm m, m256/m128 for loading from memory. That is: 32/16 bytes of data starting at an address specified by the source memory operand (second operand) are fetched from memory and placed in a destination register (first operand). The source operand need not be aligned on a 32/16-byte boundary. Up to 64/32 bytes may be loaded from memory; this is implementation dependent.\nThis instruction may improve performance relative to (V)MOVDQU if the source operand crosses a cache line boundary. In situations that require the data loaded by (V)LDDQU be modified and stored to the same location, use (V)MOVDQU or (V)MOVDQA instead of (V)LDDQU. To move a double quadword to or from memory locations that are known to be aligned on 16-byte boundaries, use the (V)MOVDQA instruction."
  }
  instruction_groups {
    name: "VPSHRDV"
    short_description: "Concatenate and Variable Shift Packed Data Right Logical"
  }
  instruction_groups {
    name: "MOVNTI"
    short_description: "Store Doubleword Using Non-Temporal Hint"
    description: "Moves the doubleword integer in the source operand (second operand) to the destination operand (first operand) using a non-temporal hint to minimize cache pollution during the write to memory. The source operand is a general-purpose register. The destination operand is a 32-bit memory location.\nThe non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an uncacheable (UC) or write protected (WP) memory region. For more information on non-temporal stores, see \342\200\234Caching of Temporal vs. Non-Temporal Data\342\200\235 in Chapter 10 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1.\nBecause the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with the SFENCE or MFENCE instruction should be used in conjunction with MOVNTI instructions if multiple processors might use different memory types to read/write the destination memory locations.\nIn 64-bit mode, the instruction\342\200\231s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the sum mary chart at the\nbeginning of this section for encoding data and limits."
  }
  instruction_groups {
    name: "VCVTUSI2SD"
    short_description: "Convert Unsigned Integer to Scalar Double-Precision Floating-Point Value"
  }
  instruction_groups {
    name: "FCLEX/FNCLEX"
    short_description: "Clear Exceptions"
    description: "Clears the floating-point exception flags (PE, UE, OE, ZE, DE, and IE), the exception sum mary status flag (ES), the stack fault flag (SF), and the busy flag (B) in the FPU status word. The FCLEX instruction checks for and handles any pending unmasked floating-point exceptions before clearing the exception flags; the FNCLEX instruction does not.\nThe assembler issues two instructions for the FCLEX instruction (an FWAIT instruction followed by an FNCLEX instruction), and the processor executes each of these instructions separately. If an exception is generated for either of these instructions, the save EIP points to the instruction that caused the exception."
    flags_affected {
      content: "The PE, UE, OE, ZE, DE, IE, ES, SF, and B flags in the FPU status word are cleared. The C0, C1, C2, and C3 flags are undefined."
    }
  }
  instruction_groups {
    name: "RCPPS"
    short_description: "Compute Reciprocals of Packed Single-Precision Floating-Point Values"
    description: "Performs a SIMD computation of the approximate reciprocals of the four packed single-precision floating-point values in the source operand (second operand) stores the packed single-precision floating-point results in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. See Figure 10-5 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1, for an illustration of a SIMD single-precision floating-point operation.\nThe relative error for this approximation is:\n|Relative Error| \342\211\244 1.5 \342\210\227 2\342\210\22212\nThe RCPPS instruction is not affected by the rounding control bits in the MXCSR register. When a source value is a 0.0, an \342\210\236 of the sign of the source value is returned. A denormal source value is treated as a 0.0 (of the same sign).\nTiny results (see Section 4.9.1.5, \342\200\234Numeric Underflow Exception (#U)\342\200\235 in Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1) are always flushed to 0.0, with the sign of the operand. (Input values greater than or equal to |1.11111111110100000000000B\342\210\2272125| are guaranteed to not produce tiny results; input values less than or equal to |1.00000000000110000000001B*2126| are guaranteed to produce tiny results, which are in turn flushed to 0.0; and input values in between this range may or may not produce tiny results, depending on the implementation.) When a source value is an SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned.\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.\nVEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
  }
  instruction_groups {
    name: "MULSD"
    short_description: "Multiply Scalar Double-Precision Floating-Point Value"
  }
  instruction_groups {
    name: "VCVTUQQ2PD"
    short_description: "Convert Packed Unsigned Quadword Integers to Packed Double-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "LAHF"
    short_description: "Load Status Flags into AH Register"
    description: "This instruction executes as described above in compatibility mode and legacy mode. It is valid in 64-bit mode only if CPUID.80000001H:ECX.LAHF-SAHF[bit 0] = 1."
    flags_affected {
      content: "None. The state of the flags in the EFLAGS register is not affected."
    }
  }
  instruction_groups {
    name: "VREDUCESS"
    short_description: "Perform a Reduction Transformation on a Scalar Float32 Value"
  }
  instruction_groups {
    name: "VMLAUNCH/VMRESUME"
    description: "Effects a VM\tentry managed by the current VMCS.\n\342\200\242\tVMLAUNCH fails if the launch state of current VMCS is not \342\200\234clear\342\200\235. If the instruction is successful, it sets the launch state to \342\200\234launched.\342\200\235\n\342\200\242\tVMRESUME fails if the launch state of the current VMCS is not \342\200\234launched.\342\200\235\nIf VM entry is attempted, the logical processor performs a series of consistency checks as detailed in Chapter 26, \342\200\234VM Entries\342\200\235. Failure to pass checks on the VMX controls or on the host-state area passes control to the instruction following the VMLAUNCH or VMRESUME instruction. If these pass but checks on the guest-state area fail, the logical processor loads state from the host-state area of the VMCS, passing control to the instruction referenced by the RIP field in the host-state area.\nVM\tentry is not allowed when events are blocked by MOV\tSS or POP SS. Neither VMLAUNCH nor VMRESUME should\nbe used im mediately after either MOV to SS or POP to SS."
    flags_affected {
      content: "See the operation section and Section 30.2."
    }
  }
  instruction_groups {
    name: "VPRORD/VPRORVD/VPRORQ/VPRORVQ"
    short_description: "Bit Rotate Right"
  }
  instruction_groups {
    name: "FBSTP"
    short_description: "Store BCD Integer and Pop"
    description: "Converts the value in the ST(0) register to an 18-digit packed BCD integer, stores the result in the destination operand, and pops the register stack. If the source value is a non-integral value, it is rounded to an integer value, according to rounding mode specified by the RC field of the FPU control word. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.\nThe destination operand specifies the address where the first byte destination value is to be stored. The BCD value (including its sign bit) requires 10 bytes of space in memory.\nThe following table shows the results obtained when storing various classes of numbers in packed BCD format.\nTable 3-19.  FBSTP Results\nST(0)\tDEST\n\342\210\222 \342\210\236 or Value Too Large for DEST Format\t*\nF \342\211\244 \342\210\222 1\t\342\210\222 D\n\342\210\2221 < F < -0\t**\n\342\210\222 0\t\342\210\222 0\n+ 0\t+ 0\n+ 0 < F < +1\t**\nF \342\211\245 +1\t+ D\n+ \342\210\236 or Value Too Large for DEST Format\t*\nNaN\t*\nNOTES:\nF\tMeans finite floating-point value.\nD\tMeans packed-BCD number.\n* Indicates floating-point invalid-operation (#IA) exception.\n**\302\2610 or \302\2611, depending on the rounding mode.\nIf the converted value is too large for the destination format, or if the source operand is an \342\210\236, SNaN, QNAN, or is in an unsupported format, an invalid-arithmetic-operand condition is signaled. If the invalid-operation exception is not masked, an invalid-arithmetic-operand exception (#IA) is generated and no value is stored in the destination operand. If the invalid-operation exception is masked, the packed BCD indefinite value is stored in memory.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C1\tSet to 0 if stack underflow occurred.\nSet if result was rounded up; cleared otherwise.\nC0, C2, C3\tUndefined."
    }
  }
  instruction_groups {
    name: "NOP"
    short_description: "No Operation"
    description: "This instruction performs no operation. It is a one-byte or multi-byte NOP that takes up space in the instruction stream but does not impact machine context, except for the EIPregister.\nThe multi-byte form of NOP is available on processors with model encoding:\n\342\200\242\tCPUID.01H.EAX[Bytes 11:8] = 0110B or 1111B\nThe multi-byte NOP instruction does not alter the content of a register and will not issue a memory operation. The instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "PINSRW"
    short_description: "Insert Word"
    description: "Copies a word from the source operand (second operand) and inserts it in the destination operand (first operand) at the location specified with the count operand (third operand). (The other words in the destination register are left untouched.) The source operand can be a general-purpose register or a 16-bit memory location. (When the source operand is a general-purpose register, the low word of the register is copied.) The destination operand can be an MMX technology register or an XMM register. The count operand is an 8-bit im\nmediate. When specifying a word location in an MMX technology register, the 2 least-significant bits of the count operand specify the location; for an XMM register, the 3 least-significant bits specify the location.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15, R8-15).\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: Bits (MAXVL-1:128) of the destination YMM register are zeroed. VEX.L must be 0, otherwise the instruction will #UD.\nEVEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed. EVEX.L\342\200\231L must be 0, otherwise the instruction will #UD."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "STAC"
    short_description: "Set AC Flag in EFLAGS Register"
    description: "Sets the AC flag bit in EFLAGS register. This may enable alignment checking of user-mode data accesses. This allows explicit supervisor-mode data accesses to user-mode pages even if the SMAP bit is set in the CR4 register.\nThis instruction\'s operation is the same in non-64-bit modes and 64-bit mode. Attempts to execute STAC when CPL > 0 cause #UD."
    flags_affected {
      content: "AC set. Other flags are unaffected."
    }
  }
  instruction_groups {
    name: "EMODPE"
  }
  instruction_groups {
    name: "RSTORSSP"
    short_description: "Restore Saved Shadow Stack Pointer"
    description: "Restores SSP from the shadow-stack-restore token pointed to by m64. If the SSP restore was successful then the instruction replaces the shadow-stack-restore token with a previous-ssp token. The instruction sets the CF flag to indicate whether the SSP address recorded in the shadow-stack-restore token that was processed was 4 byte aligned, i.e., whether an alignment hole was created when the restore-shadow-stack token was pushed on this shadow stack.\nFollowing RSTORSSP if a restore-shadow-stack token needs to be saved on the previous shadow stack, use the SAVEPREVSSP instruction.\nIf pushing a restore-shadow-stack token on the previous shadow stack is not required, the previous-ssp token can be popped using the INCSSPQ instruction. If the CF flag was set to indicate presence of an alignment hole, an additional INCSSPD instruction is needed to advance the SSP past the alignment hole."
    flags_affected {
      content: "CF is set to indicate if the shadow stack pointer in the restore token was 4 byte aligned, else it is cleared. ZF, PF, AF, OF, and SF are cleared."
    }
  }
  instruction_groups {
    name: "MOVMSKPD"
    short_description: "Extract Packed Double-Precision Floating-Point Sign Mask"
    description: "Extracts the sign bits from the packed double-precision floating-point values in the source operand (second operand), formats them into a 2-bit mask, and stores the mask in the destination operand (first operand). The source operand is an XMM register, and the destination operand is a general-purpose register. The mask is stored in the 2 low-order bits of the destination operand. Zero-extend the upper bits of the destination.\nIn 64-bit mode, the instruction can access additional registers (XMM8-XMM15, R8-R15) when used with a REX.R prefix. The default operand size is 64-bit in 64-bit mode.\n128-bit versions: The source operand is a YMM register. The destination operand is a general purpose register.\nVEX.256 encoded version: The source operand is a YMM register. The destination operand is a general purpose register.\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
  }
  instruction_groups {
    name: "V4FMADDSS/V4FNMADDSS"
    short_description: "Scalar Single-Precision Floating-Point Fused Multiply-Add (4-iterations)"
  }
  instruction_groups {
    name: "VFMSUBADD132PS/VFMSUBADD213PS/VFMSUBADD231PS"
    short_description: "Fused Multiply-Alternating Subtract/Add of Packed Single-Precision"
  }
  instruction_groups {
    name: "MONITOR"
    short_description: "Set Up Monitor Address"
    description: "The MONITOR instruction arms address monitoring hardware using an address specified in EAX (the address range that the monitoring hardware checks for store operations can be determined by using CPUID). A store to an address within the specified address range triggers the monitoring hardware. The state of monitor hardware is used by M WAIT.\nThe address is specified in RAX/EAX/AX and the size is based on the effective address size of the encoded instruction. By default, the DS segment is used to create a linear address that is monitored. Segment overrides can be used.\nECX and EDX are also used. They com municate other information to MONITOR. ECX specifies optional extensions.\nEDX specifies optional hints; it does not change the architectural behavior of the instruction. For the Pentium 4 processor (family 15, model 3), no extensions or hints are defined. Undefined hints in EDX are ignored by the processor; undefined extensions in ECX raises a general protection fault.\nThe address range must use memory of the write-back type. Only write-back memory will correctly trigger the monitoring hardware. Additional information on determining what address range to use in order to prevent false wake-ups is described in Chapter 8, \342\200\234Multiple-Processor Management\342\200\235 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3A.\nThe MONITOR instruction is ordered as a load operation with respect to other memory transactions. The instruction is subject to the permission checking and faults associated with a byte load. Like a load, MONITOR sets the A-bit but not the D-bit in page tables.\nCPUID.01H:ECX.MONITOR[bit 3] indicates the availability of MONITOR and M WAIT in the processor. When set, MONITOR may be executed only at privilege level 0 (use at any other privilege level results in an invalid-opcode exception). The operating system or system BIOS may disable this instruction by using the IA32_MISC_ENABLE MSR; disabling MONITOR clears the CPUID feature flag and causes execution to generate an invalid-opcode exception.\nThe instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
  }
  instruction_groups {
    name: "PREFETCHh"
    short_description: "Prefetch Data Into Caches"
    description: "Fetches the line of data from memory that contains the byte specified with the source operand to a location in the cache hierarchy specified by a locality hint:\n\342\200\242\tT0 (temporal data)-prefetch data into all levels of the cache hierarchy.\n\342\200\242\tT1 (temporal data with respect to first level cache misses)-prefetch data into level 2 cache and higher.\n\342\200\242\tT2 (temporal data with respect to second level cache misses)-prefetch data into level 3 cache and higher, or an implementation-specific choice.\n\342\200\242\tNTA (non-temporal data with respect to all cache levels)-prefetch data into non-temporal cache structure and into a location close to the processor, minimizing cache pollution.\nThe source operand is a byte memory location. (The locality hints are encoded into the machine level instruction using bits 3 through 5 of the ModR/M byte.)\nIf the line selected is already present in the cache hierarchy at a level closer to the processor, no data movement occurs. Prefetches from uncacheable or WC memory are ignored.\nThe PREFETCHh instruction is merely a hint and does not affect program behavior. If executed, this instruction moves data closer to the processor in anticipation of future use.\nThe implementation of prefetch locality hints is implementation-dependent, and can be overloaded or ignored by a processor implementation. The amount of data prefetched is also processor implementation-dependent. It will, however, be a minimum of 32 bytes. Additional details of the implementation-dependent locality hints are described in Section 7.4 of Intel\302\256 64 and IA-32 Architectures Optimization Reference Manual.\nIt should be noted that processors are free to speculatively fetch and cache data from system memory regions that are assigned a memory-type that permits speculative reads (that is, the WB, WC, and WT memory types). A PREFETCHh instruction is considered a hint to this speculative behavior. Because this speculative fetching can occur at any time and is not tied to instruction execution, a PREFETCHh instruction is not ordered with respect to the fence instructions (MFENCE, SFENCE, and LFENCE) or locked memory references. A PREFETCHh instruction is also unordered with respect to CLFLUSH and CLFLUSHOPT instructions, other PREFETCHh instructions, or any other general instruction. It is ordered with respect to serializing instructions such as CPUID, WRMSR, OUT, and MOV CR.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
  }
  instruction_groups {
    name: "PMULHRSW"
    short_description: "Packed Multiply High with Round and Scale"
    description: "PMULHRSW multiplies vertically each signed 16-bit integer from the destination operand (first operand) with the corresponding signed 16-bit integer of the source operand (second operand), producing intermediate, signed 32- bit integers. Each intermediate 32-bit integer is truncated to the 18 most significant bits. Rounding is always performed by adding 1 to the least significant bit of the 18-bit intermediate result. The final result is obtained by selecting the 16 bits im\nmediately to the right of the most significant bit of each 18-bit intermediate result and packed to the destination operand.\nWhen the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.\nIn 64-bit mode and not encoded with VEX/EVEX, use the REX prefix to access XMM8-XMM15 registers.\nLegacy SSE version 64-bit operand: Both operands can be MMX registers. The second source operand is an MMX register or a 64-bit memory location.\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1."
  }
  instruction_groups {
    name: "TEST"
    short_description: "Logical Compare"
    description: "Computes the bit-wise logical AND of first operand (source 1 operand) and the second operand (source 2 operand) and sets the SF, ZF, and PF status flags according to the result. The result is then discarded.\nIn 64-bit mode, using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the sum mary chart at the beginning of this\nsection for encoding data and limits."
    flags_affected {
      content: "The OF and CF flags are set to 0. The SF, ZF, and PF flags are set according to the result (see the \342\200\234Operation\342\200\235 section above). The state of the AF flag is undefined."
    }
  }
  instruction_groups {
    name: "VPTESTMB/VPTESTMW/VPTESTMD/VPTESTMQ"
    short_description: "Logical AND and Set Mask"
  }
  instruction_groups {
    name: "VFMSUB132SS/VFMSUB213SS/VFMSUB231SS"
    short_description: "Fused Multiply-Subtract of Scalar Single-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "HLT"
    short_description: "Halt"
    description: "Stops instruction execution and places the processor in a HALT state. An enabled interrupt (including NMI and SMI), a debug exception, the BINIT# signal, the INIT# signal, or the RESET# signal will resume execution. If an interrupt (including NMI) is used to resume execution after a HLT instruction, the saved instruction pointer (CS:EIP) points to the instruction following the HLT instruction.\nWhen a HLT instruction is executed on an Intel 64 or IA-32 processor supporting Intel Hyper-Threading Technology, only the logical processor that executes the instruction is halted. The other logical processors in the physical processor remain active, unless they are each individually halted by executing a HLT instruction.\nThe HLT instruction is a privileged instruction. When the processor is running in protected or virtual-8086 mode, the privilege level of a program or procedure must be 0 to execute the HLT instruction.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "UNPCKHPD"
    short_description: "Unpack and Interleave High Packed Double-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "AESKEYGENASSIST"
    short_description: "AES Round Key Generation Assist"
    description: "Assist in expanding the AES cipher key, by computing steps towards generating a round key for encryption, using 128-bit data specified in the source operand and an 8-bit round constant specified as an im mediate, store the\nresult in the destination operand.\nThe destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory location.\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
  }
  instruction_groups {
    name: "PAND"
    short_description: "Logical AND"
    description: "Performs a bitwise logical AND operation on the first source operand and second source operand and stores the result in the destination operand. Each bit of the result is set to 1 if the corresponding bits of the first and second operands are 1, otherwise it is set to 0.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.\n128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1 at 32/64-bit granularity.\nVEX.256 encoded versions: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\nVEX.128 encoded versions: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "VGETMANTPD"
    short_description: "Extract Float64 Vector of Normalized Mantissas from Float64 Vector"
  }
  instruction_groups {
    name: "MOVNTQ"
    short_description: "Store of Quadword Using Non-Temporal Hint"
    description: "Moves the quadword in the source operand (second operand) to the destination operand (first operand) using a non-temporal hint to minimize cache pollution during the write to memory. The source operand is an MMX technology register, which is assumed to contain packed integer data (packed bytes, words, or doublewords). The destination operand is a 64-bit memory location.\nThe non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an uncacheable (UC) or write protected (WP) memory region. For more information on non-temporal stores, see \342\200\234Caching of Temporal vs. Non-Temporal Data\342\200\235 in Chapter 10 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1.\nBecause the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with the SFENCE or MFENCE instruction should be used in conjunction with MOVNTQ instructions if multiple processors might use different memory types to read/write the destination memory locations.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
  }
  instruction_groups {
    name: "LLDT"
    short_description: "Load Local Descriptor Table Register"
    description: "Loads the source operand into the segment selector field of the local descriptor table register (LDTR). The source operand (a general-purpose register or a memory location) contains a segment selector that points to a local descriptor table (LDT). After the segment selector is loaded in the LDTR, the processor uses the segment selector to locate the segment descriptor for the LDT in the global descriptor table (GDT). It then loads the segment limit and base address for the LDT from the segment descriptor into the LDTR. The segment registers DS, ES, SS, FS, GS, and CS are not affected by this instruction, nor is the LDTR field in the task state segment (TSS) for the current task.\nIf bits 2-15 of the source operand are 0, LDTR is marked invalid and the LLDT instruction completes silently.\nHowever, all subsequent references to descriptors in the LDT (except by the LAR, VERR, VERW or LSL instructions) cause a general protection exception (#GP).\nThe operand-size attribute has no effect on this instruction.\nThe LLDT instruction is provided for use in operating-system software; it should not be used in application programs. This instruction can only be executed in protected mode or 64-bit mode.\nIn 64-bit mode, the operand size is fixed at 16 bits."
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "PANDN"
    short_description: "Logical AND NOT"
    description: "Performs a bitwise logical NOT operation on the first source operand, then performs bitwise AND with second source operand and stores the result in the destination operand. Each bit of the result is set to 1 if the corresponding bit in the first operand is 0 and the corresponding bit in the second operand is 1, otherwise it is set to 0.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.\n128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1 at 32/64-bit granularity.\nVEX.256 encoded versions: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\nVEX.128 encoded versions: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "PSADBW"
    short_description: "Compute Sum of Absolute Differences"
    description: "Computes the absolute value of the difference of 8 unsigned byte integers from the source operand (second operand) and from the destination operand (first operand). These 8 differences are then sum med to produce an\nunsigned word integer result that is stored in the destination operand. Figure\t4-14 shows the operation of the\nPSADBW instruction when using 64-bit operands.\nWhen operating on 64-bit operands, the word integer result is stored in the low word of the destination operand, and the remaining bytes in the destination operand are cleared to all 0s.\nWhen operating on 128-bit operands, two packed results are computed. Here, the 8 low-order bytes of the source and destination operands are operated on to produce a word result that is stored in the low word of the destination operand, and the 8 high-order bytes are operated on to produce a word result that is stored in bits 64 through 79 of the destination operand. The remaining bytes of the destination operand are cleared.\nFor 256-bit version, the third group of 8 differences are sum\nmed to produce an unsigned word in bits[143:128] of the destination register and the fourth group of 8 differences are sum\nmed to produce an unsigned word in bits[207:192] of the destination register. The remaining words of the destination are set to 0.\nFor 512-bit version, the fifth group result is stored in bits [271:256] of the destination. The result from the sixth group is stored in bits [335:320]. The results for the seventh and eighth group are stored respectively in bits [399:384] and bits [463:447], respectively. The remaining bits in the destination are set to 0.\nIn 64-bit mode and not encoded by VEX/EVEX prefix, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE version: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register.\n128-bit Legacy SSE version: The first source operand and destination register are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding ZMM destination register remain unchanged.\nVEX.128 and EVEX.128 encoded versions: The first source operand and destination register are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding ZMM register are zeroed.\nVEX.256 and EVEX.256 encoded versions: The first source operand and destination register are YMM registers. The second source operand is an YMM register or a 256-bit memory location. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.\nEVEX.512 encoded version: The first source operand and destination register are ZMM registers. The second source operand is a ZMM register or a 512-bit memory location.\nSRC\tX7\tX6\tX5\tX4\tX3\tX2\tX1\tX0\nDEST\tY7\tY6\tY5\tY4\tY3\tY2\tY1\tY0\nTEMP\tABS(X7:Y7)\tABS(X6:Y6)\tABS(X5:Y5)\tABS(X4:Y4)\tABS(X3:Y3)\tABS(X2:Y2)\tABS(X1:Y1)\tABS(X0:Y0)\nDEST\t00H\t00H\t00H\t00H\t00H\t00H\tSUM(TEMP7...TEMP0)\nFigure 4-14.  PSADBW Instruction Operation Using 64-bit Operands"
    flags_affected {
      content: "None.\nSIMD Floating-Point Exceptions\nNone."
    }
  }
  instruction_groups {
    name: "BT"
    short_description: "Bit Test"
    description: "Selects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by the bit offset (specified by the second operand) and stores the value of the bit in the CF flag. The bit base operand can be a register or a memory location; the bit offset operand can be a register or an im mediate value:\n\342\200\242\tIf the bit base operand specifies a register, the instruction takes the modulo 16, 32, or 64 of the bit offset operand (modulo size depends on the mode and register size; 64-bit operands are available only in 64-bit mode).\n\342\200\242\tIf the bit base operand specifies a memory location, the operand represents the address of the byte in memory that contains the bit base (bit 0 of the specified byte) of the bit string. The range of the bit position that can be referenced by the offset operand depends on the operand size.\nSee also: Bit(BitBase, BitOffset) on page 3-11.\nSome assemblers support im mediate bit offsets larger than 31 by using the im mediate bit offset field in combination with the displacement field of the memory operand. In this case, the low-order 3 or 5 bits (3 for 16-bit operands, 5 for 32-bit operands) of the im mediate bit offset are stored in the im mediate bit offset field, and the highorder bits are shifted and combined with the byte displacement in the addressing mode by the assembler. The processor will ignore the high order bits if they are not zero.\nWhen accessing a bit in memory, the processor may access 4 bytes starting from the memory address for a 32-bit operand size, using by the following relationship:\nEffective Address + (4 \342\210\227 (BitOffset DIV 32))\nOr, it may access 2 bytes starting from the memory address for a 16-bit operand, using this relationship:\nEffective Address + (2 \342\210\227 (BitOffset DIV 16))\nIt may do so even when only a single byte needs to be accessed to reach the given bit. When using this bit addressing mechanism, software should avoid referencing areas of memory close to address space holes. In particular, it should avoid references to memory-mapped I/O registers. Instead, software should use the MOV instructions to load from or store to these addresses, and use the register form of these instructions to manipulate the data.\nIn 64-bit mode, the instruction\342\200\231s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bit operands. See the sum mary chart at the beginning of this section for encoding data and limits."
    flags_affected {
      content: "The CF flag contains the value of the selected bit. The ZF flag is unaffected. The OF, SF, AF, and PF flags are undefined."
    }
  }
  instruction_groups {
    name: "ADDPS"
    short_description: "Add Packed Single-Precision Floating-Point Values"
    description: "Adds four, eight or sixteen packed single-precision floating-point values from the first source operand with the second source operand, and stores the packed single-precision floating-point result in the destination operand.\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\nVEX.128 encoded version: the first source operand is a XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper Bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified."
  }
  instruction_groups {
    name: "PSRAW/PSRAD/PSRAQ"
    short_description: "Shift Packed Data Right Arithmetic"
    description: "Shifts the bits in the individual data elements (words, doublewords or quadwords) in the destination operand (first operand) to the right by the number of bits specified in the count operand (second operand). As the bits in the data elements are shifted right, the empty high-order bits are filled with the initial value of the sign bit of the data element. If the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for quadwords), each destination data element is filled with the initial value of the sign bit of the element. (Figure 4-18\ngives an example of shifting words in a 64-bit operand.)\nPre-Shift\nX3\tX2\tX1\tX0\nDEST\nShift Right\nwith Sign Extension\nPost-Shift DEST\tX3 >> COUNT\tX2 >> COUNT\tX1 >> COUNT\tX0 >> COUNT\nFigure 4-18.  PSRAW and PSRAD Instruction Operation Using a 64-bit Operand\nNote that only the first 64-bits of a 128-bit count operand are checked to compute the count. If the second source operand is a memory address, 128 bits are loaded.\nThe (V)PSRAW instruction shifts each of the words in the destination operand to the right by the number of bits specified in the count operand, and the (V)PSRAD instruction shifts each of the doublewords in the destination operand.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE instructions 64-bit operand: The destination operand is an MMX technology register; the count operand can be either an MMX technology register or an 64-bit memory location.\n128-bit Legacy SSE version: The destination and first source operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged. The count operand can be either an XMM register or a 128-bit memory location or an 8-bit im mediate. If the count operand is a memory address, 128 bits are loaded\nbut the upper 64 bits are ignored.\nVEX.128 encoded version: The destination and first source operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed. The count operand can be either an XMM register or a 128-bit memory location or an 8-bit im mediate. If the count operand is a memory address, 128 bits are loaded but the upper 64 bits are\nignored.\nVEX.256 encoded version: The destination operand is a YMM register. The source operand is a YMM register or a memory location. The count operand can come either from an XMM register or a memory location or an 8-bit im mediate. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.\nEVEX encoded versions: The destination operand is a ZMM register updated according to the writemask. The count operand is either an 8-bit im mediate (the im mediate count version) or an 8-bit value from an XMM register or a memory location (the variable count version). For the im\nmediate count version, the source operand (the second operand) can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location. For the variable count version, the first source operand (the second operand) is a ZMM register, the second source operand (the third operand, 8-bit variable count) can be an XMM register or a memory location.\nNote: In VEX/EVEX encoded versions of shifts with an im\nmediate count, vvvv of VEX/EVEX encode the destination register, and VEX.B/EVEX.B + ModRM.r/m encodes the source register.\nNote: For shifts with an im mediate count (VEX.128.66.0F 71-73 /4, EVEX.128.66.0F 71-73 /4), VEX.vvvv/EVEX.vvvv encodes the destination register."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "BOUND"
    short_description: "Check Array Index Against Bounds"
    description: "BOUND determines if the first operand (array index) is within the bounds of an array specified the second operand (bounds operand). The array index is a signed integer located in a register. The bounds operand is a memory location that contains a pair of signed doubleword-integers (when the operand-size attribute is 32) or a pair of signed word-integers (when the operand-size attribute is 16). The first doubleword (or word) is the lower bound of the array and the second doubleword (or word) is the upper bound of the array. The array index must be greater than or equal to the lower bound and less than or equal to the upper bound plus the operand size in bytes. If the index is not within bounds, a BOUND range exceeded exception (#BR) is signaled. When this exception is generated, the saved return instruction pointer points to the BOUND instruction.\nThe bounds limit data structure (two words or doublewords containing the lower and upper limits of the array) is usually placed just before the array itself, making the limits addressable via a constant offset from the beginning of the array. Because the address of the array already will be present in a register, this practice avoids extra bus cycles to obtain the effective address of the array bounds.\nThis instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "POPA/POPAD"
    short_description: "Pop All General-Purpose Registers"
    description: "Pops doublewords (POPAD) or words (POPA) from the stack into the general-purpose registers. The registers are loaded in the following order: EDI, ESI, EBP, EBX, EDX, ECX, and EAX (if the operand-size attribute is 32) and DI, SI, BP, BX, DX, CX, and AX (if the operand-size attribute is 16). (These instructions reverse the operation of the PUSHA/PUSHAD instructions.) The value on the stack for the ESP or SP register is ignored. Instead, the ESP or SP register is incremented after each register is loaded.\nThe POPA (pop all) and POPAD (pop all double) mnemonics reference the same opcode. The POPA instruction is intended for use when the operand-size attribute is 16 and the POPAD instruction for when the operand-size attribute is 32. Some assemblers may force the operand size to 16 when POPA is used and to 32 when POPAD is used (using the operand-size override prefix [66H] if necessary). Others may treat these mnemonics as synonyms (POPA/POPAD) and use the current setting of the operand-size attribute to determine the size of values to be popped from the stack, regardless of the mnemonic used. (The D flag in the current code segment\342\200\231s segment descriptor determines the operand-size attribute.)\nThis instruction executes as described in non-64-bit modes. It is not valid in 64-bit mode."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "SUBSD"
    short_description: "Subtract Scalar Double-Precision Floating-Point Value"
  }
  instruction_groups {
    name: "MAXPS"
    short_description: "Maximum of Packed Single-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "PSHUFW"
    short_description: "Shuffle Packed Words"
    description: "Copies words from the source operand (second operand) and inserts them in the destination operand (first operand) at word locations selected with the order operand (third operand). This operation is similar to the operation used by the PSHUFD instruction, which is illustrated in Figure\n4-16. For the PSHUFW instruction, each 2-bit field in the order operand selects the contents of one word location in the destination operand. The encodings of the order operand fields select words from the source operand to be copied to the destination operand.\nThe source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register. The order operand is an 8-bit im\nmediate. Note that this instruction permits a word in the source operand to be copied to more than one word location in the destination operand.\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15)."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "SYSEXIT"
    short_description: "Fast Return from Fast System Call"
    description: "Executes a fast return to privilege level 3 user code. SYSEXIT is a companion instruction to the SYSENTER instruction. The instruction is optimized to provide the maximum performance for returns from system procedures executing at protections levels 0 to user procedures executing at protection level 3. It must be executed from code executing at privilege level 0.\nWith a 64-bit operand size, SYSEXIT remains in 64-bit mode; otherwise, it either enters compatibility mode (if the logical processor is in IA-32e mode) or remains in protected mode (if it is not).\nPrior to executing SYSEXIT, software must specify the privilege level 3 code segment and code entry point, and the privilege level 3 stack segment and stack pointer by writing values into the following MSR and general-purpose registers:\n\342\200\242\tIA32_SYSENTER_CS (MSR address 174H) - Contains a 32-bit value that is used to determine the segment selectors for the privilege level 3 code and stack segments (see the Operation section)\n\342\200\242\tRDX - The canonical address in this register is loaded into RIP (thus, this value references the first instruction to be executed in the user code). If the return is not to 64-bit mode, only bits 31:0 are loaded.\n\342\200\242\tECX - The canonical address in this register is loaded into RSP (thus, this value contains the stack pointer for the privilege level 3 stack). If the return is not to 64-bit mode, only bits 31:0 are loaded.\nThe IA32_SYSENTER_CS MSR can be read from and written to using RDMSR and WRMSR.\nWhile SYSEXIT loads the CS and SS selectors with values derived from the IA32_SYSENTER_CS MSR, the CS and SS descriptor caches are not loaded from the descriptors (in GDT or LDT) referenced by those selectors. Instead, the descriptor caches are loaded with fixed values. See the Operation section for details. It is the responsibility of OS software to ensure that the descriptors (in GDT or LDT) referenced by those selector values correspond to the fixed values loaded into the descriptor caches; the SYSEXIT instruction does not ensure this correspondence.\nThe SYSEXIT instruction can be invoked from all operating modes except real-address mode and virtual-8086 mode.\nThe SYSENTER and SYSEXIT instructions were introduced into the IA-32 architecture in the Pentium II processor.\nThe availability of these instructions on a processor is indicated with the SYSENTER/SYSEXIT present (SEP) feature flag returned to the EDX register by the CPUID instruction. An operating system that qualifies the SEP flag must also qualify the processor family and model to ensure that the SYSENTER/SYSEXIT instructions are actually present. For example:\nIF CPUID SEP bit is set THEN IF (Family = 6) and (Model < 3) and (Stepping < 3) THEN SYSENTER/SYSEXIT_Not_Supported; FI; ELSE SYSENTER/SYSEXIT_Supported; FI;\nFI;\nWhen the CPUID instruction is executed on the Pentium Pro processor (model 1), the processor returns a the SEP flag as set, but does not support the SYSENTER/SYSEXIT instructions.\nWhen shadow stacks are enabled at privilege level 3 the instruction loads SSP with value from IA32_PL3_SSP MSR.\nRefer to Chapter 6, \342\200\234Procedure Calls, Interrupts, and Exceptions\342\200\235 and Chapter 18, \342\200\234Control-Flow Enforcement Technology (CET)\342\200\235 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1 for additional CET details.\nInstruction ordering. Instructions following a SYSEXIT may be fetched from memory before earlier instructions complete execution, but they will not execute (even speculatively) until all instructions prior to the SYSEXIT have completed execution (the later instructions may execute before data stored by the earlier instructions have become globally visible)."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "HSUBPD"
    short_description: "Packed Double-FP Horizontal Subtract"
    description: "The HSUBPD instruction subtracts horizontally the packed DP FP numbers of both operands.\nSubtracts the double-precision floating-point value in the high quadword of the destination operand from the low quadword of the destination operand and stores the result in the low quadword of the destination operand.\nSubtracts the double-precision floating-point value in the high quadword of the source operand from the low quadword of the source operand and stores the result in the high quadword of the destination operand.\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).\nSee Figure\t3-20 for HSUBPD; see Figure\t3-21 for VHSUBPD.\nHSUBPD xmm1, xmm2/m128\n[127:64]\t[63:0]\txmm2 /m128\n[127:64]\t[63:0]\txmm1\nxmm2/m128[63:0] - xmm2/m128[127:64]\txmm1[63:0] - xmm1[127:64]\tResult: xmm1\n[127:64]\t[63:0]\nOM15995\nFigure 3-20.  HSUBPD-Packed Double-FP Horizontal Subtract\nSRC1\tX3\tX2\tX1\tX0\nSRC2\tY3\tY2\tY1\tY0\nDEST\tY2 - Y3\tX2 - X3\tY0 - Y1\tX0 - X1\nFigure 3-21.  VHSUBPD operation\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.\nVEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register."
  }
  instruction_groups {
    name: "DIVSD"
    short_description: "Divide Scalar Double-Precision Floating-Point Value"
    description: "Divides the low double-precision floating-point value in the first source operand by the low double-precision floating-point value in the second source operand, and stores the double-precision floating-point result in the destination operand. The second source operand can be an XMM register or a 64-bit memory location. The first source and destination are XMM registers.\n128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL- 1:64) of the corresponding ZMM destination register remain unchanged.\nVEX.128 encoded version: The first source operand is an xm\nm register encoded by VEX.vvvv. The quadword at bits 127:64 of the destination operand is copied from the corresponding quadword of the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\nEVEX.128 encoded version: The first source operand is an xm\nm register encoded by EVEX.vvvv. The quadword element of the destination operand at bits 127:64 are copied from the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\nEVEX version: The low quadword element of the destination is updated according to the writemask.\nSoftware should ensure VDIVSD is encoded with VEX.L=0. Encoding VDIVSD with VEX.L=1 may encounter unpredictable behavior across different processor generations."
  }
  instruction_groups {
    name: "VPDPWSSDS"
    short_description: "Multiply and Add Signed Word Integers with Saturation"
  }
  instruction_groups {
    name: "PSHUFHW"
    short_description: "Shuffle Packed High Words"
    description: "Copies words from the high quadword of a 128-bit lane of the source operand and inserts them in the high quadword of the destination operand at word locations (of the respective lane) selected with the im\nmediate operand.\nThis 256-bit operation is similar to the in-lane operation used by the 256-bit VPSHUFD instruction, which is illustrated in Figure 4-16. For 128-bit operation, only the low 128-bit lane is operative. Each 2-bit field in the im\nmediate operand selects the contents of one word location in the high quadword of the destination operand. The binary encodings of the im\nmediate operand fields select words (0, 1, 2 or 3, 4) from the high quadword of the source operand to be copied to the destination operand. The low quadword of the source operand is copied to the low quadword of the destination operand, for each 128-bit lane.\nNote that this instruction permits a word in the high quadword of the source operand to be copied to more than one word location in the high quadword of the destination operand.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n128-bit Legacy SSE version: The destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed. VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD.\nVEX.256 encoded version: The destination operand is an YMM register. The source operand can be an YMM register or a 256-bit memory location.\nEVEX encoded version: The destination operand is a ZMM/YMM/XMM registers. The source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination is updated according to the writemask.\nNote: In VEX encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
    flags_affected {
      content: "None.\nSIMD Floating-Point Exceptions\nNone."
    }
  }
  instruction_groups {
    name: "IRET/IRETD/IRETQ"
    short_description: "Interrupt Return"
    description: "Returns program control from an exception or interrupt handler to a program or procedure that was interrupted by an exception, an external interrupt, or a software-generated interrupt. These instructions are also used to perform a return from a nested task. (A nested task is created when a CALL instruction is used to initiate a task switch or when an interrupt or exception causes a task switch to an interrupt or exception handler.) See the section titled \342\200\234Task Linking\342\200\235 in Chapter 7 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3A.\nIRET and IRETD are mnemonics for the same opcode. The IRETD mnemonic (interrupt return double) is intended for use when returning from an interrupt when using the 32-bit operand size; however, most assemblers use the IRET mnemonic interchangeably for both operand sizes.\nIn Real-Address Mode, the IRET instruction performs a far return to the interrupted program or procedure. During this operation, the processor pops the return instruction pointer, return code segment selector, and EFLAGS image from the stack to the EIP, CS, and EFLAGS registers, respectively, and then resumes execution of the interrupted program or procedure.\nIn Protected Mode, the action of the IRET instruction depends on the settings of the NT (nested task) and VM flags in the EFLAGS register and the VM flag in the EFLAGS image stored on the current stack. Depending on the setting of these flags, the processor performs the following types of interrupt returns:\n\342\200\242\tReturn from virtual-8086 mode.\n\342\200\242\tReturn to virtual-8086 mode.\n\342\200\242\tIntra-privilege level return.\n\342\200\242\tInter-privilege level return.\n\342\200\242\tReturn from nested task (task switch).\nIf the NT flag (EFLAGS register) is cleared, the IRET instruction performs a far return from the interrupt procedure, without a task switch. The code segment being returned to must be equally or less privileged than the interrupt handler routine (as indicated by the RPL field of the code segment selector popped from the stack).\nAs with a real-address mode interrupt return, the IRET instruction pops the return instruction pointer, return code segment selector, and EFLAGS image from the stack to the EIP, CS, and EFLAGS registers, respectively, and then resumes execution of the interrupted program or procedure. If the return is to another privilege level, the IRET instruction also pops the stack pointer and SS from the stack, before resuming program execution. If the return is to virtual-8086 mode, the processor also pops the data segment registers from the stack.\nIf the NT flag is set, the IRET instruction performs a task switch (return) from a nested task (a task called with a CALL instruction, an interrupt, or an exception) back to the calling or interrupted task. The updated state of the task executing the IRET instruction is saved in its TSS. If the task is re-entered later, the code that follows the IRET instruction is executed.\nIf the NT flag is set and the processor is in IA-32e mode, the IRET instruction causes a general protection exception.\nIf nonmaskable interrupts (NMIs) are blocked (see Section 6.7.1, \342\200\234Handling Multiple NMIs\342\200\235 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3A), execution of the IRET instruction unblocks NMIs.\nThis unblocking occurs even if the instruction causes a fault. In such a case, NMIs are unmasked before the exception handler is invoked.\nIn 64-bit mode, the instruction\342\200\231s default operation size is 32 bits. Use of the REX.W prefix promotes operation to 64 bits (IRETQ). See the sum mary chart at the beginning of this section for encoding data and limits.\nRefer to Chapter 6, \342\200\234Procedure Calls, Interrupts, and Exceptions\342\200\235 and Chapter 18, \342\200\234Control-Flow Enforcement Technology (CET)\342\200\235 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1 for CET details.\nInstruction ordering. IRET is a serializing instruction. See Section 8.3 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3A.\nSee \342\200\234Changes to Instruction Behavior in VMX Non-Root Operation\342\200\235 in Chapter 25 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3C, for more information about the behavior of this instruction in VMX non-root operation."
    flags_affected {
      content: "All the flags and fields in the EFLAGS register are potentially modified, depending on the mode of operation of the processor. If performing a return from a nested task to a previous task, the EFLAGS register will be modified according to the EFLAGS image stored in the previous task\342\200\231s TSS."
    }
  }
  instruction_groups {
    name: "DPPS"
    short_description: "Dot Product of Packed Single Precision Floating-Point Values"
    description: "Conditionally multiplies the packed single precision floating-point values in the destination operand (first operand) with the packed single-precision floats in the source (second operand) depending on a mask extracted from the high 4 bits of the im mediate byte (third operand). If a condition mask bit in Im m8[7:4] is zero, the corresponding multiplication is replaced by a value of 0.0 in the manner described by Section 12.8.4 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1.\nThe four resulting single-precision values are sum med into an intermediate result. The intermediate result is conditionally broadcasted to the destination using a broadcast mask specified by bits [3:0] of the im mediate byte.\nIf a broadcast mask bit is \342\200\2341\342\200\235, the intermediate result is copied to the corresponding dword element in the destination operand. If a broadcast mask bit is zero, the corresponding element in the destination is set to zero.\nDPPS follows the NaN forwarding rules stated in the Software Developer\342\200\231s Manual, vol. 1, table 4.7. These rules do not cover horizontal prioritization of NaNs. Horizontal propagation of NaNs to the destination and the positioning of those NaNs in the destination is implementation dependent. NaNs on the input sources or computationally generated NaNs will have at least one NaN propagated to the destination.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.\nVEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register."
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "PCMPGTB/PCMPGTW/PCMPGTD"
    short_description: "Compare Packed Signed Integers for Greater Than"
    description: "Performs an SIMD signed compare for the greater value of the packed byte, word, or doubleword integers in the destination operand (first operand) and the source operand (second operand). If a data element in the destination operand is greater than the corresponding date element in the source operand, the corresponding data element in the destination operand is set to all 1s; otherwise, it is set to all 0s.\nThe PCMPGTB instruction compares the corresponding signed byte integers in the destination and source operands; the PCMPGTW instruction compares the corresponding signed word integers in the destination and source operands; and the PCMPGTD instruction compares the corresponding signed doubleword integers in the destination and source operands.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.\n128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The first source operand and destination operand are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source operand and destination operand are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.\nEVEX encoded VPCMPGTD: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.\nEVEX encoded VPCMPGTB/W: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "BNDCL"
    short_description: "Check Lower Bound"
    description: "Compare the address in the second operand with the lower bound in bnd. The second operand can be either a register or memory operand. If the address is lower than the lower bound in bnd.LB, it will set BNDSTATUS to 01H and signal a #BR exception.\nThis instruction does not cause any memory access, and does not read or write any flags."
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "PDEP"
    short_description: "Parallel Bits Deposit"
    description: "PDEP uses a mask in the second source operand (the third operand) to transfer/scatter contiguous low order bits in the first source operand (the second operand) into the destination (the first operand). PDEP takes the low bits from the first source operand and deposit them in the destination operand at the corresponding bit locations that are set in the second source operand (mask). All other bits (bits not set in mask) in destination are set to zero.\nSRC1\tS31\tS30\tS29\tS28\tS27\tS7\tS6\tS5\tS4\tS3\tS2\tS1\tS0\nSRC2 (mask)\t0\t0\t0\t1\t0\t1\t0\t1\t0\t0\t1\t0\t0\nDEST\t0\t0\t0\tS3\t0\tS2\t0\tS1\t0\t0\tS0\t0\t0\nbit 31\tbit 0\nFigure 4-8.  PDEP Example\nThis instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "GF2P8MULB"
    short_description: "Galois Field Multiply Bytes"
  }
  instruction_groups {
    name: "AESDECLAST"
    short_description: "Perform Last Round of an AES Decryption Flow"
    description: "This instruction performs the last round of the AES decryption flow using the Equivalent Inverse Cipher, with the round key from the second source operand, operating on a 128-bit data (state) from the first source operand, and store the result in the destination operand.\nVEX and EVEX encoded versions of the instruction allow 3-operand (non-destructive) operation. The legacy encoded versions of the instruction require that the first source operand and the destination operand are the same and must be an XMM register.\nThe EVEX encoded form of this instruction does not support memory fault suppression."
  }
  instruction_groups {
    name: "RET"
    short_description: "Return from Procedure"
    description: "Transfers program control to a return address located on the top of the stack. The address is usually placed on the stack by a CALL instruction, and the return is made to the instruction that follows the CALL instruction.\nThe optional source operand specifies the number of stack bytes to be released after the return address is popped; the default is none. This operand can be used to release parameters from the stack that were passed to the called procedure and are no longer needed. It must be used when the CALL instruction used to switch to a new procedure uses a call gate with a non-zero word count to access the new procedure. Here, the source operand for the RET instruction must specify the same number of bytes as is specified in the word count field of the call gate.\nThe RET instruction can be used to execute three different types of returns:\n\342\200\242\tNear return - A return to a calling procedure within the current code segment (the segment currently pointed to by the CS register), sometimes referred to as an intrasegment return.\n\342\200\242\tFar return - A return to a calling procedure located in a different segment than the current code segment, sometimes referred to as an intersegment return.\n\342\200\242\tInter-privilege-level far return - A far return to a different privilege level than that of the currently executing program or procedure.\nThe inter-privilege-level return type can only be executed in protected mode. See the section titled \342\200\234Calling Procedures Using Call and RET\342\200\235 in Chapter 6 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1, for detailed information on near, far, and inter-privilege-level returns.\nWhen executing a near return, the processor pops the return instruction pointer (offset) from the top of the stack into the EIP register and begins program execution at the new instruction pointer. The CS register is unchanged.\nWhen executing a far return, the processor pops the return instruction pointer from the top of the stack into the EIP register, then pops the segment selector from the top of the stack into the CS register. The processor then begins program execution in the new code segment at the new instruction pointer.\nThe mechanics of an inter-privilege-level far return are similar to an intersegment return, except that the processor examines the privilege levels and access rights of the code and stack segments being returned to determine if the control transfer is allowed to be made. The DS, ES, FS, and GS segment registers are cleared by the RET instruction during an inter-privilege-level return if they refer to segments that are not allowed to be accessed at the new privilege level. Since a stack switch also occurs on an inter-privilege level return, the ESP and SS registers are loaded from the stack.\nIf parameters are passed to the called procedure during an inter-privilege level call, the optional source operand must be used with the RET instruction to release the parameters on the return. Here, the parameters are released both from the called procedure\342\200\231s stack and the calling procedure\342\200\231s stack (that is, the stack being returned to).\nIn 64-bit mode, the default operation size of this instruction is the stack-address size, i.e. 64 bits. This applies to near returns, not far returns; the default operation size of far returns is 32 bits.\nRefer to Chapter 6, \342\200\234Procedure Calls, Interrupts, and Exceptions\342\200\235 and Chapter 18, \342\200\234Control-Flow Enforcement Technology (CET)\342\200\235 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1 for CET details.\nInstruction ordering. Instructions following a far return may be fetched from memory before earlier instructions complete execution, but they will not execute (even speculatively) until all instructions prior to the far return have completed execution (the later instructions may execute before data stored by the earlier instructions have become globally visible).\nUnlike near indirect CALL and near indirect JMP, the processor will not speculatively execute the next sequential instruction after a near RET unless that instruction is also the target of a jump or is a target in a branch predictor."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "MOVQ2DQ"
    short_description: "Move Quadword from MMX Technology to XMM Register"
    description: "Moves the quadword from the source operand (second operand) to the low quadword of the destination operand (first operand). The source operand is an MMX technology register and the destination operand is an XMM register.\nThis instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the MOVQ2DQ instruction is executed.\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15)."
  }
  instruction_groups {
    name: "VBROADCAST"
    short_description: "Load with Broadcast Floating-Point Data"
  }
  instruction_groups {
    name: "VPBLENDMB/VPBLENDMW"
    short_description: "Blend Byte/Word Vectors Using an Opmask Control"
  }
  instruction_groups {
    name: "RDMSR"
    short_description: "Read from Model Specific Register"
    description: "Reads the contents of a 64-bit model specific register (MSR) specified in the ECX register into registers EDX:EAX.\n(On processors that support the Intel64 architecture, the high-order 32 bits of RCX are ignored.) The EDX register is loaded with the high-order 32 bits of the MSR and the EAX register is loaded with the low-order 32 bits. (On processors that support the Intel64 architecture, the high-order 32 bits of each of RAX and RDX are cleared.) If fewer than 64 bits are implemented in the MSR being read, the values returned to EDX:EAX in unimplemented bit locations are undefined.\nThis instruction must be executed at privilege level 0 or in real-address mode; otherwise, a general protection exception #GP(0) will be generated. Specifying a reserved or unimplemented MSR address in ECX will also cause a general protection exception.\nThe MSRs control functions for testability, execution tracing, performance-monitoring, and machine check errors.\nChapter 2, \342\200\234Model-Specific Registers (MSRs)\342\200\235 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 4, lists all the MSRs that can be read with this instruction and their addresses. Note that each processor family has its own set of MSRs.\nThe CPUID instruction should be used to determine whether MSRs are supported (CPUID.01H:EDX[5] = 1) before using this instruction."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "VGATHERPF1DPS/VGATHERPF1QPS/VGATHERPF1DPD/VGATHERPF1QPD"
    short_description: "Sparse Prefetch Packed SP/DP Data Values with Signed"
  }
  instruction_groups {
    name: "ENCLU"
  }
  instruction_groups {
    name: "VPMOVQD/VPMOVSQD/VPMOVUSQD"
    short_description: "Down Convert QWord to DWord"
  }
  instruction_groups {
    name: "CVTSS2SD"
    short_description: "Convert Scalar Single-Precision Floating-Point Value to Scalar Double-Precision Floating-Point Value"
    description: "Converts a single-precision floating-point value in the \342\200\234convert-from\342\200\235 source operand to a double-precision floating-point value in the destination operand. When the \342\200\234convert-from\342\200\235 source operand is an XMM register, the single-precision floating-point value is contained in the low doubleword of the register. The result is stored in the low quadword of the destination operand.\n128-bit Legacy SSE version: The \342\200\234convert-from\342\200\235 source operand (the second operand) is an XMM register or memory location. Bits (MAXVL-1:64) of the corresponding destination register remain unchanged. The destination operand is an XMM register.\nVEX.128 and EVEX encoded versions: The \342\200\234convert-from\342\200\235 source operand (the third operand) can be an XMM register or a 32-bit memory location. The first source and destination operands are XMM registers. Bits (127:64) of the XMM register destination are copied from the corresponding bits in the first source operand. Bits (MAXVL- 1:128) of the destination register are zeroed.\nSoftware should ensure VCVTSS2SD is encoded with VEX.L=0. Encoding VCVTSS2SD with VEX.L=1 may encounter unpredictable behavior across different processor generations."
  }
  instruction_groups {
    name: "MOVDQA,VMOVDQA32/64"
    short_description: "Move Aligned Packed Integer Values"
  }
  instruction_groups {
    name: "MOVLHPS"
    short_description: "Move Packed Single-Precision Floating-Point Values Low to High"
  }
  instruction_groups {
    name: "VSCALEFPD"
    short_description: "Scale Packed Float64 Values With Float64 Values"
  }
  instruction_groups {
    name: "VSCALEFSS"
    short_description: "Scale Scalar Float32 Value With Float32 Value"
  }
  instruction_groups {
    name: "VMREAD"
    description: "Reads a specified field from a VMCS and stores it into a specified destination operand (register or memory). In VMX root operation, the instruction reads from the current VMCS. If executed in VMX non-root operation, the instruction reads from the VMCS referenced by the VMCS link pointer field in the current VMCS.\nThe VMCS field is specified by the VMCS-field encoding contained in the register source operand. Outside IA-32e mode, the source operand has 32 bits, regardless of the value of CS.D. In 64-bit mode, the source operand has 64 bits.\nThe effective size of the destination operand, which may be a register or in memory, is always 32 bits outside IA- 32e mode (the setting of CS.D is ignored with respect to operand size) and 64 bits in 64-bit mode. If the VMCS field specified by the source operand is shorter than this effective operand size, the high bits of the destination operand are cleared to 0. If the VMCS field is longer, then the high bits of the field are not read.\nNote that any faults resulting from accessing a memory destination operand can occur only after determining, in the operation section below, that the relevant VMCS pointer is valid and that the specified VMCS field is supported."
    flags_affected {
      content: "See the operation section and Section 30.2."
    }
  }
  instruction_groups {
    name: "ADD"
    short_description: "Add"
    description: "Adds the destination operand (first operand) and the source operand (second operand) and then stores the result in the destination operand. The destination operand can be a register or a memory location; the source operand can be an im\nmediate, a register, or a memory location. (However, two memory operands cannot be used in one instruction.) When an im mediate value is used as an operand, it is sign-extended to the length of the destination\noperand format.\nThe ADD instruction performs integer addition. It evaluates the result for both signed and unsigned integer operands and sets the CF and OF flags to indicate a carry (overflow) in the signed or unsigned result, respectively. The SF flag indicates the sign of the signed result.\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.\nIn 64-bit mode, the instruction\342\200\231s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the sum mary chart at the beginning of this section for encoding data and limits."
    flags_affected {
      content: "The OF, SF, ZF, AF, CF, and PF flags are set according to the result."
    }
  }
  instruction_groups {
    name: "CLDEMOTE"
    short_description: "Cache Line Demote"
    description: "Hints to hardware that the cache line that contains the linear address specified with the memory operand should be moved (\342\200\234demoted\342\200\235) from the cache(s) closest to the processor core to a level more distant from the processor core. This may accelerate subsequent accesses to the line by other cores in the same coherence domain, especially if the line was written by the core that demotes the line. Moving the line in such a manner is a performance optimization, i.e., it is a hint which does not modify architectural state. Hardware may choose which level in the cache hierarchy to retain the line (e.g., L3 in typical server designs). The source operand is a byte memory location.\nThe availability of the CLDEMOTE instruction is indicated by the presence of the CPUID feature flag CLDEMOTE (bit 25 of the ECX register in sub-leaf 07H, see \342\200\234CPUID-CPU Identification\342\200\235). On processors which do not support the CLDEMOTE instruction (including legacy hardware) the instruction will be treated as a NOP.\nA CLDEMOTE instruction is ordered with respect to stores to the same cache line, but unordered with respect to other instructions including memory fences, CLDEMOTE, CLWB or CLFLUSHOPT instructions to a different cache line. Since CLDEMOTE will retire in order with respect to stores to the same cache line, software should ensure that after issuing CLDEMOTE the line is not accessed again im mediately by the same core to avoid cache data move-\nment penalties.\nThe effective memory type of the page containing the affected line determines the effect; cacheable types are likely to generate a data movement operation, while uncacheable types may cause the instruction to be ignored.\nSpeculative fetching can occur at any time and is not tied to instruction execution. The CLDEMOTE instruction is not ordered with respect to PREFETCHh instructions or any of the speculative fetching mechanisms. That is, data can be speculatively loaded into a cache line just before, during, or after the execution of a CLDEMOTE instruction that references the cache line.\nUnlike CLFLUSH, CLFLUSHOPT and CLWB instructions, CLDEMOTE is not guaranteed to write back modified data to memory.\nThe CLDEMOTE instruction may be ignored by hardware in certain cases and is not a guarantee.\nThe CLDEMOTE instruction can be used at all privilege levels. In certain processor implementations the CLDEMOTE instruction may set the A bit but not the D bit in the page tables.\nIf the line is not found in the cache, the instruction will be treated as a NOP.\nIn some implementations, the CLDEMOTE instruction may always cause a transactional abort with Transactional Synchronization Extensions (TSX). However, program mers must not rely on CLDEMOTE instruction to force a\ntransactional abort.\n1.\tThe Mod field of the ModR/M byte cannot have value 11B."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "PCMPGTQ"
    short_description: "Compare Packed Data for Greater Than"
    description: "Performs an SIMD signed compare for the packed quadwords in the destination operand (first operand) and the source operand (second operand). If the data element in the first (destination) operand is greater than the corresponding element in the second (source) operand, the corresponding data element in the destination is set to all 1s; otherwise, it is set to 0s.\n128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The first source operand and destination operand are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source operand and destination operand are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.\nEVEX encoded VPCMPGTD/Q: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2."
    flags_affected {
      content: "None.\nSIMD Floating-Point Exceptions\nNone."
    }
  }
  instruction_groups {
    name: "PCMPESTRM"
    short_description: "Packed Compare Explicit Length Strings, Return Mask"
    description: "The instruction compares data from two string fragments based on the encoded value in the im m8 contol byte (see\nSection 4.1, \342\200\234Im m8 Control Byte Operation for PCMPESTRI / PCMPESTRM / PCMPISTRI / PCMPISTRM\342\200\235), and generates a mask stored to XMM0.\nEach string fragment is represented by two values. The first value is an xm m (or possibly m128 for the second operand) which contains the data elements of the string (byte or word data). The second value is stored in an input length register. The input length register is EAX/RAX (for xm m1) or EDX/RDX (for xm m2/m128). The length repre-\nsents the number of bytes/words which are valid for the respective xm m/m128 data.\nThe length of each input is interpreted as being the absolute-value of the value in the length register. The absolutevalue computation saturates to 16 (for bytes) and 8 (for words), based on the value of im m8[bit3] when the value\nin the length register is greater than 16 (8) or less than -16 (-8).\nThe comparison and aggregation operations are performed according to the encoded value of Im m8 bit fields (see\nSection 4.1). As defined by im m8[6], IntRes2 is then either stored to the least significant bits of XMM0 (zero extended to 128 bits) or expanded into a byte/word-mask and then stored to XMM0.\nNote that the Arithmetic Flags are written in a non-standard manner in order to supply the most relevant information:\nCFlag - Reset if IntRes2 is equal to zero, set otherwise ZFlag - Set if absolute-value of EDX is < 16 (8), reset otherwise SFlag - Set if absolute-value of EAX is < 16 (8), reset otherwise OFlag -IntRes2[0] AFlag - Reset PFlag - Reset\nNote: In VEX.128 encoded versions, bits (MAXVL-1:128) of XMM0 are zeroed. VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD."
  }
  instruction_groups {
    name: "ECREATE"
  }
  instruction_groups {
    name: "CVTSI2SD"
    short_description: "Convert Doubleword Integer to Scalar Double-Precision Floating-Point Value"
    description: "Converts a signed doubleword integer (or signed quadword integer if operand size is 64 bits) in the \342\200\234convert-from\342\200\235 source operand to a double-precision floating-point value in the destination operand. The result is stored in the low quadword of the destination operand, and the high quadword left unchanged. When conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.\nThe second source operand can be a general-purpose register or a 32/64-bit memory location. The first source and destination operands are XMM registers.\n128-bit Legacy SSE version: Use of the REX.W prefix promotes the instruction to 64-bit operands. The \342\200\234convertfrom\342\200\235 source operand (the second operand) is a general-purpose register or memory location. The destination is an XMM register Bits (MAXVL-1:64) of the corresponding destination register remain unchanged.\nVEX.128 and EVEX encoded versions: The \342\200\234convert-from\342\200\235 source operand (the third operand) can be a generalpurpose register or a memory location. The first source and destination operands are XMM registers. Bits (127:64) of the XMM register destination are copied from the corresponding bits in the first source operand. Bits (MAXVL- 1:128) of the destination register are zeroed.\nEVEX.W0 version: attempt to encode this instruction with EVEX embedded rounding is ignored.\nVEX.W1 and EVEX.W1 versions: promotes the instruction to use 64-bit input value in 64-bit mode.\nSoftware should ensure VCVTSI2SD is encoded with VEX.L=0. Encoding VCVTSI2SD with VEX.L=1 may encounter unpredictable behavior across different processor generations."
  }
  instruction_groups {
    name: "VFNMADD132PS/VFNMADD213PS/VFNMADD231PS"
    short_description: "Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "F2XM1"
    short_description: "Compute 2x-1"
    description: "Computes the exponential value of 2 to the power of the source operand minus 1. The source operand is located in register ST(0) and the result is also stored in ST(0). The value of the source operand must lie in the range -1.0 to +1.0. If the source value is outside this range, the result is undefined.\nThe following table shows the results obtained when computing the exponential value of various classes of numbers, assuming that neither overflow nor underflow occurs.\nTable 3-16.  Results Obtained from F2XM1\nST(0) SRC\tST(0) DEST\n\342\210\222 1.0 to \342\210\2220\t\342\210\222 0.5 to \342\210\222 0\n\342\210\222 0\t\342\210\222 0\n+ 0\t+ 0\n+ 0 to +1.0\t+ 0 to 1.0\nValues other than 2 can be exponentiated using the following formula:\nxy := 2(y \342\210\227 log 2\tx)\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C1\tSet to 0 if stack underflow occurred.\nSet if result was rounded up; cleared otherwise.\nC0, C2, C3\tUndefined."
    }
  }
  instruction_groups {
    name: "XORPS"
    short_description: "Bitwise Logical XOR of Packed Single Precision Floating-Point Values"
  }
  instruction_groups {
    name: "CVTTPS2DQ"
    short_description: "Convert with Truncation Packed Single-Precision Floating-Point Values to Packed Signed Doubleword Integer Values"
    description: "Converts four, eight or sixteen packed single-precision floating-point values in the source operand to four, eight or sixteen signed doubleword integers in the destination operand.\nWhen a conversion is inexact, a truncated (round toward zero) value is returned. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.\nEVEX encoded versions: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\nVEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\nVEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
  }
  instruction_groups {
    name: "VPERMI2W/D/Q/PS/PD"
    short_description: "Full Permute From Two Tables Overwriting the Index"
  }
  instruction_groups {
    name: "CVTTSS2SI"
    short_description: "Convert with Truncation Scalar Single-Precision Floating-Point Value to Integer"
    description: "Converts a single-precision floating-point value in the source operand (the second operand) to a signed doubleword integer (or signed quadword integer if operand size is 64 bits) in the destination operand (the first operand).\nThe source operand can be an XMM register or a 32-bit memory location. The destination operand is a general purpose register. When the source operand is an XMM register, the single-precision floating-point value is contained in the low doubleword of the register.\nWhen a conversion is inexact, a truncated (round toward zero) result is returned. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised. If this exception is masked, the indefinite integer value (80000000H or 80000000_00000000H if operand size is 64 bits) is returned.\nLegacy SSE instructions: In 64-bit mode, Use of the REX.W prefix promotes the instruction to 64-bit operation. See the sum\nmary chart at the beginning of this section for encoding data and limits.\nVEX.W1 and EVEX.W1 versions: promotes the instruction to produce 64-bit data in 64-bit mode.\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.\nSoftware should ensure VCVTTSS2SI is encoded with VEX.L=0. Encoding VCVTTSS2SI with VEX.L=1 may encounter unpredictable behavior across different processor generations."
  }
  instruction_groups {
    name: "PMADDUBSW"
    short_description: "Multiply and Add Packed Signed and Unsigned Bytes"
    description: "(V)PMADDUBSW multiplies vertically each unsigned byte of the destination operand (first operand) with the corresponding signed byte of the source operand (second operand), producing intermediate signed 16-bit integers. Each adjacent pair of signed words is added and the saturated result is packed to the destination operand. For example, the lowest-order bytes (bits 7-0) in the source and destination operands are multiplied and the intermediate signed word result is added with the corresponding intermediate result from the 2nd lowest-order bytes (bits 15-8) of the operands; the sign-saturated result is stored in the lowest word of the destination register (15-0). The same operation is performed on the other pairs of adjacent bytes. Both operands can be MMX register or XMM registers. When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.\nIn 64-bit mode and not encoded with VEX/EVEX, use the REX prefix to access XMM8-XMM15.\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\nVEX.128 and EVEX.128 encoded versions: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\nVEX.256 and EVEX.256 encoded versions: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.\nEVEX.512 encoded version: The second source operand can be an ZMM register or a 512-bit memory location. The first source and destination operands are ZMM registers."
  }
  instruction_groups {
    name: "ANDPS"
    short_description: "Bitwise Logical AND of Packed Single Precision Floating-Point Values"
    description: "Performs a bitwise logical AND of the four, eight or sixteen packed single-precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand.\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\nVEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified."
  }
  instruction_groups {
    name: "PMULLW"
    short_description: "Multiply Packed Signed Integers and Store Low Result"
    description: "Performs a SIMD signed multiply of the packed signed word integers in the destination operand (first operand) and the source operand (second operand), and stores the low 16 bits of each intermediate 32-bit result in the destination operand. (Figure 4-12 shows this operation when using 64-bit operands.)\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE version 64-bit operand: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register.\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed. VEX.L must be 0, otherwise the instruction will #UD.\nVEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1.\nSRC\tX3\tX2\tX1\tX0\nDEST\tY3\tY2\tY1\tY0\nTEMP\tZ3 = X3 \342\210\227 Y3\tZ2 = X2 \342\210\227 Y2\tZ1 = X1 \342\210\227 Y1\tZ0 = X0 \342\210\227 Y0\nDEST\tZ3[15:0]\tZ2[15:0]\tZ1[15:0]\tZ0[15:0]\nFigure 4-13.  PMULLU Instruction Operation Using 64-bit Operands"
    flags_affected {
      content: "None.\nSIMD Floating-Point Exceptions\nNone."
    }
  }
  instruction_groups {
    name: "MAXPD"
    short_description: "Maximum of Packed Double-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "STR"
    short_description: "Store Task Register"
    description: "Stores the segment selector from the task register (TR) in the destination operand. The destination operand can be a general-purpose register or a memory location. The segment selector stored with this instruction points to the task state segment (TSS) for the currently running task.\nWhen the destination operand is a 32-bit register, the 16-bit segment selector is copied into the lower 16 bits of the register and the upper 16 bits of the register are cleared. When the destination operand is a memory location, the segment selector is written to memory as a 16-bit quantity, regardless of operand size.\nIn 64-bit mode, operation is the same. The size of the memory operand is fixed at 16 bits. In register stores, the 2- byte TR is zero extended if stored to a 64-bit register.\nThe STR instruction is useful only in operating-system software. It can only be executed in protected mode."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "VSCALEFPS"
    short_description: "Scale Packed Float32 Values With Float32 Values"
  }
  instruction_groups {
    name: "MOV"
    short_description: "Move to/from Control Registers"
    description: "Moves the contents of a control register (CR0, CR2, CR3, CR4, or CR8) to a general-purpose register or the contents of a general purpose register to a control register. The operand size for these instructions is always 32 bits in non-64-bit modes, regardless of the operand-size attribute. (See \342\200\234Control Registers\342\200\235 in Chapter 2 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3A, for a detailed description of the flags and fields in the control registers.) This instruction can be executed only when the current privilege level is 0.\nAt the opcode level, the reg field within the ModR/M byte specifies which of the control registers is loaded or read.\nThe 2 bits in the mod field are ignored. The r/m field specifies the general-purpose register loaded or read.\nWhen loading control registers, programs should not attempt to change the reserved bits; that is, always set reserved bits to the value previously read. An attempt to change CR4\'s reserved bits will cause a general protection fault. Reserved bits in CR0 and CR3 remain clear after any load of those registers; attempts to set them have no impact. On Pentium 4, Intel Xeon and P6 family processors, CR0.ET remains set after any load of CR0; attempts to clear this bit have no impact.\nIn certain cases, these instructions have the side effect of invalidating entries in the TLBs and the paging-structure caches. See Section 4.10.4.1, \342\200\234Operations that Invalidate TLBs and Paging-Structure Caches,\342\200\235 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3A for details.\nThe following side effects are implementation-specific for the Pentium 4, Intel Xeon, and P6 processor family: when modifying PE or PG in register CR0, or PSE or PAE in register CR4, all TLB entries are flushed, including global entries. Software should not depend on this functionality in all Intel64 or IA-32 processors.\nIn 64-bit mode, the instruction\342\200\231s default operation size is 64 bits. The REX.R prefix must be used to access CR8. Use of REX.B permits access to additional registers (R8-R15). Use of the REX.W prefix or 66H prefix is ignored. Use of the REX.R prefix to specify a register other than CR8 causes an invalid-opcode exception. See the sum mary chart\nat the beginning of this section for encoding data and limits.\nIf CR4.PCIDE = 1, bit63 of the source operand to MOV to CR3 determines whether the instruction invalidates entries in the TLBs and the paging-structure caches (see Section 4.10.4.1, \342\200\234Operations that Invalidate TLBs and Paging-Structure Caches,\342\200\235 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3A). The instruction does not modify bit63 of CR3, which is reserved and always 0.\nSee \342\200\234Changes to Instruction Behavior in VMX Non-Root Operation\342\200\235 in Chapter 25 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3C, for more information about the behavior of this instruction in VMX non-root operation."
    flags_affected {
      content: "The OF, SF, ZF, AF, PF, and CF flags are undefined."
    }
  }
  instruction_groups {
    name: "VEXPANDPD"
    short_description: "Load Sparse Packed Double-Precision Floating-Point Values from Dense Memory"
  }
  instruction_groups {
    name: "VRSQRT28PD"
    short_description: "Approximation to the Reciprocal Square Root of Packed Double-Precision Floating-Point Values with Less Than 2^-28"
  }
  instruction_groups {
    name: "EGETKEY"
  }
  instruction_groups {
    name: "VPSRAVW/VPSRAVD/VPSRAVQ"
    short_description: "Variable Bit Shift Right Arithmetic"
  }
  instruction_groups {
    name: "PSUBB/PSUBW/PSUBD"
    short_description: "Subtract Packed Integers"
    description: "Performs a SIMD subtract of the packed integers of the source operand (second operand) from the packed integers of the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with wraparound, as described in the following paragraphs.\nThe (V)PSUBB instruction subtracts packed byte integers. When an individual result is too large or too small to be represented in a byte, the result is wrapped around and the low 8 bits are written to the destination element.\nThe (V)PSUBW instruction subtracts packed word integers. When an individual result is too large or too small to be represented in a word, the result is wrapped around and the low 16 bits are written to the destination element.\nThe (V)PSUBD instruction subtracts packed doubleword integers. When an individual result is too large or too small to be represented in a doubleword, the result is wrapped around and the low 32 bits are written to the destination element.\nNote that the (V)PSUBB, (V)PSUBW, and (V)PSUBD instructions can operate on either unsigned or signed (two\'s complement notation) packed integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of values upon which it operates.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE version 64-bit operand: The destination operand must be an MMX technology register and the source operand can be either an MMX technology register or a 64-bit memory location.\n128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded versions: The second source operand is an YMM register or an 256-bit memory location. The first source operand and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.\nEVEX encoded VPSUBD: The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1.\nEVEX encoded VPSUBB/W: The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "BTS"
    short_description: "Bit Test and Set"
    description: "Selects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by the bit offset operand (second operand), stores the value of the bit in the CF flag, and sets the selected bit in the bit string to 1. The bit base operand can be a register or a memory location; the bit offset operand can be a register or an im mediate value:\n\342\200\242\tIf the bit base operand specifies a register, the instruction takes the modulo 16, 32, or 64 of the bit offset operand (modulo size depends on the mode and register size; 64-bit operands are available only in 64-bit mode). This allows any bit position to be selected.\n\342\200\242\tIf the bit base operand specifies a memory location, the operand represents the address of the byte in memory that contains the bit base (bit 0 of the specified byte) of the bit string. The range of the bit position that can be referenced by the offset operand depends on the operand size.\nSee also: Bit(BitBase, BitOffset) on page 3-11.\nSome assemblers support im mediate bit offsets larger than 31 by using the im mediate bit offset field in combination with the displacement field of the memory operand. See \342\200\234BT-Bit Test\342\200\235 in this chapter for more information on this addressing mechanism.\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.\nIn 64-bit mode, the instruction\342\200\231s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the sum mary chart at the beginning of this section for encoding data and limits."
    flags_affected {
      content: "The CF flag contains the value of the selected bit before it is set. The ZF flag is unaffected. The OF, SF, AF, and PF flags are undefined."
    }
  }
  instruction_groups {
    name: "BLENDPD"
    short_description: "Blend Packed Double Precision Floating-Point Values"
    description: "Double-precision floating-point values from the second source operand (third operand) are conditionally merged with values from the first source operand (second operand) and written to the destination operand (first operand).\nThe im\nmediate bits [3:0] determine whether the corresponding double-precision floating-point value in the destination is copied from the second source or first source. If a bit in the mask, corresponding to a word, is \342\200\2351\342\200\235, then the double-precision floating-point value in the second source operand is copied, else the value in the first source operand is copied.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.\nVEX.128 encoded version: the first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register."
  }
  instruction_groups {
    name: "INT n/INTO/INT3/INT1"
    short_description: "Call to Interrupt Procedure"
    description: "The INT n instruction generates a call to the interrupt or exception handler specified with the destination operand (see the section titled \342\200\234Interrupts and Exceptions\342\200\235 in Chapter 6 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1). The destination operand specifies a vector from 0 to 255, encoded as an 8-bit unsigned intermediate value. Each vector provides an index to a gate descriptor in the IDT. The first 32 vectors are reserved by Intel for system use. Some of these vectors are used for internally generated exceptions.\nThe INT n instruction is the general mnemonic for executing a software-generated call to an interrupt handler. The INTO instruction is a special mnemonic for calling overflow exception (#OF), exception 4. The overflow interrupt checks the OF flag in the EFLAGS register and calls the overflow interrupt handler if the OF flag is set to 1. (The INTO instruction cannot be used in 64-bit mode.)\nThe INT3 instruction uses a one-byte opcode (CC) and is intended for calling the debug exception handler with a breakpoint exception (#BP). (This one-byte form is useful because it can replace the first byte of any instruction at which a breakpoint is desired, including other one-byte instructions, without overwriting other instructions.)\nThe INT1 instruction also uses a one-byte opcode (F1) and generates a debug exception (#DB) without setting any bits in DR6.1 Hardware vendors may use the INT1 instruction for hardware debug. For that reason, Intel recommends software vendors instead use the INT3 instruction for software breakpoints.\nAn interrupt generated by the INTO, INT3, or INT1 instruction differs from one generated by INT n in the following ways:\n\342\200\242\tThe normal IOPL checks do not occur in virtual-8086 mode. The interrupt is taken (without fault) with any IOPL value.\n\342\200\242\tThe interrupt redirection enabled by the virtual-8086 mode extensions (VME) does not occur. The interrupt is always handled by a protected-mode handler.\n(These features do not pertain to CD03, the \342\200\234normal\342\200\235 2-byte opcode for INT 3. Intel and Microsoft assemblers will not generate the CD03 opcode from any mnemonic, but this opcode can be created by direct numeric code definition or by self-modifying code.)\nThe action of the INT n instruction (including the INTO, INT3, and INT1 instructions) is similar to that of a far call made with the CALL instruction. The primary difference is that with the INT n instruction, the EFLAGS register is pushed onto the stack before the return address. (The return address is a far address consisting of the current values of the CS and EIP registers.) Returns from interrupt procedures are handled with the IRET instruction, which pops the EFLAGS information and return address from the stack.\nEach of the INT n, INTO, and INT3 instructions generates a general-protection exception (#GP) if the CPL is greater than the DPL value in the selected gate descriptor in the IDT. In contrast, the INT1 instruction can deliver a #DB\n1.\tThe mnemonic ICEBP has also been used for the instruction with opcode F1.\neven if the CPL is greater than the DPL of descriptor 1 in the IDT. (This behavior supports the use of INT1 by hardware vendors performing hardware debug.)\nThe vector specifies an interrupt descriptor in the interrupt descriptor table (IDT); that is, it provides index into the IDT. The selected interrupt descriptor in turn contains a pointer to an interrupt or exception handler procedure.\nIn protected mode, the IDT contains an array of 8-byte descriptors, each of which is an interrupt gate, trap gate, or task gate. In real-address mode, the IDT is an array of 4-byte far pointers (2-byte code segment selector and a 2-byte instruction pointer), each of which point directly to a procedure in the selected segment. (Note that in real-address mode, the IDT is called the interrupt vector table, and its pointers are called interrupt vectors.)\nThe following decision table indicates which action in the lower portion of the table is taken given the conditions in the upper portion of the table. Each Y in the lower section of the decision table represents a procedure defined in the \342\200\234Operation\342\200\235 section for this instruction (except #GP).\nTable 3-52.  Decision Table\nPE\t0\t1\t1\t1\t1\t1\t1\t1\nVM\t-\t-\t-\t-\t-\t0\t1\t1\nIOPL\t-\t-\t-\t-\t-\t-\t<3\t=3\nDPL/CPL RELATIONSHIP\t-\tDPL< CPL\t-\tDPL> CPL\tDPL= CPL or C\tDPL< CPL & NC\t-\t-\nINTERRUPT TYPE\t-\tS/W\t-\t-\t-\t-\t-\t-\nGATE TYPE\t-\t-\tTask\tTrap or Interrupt\tTrap or Interrupt\tTrap or Interrupt\tTrap or Interrupt\tTrap or Interrupt\nREAL-ADDRESS-MODE\tY\nPROTECTED-MODE\tY\tY\tY\tY\tY\tY\tY\nTRAP-OR-INTERRUPTGATE\tY\tY\tY\tY\tY\nINTER-PRIVILEGE-LEVELINTERRUPT\tY\nINTRA-PRIVILEGE-LEVELINTERRUPT\tY\nINTERRUPT-FROMVIRTUAL-8086-MODE\tY\nTASK-GATE\tY\n#GP\tY\tY\tY\nNOTES:\n\342\210\222\tDon\'t Care.\nY\tYes, action taken.\nBlank\tAction not taken.\nS/W\tApplies to INTn, INT3, and INTO, but not to INT1.\nWhen the processor is executing in virtual-8086 mode, the IOPL determines the action of the INT n instruction. If the IOPL is less than 3, the processor generates a #GP(selector) exception; if the IOPL is 3, the processor executes a protected mode interrupt to privilege level 0. The interrupt gate\'s DPL must be set to 3 and the target CPL of the interrupt handler procedure must be 0 to execute the protected mode interrupt to privilege level 0.\nThe interrupt descriptor table register (IDTR) specifies the base linear address and limit of the IDT. The initial base address value of the IDTR after the processor is powered up or reset is 0.\nRefer to Chapter 6, \342\200\234Procedure Calls, Interrupts, and Exceptions\342\200\235 and Chapter 18, \342\200\234Control-Flow Enforcement Technology (CET)\342\200\235 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1 for CET details.\nInstruction ordering. Instructions following an INT n may be fetched from memory before earlier instructions complete execution, but they will not execute (even speculatively) until all instructions prior to the INT n have completed execution (the later instructions may execute before data stored by the earlier instructions have become globally visible). This applies also to the INTO, INT3, and INT1 instructions, but not to executions of INTO when EFLAGS.OF = 0."
    flags_affected {
      content: "The EFLAGS register is pushed onto the stack. The IF, TF, NT, AC, RF, and VM flags may be cleared, depending on the mode of operation of the processor when the INT instruction is executed (see the \342\200\234Operation\342\200\235 section). If the interrupt uses a task gate, any flags may be set or cleared, controlled by the EFLAGS image in the new task\342\200\231s TSS."
    }
  }
  instruction_groups {
    name: "PMULUDQ"
    short_description: "Multiply Packed Unsigned Doubleword Integers"
    description: "Multiplies the first operand (destination operand) by the second operand (source operand) and stores the result in the destination operand.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE version 64-bit operand: The source operand can be an unsigned doubleword integer stored in the low doubleword of an MMX technology register or a 64-bit memory location. The destination operand can be an unsigned doubleword integer stored in the low doubleword an MMX technology register. The result is an unsigned\nquadword integer stored in the destination an MMX technology register. When a quadword result is too large to be represented in 64 bits (overflow), the result is wrapped around and the low 64 bits are written to the destination element (that is, the carry is ignored).\nFor 64-bit memory operands, 64 bits are fetched from memory, but only the low doubleword is used in the computation.\n128-bit Legacy SSE version: The second source operand is two packed unsigned doubleword integers stored in the first (low) and third doublewords of an XMM register or a 128-bit memory location. For 128-bit memory operands, 128 bits are fetched from memory, but only the first and third doublewords are used in the computation. The first source operand is two packed unsigned doubleword integers stored in the first and third doublewords of an XMM register. The destination contains two packed unsigned quadword integers stored in an XMM register. Bits (MAXVL- 1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The second source operand is two packed unsigned doubleword integers stored in the first (low) and third doublewords of an XMM register or a 128-bit memory location. For 128-bit memory operands, 128 bits are fetched from memory, but only the first and third doublewords are used in the computation. The first source operand is two packed unsigned doubleword integers stored in the first and third doublewords of an XMM register. The destination contains two packed unsigned quadword integers stored in an XMM register. Bits (MAXVL- 1:128) of the destination YMM register are zeroed.\nVEX.256 encoded version: The second source operand is four packed unsigned doubleword integers stored in the first (low), third, fifth and seventh doublewords of a YMM register or a 256-bit memory location. For 256-bit memory operands, 256 bits are fetched from memory, but only the first, third, fifth and seventh doublewords are used in the computation. The first source operand is four packed unsigned doubleword integers stored in the first, third, fifth and seventh doublewords of an YMM register. The destination contains four packed unaligned quadword integers stored in an YMM register.\nEVEX encoded version: The input unsigned doubleword integers are taken from the even-numbered elements of the source operands. The first source operand is a ZMM/YMM/XMM registers. The second source operand can be an ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64- bit memory location. The destination is a ZMM/YMM/XMM register, and updated according to the writemask at 64- bit granularity."
    flags_affected {
      content: "None.\nSIMD Floating-Point Exceptions\nNone."
    }
  }
  instruction_groups {
    name: "SAVEPREVSSP"
    short_description: "Save Previous Shadow Stack Pointer"
    description: "Push a restore-shadow-stack token on the previous shadow stack at the next 8 byte aligned boundary. The previous SSP is obtained from the previous-ssp token at the top of the current shadow stack."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "UCOMISD"
    short_description: "Unordered Compare Scalar Double-Precision Floating-Point Values and Set EFLAGS"
  }
  instruction_groups {
    name: "MOVUPS"
    short_description: "Move Unaligned Packed Single-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "VMCLEAR"
    description: "This instruction applies to the VMCS whose VMCS region resides at the physical address contained in the instruction operand. The instruction ensures that VMCS data for that VMCS (some of these data may be currently maintained on the processor) are copied to the VMCS region in memory. It also initializes parts of the VMCS region (for example, it sets the launch state of that VMCS to clear). See Chapter 24, \342\200\234Virtual-Machine Control Structures\342\200\235.\nThe operand of this instruction is always 64 bits and is always in memory. If the operand is the current-VMCS pointer, then that pointer is made invalid (set to FFFFFFFF_FFFFFFFFH).\nNote that the VMCLEAR instruction might not explicitly write any VMCS data to memory; the data may be already resident in memory before the VMCLEAR is executed."
    flags_affected {
      content: "See the operation section and Section 30.2.\n1.\tIf IA32_VMX_BASIC[48] is read as 1, VMfail occurs if addr sets any bits in the range 63:32; see Appendix A.1."
    }
  }
  instruction_groups {
    name: "ETRACKC"
  }
  instruction_groups {
    name: "VCVTTPS2QQ"
    short_description: "Convert with Truncation Packed Single Precision Floating-Point Values to Packed Signed Quadword Integer Values"
  }
  instruction_groups {
    name: "SWAPGS"
    short_description: "Swap GS Base Register"
    description: "SWAPGS exchanges the current GS base register value with the value contained in MSR address C0000102H (IA32_KERNEL_GS_BASE). The SWAPGS instruction is a privileged instruction intended for use by system software.\nWhen using SYSCALL to implement system calls, there is no kernel stack at the OS entry point. Neither is there a straightforward method to obtain a pointer to kernel structures from which the kernel stack pointer could be read.\nThus, the kernel cannot save general purpose registers or reference memory.\nBy design, SWAPGS does not require any general purpose registers or memory operands. No registers need to be saved before using the instruction. SWAPGS exchanges the CPL 0 data pointer from the IA32_KERNEL_GS_BASE MSR with the GS base register. The kernel can then use the GS prefix on normal memory references to access kernel data structures. Similarly, when the OS kernel is entered using an interrupt or exception (where the kernel stack is already set up), SWAPGS can be used to quickly get a pointer to the kernel data structures.\nThe IA32_KERNEL_GS_BASE MSR itself is only accessible using RDMSR/WRMSR instructions. Those instructions are only accessible at privilege level 0. The WRMSR instruction ensures that the IA32_KERNEL_GS_BASE MSR contains a canonical address."
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "XRSTOR"
    short_description: "Restore Processor Extended States"
    description: "Performs a full or partial restore of processor state components from the XSAVE area located at the memory address specified by the source operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask.\nThe specific state components restored correspond to the bits set in the requested-feature bitmap (RFBM), which is the logical-AND of EDX:EAX and XCR0.\nThe format of the XSAVE area is detailed in Section 13.4, \342\200\234XSAVE Area,\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1. Like FXRSTOR and FXSAVE, the memory format used for x87 state depends on a REX.W prefix; see Section 13.5.1, \342\200\234x87 State\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1.\nSection 13.8, \342\200\234Operation of XRSTOR,\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1 provides a detailed description of the operation of the XRSTOR instruction. The following items provide a highlevel outline:\n\342\200\242\tExecution of XRSTOR may take one of two forms: standard and compacted. Bit63 of the XCOMP_BV field in the XSAVE header determines which form is used: value 0 specifies the standard form, while value 1 specifies the compacted form.\n\342\200\242\tIf RFBM[i]\t= 0, XRSTOR does not update state component i.1\n\342\200\242\tIf RFBM[i] = 1 and biti is clear in the XSTATE_BV field in the XSAVE header, XRSTOR initializes state component i.\n\342\200\242\tIf RFBM[i]\t= 1 and XSTATE_BV[i]\t= 1, XRSTOR loads state componenti from the XSAVE area.\n\342\200\242\tThe standard form of XRSTOR treats MXCSR (which is part of state component 1 - SSE) differently from the XMM registers. If either form attempts to load MXCSR with an illegal value, a general-protection exception (#GP) occurs.\n\342\200\242\tXRSTOR loads the internal value XRSTOR_INFO, which may be used to optimize a subsequent execution of XSAVEOPT or XSAVES.\n\342\200\242\tIm mediately following an execution of XRSTOR, the processor tracks as in-use (not in initial configuration) any state componenti for which RFBM[i] = 1 and XSTATE_BV[i] = 1; it tracks as modified any state component\nifor which RFBM[i]\t= 0.\nUse of a source operand not aligned to 64-byte boundary (for 64-bit and 32-bit modes) results in a general-protection (#GP) exception. In 64-bit mode, the upper 32 bits of RDX and RAX are ignored.\nSee Section 13.6, \342\200\234Processor Tracking of XSAVE-Managed State,\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1 for discussion of the bitmaps XINUSE and XMODIFIED and of the quantity XRSTOR_INFO.\n1.\tThere is an exception if RFBM[1]= 0 and RFBM[2]= 1. In this case, the standard form of XRSTOR will load MXCSR from memory, even though MXCSR is part of state component 1 - SSE. The compacted form of XRSTOR does not make this exception."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "PMADDWD"
    short_description: "Multiply and Add Packed Integers"
    description: "Multiplies the individual signed words of the destination operand (first operand) by the corresponding signed words of the source operand (second operand), producing temporary signed, doubleword results. The adjacent doubleword results are then sum\nmed and stored in the destination operand. For example, the corresponding low-order words (15-0) and (31-16) in the source and destination operands are multiplied by one another and the doubleword results are added together and stored in the low doubleword of the destination register (31-0). The same operation is performed on the other pairs of adjacent words. (Figure 4-11 shows this operation when using 64-bit\noperands).\nThe (V)PMADDWD instruction wraps around only in one situation: when the 2 pairs of words being operated on in a group are all 8000H. In this case, the result wraps around to 80000000H.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE version: The first source and destination operands are MMX registers. The second source operand is an MMX register or a 64-bit memory location.\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.\nEVEX.512 encoded version: The second source operand can be an ZMM register or a 512-bit memory location. The first source and destination operands are ZMM registers.\nSRC\tX3\tX2\tX1\tX0\nDEST\tY3\tY2\tY1\tY0\nTEMP\tX3 \342\210\227 Y3\tX2 \342\210\227 Y2\tX1 \342\210\227 Y1\tX0 \342\210\227 Y0\nDEST\t(X3\342\210\227Y3) + (X2\342\210\227Y2) (X1\342\210\227Y1) + (X0\342\210\227Y0)\nFigure 4-11.  PMADDWD Execution Model Using 64-bit Operands"
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "POPF/POPFD/POPFQ"
    short_description: "Pop Stack into EFLAGS Register"
    description: "Pops a doubleword (POPFD) from the top of the stack (if the current operand-size attribute is 32) and stores the value in the EFLAGS register, or pops a word from the top of the stack (if the operand-size attribute is 16) and stores it in the lower 16 bits of the EFLAGS register (that is, the FLAGS register). These instructions reverse the operation of the PUSHF/PUSHFD/PUSHFQ instructions.\nThe POPF (pop flags) and POPFD (pop flags double) mnemonics reference the same opcode. The POPF instruction is intended for use when the operand-size attribute is 16; the POPFD instruction is intended for use when the operand-size attribute is 32. Some assemblers may force the operand size to 16 for POPF and to 32 for POPFD.\nOthers may treat the mnemonics as synonyms (POPF/POPFD) and use the setting of the operand-size attribute to determine the size of values to pop from the stack.\nThe effect of POPF/POPFD on the EFLAGS register changes, depending on the mode of operation. See Table 4-15 and the key below for details.\nWhen operating in protected, compatibility, or 64-bit mode at privilege level 0 (or in real-address mode, the equivalent to privilege level 0), all non-reserved flags in the EFLAGS register except RF1, VIP, VIF, and VM may be modified. VIP, VIF and VM remain unaffected.\nWhen operating in protected, compatibility, or 64-bit mode with a privilege level greater than 0, but less than or equal to IOPL, all flags can be modified except the IOPL field and RF, IF, VIP, VIF, and VM; these remain unaffected.\nThe AC and ID flags can only be modified if the operand-size attribute is 32. The interrupt flag (IF) is altered only when executing at a level at least as privileged as the IOPL. If a POPF/POPFD instruction is executed with insufficient privilege, an exception does not occur but privileged bits do not change.\nWhen operating in virtual-8086 mode (EFLAGS.VM = 1) without the virtual-8086 mode extensions (CR4.VME = 0), the POPF/POPFD instructions can be used only if IOPL = 3; otherwise, a general-protection exception (#GP) occurs. If the virtual-8086 mode extensions are enabled (CR4.VME = 1), POPF (but not POPFD) can be executed in virtual-8086 mode with IOPL < 3.\n(The protected-mode virtual-interrupt feature - enabled by setting CR4.PVI - affects the CLI and STI instructions in the same manner as the virtual-8086 mode extensions. POPF, however, is not affected by CR4.PVI.)\nIn 64-bit mode, the mnemonic assigned is POPFQ (note that the 32-bit operand is not encodable). POPFQ pops 64 bits from the stack. Reserved bits of RFLAGS (including the upper 32 bits of RFLAGS) are not affected.\nSee Chapter 3 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1, for more information about the EFLAGS registers.\n1.\tRF is always zero after the execution of POPF. This is because POPF, like all instructions, clears RF as it begins to execute.\nTable 4-15.  Effect of POPF/POPFD on the EFLAGS Register\nFlags\nMode\tOperand Size\tCPL\tIOPL\t21\t20\t19\t18\t17\t16\t14\t13:12\t11\t10\t9\t8\t7\t6\t4\t2\t0\tNotes\nID\tVIP\tVIF\tAC\tVM\tRF\tNT\tIOPL\tOF\tDF\tIF\tTF\tSF\tZF\tAF\tPF\tCF\nReal-Address Mode (CR0.PE = 0)\t16 32\t0 0\t0-3 0-3\tN S\tN N\tN N\tN S\tN N\t0 0\tS S\tS S\tS S\tS S\tS S\tS S\tS S\tS S\tS S\tS S\tS S\n16\t0\t0-3\tN\tN\tN\tN\tN\t0\tS\tS\tS\tS\tS\tS\tS\tS\tS\tS\tS\nProtected, Compatibility, and 64-Bit Modes\t16 16\t1-3 1-3\t<CPL \342\211\245CPL\tN N\tN N\tN N\tN N\tN N\t0 0\tS S\tN N\tS S\tS S\tN S\tS S\tS S\tS S\tS S\tS S\tS S\n32, 64\t0\t0-3\tS\tN\tN\tS\tN\t0\tS\tS\tS\tS\tS\tS\tS\tS\tS\tS\tS\n(CR0.PE = 1 EFLAGS.VM = 0)\t32, 64\t1-3\t<CPL\tS\tN\tN\tS\tN\t0\tS\tN\tS\tS\tN\tS\tS\tS\tS\tS\tS\n32, 64\t1-3\t\342\211\245CPL\tS\tN\tN\tS\tN\t0\tS\tN\tS\tS\tS\tS\tS\tS\tS\tS\tS\n16\t3\t0-2\tX\tX\tX\tX\tX\tX\tX\tX\tX\tX\tX\tX\tX\tX\tX\tX\tX\t1\nVirtual-8086 (CR0.PE = 1 EFLAGS.VM = 1 CR4.VME = 0)\t16 32\t3 3\t3 0-2\tN X\tN X\tN X\tN X\tN X\t0 X\tS X\tN X\tS X\tS X\tS X\tS X\tS X\tS X\tS X\tS X\tS X\t1\n32\t3\t3\tS\tN\tN\tS\tN\t0\tS\tN\tS\tS\tS\tS\tS\tS\tS\tS\tS\n16\t3\t0-2\tN/ X\tN/ X\tSV/ X\tN/ X\tN/ X\t0/ X\tS/ X\tN/X\tS/ X\tS/ X\tN/ X\tS/ X\tS/ X\tS/ X\tS/ X\tS/ X\tS/ X\t2,3\nVME (CR0.PE = 1 EFLAGS.VM = 1 CR4.VME = 1)\t16 32\t3 3\t3 0-2\tN X\tN X\tN X\tN X\tN X\t0 X\tS X\tN X\tS X\tS X\tS X\tS X\tS X\tS X\tS X\tS X\tS X\t1\n32\t3\t3\tS\tN\tN\tS\tN\t0\tS\tN\tS\tS\tS\tS\tS\tS\tS\tS\tS\nNOTES:\n1. #GP fault - no flag update 2. #GP fault with no flag update if VIP=1 in EFLAGS register and IF=1 in FLAGS value on stack 3. #GP fault with no flag update if TF=1 in FLAGS value on stack\nKey\nS\tUpdated from stack\nSV\tUpdated from IF (bit 9) in FLAGS value on stack\nN\tNo change in value\nX\tNo EFLAGS update\n0\tValue is cleared"
    flags_affected {
      content: "All flags may be affected; see the Operation section for details."
    }
  }
  instruction_groups {
    name: "LZCNT"
    short_description: "Count the Number of Leading Zero Bits"
    description: "Counts the number of leading most significant zero bits in a source operand (second operand) returning the result into a destination (first operand).\nLZCNT differs from BSR. For example, LZCNT will produce the operand size when the input operand is zero. It should be noted that on processors that do not support LZCNT, the instruction byte encoding is executed as BSR.\nIn 64-bit mode 64-bit operand size requires REX.W =1."
    flags_affected {
      content: "ZF flag is set to 1 in case of zero output (most significant bit of the source is set), and to 0 otherwise, CF flag is set to 1 if input was zero and cleared otherwise. OF, SF, PF and AF flags are undefined."
    }
  }
  instruction_groups {
    name: "KMOVW/KMOVB/KMOVQ/KMOVD"
    short_description: "Move from and to Mask Registers"
    description: "Copies values from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be mask registers, memory location or general purpose. The instruction cannot be used to transfer data between general purpose registers and or memory locations.\nWhen moving to a mask register, the result is zero extended to MAX_KL size (i.e., 64 bits currently). When moving to a general-purpose register (GPR), the result is zero-extended to the size of the destination. In 32-bit mode, the default GPR destination\342\200\231s size is 32 bits. In 64-bit mode, the default GPR destination\342\200\231s size is 64 bits. Note that VEX.W can only be used to modify the size of the GPR operand in 64b mode."
    flags_affected {
      content: "None\nSIMD Floating-Point Exceptions\nNone"
    }
  }
  instruction_groups {
    name: "UMONITOR"
    short_description: "User Level Set Up Monitor Address"
    description: "The UMONITOR instruction arms address monitoring hardware using an address specified in the source register (the address range that the monitoring hardware checks for store operations can be determined by using the CPUID monitor leaf function, EAX=05H). A store to an address within the specified address range triggers the monitoring hardware. The state of monitor hardware is used by UM WAIT.\nThe content of the source register is an effective address. By default, the DS segment is used to create a linear address that is monitored. Segment overrides can be used. The address range must use memory of the write-back type. Only write-back memory is guaranteed to correctly trigger the monitoring hardware. Additional information on determining what address range to use in order to prevent false wake-ups is described in Chapter 8, \342\200\234MultipleProcessor Management\342\200\235 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3A.\nThe UMONITOR instruction is ordered as a load operation with respect to other memory transactions. The instruction is subject to the permission checking and faults associated with a byte load. Like a load, UMONITOR sets the A-bit but not the D-bit in page tables.\nUMONITOR and UM WAIT are available when CPUID.7.0:ECX.WAITPKG[bit 5] is enumerated as 1. UMONITOR and\nUM WAIT may be executed at any privilege level. Except for the width of the source register, the instruction\342\200\231s operation is the same in non-64-bit modes and in 64-bit mode.\nUMONITOR does not interoperate with the legacy M WAIT instruction. If UMONITOR was executed prior to executing\nM WAIT and following the most recent execution of the legacy MONITOR instruction, M WAIT will not enter an opti-\nmized state. Execution will continue to the instruction following M WAIT.\nThe UMONITOR instruction causes a transactional abort when used inside a transactional region.\nThe width of the source register (16b, 32b or 64b) is determined by the effective addressing width, which is affected in the standard way by the machine mode settings and 67 prefix."
  }
  instruction_groups {
    name: "VCOMPRESSPS"
    short_description: "Store Sparse Packed Single-Precision Floating-Point Values into Dense Memory"
  }
  instruction_groups {
    name: "VPGATHERDQ/VPGATHERQQ"
    short_description: "Gather Packed Qword Values Using Signed Dword/Qword Indices"
    description: "The instruction conditionally loads up to 2 or 4 qword values from memory addresses specified by the memory operand (the second operand) and using qword indices. The memory operand uses the VSIB form of the SIB byte to specify a general purpose register operand as the com mon base, a vector register for an array of indices relative\nto the base and a constant scale factor.\nThe mask operand (the third operand) specifies the conditional load operation from each memory address and the corresponding update of each data element of the destination operand (the first operand). Conditionality is specified by the most significant bit of each data element of the mask register. If an element\342\200\231s mask bit is not set, the corresponding element of the destination register is left unchanged. The width of data element in the destination register and mask register are identical. The entire mask register will be set to zero by this instruction unless the instruction causes an exception.\nUsing dword indices in the lower half of the mask register, the instruction conditionally loads up to 2 or 4 qword values from the VSIB addressing memory operand, and updates the destination register.\nThis instruction can be suspended by an exception if at least one element is already gathered (i.e., if the exception is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination register and the mask operand are partially updated; those elements that have been gathered are placed into the destination register and have their mask bits set to zero. If any traps or interrupts are pending from already gathered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction breakpoint is not re-triggered when the instruction is continued.\nIf the data size and index size are different, part of the destination register and part of the mask register do not correspond to any elements being gathered. This instruction sets those parts to zero. It may do this to one or both of those registers even if the instruction triggers an exception, and even if the instruction triggers the exception before gathering any elements.\nVEX.128 version: The instruction will gather two qword values. For dword indices, only the lower two indices in the vector index register are used.\nVEX.256 version: The instruction will gather four qword values. For dword indices, only the lower four indices in the vector index register are used.\nNote that:\n\342\200\242\tIf any pair of the index, mask, or destination registers are the same, this instruction results a UD fault.\n\342\200\242\tThe values may be read from memory in any order. Memory ordering with other instructions follows the Intel- 64 memory-ordering model.\n\342\200\242\tFaults are delivered in a right-to-left manner. That is, if a fault is triggered by an element and delivered, all elements closer to the LSB of the destination will be completed (and non-faulting). Individual elements closer to the MSB may or may not be completed. If a given element triggers multiple faults, they are delivered in the conventional order.\n\342\200\242\tElements may be gathered in any order, but faults must be delivered in a right-to-left order; thus, elements to the left of a faulting one may be gathered before the fault is delivered. A given implementation of this instruction is repeatable - given the same input values and architectural state, the same set of elements to the left of the faulting one will be gathered.\n\342\200\242\tThis instruction does not perform AC checks, and so will never deliver an AC fault.\n\342\200\242\tThis instruction will cause a #UD if the address size attribute is 16-bit.\n\342\200\242\tThis instruction will cause a #UD if the memory operand is encoded without the SIB byte.\n\342\200\242\tThis instruction should not be used to access memory mapped I/O as the ordering of the individual loads it does is implementation specific, and some implementations may use loads larger than the data element size or load elements an indeterminate number of times.\n\342\200\242\tThe scaled index may require more bits to represent than the address bits used by the processor (e.g., in 32- bit mode, if the scale is greater than one). In this case, the most significant bits beyond the number of address bits are ignored."
  }
  instruction_groups {
    name: "XRSTORS"
    short_description: "Restore Processor Extended States Supervisor"
    description: "Performs a full or partial restore of processor state components from the XSAVE area located at the memory address specified by the source operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components restored correspond to the bits set in the requested-feature bitmap (RFBM), which is the logical-AND of EDX:EAX and the logical-OR of XCR0 with the IA32_XSS MSR. XRSTORS may be executed only if CPL = 0.\nThe format of the XSAVE area is detailed in Section 13.4, \342\200\234XSAVE Area,\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1. Like FXRSTOR and FXSAVE, the memory format used for x87 state depends on a REX.W prefix; see Section 13.5.1, \342\200\234x87 State\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1.\nSection 13.12, \342\200\234Operation of XRSTORS,\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1 provides a detailed description of the operation of the XRSTOR instruction. The following items provide a high-level outline:\n\342\200\242\tExecution of XRSTORS is similar to that of the compacted form of XRSTOR; XRSTORS cannot restore from an XSAVE area in which the extended region is in the standard format (see Section 13.4.3, \342\200\234Extended Region of an XSAVE Area\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1).\n\342\200\242\tXRSTORS differs from XRSTOR in that it can restore state components corresponding to bits set in the IA32_XSS MSR.\n\342\200\242\tIf RFBM[i]\t= 0, XRSTORS does not update state component i.\n\342\200\242\tIf RFBM[i] = 1 and biti is clear in the XSTATE_BV field in the XSAVE header, XRSTORS initializes state component i.\n\342\200\242\tIf RFBM[i]\t= 1 and XSTATE_BV[i]\t= 1, XRSTORS loads state componenti from the XSAVE area.\n\342\200\242\tIf XRSTORS attempts to load MXCSR with an illegal value, a general-protection exception (#GP) occurs.\n\342\200\242\tXRSTORS loads the internal value XRSTOR_INFO, which may be used to optimize a subsequent execution of XSAVEOPT or XSAVES.\n\342\200\242\tIm mediately following an execution of XRSTORS, the processor tracks as in-use (not in initial configuration) any state componenti for which RFBM[i] = 1 and XSTATE_BV[i] = 1; it tracks as modified any state component\nifor which RFBM[i]\t= 0.\nUse of a source operand not aligned to 64-byte boundary (for 64-bit and 32-bit modes) results in a general-protection (#GP) exception. In 64-bit mode, the upper 32 bits of RDX and RAX are ignored.\nSee Section 13.6, \342\200\234Processor Tracking of XSAVE-Managed State,\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1 for discussion of the bitmaps XINUSE and XMODIFIED and of the quantity XRSTOR_INFO."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "INVPCID"
    short_description: "Invalidate Process-Context Identifier"
    description: "Invalidates mappings in the translation lookaside buffers (TLBs) and paging-structure caches based on processcontext identifier (PCID). (See Section 4.10, \342\200\234Caching Translation Information,\342\200\235 in Intel64 and IA-32 Architecture Software Developer\342\200\231s Manual, Volume 3A.) Invalidation is based on the INVPCID type specified in the register operand and the INVPCID descriptor specified in the memory operand.\nOutside 64-bit mode, the register operand is always 32 bits, regardless of the value of CS.D. In 64-bit mode the register operand has 64 bits.\nThere are four INVPCID types currently defined:\n\342\200\242\tIndividual-address invalidation: If the INVPCID type is 0, the logical processor invalidates mappings-except global translations-for the linear address and PCID specified in the INVPCID descriptor.1 In some cases, the instruction may invalidate global translations or mappings for other linear addresses (or other PCIDs) as well.\n\342\200\242\tSingle-context invalidation: If the INVPCID type is 1, the logical processor invalidates all mappings-except global translations-associated with the PCID specified in the INVPCID descriptor. In some cases, the instruction may invalidate global translations or mappings for other PCIDs as well.\n\342\200\242\tAll-context invalidation, including global translations: If the INVPCID type is 2, the logical processor invalidates all mappings-including global translations-associated with any PCID.\n\342\200\242\tAll-context invalidation: If the INVPCID type is 3, the logical processor invalidates all mappings-except global translations-associated with any PCID. In some case, the instruction may invalidate global translations as well.\nThe INVPCID descriptor comprises 128 bits and consists of a PCID and a linear address as shown in Figure 3-24.\nFor INVPCID type 0, the processor uses the full 64 bits of the linear address even outside 64-bit mode; the linear address is not used for other INVPCID types.\n127\t6463\t1211\t0\nLinear Address\tReserved (must be zero)\tPCID\nFigure 3-24.  INVPCID Descriptor\n1.\tIf the paging structures map the linear address using a page larger than 4 KBytes and there are multiple TLB entries for that page (see Section 4.10.2.3, \342\200\234Details of TLB Use,\342\200\235 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3A), the instruction invalidates all of them.\nIf CR4.PCIDE = 0, a logical processor does not cache information for any PCID other than 000H. In this case, executions with INVPCID types 0 and 1 are allowed only if the PCID specified in the INVPCID descriptor is 000H; executions with INVPCID types 2 and 3 invalidate mappings only for PCID 000H. Note that CR4.PCIDE must be 0 outside IA-32e mode (see Chapter 4.10.1, \342\200\234Process-Context Identifiers (PCIDs)\342\200\232\342\200\235 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3A)."
  }
  instruction_groups {
    name: "ADCX"
    short_description: "Unsigned Integer Addition of Two Operands with Carry Flag"
    description: "Performs an unsigned addition of the destination operand (first operand), the source operand (second operand) and the carry-flag (CF) and stores the result in the destination operand. The destination operand is a generalpurpose register, whereas the source operand can be a general-purpose register or memory location. The state of CF can represent a carry from a previous addition. The instruction sets the CF flag with the carry generated by the unsigned addition of the operands.\nThe ADCX instruction is executed in the context of multi-precision addition, where we add a series of operands with a carry-chain. At the beginning of a chain of additions, we need to make sure the CF is in a desired initial state.\nOften, this initial state needs to be 0, which can be achieved with an instruction to zero the CF (e.g. XOR).\nThis instruction is supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64- bit mode.\nIn 64-bit mode, the default operation size is 32 bits. Using a REX Prefix in the form of REX.R permits access to additional registers (R8-15). Using REX Prefix in the form of REX.W promotes operation to 64 bits.\nADCX executes normally either inside or outside a transaction region.\nNote: ADCX defines the OF flag differently than the ADD/ADC instructions as defined in Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 2A."
    flags_affected {
      content: "CF is updated based on result. OF, SF, ZF, AF and PF flags are unmodified."
    }
  }
  instruction_groups {
    name: "VPCMPD/VPCMPUD"
    short_description: "Compare Packed Integer Values into Mask"
  }
  instruction_groups {
    name: "ANDN"
    short_description: "Logical AND NOT"
    description: "Performs a bitwise logical AND of inverted second operand (the first source operand) with the third operand (the second source operand). The result is stored in the first operand (destination operand).\nThis instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD."
    flags_affected {
      content: "SF and ZF are updated based on result. OF and CF flags are cleared. AF and PF flags are undefined."
    }
  }
  instruction_groups {
    name: "VGETMANTSS"
    short_description: "Extract Float32 Vector of Normalized Mantissa from Float32 Vector"
  }
  instruction_groups {
    name: "CLI"
    short_description: "Clear Interrupt Flag"
    description: "In most cases, CLI clears the IF flag in the EFLAGS register and no other flags are affected. Clearing the IF flag causes the processor to ignore maskable external interrupts. The IF flag and the CLI and STI instruction have no effect on the generation of exceptions and NMI interrupts.\nOperation is different in two modes defined as follows:\n\342\200\242\tPVI mode (protected-mode virtual interrupts): CR0.PE\t= 1, EFLAGS.VM\t= 0, CPL\t= 3, and CR4.PVI\t= 1;\n\342\200\242\tVME mode (virtual-8086 mode extensions): CR0.PE\t= 1, EFLAGS.VM\t= 1, and CR4.VME\t= 1.\nIf IOPL < 3 and either VME mode or PVI mode is active, CLI clears the VIF flag in the EFLAGS register, leaving IF unaffected.\nTable 3-7 indicates the action of the CLI instruction depending on the processor operating mode, IOPL, and CPL.\nTable 3-7.  Decision Table for CLI Results\nMode\tIOPL\tCLI Result\nReal-address\tX1\tIF = 0\n\342\211\245 CPL\tIF = 0\nProtected, not PVI2\n< CPL\t#GP fault\n3\tIF = 0\nProtected, PVI3\n0-2\tVIF = 0\n3\tIF = 0\nVirtual-8086, not VME3\n0-2\t#GP fault\n3\tIF = 0\nVirtual-8086, VME3\n0-2\tVIF = 0\nNOTES:\n1. X = This setting has no effect on instruction operation.\n2. For this table, \342\200\234protected mode\342\200\235 applies whenever CR0.PE= 1 and EFLAGS.VM= 0; it includes compatibility mode and 64-bit mode.\n3. PVI mode and virtual-8086 mode each imply CPL= 3."
    flags_affected {
      content: "Either the IF flag or the VIF flag is cleared to 0. Other flags are unaffected."
    }
  }
  instruction_groups {
    name: "RSM"
    short_description: "Resume from System Management Mode"
    description: "Returns program control from system management mode (SMM) to the application program or operating-system procedure that was interrupted when the processor received an SMM interrupt. The processor\342\200\231s state is restored from the dump created upon entering SMM. If the processor detects invalid state information during state restoration, it enters the shutdown state. The following invalid information can cause a shutdown:\n\342\200\242\tAny reserved bit of CR4 is set to 1.\n\342\200\242\tAny illegal combination of bits in CR0, such as (PG=1 and PE=0) or (NW=1 and CD=0).\n\342\200\242\t(Intel Pentium and Intel486\342\204\242 processors only.) The value stored in the state dump base field is not a 32-KByte aligned address.\nThe contents of the model-specific registers are not affected by a return from SMM.\nThe SMM state map used by RSM supports resuming processor context for non-64-bit modes and 64-bit mode.\nSee Chapter 34, \342\200\234System Management Mode,\342\200\235 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3C, for more information about SMM and the behavior of the RSM instruction."
    flags_affected {
      content: "All."
    }
  }
  instruction_groups {
    name: "VFMADD132PS/VFMADD213PS/VFMADD231PS"
    short_description: "Fused Multiply-Add of Packed Single-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "EBLOCK"
  }
  instruction_groups {
    name: "ROUNDSS"
    short_description: "Round Scalar Single Precision Floating-Point Values"
    description: "Round the single-precision floating-point value in the lowest dword of the source operand (second operand) using the rounding mode specified in the im\nmediate operand (third operand) and place the result in the destination operand (first operand). The rounding process rounds a single-precision floating-point input to an integer value and returns the result as a single-precision floating-point value in the lowest position. The upper three single-precision floating-point values in the destination are retained.\nThe im mediate operand specifies control fields for the rounding operation, three bit fields are defined and shown in\nFigure 4-24. Bit 3 of the im mediate byte controls processor behavior for a precision exception, bit 2 selects the source of rounding mode control. Bits 1:0 specify a non-sticky rounding-mode value (Table 4-17 lists the encoded values for rounding-mode field).\nThe Precision Floating-Point Exception is signaled according to the im mediate operand. If any source operand is an SNaN then it will be converted to a QNaN. If DAZ is set to \342\200\2301 then denormals will be converted to zero before rounding.\n128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL- 1:32) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: Bits (MAXVL-1:128) of the destination YMM register are zeroed."
  }
  instruction_groups {
    name: "EPA"
  }
  instruction_groups {
    name: "SCAS/SCASB/SCASW/SCASD"
    short_description: "Scan String"
    description: "In non-64-bit modes and in default 64-bit mode: this instruction compares a byte, word, doubleword or quadword specified using a memory operand with the value in AL, AX, or EAX. It then sets status flags in EFLAGS recording the results. The memory operand address is read from ES:(E)DI register (depending on the address-size attribute of the instruction and the current operational mode). Note that ES cannot be overridden with a segment override prefix.\nAt the assembly-code level, two forms of this instruction are allowed. The explicit-operand form and the no-operands form. The explicit-operand form (specified using the SCAS mnemonic) allows a memory operand to be specified explicitly. The memory operand must be a symbol that indicates the size and location of the operand value. The register operand is then automatically selected to match the size of the memory operand (AL register for byte comparisons, AX for word comparisons, EAX for doubleword comparisons). The explicit-operand form is provided to allow documentation. Note that the documentation provided by this form can be misleading. That is, the memory operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword) but it does not have to specify the correct location. The location is always specified by ES:(E)DI.\nThe no-operands form of the instruction uses a short form of SCAS. Again, ES:(E)DI is assumed to be the memory operand and AL, AX, or EAX is assumed to be the register operand. The size of operands is selected by the mnemonic: SCASB (byte comparison), SCASW (word comparison), or SCASD (doubleword comparison).\nAfter the comparison, the (E)DI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. If the DF flag is 0, the (E)DI register is incremented; if the DF flag is 1, the (E)DI register is decremented. The register is incremented or decremented by 1 for byte operations, by 2 for word operations, and by 4 for doubleword operations.\nSCAS, SCASB, SCASW, SCASD, and SCASQ can be preceded by the REP prefix for block comparisons of ECX bytes, words, doublewords, or quadwords. Often, however, these instructions will be used in a LOOP construct that takes\nsome action based on the setting of status flags. See \342\200\234REP/REPE/REPZ /REPNE/REPNZ-Repeat String Operation Prefix\342\200\235 in this chapter for a description of the REP prefix.\nIn 64-bit mode, the instruction\342\200\231s default address size is 64-bits, 32-bit address size is supported using the prefix 67H. Using a REX prefix in the form of REX.W promotes operation on doubleword operand to 64 bits. The 64-bit nooperand mnemonic is SCASQ. Address of the memory operand is specified in either RDI or EDI, and AL/AX/EAX/RAX may be used as the register operand. After a comparison, the destination register is incremented or decremented by the current operand size (depending on the value of the DF flag). See the sum mary chart at the\nbeginning of this section for encoding data and limits."
    flags_affected {
      content: "The OF, SF, ZF, AF, PF, and CF flags are set according to the temporary result of the comparison."
    }
  }
  instruction_groups {
    name: "CMPPD"
    short_description: "Compare Packed Double-Precision Floating-Point Values"
    description: "Performs a SIMD compare of the packed double-precision floating-point values in the second source operand and the first source operand and returns the result of the comparison to the destination operand. The comparison predicate operand (im\nmediate byte) specifies the type of comparison performed on each pair of packed values in the two source operands.\nEVEX encoded versions: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand (first operand) is an opmask register.\nComparison results are written to the destination operand under the writemask k2. Each comparison result is a single mask bit of 1 (comparison true) or 0 (comparison false).\nVEX.256 encoded version: The first source operand (second operand) is a YMM register. The second source operand (third operand) can be a YMM register or a 256-bit memory location. The destination operand (first operand) is a YMM register. Four comparisons are performed with results written to the destination operand. The result of each comparison is a quadword mask of all 1s (comparison true) or all 0s (comparison false).\n128-bit Legacy SSE version: The first source and destination operand (first operand) is an XMM register. The second source operand (second operand) can be an XMM register or 128-bit memory location. Bits (MAXVL-1:128) of the corresponding ZMM destination register remain unchanged. Two comparisons are performed with results written to bits 127:0 of the destination operand. The result of each comparison is a quadword mask of all 1s (comparison true) or all 0s (comparison false).\nVEX.128 encoded version: The first source operand (second operand) is an XMM register. The second source operand (third operand) can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination ZMM register are zeroed. Two comparisons are performed with results written to bits 127:0 of the destination operand.\nThe comparison predicate operand is an 8-bit im mediate:\n\342\200\242\tFor instructions encoded using the VEX or EVEX prefix, bits 4:0 define the type of comparison to be performed (see Table 3-1). Bits 5 through 7 of the im mediate are reserved.\n\342\200\242\tFor instruction encodings that do not use VEX prefix, bits 2:0 define the type of comparison to be made (see the first 8 rows of Table 3-1). Bits 3 through 7 of the im mediate are reserved.\nTable 3-1. Comparison Predicate for CMPPD and CMPPS Instructions\nPredicate\timm8 Value\tDescription\tResult: A Is 1st Operand, B Is 2nd Operand Unordered1 A >B A < B A = B\tSignals #IA on QNAN\nEQ_OQ (EQ)\t0H\tEqual (ordered, non-signaling)\tFalse\tFalse\tTrue\tFalse\tNo\nLT_OS (LT)\t1H\tLess-than (ordered, signaling)\tFalse\tTrue\tFalse\tFalse\tYes\nLE_OS (LE)\t2H\tLess-than-or-equal (ordered, signaling)\tFalse\tTrue\tTrue\tFalse\tYes\nUNORD_Q (UNORD)\t3H\tUnordered (non-signaling)\tFalse\tFalse\tFalse\tTrue\tNo\nNEQ_UQ (NEQ)\t4H\tNot-equal (unordered, non-signaling)\tTrue\tTrue\tFalse\tTrue\tNo\nNLT_US (NLT)\t5H\tNot-less-than (unordered, signaling)\tTrue\tFalse\tTrue\tTrue\tYes\nNLE_US (NLE)\t6H\tNot-less-than-or-equal (unordered, signaling)\tTrue\tFalse\tFalse\tTrue\tYes\nORD_Q (ORD)\t7H\tOrdered (non-signaling)\tTrue\tTrue\tTrue\tFalse\tNo\nEQ_UQ\t8H\tEqual (unordered, non-signaling)\tFalse\tFalse\tTrue\tTrue\tNo\nNGE_US (NGE)\t9H\tNot-greater-than-or-equal (unordered, signaling)\tFalse\tTrue\tFalse\tTrue\tYes\nNGT_US (NGT)\tAH\tNot-greater-than (unordered, signaling)\tFalse\tTrue\tTrue\tTrue\tYes\nFALSE_OQ(FALSE)\tBH\tFalse (ordered, non-signaling)\tFalse\tFalse\tFalse\tFalse\tNo\nNEQ_OQ\tCH\tNot-equal (ordered, non-signaling)\tTrue\tTrue\tFalse\tFalse\tNo\nGE_OS (GE)\tDH\tGreater-than-or-equal (ordered, signaling)\tTrue\tFalse\tTrue\tFalse\tYes\nGT_OS (GT)\tEH\tGreater-than (ordered, signaling)\tTrue\tFalse\tFalse\tFalse\tYes\nTRUE_UQ(TRUE)\tFH\tTrue (unordered, non-signaling)\tTrue\tTrue\tTrue\tTrue\tNo\nEQ_OS\t10H\tEqual (ordered, signaling)\tFalse\tFalse\tTrue\tFalse\tYes\nLT_OQ\t11H\tLess-than (ordered, nonsignaling)\tFalse\tTrue\tFalse\tFalse\tNo\nLE_OQ\t12H\tLess-than-or-equal (ordered, nonsignaling)\tFalse\tTrue\tTrue\tFalse\tNo\nUNORD_S\t13H\tUnordered (signaling)\tFalse\tFalse\tFalse\tTrue\tYes\nNEQ_US\t14H\tNot-equal (unordered, signaling)\tTrue\tTrue\tFalse\tTrue\tYes\nNLT_UQ\t15H\tNot-less-than (unordered, nonsignaling)\tTrue\tFalse\tTrue\tTrue\tNo\nNLE_UQ\t16H\tNot-less-than-or-equal (unordered, nonsignaling)\tTrue\tFalse\tFalse\tTrue\tNo\nORD_S\t17H\tOrdered (signaling)\tTrue\tTrue\tTrue\tFalse\tYes\nEQ_US\t18H\tEqual (unordered, signaling)\tFalse\tFalse\tTrue\tTrue\tYes\nNGE_UQ\t19H\tNot-greater-than-or-equal (unordered, nonsignaling)\tFalse\tTrue\tFalse\tTrue\tNo\nTable 3-1. Comparison Predicate for CMPPD and CMPPS Instructions  (Contd.)\nPredicate\timm8 Value\tDescription\tResult: A Is 1st Operand, B Is 2nd Operand Unordered1 A >B A < B A = B\tSignals #IA on QNAN\nNGT_UQ\t1AH\tNot-greater-than (unordered, nonsignaling)\tFalse\tTrue\tTrue\tTrue\tNo\nFALSE_OS\t1BH\tFalse (ordered, signaling)\tFalse\tFalse\tFalse\tFalse\tYes\nNEQ_OS\t1CH\tNot-equal (ordered, signaling)\tTrue\tTrue\tFalse\tFalse\tYes\nGE_OQ\t1DH\tGreater-than-or-equal (ordered, nonsignaling)\tTrue\tFalse\tTrue\tFalse\tNo\nGT_OQ\t1EH\tGreater-than (ordered, nonsignaling)\tTrue\tFalse\tFalse\tFalse\tNo\nTRUE_US\t1FH\tTrue (unordered, signaling)\tTrue\tTrue\tTrue\tTrue\tYes\nNOTES:\n1. If either operand A or B is a NAN.\nThe unordered relationship is true when at least one of the two source operands being compared is a NaN; the ordered relationship is true when neither source operand is a NaN.\nA subsequent computational instruction that uses the mask result in the destination operand as an input operand will not generate an exception, because a mask of all 0s corresponds to a floating-point value of +0.0 and a mask of all 1s corresponds to a QNaN.\nNote that processors with \342\200\234CPUID.1H:ECX.AVX =0\342\200\235 do not implement the \342\200\234greater-than\342\200\235, \342\200\234greater-than-or-equal\342\200\235, \342\200\234not-greater than\342\200\235, and \342\200\234not-greater-than-or-equal relations\342\200\235 predicates. These comparisons can be made either by using the inverse relationship (that is, use the \342\200\234not-less-than-or-equal\342\200\235 to make a \342\200\234greater-than\342\200\235 comparison) or by using software emulation. When using software emulation, the program must swap the operands (copying registers when necessary to protect the data that will now be in the destination), and then perform the compare using a different predicate. The predicate to be used for these emulations is listed in the first 8 rows of Table 3-7 (Intel 64 and IA-32 Architectures Software Developer\342\200\231s Manual Volume 2A) under the heading Emulation.\nCompilers and assemblers may implement the following two-operand pseudo-ops in addition to the three-operand CMPPD instruction, for processors with \342\200\234CPUID.1H:ECX.AVX =0\342\200\235. See Table 3-2. Compiler should treat reserved\nIm m8 values as illegal syntax.\nTable 3-2. Pseudo-Op and CMPPD Implementation\nPseudo-Op\tCMPPD Implementation\nCMPEQPD xmm1, xmm2\tCMPPD xmm1, xmm2, 0\nCMPLTPD xmm1, xmm2\tCMPPD xmm1, xmm2, 1\nCMPLEPD xmm1, xmm2\tCMPPD xmm1, xmm2, 2\nCMPUNORDPD xmm1, xmm2\tCMPPD xmm1, xmm2, 3\nCMPNEQPD xmm1, xmm2\tCMPPD xmm1, xmm2, 4\nCMPNLTPD xmm1, xmm2\tCMPPD xmm1, xmm2, 5\nCMPNLEPD xmm1, xmm2\tCMPPD xmm1, xmm2, 6\nCMPORDPD xmm1, xmm2\tCMPPD xmm1, xmm2, 7\nThe greater-than relations that the processor does not implement require more than one instruction to emulate in software and therefore should not be implemented as pseudo-ops. (For these, the program\nmer should reverse the operands of the corresponding less than relations and use move instructions to ensure that the mask is moved to the correct destination register and that the source operand is left intact.) Processors with \342\200\234CPUID.1H:ECX.AVX =1\342\200\235 implement the full complement of 32 predicates shown in Table\n3-3, software emulation is no longer needed. Compilers and assemblers may implement the following three-operand pseudo-ops in addition to the four-operand VCMPPD instruction. See Table\n3-3, where the notations of reg1 reg2, and reg3 represent either XMM registers or YMM registers. Compiler should treat reserved Im m8 values as illegal\nsyntax. Alternately, intrinsics can map the pseudo-ops to pre-defined constants to support a simpler intrinsic interface. Compilers and assemblers may implement three-operand pseudo-ops for EVEX encoded VCMPPD instructions in a similar fashion by extending the syntax listed in Table 3-3.\nTable 3-3. Pseudo-Op and VCMPPD Implementation\nPseudo-Op\tCMPPD Implementation\nVCMPEQPD reg1, reg2, reg3\tVCMPPD reg1, reg2, reg3, 0\nVCMPLTPD reg1, reg2, reg3\tVCMPPD reg1, reg2, reg3, 1\nVCMPLEPD reg1, reg2, reg3\tVCMPPD reg1, reg2, reg3, 2\nVCMPUNORDPD reg1, reg2, reg3\tVCMPPD reg1, reg2, reg3, 3\nVCMPNEQPD reg1, reg2, reg3\tVCMPPD reg1, reg2, reg3, 4\nVCMPNLTPD reg1, reg2, reg3\tVCMPPD reg1, reg2, reg3, 5\nVCMPNLEPD reg1, reg2, reg3\tVCMPPD reg1, reg2, reg3, 6\nVCMPORDPD reg1, reg2, reg3\tVCMPPD reg1, reg2, reg3, 7\nVCMPEQ_UQPD reg1, reg2, reg3\tVCMPPD reg1, reg2, reg3, 8\nVCMPNGEPD reg1, reg2, reg3\tVCMPPD reg1, reg2, reg3, 9\nVCMPNGTPD reg1, reg2, reg3\tVCMPPD reg1, reg2, reg3, 0AH\nVCMPFALSEPD reg1, reg2, reg3\tVCMPPD reg1, reg2, reg3, 0BH\nVCMPNEQ_OQPD reg1, reg2, reg3\tVCMPPD reg1, reg2, reg3, 0CH\nVCMPGEPD reg1, reg2, reg3\tVCMPPD reg1, reg2, reg3, 0DH\nVCMPGTPD reg1, reg2, reg3\tVCMPPD reg1, reg2, reg3, 0EH\nVCMPTRUEPD reg1, reg2, reg3\tVCMPPD reg1, reg2, reg3, 0FH\nVCMPEQ_OSPD reg1, reg2, reg3\tVCMPPD reg1, reg2, reg3, 10H\nVCMPLT_OQPD reg1, reg2, reg3\tVCMPPD reg1, reg2, reg3, 11H\nVCMPLE_OQPD reg1, reg2, reg3\tVCMPPD reg1, reg2, reg3, 12H\nVCMPUNORD_SPD reg1, reg2, reg3\tVCMPPD reg1, reg2, reg3, 13H\nVCMPNEQ_USPD reg1, reg2, reg3\tVCMPPD reg1, reg2, reg3, 14H\nVCMPNLT_UQPD reg1, reg2, reg3\tVCMPPD reg1, reg2, reg3, 15H\nVCMPNLE_UQPD reg1, reg2, reg3\tVCMPPD reg1, reg2, reg3, 16H\nVCMPORD_SPD reg1, reg2, reg3\tVCMPPD reg1, reg2, reg3, 17H\nVCMPEQ_USPD reg1, reg2, reg3\tVCMPPD reg1, reg2, reg3, 18H\nVCMPNGE_UQPD reg1, reg2, reg3\tVCMPPD reg1, reg2, reg3, 19H\nVCMPNGT_UQPD reg1, reg2, reg3\tVCMPPD reg1, reg2, reg3, 1AH\nVCMPFALSE_OSPD reg1, reg2, reg3\tVCMPPD reg1, reg2, reg3, 1BH\nVCMPNEQ_OSPD reg1, reg2, reg3\tVCMPPD reg1, reg2, reg3, 1CH\nVCMPGE_OQPD reg1, reg2, reg3\tVCMPPD reg1, reg2, reg3, 1DH\nVCMPGT_OQPD reg1, reg2, reg3\tVCMPPD reg1, reg2, reg3, 1EH\nVCMPTRUE_USPD reg1, reg2, reg3\tVCMPPD reg1, reg2, reg3, 1FH"
  }
  instruction_groups {
    name: "MOVBE"
    short_description: "Move Data After Swapping Bytes"
    description: "Performs a byte swap operation on the data copied from the second operand (source operand) and store the result in the first operand (destination operand). The source operand can be a general-purpose register, or memory location; the destination register can be a general-purpose register, or a memory location; however, both operands can not be registers, and only one operand can be a memory location. Both operands must be the same size, which can be a word, a doubleword or quadword.\nThe MOVBE instruction is provided for swapping the bytes on a read from memory or on a write to memory; thus providing support for converting little-endian values to big-endian format and vice versa.\nIn 64-bit mode, the instruction\'s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the sum mary chart at the\nbeginning of this section for encoding data and limits."
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "VRSQRT28SS"
    short_description: "Approximation to the Reciprocal Square Root of Scalar Single-Precision Floating-Point Value with Less Than 2^-28 Rel-"
  }
  instruction_groups {
    name: "FTST"
    short_description: "TEST"
    description: "Compares the value in the ST(0) register with 0.0 and sets the condition code flags C0, C2, and C3 in the FPU status word according to the results (see table below).\nTable 3-40.  FTST Results\nCondition\tC3\tC2\tC0\nST(0) > 0.0\t0\t0\t0\nST(0) < 0.0\t0\t0\t1\nST(0) = 0.0\t1\t0\t0\nUnordered\t1\t1\t1\nThis instruction performs an \342\200\234unordered comparison.\342\200\235 An unordered comparison also checks the class of the numbers being compared (see \342\200\234FXAM\n-Examine Floating-Point\342\200\235 in this chapter). If the value in register ST(0) is a NaN or is in an undefined format, the condition flags are set to \342\200\234unordered\342\200\235 and the invalid operation exception is generated.\nThe sign of zero is ignored, so that (- 0.0 := +0.0).\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C1\tSet to 0.\nC0, C2, C3\tSee Table 3-40."
    }
  }
  instruction_groups {
    name: "PBLENDVB"
    short_description: "Variable Blend Packed Bytes"
    description: "Conditionally copies byte elements from the source operand (second operand) to the destination operand (first operand) depending on mask bits defined in the implicit third register argument, XMM0. The mask bits are the most significant bit in each byte element of the XMM0 register.\nIf a mask bit is \342\200\2341\", then the corresponding byte element in the source operand is copied to the destination, else the byte element in the destination operand is left unchanged.\nThe register assignment of the implicit third operand is defined to be the architectural register XMM0.\n128-bit Legacy SSE version: The first source operand and the destination operand is the same. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged. The mask register operand is implicitly defined to be the architectural register XMM0. An attempt to execute PBLENDVB with a VEX prefix will cause #UD.\nVEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second source operand is an XMM register or 128-bit memory location. The mask operand is the third source register, and encoded in bits[7:4] of the im mediate byte(im m8). The bits[3:0] of im m8 are ignored. In 32-bit mode, im m8[7] is ignored. The upper bits (MAXVL-1:128) of the corresponding YMM register (destination register) are zeroed. VEX.L must be 0, otherwise the instruction will #UD. VEX.W must be 0, otherwise, the instruction will #UD.\nVEX.256 encoded version: The first source operand and the destination operand are YMM registers. The second source operand is an YMM register or 256-bit memory location. The third source register is an YMM register and encoded in bits[7:4] of the im mediate byte(im m8). The bits[3:0] of im m8 are ignored. In 32-bit mode, im m8[7] is\nignored.\nVPBLENDVB permits the mask to be any XMM or YMM register. In contrast, PBLENDVB treats XMM0 implicitly as the mask and do not support non-destructive destination operation. An attempt to execute PBLENDVB encoded with a VEX prefix will cause a #UD exception."
    flags_affected {
      content: "None.\nSIMD Floating-Point Exceptions\nNone."
    }
  }
  instruction_groups {
    name: "WBINVD"
    short_description: "Write Back and Invalidate Cache"
    description: "Writes back all modified cache lines in the processor\342\200\231s internal cache to main memory and invalidates (flushes) the internal caches. The instruction then issues a special-function bus cycle that directs external caches to also write back modified data and another bus cycle to indicate that the external caches should be invalidated.\nAfter executing this instruction, the processor does not wait for the external caches to complete their write-back and flushing operations before proceeding with instruction execution. It is the responsibility of hardware to respond to the cache write-back and flush signals. The amount of time or cycles for WBINVD to complete will vary due to size and other factors of different cache hierarchies. As a consequence, the use of the WBINVD instruction can have an impact on logical processor interrupt/event response time. Additional information of WBINVD behavior in a cache hierarchy with hierarchical sharing topology can be found in Chapter 2 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3A.\nThe WBINVD instruction is a privileged instruction. When the processor is running in protected mode, the CPL of a program or procedure must be 0 to execute this instruction. This instruction is also a serializing instruction (see \342\200\234Serializing Instructions\342\200\235 in Chapter 8 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3A).\nIn situations where cache coherency with main memory is not a concern, software can use the INVD instruction.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "CMPS/CMPSB/CMPSW/CMPSD/CMPSQ"
    short_description: "Compare String Operands"
    description: "Compares the byte, word, doubleword, or quadword specified with the first source operand with the byte, word, doubleword, or quadword specified with the second source operand and sets the status flags in the EFLAGS register according to the results.\nBoth source operands are located in memory. The address of the first source operand is read from DS:SI, DS:ESI or RSI (depending on the address-size attribute of the instruction is 16, 32, or 64, respectively). The address of the second source operand is read from ES:DI, ES:EDI or RDI (again depending on the address-size attribute of the instruction is 16, 32, or 64). The DS segment may be overridden with a segment override prefix, but the ES segment cannot be overridden.\nAt the assembly-code level, two forms of this instruction are allowed: the \342\200\234explicit-operands\342\200\235 form and the \342\200\234nooperands\342\200\235 form. The explicit-operands form (specified with the CMPS mnemonic) allows the two source operands to be specified explicitly. Here, the source operands should be symbols that indicate the size and location of the source values. This explicit-operand form is provided to allow documentation. However, note that the documentation provided by this form can be misleading. That is, the source operand symbols must specify the correct type (size) of the operands (bytes, words, or doublewords, quadwords), but they do not have to specify the correct loca-\ntion. Locations of the source operands are always specified by the DS:(E)SI (or RSI) and ES:(E)DI (or RDI) registers, which must be loaded correctly before the compare string instruction is executed.\nThe no-operands form provides \342\200\234short forms\342\200\235 of the byte, word, and doubleword versions of the CMPS instructions.\nHere also the DS:(E)SI (or RSI) and ES:(E)DI (or RDI) registers are assumed by the processor to specify the location of the source operands. The size of the source operands is selected with the mnemonic: CMPSB (byte comparison), CMPSW (word comparison), CMPSD (doubleword comparison), or CMPSQ (quadword comparison using REX.W).\nAfter the comparison, the (E/R)SI and (E/R)DI registers increment or decrement automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E/R)SI and (E/R)DI register increment; if the DF flag is 1, the registers decrement.) The registers increment or decrement by 1 for byte operations, by 2 for word operations, 4 for doubleword operations. If operand size is 64, RSI and RDI registers increment by 8 for quadword operations.\nThe CMPS, CMPSB, CMPSW, CMPSD, and CMPSQ instructions can be preceded by the REP prefix for block comparisons. More often, however, these instructions will be used in a LOOP construct that takes some action based on the setting of the status flags before the next comparison is made. See \342\200\234REP/REPE/REPZ /REPNE/REPNZ-Repeat String Operation Prefix\342\200\235 in Chapter 4 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 2B, for a description of the REP prefix.\nIn 64-bit mode, the instruction\342\200\231s default address size is 64 bits, 32 bit address size is supported using the prefix 67H. Use of the REX.W prefix promotes doubleword operation to 64 bits (see CMPSQ). See the sum mary chart at\nthe beginning of this section for encoding data and limits."
    flags_affected {
      content: "The CF, OF, SF, ZF, AF, and PF flags are set according to the temporary result of the comparison."
    }
  }
  instruction_groups {
    name: "FLD"
    short_description: "Load Floating Point Value"
    description: "Pushes the source operand onto the FPU register stack. The source operand can be in single-precision, doubleprecision, or double extended-precision floating-point format. If the source operand is in single-precision or double-precision floating-point format, it is automatically converted to the double extended-precision floatingpoint format before being pushed on the stack.\nThe FLD instruction can also push the value in a selected FPU register [ST(i)] onto the stack. Here, pushing register ST(0) duplicates the stack top.\nNOTE\nWhen the FLD instruction loads a denormal value and the DM bit in the CW is not masked, an exception is flagged but the value is still pushed onto the x87 stack.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C1\tSet to 1 if stack overflow occurred; otherwise, set to 0.\nC0, C2, C3\tUndefined."
    }
  }
  instruction_groups {
    name: "VREDUCESD"
    short_description: "Perform a Reduction Transformation on a Scalar Float64 Value"
  }
  instruction_groups {
    name: "MINPD"
    short_description: "Minimum of Packed Double-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "DIVPS"
    short_description: "Divide Packed Single-Precision Floating-Point Values"
    description: "Performs a SIMD divide of the four, eight or sixteen packed single-precision floating-point values in the first source operand (the second operand) by the four, eight or sixteen packed single-precision floating-point values in the second source operand (the third operand). Results are written to the destination operand (the first operand).\nEVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.\nVEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified."
  }
  instruction_groups {
    name: "XSETBV"
    short_description: "Set Extended Control Register"
    description: "Writes the contents of registers EDX:EAX into the 64-bit extended control register (XCR) specified in the ECX register. (On processors that support the Intel64 architecture, the high-order 32 bits of RCX are ignored.) The contents of the EDX register are copied to high-order 32 bits of the selected XCR and the contents of the EAX register are copied to low-order 32 bits of the XCR. (On processors that support the Intel64 architecture, the highorder 32 bits of each of RAX and RDX are ignored.) Undefined or reserved bits in an XCR should be set to values previously read.\nThis instruction must be executed at privilege level 0 or in real-address mode; otherwise, a general protection exception #GP(0) is generated. Specifying a reserved or unimplemented XCR in ECX will also cause a general protection exception. The processor will also generate a general protection exception if software attempts to write to reserved bits in an XCR.\nCurrently, only XCR0 is supported. Thus, all other values of ECX are reserved and will cause a #GP(0). Note that bit0 of XCR0 (corresponding to x87 state) must be set to 1; the instruction will cause a #GP(0) if an attempt is made to clear this bit. In addition, the instruction causes a #GP(0) if an attempt is made to set XCR0[2] (AVX state) while clearing XCR0[1] (SSE state); it is necessary to set both bits to use AVX instructions; Section 13.3, \342\200\234Enabling the XSAVE Feature Set and XSAVE-Enabled Features,\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "VSCALEFSD"
    short_description: "Scale Scalar Float64 Values With Float64 Values"
  }
  instruction_groups {
    name: "MOVDDUP"
    short_description: "Replicate Double FP Values"
  }
  instruction_groups {
    name: "VCVTPD2UQQ"
    short_description: "Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Quadword Integers"
  }
  instruction_groups {
    name: "TZCNT"
    short_description: "Count the Number of Trailing Zero Bits"
    description: "TZCNT counts the number of trailing least significant zero bits in source operand (second operand) and returns the result in destination operand (first operand). TZCNT is an extension of the BSF instruction. The key difference between TZCNT and BSF instruction is that TZCNT provides operand size as output when source operand is zero while in the case of BSF instruction, if source operand is zero, the content of destination operand are undefined. On processors that do not support TZCNT, the instruction byte encoding is executed as BSF."
    flags_affected {
      content: "ZF is set to 1 in case of zero output (least significant bit of the source is set), and to 0 otherwise, CF is set to 1 if the input was zero and cleared otherwise. OF, SF, PF and AF flags are undefined."
    }
  }
  instruction_groups {
    name: "PACKUSDW"
    short_description: "Pack with Unsigned Saturation"
  }
  instruction_groups {
    name: "VRCP28SS"
    short_description: "Approximation to the Reciprocal of Scalar Single-Precision Floating-Point Value with Less Than 2^-28 Relative Error"
  }
  instruction_groups {
    name: "ETRACK"
  }
  instruction_groups {
    name: "MAXSD"
    short_description: "Return Maximum Scalar Double-Precision Floating-Point Value"
  }
  instruction_groups {
    name: "VREDUCEPS"
    short_description: "Perform Reduction Transformation on Packed Float32 Values"
  }
  instruction_groups {
    name: "VFPCLASSPD"
    short_description: "Tests Types Of a Packed Float64 Values"
  }
  instruction_groups {
    name: "JMP"
    short_description: "Jump"
    description: "Transfers program control to a different point in the instruction stream without recording return information. The destination (target) operand specifies the address of the instruction being jumped to. This operand can be an im mediate value, a general-purpose register, or a memory location.\nThis instruction can be used to execute four different types of jumps:\n\342\200\242\tNear jump-A jump to an instruction within the current code segment (the segment currently pointed to by the CS register), sometimes referred to as an intrasegment jump.\n\342\200\242\tShort jump-A near jump where the jump range is limited to -128 to +127 from the current EIP value.\n\342\200\242\tFar jump-A jump to an instruction located in a different segment than the current code segment but at the same privilege level, sometimes referred to as an intersegment jump.\n\342\200\242\tTask switch-A jump to an instruction located in a different task.\nA task switch can only be executed in protected mode (see Chapter 7, in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3A, for information on performing task switches with the JMP instruction).\nNear and Short Jumps. When executing a near jump, the processor jumps to the address (within the current code segment) that is specified with the target operand. The target operand specifies either an absolute offset (that is an offset from the base of the code segment) or a relative offset (a signed displacement relative to the current\nvalue of the instruction pointer in the EIP register). A near jump to a relative offset of 8-bits (rel8) is referred to as a short jump. The CS register is not changed on near and short jumps.\nAn absolute offset is specified indirectly in a general-purpose register or a memory location (r/m16 or r/m32). The operand-size attribute determines the size of the target operand (16 or 32 bits). Absolute offsets are loaded directly into the EIP register. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.\nA relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed 8-, 16-, or 32-bit im\nmediate value. This value is added to the value in the EIP register. (Here, the EIP register contains the address of the instruction following the JMP instruction). When using relative offsets, the opcode (for short vs. near jumps) and the operand-size attribute (for near relative jumps) determines the size of the target operand (8, 16, or 32 bits).\nFar Jumps in Real-Address or Virtual-8086 Mode. When executing a far jump in real-address or virtual-8086 mode, the processor jumps to the code segment and offset specified with the target operand. Here the target operand specifies an absolute far address either directly with a pointer (ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 or m16:32). With the pointer method, the segment and address of the called procedure is encoded in the instruction, using a 4-byte (16-bit operand size) or 6-byte (32-bit operand size) far address im\nmediate. With the indirect method, the target operand specifies a memory location that contains a 4-byte (16-bit operand size) or 6-byte (32-bit operand size) far address. The far address is loaded directly into the CS and EIP registers. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared.\nFar Jumps in Protected Mode. When the processor is operating in protected mode, the JMP instruction can be used to perform the following three types of far jumps:\n\342\200\242\tA far jump to a conforming or non-conforming code segment.\n\342\200\242\tA far jump through a call gate.\n\342\200\242\tA task switch.\n(The JMP instruction cannot be used to perform inter-privilege-level far jumps.)\nIn protected mode, the processor always uses the segment selector part of the far address to access the corresponding descriptor in the GDT or LDT. The descriptor type (code segment, call gate, task gate, or TSS) and access rights determine the type of jump to be performed.\nIf the selected descriptor is for a code segment, a far jump to a code segment at the same privilege level is performed. (If the selected code segment is at a different privilege level and the code segment is non-conforming, a general-protection exception is generated.) A far jump to the same privilege level in protected mode is very similar to one carried out in real-address or virtual-8086 mode. The target operand specifies an absolute far address either directly with a pointer (ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 or m16:32). The operand-size attribute determines the size of the offset (16 or 32 bits) in the far address. The new code segment selector and its descriptor are loaded into CS register, and the offset from the instruction is loaded into the EIP register. Note that a call gate (described in the next paragraph) can also be used to perform far call to a code segment at the same privilege level. Using this mechanism provides an extra level of indirection and is the preferred method of making jumps between 16-bit and 32-bit code segments.\nWhen executing a far jump through a call gate, the segment selector specified by the target operand identifies the call gate. (The offset part of the target operand is ignored.) The processor then jumps to the code segment specified in the call gate descriptor and begins executing the instruction at the offset specified in the call gate. No stack switch occurs. Here again, the target operand can specify the far address of the call gate either directly with a pointer (ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 or m16:32).\nExecuting a task switch with the JMP instruction is somewhat similar to executing a jump through a call gate. Here the target operand specifies the segment selector of the task gate for the task being switched to (and the offset part of the target operand is ignored). The task gate in turn points to the TSS for the task, which contains the segment selectors for the task\342\200\231s code and stack segments. The TSS also contains the EIP value for the next instruction that was to be executed before the task was suspended. This instruction pointer value is loaded into the EIP register so that the task begins executing again at this next instruction.\nThe JMP instruction can also specify the segment selector of the TSS directly, which eliminates the indirection of the task gate. See Chapter 7 in Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3A, for detailed information on the mechanics of a task switch.\nNote that when you execute at task switch with a JMP instruction, the nested task flag (NT) is not set in the EFLAGS register and the new TSS\342\200\231s previous task link field is not loaded with the old task\342\200\231s TSS selector. A return to the previous task can thus not be carried out by executing the IRET instruction. Switching tasks with the JMP instruction differs in this regard from the CALL instruction which does set the NT flag and save the previous task link information, allowing a return to the calling task with an IRET instruction.\nRefer to Chapter 6, \342\200\234Procedure Calls, Interrupts, and Exceptions\342\200\235 and Chapter 18, \342\200\234Control-Flow Enforcement Technology (CET)\342\200\235 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1 for CET details.\nIn 64-Bit Mode. The instruction\342\200\231s operation size is fixed at 64 bits. If a selector points to a gate, then RIP equals the 64-bit displacement taken from gate; else RIP equals the zero-extended offset from the far pointer referenced in the instruction.\nSee the sum mary chart at the beginning of this section for encoding data and limits.\nInstruction ordering. Instructions following a far jump may be fetched from memory before earlier instructions complete execution, but they will not execute (even speculatively) until all instructions prior to the far jump have completed execution (the later instructions may execute before data stored by the earlier instructions have become globally visible).\nCertain situations may lead to the next sequential instruction after a near indirect JMP being speculatively executed. If software needs to prevent this (e.g., in order to prevent a speculative execution side channel), then an INT3 or LFENCE instruction opcode can be placed after the near indirect JMP in order to block speculative execution."
    flags_affected {
      content: "All flags are affected if a task switch occurs; no flags are affected if a task switch does not occur."
    }
  }
  instruction_groups {
    name: "SHUFPS"
    short_description: "Packed Interleave Shuffle of Quadruplets of Single-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "SYSENTER"
    short_description: "Fast System Call"
    description: "Executes a fast call to a level 0 system procedure or routine. SYSENTER is a companion instruction to SYSEXIT. The instruction is optimized to provide the maximum performance for system calls from user code running at privilege level 3 to operating system or executive procedures running at privilege level 0.\nWhen executed in IA-32e mode, the SYSENTER instruction transitions the logical processor to 64-bit mode; otherwise, the logical processor remains in protected mode.\nPrior to executing the SYSENTER instruction, software must specify the privilege level 0 code segment and code entry point, and the privilege level 0 stack segment and stack pointer by writing values to the following MSRs:\n\342\200\242\tIA32_SYSENTER_CS (MSR address 174H) - The lower 16 bits of this MSR are the segment selector for the privilege level 0 code segment. This value is also used to determine the segment selector of the privilege level 0 stack segment (see the Operation section). This value cannot indicate a null selector.\n\342\200\242\tIA32_SYSENTER_EIP (MSR address 176H) - The value of this MSR is loaded into RIP (thus, this value references the first instruction of the selected operating procedure or routine). In protected mode, only bits 31:0 are loaded.\n\342\200\242\tIA32_SYSENTER_ESP (MSR address 175H) - The value of this MSR is loaded into RSP (thus, this value contains the stack pointer for the privilege level 0 stack). This value cannot represent a non-canonical address.\nIn protected mode, only bits 31:0 are loaded.\nThese MSRs can be read from and written to using RDMSR/WRMSR. The WRMSR instruction ensures that the IA32_SYSENTER_EIP and IA32_SYSENTER_ESP MSRs always contain canonical addresses.\nWhile SYSENTER loads the CS and SS selectors with values derived from the IA32_SYSENTER_CS MSR, the CS and SS descriptor caches are not loaded from the descriptors (in GDT or LDT) referenced by those selectors. Instead, the descriptor caches are loaded with fixed values. See the Operation section for details. It is the responsibility of OS software to ensure that the descriptors (in GDT or LDT) referenced by those selector values correspond to the fixed values loaded into the descriptor caches; the SYSENTER instruction does not ensure this correspondence.\nThe SYSENTER instruction can be invoked from all operating modes except real-address mode.\nThe SYSENTER and SYSEXIT instructions are companion instructions, but they do not constitute a call/return pair.\nWhen executing a SYSENTER instruction, the processor does not save state information for the user code (e.g., the instruction pointer), and neither the SYSENTER nor the SYSEXIT instruction supports passing parameters on the stack.\nTo use the SYSENTER and SYSEXIT instructions as companion instructions for transitions between privilege level 3 code and privilege level 0 operating system procedures, the following conventions must be followed:\n\342\200\242\tThe segment descriptors for the privilege level 0 code and stack segments and for the privilege level 3 code and stack segments must be contiguous in a descriptor table. This convention allows the processor to compute the segment selectors from the value entered in the SYSENTER_CS_MSR MSR.\n\342\200\242\tThe fast system call \342\200\234stub\342\200\235 routines executed by user code (typically in shared libraries or DLLs) must save the required return IP and processor state information if a return to the calling procedure is required. Likewise, the operating system or executive procedures called with SYSENTER instructions must have access to and use this saved return and state information when returning to the user code.\nThe SYSENTER and SYSEXIT instructions were introduced into the IA-32 architecture in the Pentium II processor.\nThe availability of these instructions on a processor is indicated with the SYSENTER/SYSEXIT present (SEP) feature flag returned to the EDX register by the CPUID instruction. An operating system that qualifies the SEP flag must also qualify the processor family and model to ensure that the SYSENTER/SYSEXIT instructions are actually present. For example:\nIF CPUID SEP bit is set THEN IF (Family = 6) and (Model < 3) and (Stepping < 3) THEN SYSENTER/SYSEXIT_Not_Supported; FI; ELSE SYSENTER/SYSEXIT_Supported; FI;\nFI;\nWhen the CPUID instruction is executed on the Pentium Pro processor (model 1), the processor returns a the SEP flag as set, but does not support the SYSENTER/SYSEXIT instructions.\nWhen shadow stacks are enabled at privilege level where SYSENTER instruction is invoked, the SSP is saved to the IA32_PL3_SSP MSR. If shadow stacks are enabled at privilege level 0, the SSP is loaded with 0. Refer to Chapter 6, \342\200\234Procedure Calls, Interrupts, and Exceptions\342\200\235 and Chapter 18, \342\200\234Control-Flow Enforcement Technology (CET)\342\200\235 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1 for additional CET details.\nInstruction ordering. Instructions following a SYSENTER may be fetched from memory before earlier instructions complete execution, but they will not execute (even speculatively) until all instructions prior to the SYSENTER have completed execution (the later instructions may execute before data stored by the earlier instructions have become globally visible)."
    flags_affected {
      content: "VM, IF (see Operation above)"
    }
  }
  instruction_groups {
    name: "VPERM2I128"
    short_description: "Permute Integer Values"
    description: "Permute 128 bit integer data from the first source operand (second operand) and second source operand (third operand) using bits in the 8-bit im\nmediate and store results in the destination operand (first operand). The first source operand is a YMM register, the second source operand is a YMM register or a 256-bit memory location, and the destination operand is a YMM register.\nSRC2\tY1\tY0\nSRC1\tX1\tX0\nDEST\tX0, X1, Y0, or Y1\tX0, X1, Y0, or Y1\nFigure 5-22.  VPERM2I128 Operation\nIm m8[1:0] select the source for the first destination 128-bit field, im m8[5:4] select the source for the second\ndestination field. If im m8[3] is set, the low 128-bit field is zeroed. If im m8[7] is set, the high 128-bit field is zeroed.\nVEX.L must be 1, otherwise the instruction will #UD."
  }
  instruction_groups {
    name: "PHADDSW"
    short_description: "Packed Horizontal Add and Saturate"
    description: "(V)PHADDSW adds two adjacent signed 16-bit integers horizontally from the source and destination operands and saturates the signed results; packs the signed, saturated 16-bit results to the destination operand (first operand) When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.\nLegacy SSE version: Both operands can be MMX registers. The second source operand can be an MMX register or a 64-bit memory location.\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nIn 64-bit mode, use the REX prefix to access additional registers.\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded version: The first source and destination operands are YMM registers. The second source operand can be an YMM register or a 256-bit memory location."
  }
  instruction_groups {
    name: "FNOP"
    short_description: "No Operation"
    description: "Performs no FPU operation. This instruction takes up space in the instruction stream but does not affect the FPU or machine context, except the EIP register and the FPU Instruction Pointer.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C0, C1, C2, C3 undefined."
    }
  }
  instruction_groups {
    name: "PSUBQ"
    short_description: "Subtract Packed Quadword Integers"
    description: "Subtracts the second operand (source operand) from the first operand (destination operand) and stores the result in the destination operand. When packed quadword operands are used, a SIMD subtract is performed. When a quadword result is too large to be represented in 64 bits (overflow), the result is wrapped around and the low 64 bits are written to the destination element (that is, the carry is ignored).\nNote that the (V)PSUBQ instruction can operate on either unsigned or signed (two\342\200\231s complement notation) integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of the values upon which it operates.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE version 64-bit operand: The source operand can be a quadword integer stored in an MMX technology register or a 64-bit memory location.\n128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded versions: The second source operand is an YMM register or an 256-bit memory location. The first source operand and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.\nEVEX encoded VPSUBQ: The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "UD"
    short_description: "Undefined Instruction"
    description: "Generates an invalid opcode exception. This instruction is provided for software testing to explicitly generate an invalid opcode exception. The opcodes for this instruction are reserved for this purpose.\nOther than raising the invalid opcode exception, this instruction has no effect on processor state or memory.\nEven though it is the execution of the UD instruction that causes the invalid opcode exception, the instruction pointer saved by delivery of the exception references the UD instruction (and not the following instruction).\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "VPBLENDMD/VPBLENDMQ"
    short_description: "Blend Int32/Int64 Vectors Using an OpMask Control"
  }
  instruction_groups {
    name: "VRCP28SD"
    short_description: "Approximation to the Reciprocal of Scalar Double-Precision Floating-Point Value with Less Than 2^-28 Relative Error"
  }
  instruction_groups {
    name: "EEXIT"
  }
  instruction_groups {
    name: "LEAVE"
    short_description: "High Level Procedure Exit"
    description: "Releases the stack frame set up by an earlier ENTER instruction. The LEAVE instruction copies the frame pointer (in the EBP register) into the stack pointer register (ESP), which releases the stack space allocated to the stack frame.\nThe old frame pointer (the frame pointer for the calling procedure that was saved by the ENTER instruction) is then popped from the stack into the EBP register, restoring the calling procedure\342\200\231s stack frame.\nA RET instruction is com monly executed following a LEAVE instruction to return program control to the calling\nprocedure.\nSee \342\200\234Procedure Calls for Block-Structured Languages\342\200\235 in Chapter 7 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1, for detailed information on the use of the ENTER and LEAVE instructions.\nIn 64-bit mode, the instruction\342\200\231s default operation size is 64 bits; 32-bit operation cannot be encoded. See the sum mary chart at the beginning of this section for encoding data and limits."
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "RDTSC"
    short_description: "Read Time-Stamp Counter"
    description: "Reads the current value of the processor\342\200\231s time-stamp counter (a 64-bit MSR) into the EDX:EAX registers. The EDX register is loaded with the high-order 32 bits of the MSR and the EAX register is loaded with the low-order 32 bits.\n(On processors that support the Intel64 architecture, the high-order 32 bits of each of RAX and RDX are cleared.)\nThe processor monotonically increments the time-stamp counter MSR every clock cycle and resets it to 0 whenever the processor is reset. See \342\200\234Time Stamp Counter\342\200\235 in Chapter 17 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3B, for specific details of the time stamp counter behavior.\nThe time stamp disable (TSD) flag in register CR4 restricts the use of the RDTSC instruction as follows. When the flag is clear, the RDTSC instruction can be executed at any privilege level; when the flag is set, the instruction can only be executed at privilege level 0.\nThe time-stamp counter can also be read with the RDMSR instruction, when executing at privilege level 0.\nThe RDTSC instruction is not a serializing instruction. It does not necessarily wait until all previous instructions have been executed before reading the counter. Similarly, subsequent instructions may begin execution before the read operation is performed. The following items may guide software seeking to order executions of RDTSC:\n\342\200\242\tIf software requires RDTSC to be executed only after all previous instructions have executed and all previous loads are globally visible,1 it can execute LFENCE im mediately before RDTSC.\n\342\200\242\tIf software requires RDTSC to be executed only after all previous instructions have executed and all previous loads and stores are globally visible, it can execute the sequence MFENCE;LFENCE im mediately before RDTSC.\n\342\200\242\tIf software requires RDTSC to be executed prior to execution of any subsequent instruction (including any memory accesses), it can execute the sequence LFENCE im mediately after RDTSC.\nThis instruction was introduced by the Pentium processor.\nSee \342\200\234Changes to Instruction Behavior in VMX Non-Root Operation\342\200\235 in Chapter 25 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3C, for more information about the behavior of this instruction in VMX non-root operation."
    flags_affected {
      content: "None.\n1.\tA load is considered to become globally visible when the value to be loaded is determined."
    }
  }
  instruction_groups {
    name: "SFENCE"
    short_description: "Store Fence"
    description: "Orders processor execution relative to all memory stores prior to the SFENCE instruction. The processor ensures that every store prior to SFENCE is globally visible before any store after SFENCE becomes globally visible. The SFENCE instruction is ordered with respect to memory stores, other SFENCE instructions, MFENCE instructions, and any serializing instructions (such as the CPUID instruction). It is not ordered with respect to memory loads or the LFENCE instruction.\nWeakly ordered memory types can be used to achieve higher processor performance through such techniques as out-of-order issue, write-combining, and write-collapsing. The degree to which a consumer of data recognizes or knows that the data is weakly ordered varies among applications and may be unknown to the producer of this data.\nThe SFENCE instruction provides a performance-efficient way of ensuring store ordering between routines that produce weakly-ordered results and routines that consume this data.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode.\nSpecification of the instruction\'s opcode above indicates a ModR/M byte of F8. For this instruction, the processor ignores the r/m field of the ModR/M byte. Thus, SFENCE is encoded by any opcode of the form 0F AE Fx, where x is in the range 8-F."
  }
  instruction_groups {
    name: "VFIXUPIMMPD"
    short_description: "Fix Up Special Packed Float64 Values"
  }
  instruction_groups {
    name: "FBLD"
    short_description: "Load Binary Coded Decimal"
    description: "Converts the BCD source operand into double extended-precision floating-point format and pushes the value onto the FPU stack. The source operand is loaded without rounding errors. The sign of the source operand is preserved, including that of \342\210\2220.\nThe packed BCD digits are assumed to be in the range 0 through 9; the instruction does not check for invalid digits (AH through FH). Attempting to load an invalid encoding produces an undefined result.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C1\tSet to 1 if stack overflow occurred; otherwise, set to 0.\nC0, C2, C3\tUndefined."
    }
  }
  instruction_groups {
    name: "PUSHF/PUSHFD/PUSHFQ"
    short_description: "Push EFLAGS Register onto the Stack"
    description: "Decrements the stack pointer by 4 (if the current operand-size attribute is 32) and pushes the entire contents of the EFLAGS register onto the stack, or decrements the stack pointer by 2 (if the operand-size attribute is 16) and pushes the lower 16 bits of the EFLAGS register (that is, the FLAGS register) onto the stack. These instructions reverse the operation of the POPF/POPFD instructions.\nWhen copying the entire EFLAGS register to the stack, the VM and RF flags (bits 16 and 17) are not copied; instead, the values for these flags are cleared in the EFLAGS image stored on the stack. See Chapter 3 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1, for more information about the EFLAGS register.\nThe PUSHF (push flags) and PUSHFD (push flags double) mnemonics reference the same opcode. The PUSHF instruction is intended for use when the operand-size attribute is 16 and the PUSHFD instruction for when the operand-size attribute is 32. Some assemblers may force the operand size to 16 when PUSHF is used and to 32 when PUSHFD is used. Others may treat these mnemonics as synonyms (PUSHF/PUSHFD) and use the current setting of the operand-size attribute to determine the size of values to be pushed from the stack, regardless of the mnemonic used.\nIn 64-bit mode, the instruction\342\200\231s default operation is to decrement the stack pointer (RSP) by 8 and pushes RFLAGS on the stack. 16-bit operation is supported using the operand size override prefix 66H. 32-bit operand size cannot be encoded in this mode. When copying RFLAGS to the stack, the VM and RF flags (bits 16 and 17) are not copied; instead, values for these flags are cleared in the RFLAGS image stored on the stack.\nWhen operating in virtual-8086 mode (EFLAGS.VM = 1) without the virtual-8086 mode extensions (CR4.VME = 0), the PUSHF/PUSHFD instructions can be used only if IOPL = 3; otherwise, a general-protection exception (#GP) occurs. If the virtual-8086 mode extensions are enabled (CR4.VME = 1), PUSHF (but not PUSHFD) can be executed in virtual-8086 mode with IOPL < 3.\n(The protected-mode virtual-interrupt feature - enabled by setting CR4.PVI - affects the CLI and STI instructions in the same manner as the virtual-8086 mode extensions. PUSHF, however, is not affected by CR4.PVI.)\nIn the real-address mode, if the ESP or SP register is 1 when PUSHF/PUSHFD instruction executes: an #SS exception is generated but not delivered (the stack error reported prevents #SS delivery). Next, the processor generates a #DF exception and enters a shutdown state as described in the #DF discussion in Chapter 6 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3A."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "VPMADD52LUQ"
    short_description: "Packed Multiply of Unsigned 52-bit Integers and Add the Low 52-bit Products to Qword Accumulators"
  }
  instruction_groups {
    name: "PSUBSB/PSUBSW"
    short_description: "Subtract Packed Signed Integers with Signed Saturation"
    description: "Performs a SIMD subtract of the packed signed integers of the source operand (second operand) from the packed signed integers of the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with signed saturation, as described in the following paragraphs.\nThe (V)PSUBSB instruction subtracts packed signed byte integers. When an individual byte result is beyond the range of a signed byte integer (that is, greater than 7FH or less than 80H), the saturated value of 7FH or 80H, respectively, is written to the destination operand.\nThe (V)PSUBSW instruction subtracts packed signed word integers. When an individual word result is beyond the range of a signed word integer (that is, greater than 7FFFH or less than 8000H), the saturated value of 7FFFH or 8000H, respectively, is written to the destination operand.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE version 64-bit operand: The destination operand must be an MMX technology register and the source operand can be either an MMX technology register or a 64-bit memory location.\n128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded versions: The second source operand is an YMM register or an 256-bit memory location. The first source operand and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.\nEVEX encoded version: The second source operand is an ZMM/YMM/XMM register or an 512/256/128-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "VRSQRT14SD"
    short_description: "Compute Approximate Reciprocal of Square Root of Scalar Float64 Value"
  }
  instruction_groups {
    name: "CLD"
    short_description: "Clear Direction Flag"
    description: "Clears the DF flag in the EFLAGS register. When the DF flag is set to 0, string operations increment the index registers (ESI and/or EDI). Operation is the same in all modes."
    flags_affected {
      content: "The DF flag is set to 0. The CF, OF, ZF, SF, AF, and PF flags are unaffected."
    }
  }
  instruction_groups {
    name: "VBLENDMPD/VBLENDMPS"
    short_description: "Blend Float64/Float32 Vectors Using an OpMask Control"
  }
  instruction_groups {
    name: "ANDPD"
    short_description: "Bitwise Logical AND of Packed Double Precision Floating-Point Values"
    description: "Performs a bitwise logical AND of the two, four or eight packed double-precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand.\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\nVEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified."
  }
  instruction_groups {
    name: "XEND"
    short_description: "Transactional End"
    description: "The instruction marks the end of an RTM code region. If this corresponds to the outermost scope (that is, including this XEND instruction, the number of XBEGIN instructions is the same as number of XEND instructions), the logical processor will attempt to com mit the logical processor state atomically. If the com mit fails, the logical processor will rollback all architectural register and memory updates performed during the RTM execution. The logical processor will resume execution at the fallback address computed from the outermost XBEGIN instruction. The EAX register is updated to reflect RTM abort information.\nXEND executed outside a transactional region will cause a #GP (General Protection Fault)."
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "FLD1/FLDL2T/FLDL2E/FLDPI/FLDLG2/FLDLN2/FLDZ"
    short_description: "Load Constant"
    description: "Push one of seven com monly used constants (in double extended-precision floating-point format) onto the FPU register stack. The constants that can be loaded with these instructions include +1.0, +0.0, log210, log2e, \317\200, log102, and loge2. For each constant, an internal 66-bit constant is rounded (as specified by the RC field in the FPU control word) to double extended-precision floating-point format. The inexact-result exception (#P) is not generated as a result of the rounding, nor is the C1 flag set in the x87 FPU status word if the value is rounded up.\nSee the section titled \342\200\234Approximation of Pi\342\200\235 in Chapter 8 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1, for a description of the \317\200 constant.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C1\tSet to 1 if stack overflow occurred; otherwise, set to 0.\nC0, C2, C3\tUndefined."
    }
  }
  instruction_groups {
    name: "ADDSUBPS"
    short_description: "Packed Single-FP Add/Subtract"
    description: "Adds odd-numbered single-precision floating-point values of the first source operand (second operand) with the corresponding single-precision floating-point values from the second source operand (third operand); stores the result in the odd-numbered values of the destination operand (first operand). Subtracts the even-numbered single-precision floating-point values from the second source operand from the corresponding single-precision floating values in the first source operand; stores the result into the even-numbered values of the destination operand.\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified. See Figure\n3-4.\nVEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.\nADDSUBPS xmm1, xmm2/m128\n[127:96]\t[95:64]\t[63:32]\t[31:0]\txmm2/ m128\nxmm1[127:96] + xmm2/m128[127:96]\txmm1[95:64] - xmm2/ m128[95:64]\txmm1[63:32] + xmm2/m128[63:32]\txmm1[31:0] - xmm2/m128[31:0]\tRESULT: xmm1\n[127:96]\t[95:64]\t[63:32]\t[31:0]\nOM15992\nFigure 3-4.  ADDSUBPS-Packed Single-FP Add/Subtract"
  }
  instruction_groups {
    name: "PAUSE"
    short_description: "Spin Loop Hint"
    description: "Improves the performance of spin-wait loops. When executing a \342\200\234spin-wait loop,\342\200\235 processors will suffer a severe performance penalty when exiting the loop because it detects a possible memory order violation. The PAUSE instruction provides a hint to the processor that the code sequence is a spin-wait loop. The processor uses this hint to avoid the memory order violation in most situations, which greatly improves processor performance. For this reason, it is recom mended that a PAUSE instruction be placed in all spin-wait loops.\nAn additional function of the PAUSE instruction is to reduce the power consumed by a processor while executing a spin loop. A processor can execute a spin-wait loop extremely quickly, causing the processor to consume a lot of power while it waits for the resource it is spinning on to become available. Inserting a pause instruction in a spinwait loop greatly reduces the processor\342\200\231s power consumption.\nThis instruction was introduced in the Pentium 4 processors, but is backward compatible with all IA-32 processors.\nIn earlier IA-32 processors, the PAUSE instruction operates like a NOP instruction. The Pentium 4 and Intel Xeon processors implement the PAUSE instruction as a delay. The delay is finite and can be zero for some processors.\nThis instruction does not change the architectural state of the processor (that is, it performs essentially a delaying no-op operation).\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
  }
  instruction_groups {
    name: "FCHS"
    short_description: "Change Sign"
    description: "Complements the sign bit of ST(0). This operation changes a positive value into a negative value of equal magnitude or vice versa. The following table shows the results obtained when changing the sign of various classes of numbers.\nTable 3-20.  FCHS Results\nST(0) SRC\tST(0) DEST\n\342\210\222 \342\210\236\t+ \342\210\236\n\342\210\222 F\t+ F\n\342\210\222 0\t+ 0\n+ 0\t\342\210\222 0\n+ F\t\342\210\222 F\n+ \342\210\236\t\342\210\222 \342\210\236\nNaN\tNaN\nNOTES:\n*\tF means finite floating-point value.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C1\tSet to 0.\nC0, C2, C3\tUndefined."
    }
  }
  instruction_groups {
    name: "OUTS/OUTSB/OUTSW/OUTSD"
    short_description: "Output String to Port"
    description: "Copies data from the source operand (second operand) to the I/O port specified with the destination operand (first operand). The source operand is a memory location, the address of which is read from either the DS:SI, DS:ESI or the RSI registers (depending on the address-size attribute of the instruction, 16, 32 or 64, respectively). (The DS segment may be overridden with a segment override prefix.) The destination operand is an I/O port address (from 0 to 65,535) that is read from the DX register. The size of the I/O port being accessed (that is, the size of the source and destination operands) is determined by the opcode for an 8-bit I/O port or by the operand-size attribute of the instruction for a 16- or 32-bit I/O port.\nAt the assembly-code level, two forms of this instruction are allowed: the \342\200\234explicit-operands\342\200\235 form and the \342\200\234nooperands\342\200\235 form. The explicit-operands form (specified with the OUTS mnemonic) allows the source and destination operands to be specified explicitly. Here, the source operand should be a symbol that indicates the size of the I/O port and the source address, and the destination operand must be DX. This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the source operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword), but it does not have to specify the correct location. The location is always specified by the DS:(E)SI or RSI registers, which must be loaded correctly before the OUTS instruction is executed.\nThe no-operands form provides \342\200\234short forms\342\200\235 of the byte, word, and doubleword versions of the OUTS instructions.\nHere also DS:(E)SI is assumed to be the source operand and DX is assumed to be the destination operand. The size of the I/O port is specified with the choice of mnemonic: OUTSB (byte), OUTSW (word), or OUTSD (doubleword).\nAfter the byte, word, or doubleword is transferred from the memory location to the I/O port, the SI/ESI/RSI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register.\n(If the DF flag is 0, the (E)SI register is incremented; if the DF flag is 1, the SI/ESI/RSI register is decremented.) The SI/ESI/RSI register is incremented or decremented by 1 for byte operations, by 2 for word operations, and by 4 for doubleword operations.\nThe OUTS, OUTSB, OUTSW, and OUTSD instructions can be preceded by the REP prefix for block input of ECX bytes, words, or doublewords. See \342\200\234REP/REPE/REPZ /REPNE/REPNZ-Repeat String Operation Prefix\342\200\235 in this chapter for a description of the REP prefix. This instruction is only useful for accessing I/O ports located in the processor\342\200\231s I/O address space. See Chapter 19, \342\200\234Input/Output,\342\200\235 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1, for more information on accessing I/O ports in the I/O address space.\nIn 64-bit mode, the default operand size is 32 bits; operand size is not promoted by the use of REX.W. In 64-bit mode, the default address size is 64 bits, and 64-bit address is specified using RSI by default. 32-bit address using ESI is support using the prefix 67H, but 16-bit address is not supported in 64-bit mode."
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "VFNMADD132SS/VFNMADD213SS/VFNMADD231SS"
    short_description: "Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "FRSTOR"
    short_description: "Restore x87 FPU State"
    description: "Loads the FPU state (operating environment and register stack) from the memory area specified with the source operand. This state data is typically written to the specified memory location by a previous FSAVE/FNSAVE instruction.\nThe FPU operating environment consists of the FPU control word, status word, tag word, instruction pointer, data pointer, and last opcode. Figures 8-9 through 8-12 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1, show the layout in memory of the stored environment, depending on the operating mode of the processor (protected or real) and the current operand-size attribute (16-bit or 32-bit). In virtual-8086 mode, the real mode layouts are used. The contents of the FPU register stack are stored in the 80 bytes im mediately following\nthe operating environment image.\nThe FRSTOR instruction should be executed in the same operating mode as the corresponding FSAVE/FNSAVE instruction.\nIf one or more unmasked exception bits are set in the new FPU status word, a floating-point exception will be generated upon execution of the next floating-point instruction (except for the no-wait floating-point instructions, see the section titled \342\200\234Software Exception Handling\342\200\235 in Chapter 8 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1). To avoid raising exceptions when loading a new operating environment, clear all the exception flags in the FPU status word that is being loaded.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "The C0, C1, C2, C3 flags are loaded."
    }
  }
  instruction_groups {
    name: "CVTTPD2DQ"
    short_description: "Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Doubleword Integers"
    description: "Converts two, four or eight packed double-precision floating-point values in the source operand (second operand) to two, four or eight packed signed doubleword integers in the destination operand (first operand).\nWhen a conversion is inexact, a truncated (round toward zero) value is returned. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.\nEVEX encoded versions: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a YMM/XMM/XMM (low 64 bits) register conditionally updated with writemask k1. The upper bits (MAXVL-1:256) of the corresponding destination are zeroed.\nVEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\nVEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:64) of the corresponding ZMM register destination are zeroed.\n128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.\nSRC\tX3\tX2\tX1\tX0\nDEST\t0\tX3\tX2\tX1\tX0\nFigure 3-15.  VCVTTPD2DQ (VEX.256 encoded version)"
  }
  instruction_groups {
    name: "FPREM1"
    short_description: "Partial Remainder"
    description: "Computes the IEEE remainder obtained from dividing the value in the ST(0) register (the dividend) by the value in the ST(1) register (the divisor or modulus), and stores the result in ST(0). The remainder represents the following value:\nRemainder := ST(0) \342\210\222 (Q \342\210\227 ST(1))\nHere, Q is an integer value that is obtained by rounding the floating-point number quotient of [ST(0) / ST(1)] toward the nearest integer value. The magnitude of the remainder is less than or equal to half the magnitude of the modulus, unless a partial remainder was computed (as described below).\nThis instruction produces an exact result; the precision (inexact) exception does not occur and the rounding control has no effect. The following table shows the results obtained when computing the remainder of various classes of numbers, assuming that underflow does not occur.\nTable 3-32.  FPREM1 Results\nST(1)\n\342\210\222 \342\210\236\t\342\210\222 F\t\342\210\222 0\t+ 0\t+ F\t+ \342\210\236\tNaN\n\342\210\222 \342\210\236\t*\t*\t*\t*\t*\t*\tNaN\nST(0)\t\342\210\222 F\tST(0)\t\302\261F or \342\210\2220\t**\t**\t\302\261 F or \342\210\222 0\tST(0)\tNaN\n\342\210\222 0\t\342\210\222 0\t\342\210\222 0\t*\t*\t\342\210\222 0\t-0\tNaN\n+ 0\t+ 0\t+ 0\t*\t*\t+ 0\t+0\tNaN\n+ F\tST(0)\t\302\261 F or + 0\t**\t**\t\302\261 F or + 0\tST(0)\tNaN\n+ \342\210\236\t*\t*\t*\t*\t*\t*\tNaN\nNaN\tNaN\tNaN\tNaN\tNaN\tNaN\tNaN\tNaN\nNOTES:\nF\tMeans finite floating-point value.\n* Indicates floating-point invalid-arithmetic-operand (#IA) exception.\n**Indicates floating-point zero-divide (#Z) exception.\nWhen the result is 0, its sign is the same as that of the dividend. When the modulus is \342\210\236, the result is equal to the value in ST(0).\nThe FPREM1 instruction computes the remainder specified in IEEE Standard 754. This instruction operates differently from the FPREM instruction in the way that it rounds the quotient of ST(0) divided by ST(1) to an integer (see the \342\200\234Operation\342\200\235 section below).\nLike the FPREM instruction, FPREM1 computes the remainder through iterative subtraction, but can reduce the exponent of ST(0) by no more than 63 in one execution of the instruction. If the instruction succeeds in producing a remainder that is less than one half the modulus, the operation is complete and the C2 flag in the FPU status word is cleared. Otherwise, C2 is set, and the result in ST(0) is called the partial remainder. The exponent of the partial remainder will be less than the exponent of the original dividend by at least 32. Software can re-execute the instruction (using the partial remainder in ST(0) as the dividend) until C2 is cleared. (Note that while executing such a remainder-computation loop, a higher-priority interrupting routine that needs the FPU can force a context switch in-between the instructions in the loop.)\nAn important use of the FPREM1 instruction is to reduce the arguments of periodic functions. When reduction is complete, the instruction stores the three least-significant bits of the quotient in the C3, C1, and C0 flags of the FPU\nstatus word. This information is important in argument reduction for the tangent function (using a modulus of \317\200/4), because it locates the original angle in the correct one of eight sectors of the unit circle.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C0\tSet to bit 2 (Q2) of the quotient.\nC1\tSet to 0 if stack underflow occurred; otherwise, set to least significant bit of quotient (Q0).\nC2\tSet to 0 if reduction complete; set to 1 if incomplete.\nC3\tSet to bit 1 (Q1) of the quotient."
    }
  }
  instruction_groups {
    name: "OR"
    short_description: "Logical Inclusive OR"
    description: "Performs a bitwise inclusive OR operation between the destination (first) and source (second) operands and stores the result in the destination operand location. The source operand can be an im\nmediate, a register, or a memory location; the destination operand can be a register or a memory location. (However, two memory operands cannot be used in one instruction.) Each bit of the result of the OR instruction is set to 0 if both corresponding bits of the first and second operands are 0; otherwise, each bit is set to 1.\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.\nIn 64-bit mode, the instruction\342\200\231s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the sum mary chart at the beginning of this section for encoding data and limits."
    flags_affected {
      content: "The OF and CF flags are cleared; the SF, ZF, and PF flags are set according to the result. The state of the AF flag is undefined."
    }
  }
  instruction_groups {
    name: "MOVLPS"
    short_description: "Move Low Packed Single-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "PMULDQ"
    short_description: "Multiply Packed Doubleword Integers"
  }
  instruction_groups {
    name: "VCVTUSI2SS"
    short_description: "Convert Unsigned Integer to Scalar Single-Precision Floating-Point Value"
  }
  instruction_groups {
    name: "VCVTQQ2PD"
    short_description: "Convert Packed Quadword Integers to Packed Double-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "VPERMILPD"
    short_description: "Permute In-Lane of Pairs of Double-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "SHA1MSG1"
    short_description: "Perform an Intermediate Calculation for the Next Four SHA1 Message Dwords"
  }
  instruction_groups {
    name: "VFMSUB132SD/VFMSUB213SD/VFMSUB231SD"
    short_description: "Fused Multiply-Subtract of Scalar Double-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "VPSHLD"
    short_description: "Concatenate and Shift Packed Data Left Logical"
  }
  instruction_groups {
    name: "XADD"
    short_description: "Exchange and Add"
    description: "Exchanges the first operand (destination operand) with the second operand (source operand), then loads the sum of the two values into the destination operand. The destination operand can be a register or a memory location; the source operand is a register.\nIn 64-bit mode, the instruction\342\200\231s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the sum mary chart at the beginning of this section for encoding data and limits.\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically."
    flags_affected {
      content: "The CF, PF, AF, SF, ZF, and OF flags are set according to the result of the addition, which is stored in the destination operand."
    }
  }
  instruction_groups {
    name: "EDECVIRTCHILD"
  }
  instruction_groups {
    name: "VPERMI2B"
    short_description: "Full Permute of Bytes from Two Tables Overwriting the Index"
  }
  instruction_groups {
    name: "CVTSD2SI"
    short_description: "Convert Scalar Double-Precision Floating-Point Value to Doubleword Integer"
    description: "Converts a double-precision floating-point value in the source operand (the second operand) to a signed doubleword integer in the destination operand (first operand). The source operand can be an XMM register or a 64-bit memory location. The destination operand is a general-purpose register. When the source operand is an XMM register, the double-precision floating-point value is contained in the low quadword of the register.\nWhen a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.\nIf a converted result exceeds the range limits of signed doubleword integer (in non-64-bit modes or 64-bit mode with REX.W/VEX.W/EVEX.W\n=0), the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.\nIf a converted result exceeds the range limits of signed quadword integer (in 64-bit mode and REX.W/VEX.W/EVEX.W = 1), the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000_00000000H) is returned.\nLegacy SSE instruction: Use of the REX.W prefix promotes the instruction to produce 64-bit data in 64-bit mode.\nSee the sum\nmary chart at the beginning of this section for encoding data and limits.\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.\nSoftware should ensure VCVTSD2SI is encoded with VEX.L=0. Encoding VCVTSD2SI with VEX.L=1 may encounter unpredictable behavior across different processor generations."
  }
  instruction_groups {
    name: "PSRLW/PSRLD/PSRLQ"
    short_description: "Shift Packed Data Right Logical"
    description: "Shifts the bits in the individual data elements (words, doublewords, or quadword) in the destination operand (first operand) to the right by the number of bits specified in the count operand (second operand). As the bits in the data elements are shifted right, the empty high-order bits are cleared (set to 0). If the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination operand is set to all 0s. Figure 4-19 gives an example of shifting words in a 64-bit operand.\nNote that only the low 64-bits of a 128-bit count operand are checked to compute the count.\nPre-Shift\nX3\tX2\tX1\tX0\nDEST\nShift Right\nwith Zero Extension\nPost-Shift DEST\tX3 >> COUNT\tX2 >> COUNT\tX1 >> COUNT\tX0 >> COUNT\nFigure 4-19.  PSRLW, PSRLD, and PSRLQ Instruction Operation Using 64-bit Operand\nThe (V)PSRLW instruction shifts each of the words in the destination operand to the right by the number of bits specified in the count operand; the (V)PSRLD instruction shifts each of the doublewords in the destination operand; and the PSRLQ instruction shifts the quadword (or quadwords) in the destination operand.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE instruction 64-bit operand: The destination operand is an MMX technology register; the count operand can be either an MMX technology register or an 64-bit memory location.\n128-bit Legacy SSE version: The destination operand is an XMM register; the count operand can be either an XMM register or a 128-bit memory location, or an 8-bit im\nmediate. If the count operand is a memory address, 128 bits are loaded but the upper 64 bits are ignored. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The destination operand is an XMM register; the count operand can be either an XMM register or a 128-bit memory location, or an 8-bit im\nmediate. If the count operand is a memory address, 128 bits are loaded but the upper 64 bits are ignored. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded version: The destination operand is a YMM register. The source operand is a YMM register or a memory location. The count operand can come either from an XMM register or a memory location or an 8-bit im me-\ndiate. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.\nEVEX encoded versions: The destination operand is a ZMM register updated according to the writemask. The count operand is either an 8-bit im mediate (the im mediate count version) or an 8-bit value from an XMM register or a memory location (the variable count version). For the im\nmediate count version, the source operand (the second operand) can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location. For the variable count version, the first source operand (the second operand) is a ZMM register, the second source operand (the third operand, 8-bit variable count) can be an XMM register or a memory location.\nNote: In VEX/EVEX encoded versions of shifts with an im\nmediate count, vvvv of VEX/EVEX encode the destination register, and VEX.B/EVEX.B + ModRM.r/m encodes the source register.\nNote: For shifts with an im mediate count (VEX.128.66.0F 71-73 /2, or EVEX.128.66.0F 71-73 /2), VEX.vvvv/EVEX.vvvv encodes the destination register."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "BSF"
    short_description: "Bit Scan Forward"
    description: "Searches the source operand (second operand) for the least significant set bit (1 bit). If a least significant 1 bit is found, its bit index is stored in the destination operand (first operand). The source operand can be a register or a memory location; the destination operand is a register. The bit index is an unsigned offset from bit 0 of the source operand. If the content of the source operand is 0, the content of the destination operand is undefined.\nIn 64-bit mode, the instruction\342\200\231s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the sum mary chart at the beginning of this section for encoding data and limits."
    flags_affected {
      content: "The ZF flag is set to 1 if the source operand is 0; otherwise, the ZF flag is cleared. The CF, OF, SF, AF, and PF flags are undefined."
    }
  }
  instruction_groups {
    name: "VPMOVDW/VPMOVSDW/VPMOVUSDW"
    short_description: "Down Convert DWord to Word"
  }
  instruction_groups {
    name: "EINIT"
  }
  instruction_groups {
    name: "PACKUSWB"
    short_description: "Pack with Unsigned Saturation"
    description: "Converts 4, 8, 16 or 32 signed word integers from the destination operand (first operand) and 4, 8, 16 or 32 signed word integers from the source operand (second operand) into 8, 16, 32 or 64 unsigned byte integers and stores the result in the destination operand. (See Figure\n4-6 for an example of the packing operation.) If a signed word integer value is beyond the range of an unsigned byte integer (that is, greater than FFH or less than 00H), the saturated unsigned byte integer value of FFH or 00H, respectively, is stored in the destination.\nEVEX.512 encoded version: The first source operand is a ZMM register. The second source operand is a ZMM register or a 512-bit memory location. The destination operand is a ZMM register.\nVEX.256 and EVEX.256 encoded versions: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL- 1:256) of the corresponding ZMM register destination are zeroed.\nVEX.128 and EVEX.128 encoded versions: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL- 1:128) of the corresponding register destination are zeroed.\n128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified."
    flags_affected {
      content: "None\nSIMD Floating-Point Exceptions\nNone"
    }
  }
  instruction_groups {
    name: "UCOMISS"
    short_description: "Unordered Compare Scalar Single-Precision Floating-Point Values and Set EFLAGS"
  }
  instruction_groups {
    name: "STD"
    short_description: "Set Direction Flag"
    description: "Sets the DF flag in the EFLAGS register. When the DF flag is set to 1, string operations decrement the index registers (ESI and/or EDI). Operation is the same in all modes."
    flags_affected {
      content: "The DF flag is set. The CF, OF, ZF, SF, AF, and PF flags are unaffected."
    }
  }
  instruction_groups {
    name: "HSUBPS"
    short_description: "Packed Single-FP Horizontal Subtract"
    description: "Subtracts the single-precision floating-point value in the second dword of the destination operand from the first dword of the destination operand and stores the result in the first dword of the destination operand.\nSubtracts the single-precision floating-point value in the fourth dword of the destination operand from the third dword of the destination operand and stores the result in the second dword of the destination operand.\nSubtracts the single-precision floating-point value in the second dword of the source operand from the first dword of the source operand and stores the result in the third dword of the destination operand.\nSubtracts the single-precision floating-point value in the fourth dword of the source operand from the third dword of the source operand and stores the result in the fourth dword of the destination operand.\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).\nSee Figure\t3-22 for HSUBPS; see Figure\t3-23 for VHSUBPS.\nHSUBPS xmm1, xmm2/m128\n[127:96]\t[95:64]\t[63:32]\t[31:0]\txmm2/ m128\n[127:96]\t[95:64]\t[63:32]\t[31:0]\txmm1\nxmm2/m128 [95:64] - xmm2/ m128[127:96]\txmm2/m128 [31:0] - xmm2/ m128[63:32]\txmm1[95:64] - xmm1[127:96]\txmm1[31:0] - xmm1[63:32]\tRESULT: xmm1\n[127:96]\t[95:64]\t[63:32]\t[31:0]\nOM15996\nFigure 3-22.  HSUBPS-Packed Single-FP Horizontal Subtract\nSRC1\tX7\tX6\tX5\tX4\tX3\tX2\tX1\tX0\nSRC2\tY7\tY6\tY5\tY4\tY3\tY2\tY1\tY0\nDEST\tY6-Y7\tY4-Y5\tX6-X7\tX4-X5\tY2-Y3\tY0-Y1\tX2-X3\tX0-X1\nFigure 3-23.  VHSUBPS operation\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.\nVEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register."
  }
  instruction_groups {
    name: "VFMSUB132PD/VFMSUB213PD/VFMSUB231PD"
    short_description: "Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "XTEST"
    short_description: "Test If In Transactional Execution"
    description: "The XTEST instruction queries the transactional execution status. If the instruction executes inside a transactionally executing RTM region or a transactionally executing HLE region, then the ZF flag is cleared, else it is set."
    flags_affected {
      content: "The ZF flag is cleared if the instruction is executed transactionally; otherwise it is set to 1. The CF, OF, SF, PF, and AF, flags are cleared."
    }
  }
  instruction_groups {
    name: "EENTER"
  }
  instruction_groups {
    name: "COMISD"
    short_description: "Compare Scalar Ordered Double-Precision Floating-Point Values and Set EFLAGS"
    description: "Compares the double-precision floating-point values in the low quadwords of operand 1 (first operand) and operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result (unordered, greater than, less than, or equal). The OF, SF and AF flags in the EFLAGS register are set to 0. The unordered result is returned if either source operand is a NaN (QNaN or SNaN).\nOperand 1 is an XMM register; operand 2 can be an XMM register or a 64 bit memory location. The COMISD instruction differs from the UCOMISD instruction in that it signals a SIMD floating-point invalid operation exception (#I) when a source operand is either a QNaN or SNaN. The UCOMISD instruction signals an invalid operation exception only if a source operand is an SNaN.\nThe EFLAGS register is not updated if an unmasked SIMD floating-point exception is generated.\nVEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.\nSoftware should ensure VCOMISD is encoded with VEX.L=0. Encoding VCOMISD with VEX.L=1 may encounter unpredictable behavior across different processor generations."
  }
  instruction_groups {
    name: "IDIV"
    short_description: "Signed Divide"
    description: "Divides the (signed) value in the AX, DX:AX, or EDX:EAX (dividend) by the source operand (divisor) and stores the result in the AX (AH:AL), DX:AX, or EDX:EAX registers. The source operand can be a general-purpose register or a memory location. The action of this instruction depends on the operand size (dividend/divisor).\nNon-integral results are truncated (chopped) towards 0. The remainder is always less than the divisor in magnitude. Overflow is indicated with the #DE (divide error) exception rather than with the CF flag.\nIn 64-bit mode, the instruction\342\200\231s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. In 64-bit mode when REX.W is applied, the instruction divides the signed value in RDX:RAX by the source operand. RAX contains a 64-bit quotient; RDX contains a 64-bit remainder.\nSee the sum mary chart at the beginning of this section for encoding data and limits. See Table 3-51.\nTable 3-51.  IDIV Results\nOperand Size\tDividend\tDivisor\tQuotient\tRemainder\tQuotient Range\nWord/byte\tAX\tr/m8\tAL\tAH\t\342\210\222128 to +127\nDoubleword/word\tDX:AX\tr/m16\tAX\tDX\t\342\210\22232,768 to +32,767\nQuadword/doubleword\tEDX:EAX\tr/m32\tEAX\tEDX\t\342\210\222231 to 231 \342\210\222 1\nDoublequadword/ quadword\tRDX:RAX\tr/m64\tRAX\tRDX\t\342\210\222263 to 263 \342\210\222 1"
    flags_affected {
      content: "The CF, OF, SF, ZF, AF, and PF flags are undefined."
    }
  }
  instruction_groups {
    name: "FPREM"
    short_description: "Partial Remainder"
    description: "Computes the remainder obtained from dividing the value in the ST(0) register (the dividend) by the value in the ST(1) register (the divisor or modulus), and stores the result in ST(0). The remainder represents the following value:\nRemainder := ST(0) \342\210\222 (Q \342\210\227 ST(1))\nHere, Q is an integer value that is obtained by truncating the floating-point number quotient of [ST(0) / ST(1)] toward zero. The sign of the remainder is the same as the sign of the dividend. The magnitude of the remainder is less than that of the modulus, unless a partial remainder was computed (as described below).\nThis instruction produces an exact result; the inexact-result exception does not occur and the rounding control has no effect. The following table shows the results obtained when computing the remainder of various classes of numbers, assuming that underflow does not occur.\nTable 3-31.  FPREM Results\nST(1)\n-\342\210\236\t-F\t-0\t+0\t+F\t+\342\210\236\tNaN\n-\342\210\236\t*\t*\t*\t*\t*\t*\tNaN\nST(0)\t-F\tST(0)\t-F or -0\t**\t**\t-F or -0\tST(0)\tNaN\n-0\t-0\t-0\t*\t*\t-0\t-0\tNaN\n+0\t+0\t+0\t*\t*\t+0\t+0\tNaN\n+F\tST(0)\t+F or +0\t**\t**\t+F or +0\tST(0)\tNaN\n+\342\210\236\t*\t*\t*\t*\t*\t*\tNaN\nNaN\tNaN\tNaN\tNaN\tNaN\tNaN\tNaN\tNaN\nNOTES:\nF\tMeans finite floating-point value.\n* Indicates floating-point invalid-arithmetic-operand (#IA) exception.\n**Indicates floating-point zero-divide (#Z) exception.\nWhen the result is 0, its sign is the same as that of the dividend. When the modulus is \342\210\236, the result is equal to the value in ST(0).\nThe FPREM instruction does not compute the remainder specified in IEEE Std 754. The IEEE specified remainder can be computed with the FPREM1 instruction. The FPREM instruction is provided for compatibility with the Intel 8087 and Intel287 math coprocessors.\nThe FPREM instruction gets its name \342\200\234partial remainder\342\200\235 because of the way it computes the remainder. This instruction arrives at a remainder through iterative subtraction. It can, however, reduce the exponent of ST(0) by no more than 63 in one execution of the instruction. If the instruction succeeds in producing a remainder that is less than the modulus, the operation is complete and the C2 flag in the FPU status word is cleared. Otherwise, C2 is set, and the result in ST(0) is called the partial remainder. The exponent of the partial remainder will be less than the exponent of the original dividend by at least 32. Software can re-execute the instruction (using the partial remainder in ST(0) as the dividend) until C2 is cleared. (Note that while executing such a remainder-computation loop, a higher-priority interrupting routine that needs the FPU can force a context switch in-between the instructions in the loop.)\nAn important use of the FPREM instruction is to reduce the arguments of periodic functions. When reduction is complete, the instruction stores the three least-significant bits of the quotient in the C3, C1, and C0 flags of the FPU\nstatus word. This information is important in argument reduction for the tangent function (using a modulus of \317\200/4), because it locates the original angle in the correct one of eight sectors of the unit circle.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C0\tSet to bit 2 (Q2) of the quotient.\nC1\tSet to 0 if stack underflow occurred; otherwise, set to least significant bit of quotient (Q0).\nC2\tSet to 0 if reduction complete; set to 1 if incomplete.\nC3\tSet to bit 1 (Q1) of the quotient."
    }
  }
  instruction_groups {
    name: "VRANGESD"
    short_description: "Range Restriction Calculation From a pair of Scalar Float64 Values"
  }
  instruction_groups {
    name: "SQRTPD"
    short_description: "Square Root of Double-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "ADOX"
    short_description: "Unsigned Integer Addition of Two Operands with Overflow Flag"
    description: "Performs an unsigned addition of the destination operand (first operand), the source operand (second operand) and the overflow-flag (OF) and stores the result in the destination operand. The destination operand is a generalpurpose register, whereas the source operand can be a general-purpose register or memory location. The state of OF represents a carry from a previous addition. The instruction sets the OF flag with the carry generated by the unsigned addition of the operands.\nThe ADOX instruction is executed in the context of multi-precision addition, where we add a series of operands with a carry-chain. At the beginning of a chain of additions, we execute an instruction to zero the OF (e.g. XOR).\nThis instruction is supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode.\nIn 64-bit mode, the default operation size is 32 bits. Using a REX Prefix in the form of REX.R permits access to additional registers (R8-15). Using REX Prefix in the form of REX.W promotes operation to 64-bits.\nADOX executes normally either inside or outside a transaction region.\nNote: ADOX defines the CF and OF flags differently than the ADD/ADC instructions as defined in Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 2A."
    flags_affected {
      content: "OF is updated based on result. CF, SF, ZF, AF and PF flags are unmodified."
    }
  }
  instruction_groups {
    name: "VSCATTERPF0DPS/VSCATTERPF0QPS/VSCATTERPF0DPD/VSCATTERPF0QPD"
    short_description: "Sparse Prefetch Packed SP/DP Data Values with"
  }
  instruction_groups {
    name: "PBLENDW"
    short_description: "Blend Packed Words"
    description: "Words from the source operand (second operand) are conditionally written to the destination operand (first operand) depending on bits in the im mediate operand (third operand). The im mediate bits (bits 7:0) form a mask that determines whether the corresponding word in the destination is copied from the source. If a bit in the mask, corresponding to a word, is \342\200\2341\", then the word is copied, else the word element in the destination operand is unchanged.\n128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register."
    flags_affected {
      content: "None.\nSIMD Floating-Point Exceptions\nNone."
    }
  }
  instruction_groups {
    name: "MOVNTPD"
    short_description: "Store Packed Double-Precision Floating-Point Values Using Non-Temporal Hint"
  }
  instruction_groups {
    name: "RCPSS"
    short_description: "Compute Reciprocal of Scalar Single-Precision Floating-Point Values"
    description: "Computes of an approximate reciprocal of the low single-precision floating-point value in the source operand (second operand) and stores the single-precision floating-point result in the destination operand. The source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register. The three high-order doublewords of the destination operand remain unchanged. See Figure 10-6 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1, for an illustration of a scalar single-precision floatingpoint operation.\nThe relative error for this approximation is:\n|Relative Error| \342\211\244 1.5 \342\210\227 2\342\210\22212\nThe RCPSS instruction is not affected by the rounding control bits in the MXCSR register. When a source value is a 0.0, an \342\210\236 of the sign of the source value is returned. A denormal source value is treated as a 0.0 (of the same sign).\nTiny results (see Section 4.9.1.5, \342\200\234Numeric Underflow Exception (#U)\342\200\235 in Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1) are always flushed to 0.0, with the sign of the operand. (Input values greater than or equal to |1.11111111110100000000000B\342\210\2272125| are guaranteed to not produce tiny results; input values less than or equal to |1.00000000000110000000001B*2126| are guaranteed to produce tiny results, which are in turn flushed to 0.0; and input values in between this range may or may not produce tiny results, depending on the implementation.) When a source value is an SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned.\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL- 1:32) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: Bits (MAXVL-1:128) of the destination YMM register are zeroed."
  }
  instruction_groups {
    name: "VCVTUDQ2PD"
    short_description: "Convert Packed Unsigned Doubleword Integers to Packed Double-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "AAM"
    short_description: "ASCII Adjust AX After Multiply"
    description: "Adjusts the result of the multiplication of two unpacked BCD values to create a pair of unpacked (base 10) BCD values. The AX register is the implied source and destination operand for this instruction. The AAM instruction is only useful when it follows an MUL instruction that multiplies (binary multiplication) two unpacked BCD values and stores a word result in the AX register. The AAM instruction then adjusts the contents of the AX register to contain the correct 2-digit unpacked (base 10) BCD result.\nThe generalized version of this instruction allows adjustment of the contents of the AX to create two unpacked digits of any number base (see the \342\200\234Operation\342\200\235 section below). Here, the im\nm8 byte is set to the selected number base (for example, 08H for octal, 0AH for decimal, or 0CH for base 12 numbers). The AAM mnemonic is interpreted by all assemblers to mean adjust to ASCII (base 10) values. To adjust to values in another number base, the instruction must be hand coded in machine code (D4 im m8).\nThis instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode."
    flags_affected {
      content: "The SF, ZF, and PF flags are set according to the resulting binary value in the AL register. The OF, AF, and CF flags are undefined."
    }
  }
  instruction_groups {
    name: "AESENCLAST"
    short_description: "Perform Last Round of an AES Encryption Flow"
    description: "This instruction performs the last round of an AES encryption flow using a round key from the second source operand, operating on 128-bit data (state) from the first source operand, and store the result in the destination operand.\nVEX and EVEX encoded versions of the instruction allows 3-operand (non-destructive) operation. The legacy encoded versions of the instruction require that the first source operand and the destination operand are the same and must be an XMM register.\nThe EVEX encoded form of this instruction does not support memory fault suppression."
  }
  instruction_groups {
    name: "VFNMSUB132SS/VFNMSUB213SS/VFNMSUB231SS"
    short_description: "Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Val-"
  }
  instruction_groups {
    name: "PMINSD/PMINSQ"
    short_description: "Minimum of Packed Signed Integers"
  }
  instruction_groups {
    name: "FSINCOS"
    short_description: "Sine and Cosine"
    description: "Computes both the approximate sine and the cosine of the source operand in register ST(0), stores the sine in ST(0), and pushes the cosine onto the top of the FPU register stack. (This instruction is faster than executing the FSIN and FCOS instructions in succession.) The source operand must be given in radians and must be within the range \342\210\222263 to +263. The following table shows the results obtained when taking the sine and cosine of various classes of numbers, assuming that underflow does not occur.\nTable 3-36.  FSINCOS Results\nSRC\tDEST\nST(0)\tST(1) Cosine\tST(0) Sine\n\342\210\222 \342\210\236\t*\t*\n\342\210\222 F\t\342\210\222 1 to + 1\t\342\210\222 1 to + 1\n\342\210\222 0\t+ 1\t\342\210\222 0\n+ 0\t+ 1\t+ 0\n+ F\t\342\210\222 1 to + 1\t\342\210\222 1 to + 1\n+ \342\210\236\t*\t*\nNaN\tNaN\tNaN\nNOTES:\nF\tMeans finite floating-point value.\n*\tIndicates floating-point invalid-arithmetic-operand (#IA) exception.\nIf the source operand is outside the acceptable range, the C2 flag in the FPU status word is set, and the value in register ST(0) remains unchanged. The instruction does not raise an exception when the source operand is out of range. It is up to the program to check the C2 flag for out-of-range conditions. Source values outside the range \342\210\222 263 to +263 can be reduced to the range of the instruction by subtracting an appropriate integer multiple of 2\317\200.\nHowever, even within the range -263 to +263, inaccurate results can occur because the finite approximation of \317\200 used internally for argument reduction is not sufficient in all cases. Therefore, for accurate results it is safe to apply FSINCOS only to arguments reduced accurately in software, to a value smaller in absolute value than 3\317\200/8. See the sections titled \342\200\234Approximation of Pi\342\200\235 and \342\200\234Transcendental Instruction Accuracy\342\200\235 in Chapter 8 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1, for a discussion of the proper value to use for \317\200 in performing such reductions.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C1\tSet to 0 if stack underflow occurred; set to 1 of stack overflow occurs.\nSet if result was rounded up; cleared otherwise.\nC2\tSet to 1 if outside range (\342\210\222263 < source operand < +263); otherwise, set to 0.\nC0, C3\tUndefined."
    }
  }
  instruction_groups {
    name: "ADDSD"
    short_description: "Add Scalar Double-Precision Floating-Point Values"
    description: "Adds the low double-precision floating-point values from the second source operand and the first source operand and stores the double-precision floating-point result in the destination operand.\nThe second source operand can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers.\n128-bit Legacy SSE version: The first source and destination operands are the same. Bits (MAXVL-1:64) of the corresponding destination register remain unchanged.\nEVEX and VEX.128 encoded version: The first source operand is encoded by EVEX.vvvv/VEX.vvvv. Bits (127:64) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\nEVEX version: The low quadword element of the destination is updated according to the writemask.\nSoftware should ensure VADDSD is encoded with VEX.L=0. Encoding VADDSD with VEX.L=1 may encounter unpredictable behavior across different processor generations."
  }
  instruction_groups {
    name: "CVTSS2SI"
    short_description: "Convert Scalar Single-Precision Floating-Point Value to Doubleword Integer"
    description: "Converts a single-precision floating-point value in the source operand (the second operand) to a signed doubleword integer (or signed quadword integer if operand size is 64 bits) in the destination operand (the first operand). The source operand can be an XMM register or a memory location. The destination operand is a general-purpose register. When the source operand is an XMM register, the single-precision floating-point value is contained in the low doubleword of the register.\nWhen a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (2w-1, where w represents the number of bits in the destination format) is returned.\nLegacy SSE instructions: In 64-bit mode, Use of the REX.W prefix promotes the instruction to produce 64-bit data.\nSee the sum\nmary chart at the beginning of this section for encoding data and limits.\nVEX.W1 and EVEX.W1 versions: promotes the instruction to produce 64-bit data in 64-bit mode.\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.\nSoftware should ensure VCVTSS2SI is encoded with VEX.L=0. Encoding VCVTSS2SI with VEX.L=1 may encounter unpredictable behavior across different processor generations."
  }
  instruction_groups {
    name: "KSHIFTRW/KSHIFTRB/KSHIFTRQ/KSHIFTRD"
    short_description: "Shift Right Mask Registers"
    description: "Shifts 8/16/32/64 bits in the second operand (source operand) right by the count specified in im mediate and place the least significant 8/16/32/64 bits of the result in the destination operand. The higher bits of the destination are zero-extended. The destination is set to zero if the count value is greater than 7 (for byte shift), 15 (for word shift), 31 (for doubleword shift) or 63 (for quadword shift)."
    flags_affected {
      content: "None\nSIMD Floating-Point Exceptions\nNone"
    }
  }
  instruction_groups {
    name: "POR"
    short_description: "Bitwise Logical OR"
    description: "Performs a bitwise logical OR operation on the source operand (second operand) and the destination operand (first operand) and stores the result in the destination operand. Each bit of the result is set to 1 if either or both of the corresponding bits of the first and second operands are 1; otherwise, it is set to 0.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE version: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register.\n128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source and destination operands can be XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source and destination operands can be XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded version: The second source operand is an YMM register or a 256-bit memory location. The first source and destination operands can be YMM registers.\nEVEX encoded version: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1 at 32/64-bit granularity."
    flags_affected {
      content: "None.\nSIMD Floating-Point Exceptions\nNone."
    }
  }
  instruction_groups {
    name: "SUB"
    short_description: "Subtract"
    description: "Subtracts the second operand (source operand) from the first operand (destination operand) and stores the result in the destination operand. The destination operand can be a register or a memory location; the source operand can be an im\nmediate, register, or memory location. (However, two memory operands cannot be used in one instruction.) When an im mediate value is used as an operand, it is sign-extended to the length of the destination\noperand format.\nThe SUB instruction performs integer subtraction. It evaluates the result for both signed and unsigned integer operands and sets the OF and CF flags to indicate an overflow in the signed or unsigned result, respectively. The SF flag indicates the sign of the signed result.\nIn 64-bit mode, the instruction\342\200\231s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the sum mary chart at the beginning of this section for encoding data and limits.\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically."
    flags_affected {
      content: "The OF, SF, ZF, AF, PF, and CF flags are set according to the result."
    }
  }
  instruction_groups {
    name: "VFIXUPIMMPS"
    short_description: "Fix Up Special Packed Float32 Values"
  }
  instruction_groups {
    name: "FCOM/FCOMP/FCOMPP"
    short_description: "Compare Floating Point Values"
    description: "Compares the contents of register ST(0) and source value and sets condition code flags C0, C2, and C3 in the FPU status word according to the results (see the table below). The source operand can be a data register or a memory location. If no source operand is given, the value in ST(0) is compared with the value in ST(1). The sign of zero is ignored, so that -0.0 is equal to +0.0.\nTable 3-21.  FCOM/FCOMP/FCOMPP Results\nCondition\tC3\tC2\tC0\nST(0) > SRC\t0\t0\t0\nST(0) < SRC\t0\t0\t1\nST(0) = SRC\t1\t0\t0\nUnordered*\t1\t1\t1\nNOTES:\n*\tFlags not set if unmasked invalid-arithmetic-operand (#IA) exception is generated.\nThis instruction checks the class of the numbers being compared (see \342\200\234FXAM\n-Examine Floating-Point\342\200\235 in this chapter). If either operand is a NaN or is in an unsupported format, an invalid-arithmetic-operand exception (#IA) is raised and, if the exception is masked, the condition flags are set to \342\200\234unordered.\342\200\235 If the invalid-arithmeticoperand exception is unmasked, the condition code flags are not set.\nThe FCOMP instruction pops the register stack following the comparison operation and the FCOMPP instruction pops the register stack twice following the comparison operation. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.\nThe FCOM instructions perform the same operation as the FUCOM instructions. The only difference is how they handle QNaN operands. The FCOM instructions raise an invalid-arithmetic-operand exception (#IA) when either or both of the operands is a NaN value or is in an unsupported format. The FUCOM instructions perform the same operation as the FCOM instructions, except that they do not generate an invalid-arithmetic-operand exception for QNaNs.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C1\tSet to 0.\nC0, C2, C3\tSee table on previous page."
    }
  }
  instruction_groups {
    name: "SLDT"
    short_description: "Store Local Descriptor Table Register"
    description: "Stores the segment selector from the local descriptor table register (LDTR) in the destination operand. The destination operand can be a general-purpose register or a memory location. The segment selector stored with this instruction points to the segment descriptor (located in the GDT) for the current LDT. This instruction can only be executed in protected mode.\nOutside IA-32e mode, when the destination operand is a 32-bit register, the 16-bit segment selector is copied into the low-order 16 bits of the register. The high-order 16 bits of the register are cleared for the Pentium 4, Intel Xeon, and P6 family processors. They are undefined for Pentium, Intel486, and Intel386 processors. When the destination operand is a memory location, the segment selector is written to memory as a 16-bit quantity, regardless of the operand size.\nIn compatibility mode, when the destination operand is a 32-bit register, the 16-bit segment selector is copied into the low-order 16 bits of the register. The high-order 16 bits of the register are cleared. When the destination operand is a memory location, the segment selector is written to memory as a 16-bit quantity, regardless of the operand size.\nIn 64-bit mode, using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). The behavior of SLDT with a 64-bit register is to zero-extend the 16-bit selector and store it in the register. If the destination is memory and operand size is 64, SLDT will write the 16-bit selector to memory as a 16-bit quantity, regardless of the operand size."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "VPLZCNTD/Q"
    short_description: "Count the Number of Leading Zero Bits for Packed Dword, Packed Qword Values"
  }
  instruction_groups {
    name: "VPERMT2B"
    short_description: "Full Permute of Bytes from Two Tables Overwriting a Table"
  }
  instruction_groups {
    name: "VRSQRT28SD"
    short_description: "Approximation to the Reciprocal Square Root of Scalar Double-Precision Floating-Point Value with Less Than 2^-28"
  }
  instruction_groups {
    name: "MOVHPS"
    short_description: "Move High Packed Single-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "MOVS/MOVSB/MOVSW/MOVSD/MOVSQ"
    short_description: "Move Data from StringtoString"
    description: "Moves the byte, word, or doubleword specified with the second operand (source operand) to the location specified with the first operand (destination operand). Both the source and destination operands are located in memory. The address of the source operand is read from the DS:ESI or the DS:SI registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). The address of the destination operand is read from the ES:EDI or the ES:DI registers (again depending on the address-size attribute of the instruction). The DS segment may be overridden with a segment override prefix, but the ES segment cannot be overridden.\nAt the assembly-code level, two forms of this instruction are allowed: the \342\200\234explicit-operands\342\200\235 form and the \342\200\234nooperands\342\200\235 form. The explicit-operands form (specified with the MOVS mnemonic) allows the source and destination operands to be specified explicitly. Here, the source and destination operands should be symbols that indicate the size and location of the source value and the destination, respectively. This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the source and destination operand symbols must specify the correct type (size) of the operands (bytes, words, or doublewords), but they do not have to specify the correct location. The locations of the source and destination operands are always specified by the DS:(E)SI and ES:(E)DI registers, which must be loaded correctly before the move string instruction is executed.\nThe no-operands form provides \342\200\234short forms\342\200\235 of the byte, word, and doubleword versions of the MOVS instructions. Here also DS:(E)SI and ES:(E)DI are assumed to be the source and destination operands, respectively. The size of the source and destination operands is selected with the mnemonic: MOVSB (byte move), MOVSW (word move), or MOVSD (doubleword move).\nAfter the move operation, the (E)SI and (E)DI registers are incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)SI and (E)DI register are incre-\nmented; if the DF flag is 1, the (E)SI and (E)DI registers are decremented.) The registers are incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword operations.\nNOTE\nTo improve performance, more recent processors support modifications to the processor\342\200\231s operation during the string store operations initiated with MOVS and MOVSB. See Section 7.3.9.3 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1 for additional information on fast-string operation.\nThe MOVS, MOVSB, MOVSW, and MOVSD instructions can be preceded by the REP prefix (see \342\200\234REP/REPE/REPZ /REPNE/REPNZ-Repeat String Operation Prefix\342\200\235 for a description of the REP prefix) for block moves of ECX bytes, words, or doublewords.\nIn 64-bit mode, the instruction\342\200\231s default address size is 64 bits, 32-bit address size is supported using the prefix 67H. The 64-bit addresses are specified by RSI and RDI; 32-bit address are specified by ESI and EDI. Use of the REX.W prefix promotes doubleword operation to 64 bits. See the sum mary chart at the beginning of this section for\nencoding data and limits."
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "KSHIFTLW/KSHIFTLB/KSHIFTLQ/KSHIFTLD"
    short_description: "Shift Left Mask Registers"
    description: "Shifts 8/16/32/64 bits in the second operand (source operand) left by the count specified in im mediate byte and place the least significant 8/16/32/64 bits of the result in the destination operand. The higher bits of the destination are zero-extended. The destination is set to zero if the count value is greater than 7 (for byte shift), 15 (for word shift), 31 (for doubleword shift) or 63 (for quadword shift)."
    flags_affected {
      content: "None\nSIMD Floating-Point Exceptions\nNone"
    }
  }
  instruction_groups {
    name: "VFNMADD132PD/VFNMADD213PD/VFNMADD231PD"
    short_description: "Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Val-"
  }
  instruction_groups {
    name: "VCVTPS2QQ"
    short_description: "Convert Packed Single Precision Floating-Point Values to Packed Signed Quadword Integer Values"
  }
  instruction_groups {
    name: "VFMADD132SS/VFMADD213SS/VFMADD231SS"
    short_description: "Fused Multiply-Add of Scalar Single-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "VPROLD/VPROLVD/VPROLQ/VPROLVQ"
    short_description: "Bit Rotate Left"
  }
  instruction_groups {
    name: "VMCALL"
    description: "This instruction allows guest software can make a call for service into an underlying VM monitor. The details of the program\nming interface for such calls are VMM-specific; this instruction does nothing more than cause a VM exit, registering the appropriate exit reason.\nUse of this instruction in VMX root operation invokes an SMM monitor (see Section 34.15.2). This invocation will activate the dual-monitor treatment of system-management interrupts (SMIs) and system-management mode (SMM) if it is not already active (see Section 34.15.6)."
    flags_affected {
      content: "See the operation section and Section 30.2."
    }
  }
  instruction_groups {
    name: "INVD"
    short_description: "Invalidate Internal Caches"
    description: "Invalidates (flushes) the processor\342\200\231s internal caches and issues a special-function bus cycle that directs external caches to also flush themselves. Data held in internal caches is not written back to main memory.\nAfter executing this instruction, the processor does not wait for the external caches to complete their flushing operation before proceeding with instruction execution. It is the responsibility of hardware to respond to the cache flush signal.\nThe INVD instruction is a privileged instruction. When the processor is running in protected mode, the CPL of a program or procedure must be 0 to execute this instruction.\nThe INVD instruction may be used when the cache is used as temporary memory and the cache contents need to be invalidated rather than written back to memory. When the cache is used as temporary memory, no external device should be actively writing data to main memory.\nUse this instruction with care. Data cached internally and not written back to main memory will be lost. Note that any data from an external device to main memory (for example, via a PCIWrite) can be temporarily stored in the caches; these data can be lost when an INVD instruction is executed. Unless there is a specific requirement or benefit to flushing caches without writing back modified cache lines (for example, temporary memory, testing, or fault recovery where cache coherency with main memory is not a concern), software should instead use the WBINVD instruction.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "FIST/FISTP"
    short_description: "Store Integer"
    description: "The FIST instruction converts the value in the ST(0) register to a signed integer and stores the result in the destination operand. Values can be stored in word or doubleword integer format. The destination operand specifies the address where the first byte of the destination value is to be stored.\nThe FISTP instruction performs the same operation as the FIST instruction and then pops the register stack. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.\nThe FISTP instruction also stores values in quadword integer format.\nThe following table shows the results obtained when storing various classes of numbers in integer format.\nTable 3-27.  FIST/FISTP Results\nST(0)\tDEST\n\342\210\222 \342\210\236 or Value Too Large for DEST Format\t*\nF \342\211\244 \342\210\2221\t\342\210\222 I\n\342\210\2221 < F < \342\210\2220\t**\n\342\210\222 0\t0\n+ 0\t0\n+ 0 < F < + 1\t**\nF \342\211\245 + 1\t+ I\n+ \342\210\236 or Value Too Large for DEST Format\t*\nNaN\t*\nNOTES:\nF\tMeans finite floating-point value.\nI\tMeans integer.\n* Indicates floating-point invalid-operation (#IA) exception.\n**0 or \302\2611, depending on the rounding mode.\nIf the source value is a non-integral value, it is rounded to an integer value, according to the rounding mode specified by the RC field of the FPU control word.\nIf the converted value is too large for the destination format, or if the source operand is an \342\210\236, SNaN, QNAN, or is in an unsupported format, an invalid-arithmetic-operand condition is signaled. If the invalid-operation exception is not masked, an invalid-arithmetic-operand exception (#IA) is generated and no value is stored in the destination operand. If the invalid-operation exception is masked, the integer indefinite value is stored in memory.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C1\tSet to 0 if stack underflow occurred.\nIndicates rounding direction of if the inexact exception (#P) is generated: 0 := not roundup; 1 := roundup.\nSet to 0 otherwise.\nC0, C2, C3\tUndefined."
    }
  }
  instruction_groups {
    name: "VGETEXPSD"
    short_description: "Convert Exponents of Scalar DP FP Values to DP FP Value"
  }
  instruction_groups {
    name: "EMODT"
  }
  instruction_groups {
    name: "PACKSSWB/PACKSSDW"
    short_description: "Pack with Signed Saturation"
    description: "Converts packed signed word integers into packed signed byte integers (PACKSSWB) or converts packed signed doubleword integers into packed signed word integers (PACKSSDW), using saturation to handle overflow conditions. See Figure 4-6 for an example of the packing operation.\n64-Bit SRC\t64-Bit DEST\nD\tC\tB\tA\nD\342\200\231\tC\342\200\231\tB\342\200\231\tA\342\200\231\n64-Bit DEST\nFigure 4-6.  Operation of the PACKSSDW Instruction Using 64-bit Operands\nPACKSSWB converts packed signed word integers in the first and second source operands into packed signed byte integers using signed saturation to handle overflow conditions beyond the range of signed byte integers. If the signed word value is beyond the range of a signed byte value (i.e., greater than 7FH or less than 80H), the saturated signed byte integer value of 7FH or 80H, respectively, is stored in the destination. PACKSSDW converts packed signed doubleword integers in the first and second source operands into packed signed word integers using signed saturation to handle overflow conditions beyond 7FFFH and 8000H.\nEVEX encoded PACKSSWB: The first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register, updated conditional under the writemask k1.\nEVEX encoded PACKSSDW: The first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32- bit memory location. The destination operand is a ZMM/YMM/XMM register, updated conditional under the writemask k1.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\nVEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM destination register destination are unmodified.\nOperation\nPACKSSWB instruction (128-bit Legacy SSE version) DEST[7:0] := SaturateSignedWordToSignedByte (DEST[15:0]); DEST[15:8] := SaturateSignedWordToSignedByte (DEST[31:16]); DEST[23:16] := SaturateSignedWordToSignedByte (DEST[47:32]); DEST[31:24] := SaturateSignedWordToSignedByte (DEST[63:48]); DEST[39:32] := SaturateSignedWordToSignedByte (DEST[79:64]); DEST[47:40] := SaturateSignedWordToSignedByte (DEST[95:80]); DEST[55:48] := SaturateSignedWordToSignedByte (DEST[111:96]); DEST[63:56] := SaturateSignedWordToSignedByte (DEST[127:112]); DEST[71:64] := SaturateSignedWordToSignedByte (SRC[15:0]); DEST[79:72] := SaturateSignedWordToSignedByte (SRC[31:16]); DEST[87:80] := SaturateSignedWordToSignedByte (SRC[47:32]); DEST[95:88] := SaturateSignedWordToSignedByte (SRC[63:48]); DEST[103:96] := SaturateSignedWordToSignedByte (SRC[79:64]); DEST[111:104] := SaturateSignedWordToSignedByte (SRC[95:80]); DEST[119:112] := SaturateSignedWordToSignedByte (SRC[111:96]); DEST[127:120] := SaturateSignedWordToSignedByte (SRC[127:112]); DEST[MAXVL-1:128] (Unmodified)\nPACKSSDW instruction (128-bit Legacy SSE version) DEST[15:0] := SaturateSignedDwordToSignedWord (DEST[31:0]); DEST[31:16] := SaturateSignedDwordToSignedWord (DEST[63:32]); DEST[47:32] := SaturateSignedDwordToSignedWord (DEST[95:64]); DEST[63:48] := SaturateSignedDwordToSignedWord (DEST[127:96]); DEST[79:64] := SaturateSignedDwordToSignedWord (SRC[31:0]); DEST[95:80] := SaturateSignedDwordToSignedWord (SRC[63:32]); DEST[111:96] := SaturateSignedDwordToSignedWord (SRC[95:64]); DEST[127:112] := SaturateSignedDwordToSignedWord (SRC[127:96]); DEST[MAXVL-1:128] (Unmodified)\nVPACKSSWB instruction (VEX.128 encoded version) DEST[7:0] := SaturateSignedWordToSignedByte (SRC1[15:0]); DEST[15:8] := SaturateSignedWordToSignedByte (SRC1[31:16]); DEST[23:16] := SaturateSignedWordToSignedByte (SRC1[47:32]); DEST[31:24] := SaturateSignedWordToSignedByte (SRC1[63:48]); DEST[39:32] := SaturateSignedWordToSignedByte (SRC1[79:64]); DEST[47:40] := SaturateSignedWordToSignedByte (SRC1[95:80]); DEST[55:48] := SaturateSignedWordToSignedByte (SRC1[111:96]); DEST[63:56] := SaturateSignedWordToSignedByte (SRC1[127:112]); DEST[71:64] := SaturateSignedWordToSignedByte (SRC2[15:0]); DEST[79:72] := SaturateSignedWordToSignedByte (SRC2[31:16]); DEST[87:80] := SaturateSignedWordToSignedByte (SRC2[47:32]); DEST[95:88] := SaturateSignedWordToSignedByte (SRC2[63:48]); DEST[103:96] := SaturateSignedWordToSignedByte (SRC2[79:64]); DEST[111:104] := SaturateSignedWordToSignedByte (SRC2[95:80]); DEST[119:112] := SaturateSignedWordToSignedByte (SRC2[111:96]); DEST[127:120] := SaturateSignedWordToSignedByte (SRC2[127:112]); DEST[MAXVL-1:128] := 0;\nVPACKSSDW instruction (VEX.128 encoded version) DEST[15:0] := SaturateSignedDwordToSignedWord (SRC1[31:0]); DEST[31:16] := SaturateSignedDwordToSignedWord (SRC1[63:32]); DEST[47:32] := SaturateSignedDwordToSignedWord (SRC1[95:64]); DEST[63:48] := SaturateSignedDwordToSignedWord (SRC1[127:96]); DEST[79:64] := SaturateSignedDwordToSignedWord (SRC2[31:0]); DEST[95:80] := SaturateSignedDwordToSignedWord (SRC2[63:32]); DEST[111:96] := SaturateSignedDwordToSignedWord (SRC2[95:64]); DEST[127:112] := SaturateSignedDwordToSignedWord (SRC2[127:96]); DEST[MAXVL-1:128] := 0;\nVPACKSSWB instruction (VEX.256 encoded version) DEST[7:0] := SaturateSignedWordToSignedByte (SRC1[15:0]); DEST[15:8] := SaturateSignedWordToSignedByte (SRC1[31:16]); DEST[23:16] := SaturateSignedWordToSignedByte (SRC1[47:32]); DEST[31:24] := SaturateSignedWordToSignedByte (SRC1[63:48]); DEST[39:32] := SaturateSignedWordToSignedByte (SRC1[79:64]); DEST[47:40] := SaturateSignedWordToSignedByte (SRC1[95:80]); DEST[55:48] := SaturateSignedWordToSignedByte (SRC1[111:96]); DEST[63:56] := SaturateSignedWordToSignedByte (SRC1[127:112]); DEST[71:64] := SaturateSignedWordToSignedByte (SRC2[15:0]); DEST[79:72] := SaturateSignedWordToSignedByte (SRC2[31:16]); DEST[87:80] := SaturateSignedWordToSignedByte (SRC2[47:32]); DEST[95:88] := SaturateSignedWordToSignedByte (SRC2[63:48]); DEST[103:96] := SaturateSignedWordToSignedByte (SRC2[79:64]); DEST[111:104] := SaturateSignedWordToSignedByte (SRC2[95:80]); DEST[119:112] := SaturateSignedWordToSignedByte (SRC2[111:96]); DEST[127:120] := SaturateSignedWordToSignedByte (SRC2[127:112]); DEST[135:128] := SaturateSignedWordToSignedByte (SRC1[143:128]); DEST[143:136] := SaturateSignedWordToSignedByte (SRC1[159:144]); DEST[151:144] := SaturateSignedWordToSignedByte (SRC1[175:160]); DEST[159:152] := SaturateSignedWordToSignedByte (SRC1[191:176]); DEST[167:160] := SaturateSignedWordToSignedByte (SRC1[207:192]); DEST[175:168] := SaturateSignedWordToSignedByte (SRC1[223:208]); DEST[183:176] := SaturateSignedWordToSignedByte (SRC1[239:224]);\nDEST[191:184] := SaturateSignedWordToSignedByte (SRC1[255:240]); DEST[199:192] := SaturateSignedWordToSignedByte (SRC2[143:128]); DEST[207:200] := SaturateSignedWordToSignedByte (SRC2[159:144]); DEST[215:208] := SaturateSignedWordToSignedByte (SRC2[175:160]); DEST[223:216] := SaturateSignedWordToSignedByte (SRC2[191:176]); DEST[231:224] := SaturateSignedWordToSignedByte (SRC2[207:192]); DEST[239:232] := SaturateSignedWordToSignedByte (SRC2[223:208]); DEST[247:240] := SaturateSignedWordToSignedByte (SRC2[239:224]); DEST[255:248] := SaturateSignedWordToSignedByte (SRC2[255:240]); DEST[MAXVL-1:256] := 0;\nVPACKSSDW instruction (VEX.256 encoded version) DEST[15:0] := SaturateSignedDwordToSignedWord (SRC1[31:0]); DEST[31:16] := SaturateSignedDwordToSignedWord (SRC1[63:32]); DEST[47:32] := SaturateSignedDwordToSignedWord (SRC1[95:64]); DEST[63:48] := SaturateSignedDwordToSignedWord (SRC1[127:96]); DEST[79:64] := SaturateSignedDwordToSignedWord (SRC2[31:0]); DEST[95:80] := SaturateSignedDwordToSignedWord (SRC2[63:32]); DEST[111:96] := SaturateSignedDwordToSignedWord (SRC2[95:64]); DEST[127:112] := SaturateSignedDwordToSignedWord (SRC2[127:96]); DEST[143:128] := SaturateSignedDwordToSignedWord (SRC1[159:128]); DEST[159:144] := SaturateSignedDwordToSignedWord (SRC1[191:160]); DEST[175:160] := SaturateSignedDwordToSignedWord (SRC1[223:192]); DEST[191:176] := SaturateSignedDwordToSignedWord (SRC1[255:224]); DEST[207:192] := SaturateSignedDwordToSignedWord (SRC2[159:128]); DEST[223:208] := SaturateSignedDwordToSignedWord (SRC2[191:160]); DEST[239:224] := SaturateSignedDwordToSignedWord (SRC2[223:192]); DEST[255:240] := SaturateSignedDwordToSignedWord (SRC2[255:224]); DEST[MAXVL-1:256] := 0;\nVPACKSSWB (EVEX encoded versions) (KL, VL) = (16, 128), (32, 256), (64, 512) TMP_DEST[7:0] := SaturateSignedWordToSignedByte (SRC1[15:0]); TMP_DEST[15:8] := SaturateSignedWordToSignedByte (SRC1[31:16]); TMP_DEST[23:16] := SaturateSignedWordToSignedByte (SRC1[47:32]); TMP_DEST[31:24] := SaturateSignedWordToSignedByte (SRC1[63:48]); TMP_DEST[39:32] := SaturateSignedWordToSignedByte (SRC1[79:64]); TMP_DEST[47:40] := SaturateSignedWordToSignedByte (SRC1[95:80]); TMP_DEST[55:48] := SaturateSignedWordToSignedByte (SRC1[111:96]); TMP_DEST[63:56] := SaturateSignedWordToSignedByte (SRC1[127:112]); TMP_DEST[71:64] := SaturateSignedWordToSignedByte (SRC2[15:0]); TMP_DEST[79:72] := SaturateSignedWordToSignedByte (SRC2[31:16]); TMP_DEST[87:80] := SaturateSignedWordToSignedByte (SRC2[47:32]); TMP_DEST[95:88] := SaturateSignedWordToSignedByte (SRC2[63:48]); TMP_DEST[103:96] := SaturateSignedWordToSignedByte (SRC2[79:64]); TMP_DEST[111:104] := SaturateSignedWordToSignedByte (SRC2[95:80]); TMP_DEST[119:112] := SaturateSignedWordToSignedByte (SRC2[111:96]); TMP_DEST[127:120] := SaturateSignedWordToSignedByte (SRC2[127:112]); IF VL >= 256 TMP_DEST[135:128] := SaturateSignedWordToSignedByte (SRC1[143:128]); TMP_DEST[143:136] := SaturateSignedWordToSignedByte (SRC1[159:144]); TMP_DEST[151:144] := SaturateSignedWordToSignedByte (SRC1[175:160]); TMP_DEST[159:152] := SaturateSignedWordToSignedByte (SRC1[191:176]); TMP_DEST[167:160] := SaturateSignedWordToSignedByte (SRC1[207:192]);\nTMP_DEST[175:168] := SaturateSignedWordToSignedByte (SRC1[223:208]); TMP_DEST[183:176] := SaturateSignedWordToSignedByte (SRC1[239:224]); TMP_DEST[191:184] := SaturateSignedWordToSignedByte (SRC1[255:240]); TMP_DEST[199:192] := SaturateSignedWordToSignedByte (SRC2[143:128]); TMP_DEST[207:200] := SaturateSignedWordToSignedByte (SRC2[159:144]); TMP_DEST[215:208] := SaturateSignedWordToSignedByte (SRC2[175:160]); TMP_DEST[223:216] := SaturateSignedWordToSignedByte (SRC2[191:176]); TMP_DEST[231:224] := SaturateSignedWordToSignedByte (SRC2[207:192]); TMP_DEST[239:232] := SaturateSignedWordToSignedByte (SRC2[223:208]); TMP_DEST[247:240] := SaturateSignedWordToSignedByte (SRC2[239:224]); TMP_DEST[255:248] := SaturateSignedWordToSignedByte (SRC2[255:240]);\nFI; IF VL >= 512 TMP_DEST[263:256] := SaturateSignedWordToSignedByte (SRC1[271:256]); TMP_DEST[271:264] := SaturateSignedWordToSignedByte (SRC1[287:272]); TMP_DEST[279:272] := SaturateSignedWordToSignedByte (SRC1[303:288]); TMP_DEST[287:280] := SaturateSignedWordToSignedByte (SRC1[319:304]); TMP_DEST[295:288] := SaturateSignedWordToSignedByte (SRC1[335:320]); TMP_DEST[303:296] := SaturateSignedWordToSignedByte (SRC1[351:336]); TMP_DEST[311:304] := SaturateSignedWordToSignedByte (SRC1[367:352]); TMP_DEST[319:312] := SaturateSignedWordToSignedByte (SRC1[383:368]);\nTMP_DEST[327:320] := SaturateSignedWordToSignedByte (SRC2[271:256]); TMP_DEST[335:328] := SaturateSignedWordToSignedByte (SRC2[287:272]); TMP_DEST[343:336] := SaturateSignedWordToSignedByte (SRC2[303:288]); TMP_DEST[351:344] := SaturateSignedWordToSignedByte (SRC2[319:304]); TMP_DEST[359:352] := SaturateSignedWordToSignedByte (SRC2[335:320]); TMP_DEST[367:360] := SaturateSignedWordToSignedByte (SRC2[351:336]); TMP_DEST[375:368] := SaturateSignedWordToSignedByte (SRC2[367:352]); TMP_DEST[383:376] := SaturateSignedWordToSignedByte (SRC2[383:368]);\nTMP_DEST[391:384] := SaturateSignedWordToSignedByte (SRC1[399:384]); TMP_DEST[399:392] := SaturateSignedWordToSignedByte (SRC1[415:400]); TMP_DEST[407:400] := SaturateSignedWordToSignedByte (SRC1[431:416]); TMP_DEST[415:408] := SaturateSignedWordToSignedByte (SRC1[447:432]); TMP_DEST[423:416] := SaturateSignedWordToSignedByte (SRC1[463:448]); TMP_DEST[431:424] := SaturateSignedWordToSignedByte (SRC1[479:464]); TMP_DEST[439:432] := SaturateSignedWordToSignedByte (SRC1[495:480]); TMP_DEST[447:440] := SaturateSignedWordToSignedByte (SRC1[511:496]);\nTMP_DEST[455:448] := SaturateSignedWordToSignedByte (SRC2[399:384]); TMP_DEST[463:456] := SaturateSignedWordToSignedByte (SRC2[415:400]); TMP_DEST[471:464] := SaturateSignedWordToSignedByte (SRC2[431:416]); TMP_DEST[479:472] := SaturateSignedWordToSignedByte (SRC2[447:432]); TMP_DEST[487:480] := SaturateSignedWordToSignedByte (SRC2[463:448]); TMP_DEST[495:488] := SaturateSignedWordToSignedByte (SRC2[479:464]); TMP_DEST[503:496] := SaturateSignedWordToSignedByte (SRC2[495:480]); TMP_DEST[511:504] := SaturateSignedWordToSignedByte (SRC2[511:496]);\nFI; FOR j := 0 TO KL-1 i := j * 8 IF k1[j] OR *no writemask* THEN DEST[i+7:i] := TMP_DEST[i+7:i]\nELSE IF *merging-masking*\n; merging-masking THEN *DEST[i+7:i] remains unchanged* ELSE *zeroing-masking* ; zeroing-masking\nDEST[i+7:i] := 0\nFI\nFI; ENDFOR; DEST[MAXVL-1:VL] := 0\nVPACKSSDW (EVEX encoded versions) (KL, VL) = (8, 128), (16, 256), (32, 512) FOR j := 0 TO ((KL/2) - 1) i := j * 32\nIF (EVEX.b == 1) AND (SRC2 *is memory*) THEN TMP_SRC2[i+31:i] := SRC2[31:0] ELSE TMP_SRC2[i+31:i] := SRC2[i+31:i]\nFI; ENDFOR;\nTMP_DEST[15:0] := SaturateSignedDwordToSignedWord (SRC1[31:0]); TMP_DEST[31:16] := SaturateSignedDwordToSignedWord (SRC1[63:32]); TMP_DEST[47:32] := SaturateSignedDwordToSignedWord (SRC1[95:64]); TMP_DEST[63:48] := SaturateSignedDwordToSignedWord (SRC1[127:96]); TMP_DEST[79:64] := SaturateSignedDwordToSignedWord (TMP_SRC2[31:0]); TMP_DEST[95:80] := SaturateSignedDwordToSignedWord (TMP_SRC2[63:32]); TMP_DEST[111:96] := SaturateSignedDwordToSignedWord (TMP_SRC2[95:64]); TMP_DEST[127:112] := SaturateSignedDwordToSignedWord (TMP_SRC2[127:96]); IF VL >= 256 TMP_DEST[143:128] := SaturateSignedDwordToSignedWord (SRC1[159:128]); TMP_DEST[159:144] := SaturateSignedDwordToSignedWord (SRC1[191:160]); TMP_DEST[175:160] := SaturateSignedDwordToSignedWord (SRC1[223:192]); TMP_DEST[191:176] := SaturateSignedDwordToSignedWord (SRC1[255:224]); TMP_DEST[207:192] := SaturateSignedDwordToSignedWord (TMP_SRC2[159:128]); TMP_DEST[223:208] := SaturateSignedDwordToSignedWord (TMP_SRC2[191:160]); TMP_DEST[239:224] := SaturateSignedDwordToSignedWord (TMP_SRC2[223:192]); TMP_DEST[255:240] := SaturateSignedDwordToSignedWord (TMP_SRC2[255:224]);\nFI; IF VL >= 512 TMP_DEST[271:256] := SaturateSignedDwordToSignedWord (SRC1[287:256]); TMP_DEST[287:272] := SaturateSignedDwordToSignedWord (SRC1[319:288]); TMP_DEST[303:288] := SaturateSignedDwordToSignedWord (SRC1[351:320]); TMP_DEST[319:304] := SaturateSignedDwordToSignedWord (SRC1[383:352]); TMP_DEST[335:320] := SaturateSignedDwordToSignedWord (TMP_SRC2[287:256]); TMP_DEST[351:336] := SaturateSignedDwordToSignedWord (TMP_SRC2[319:288]); TMP_DEST[367:352] := SaturateSignedDwordToSignedWord (TMP_SRC2[351:320]); TMP_DEST[383:368] := SaturateSignedDwordToSignedWord (TMP_SRC2[383:352]);\nTMP_DEST[399:384] := SaturateSignedDwordToSignedWord (SRC1[415:384]); TMP_DEST[415:400] := SaturateSignedDwordToSignedWord (SRC1[447:416]); TMP_DEST[431:416] := SaturateSignedDwordToSignedWord (SRC1[479:448]);\nTMP_DEST[447:432] := SaturateSignedDwordToSignedWord (SRC1[511:480]); TMP_DEST[463:448] := SaturateSignedDwordToSignedWord (TMP_SRC2[415:384]); TMP_DEST[479:464] := SaturateSignedDwordToSignedWord (TMP_SRC2[447:416]); TMP_DEST[495:480] := SaturateSignedDwordToSignedWord (TMP_SRC2[479:448]); TMP_DEST[511:496] := SaturateSignedDwordToSignedWord (TMP_SRC2[511:480]);\nFI; FOR j := 0 TO KL-1 i := j * 16 IF k1[j] OR *no writemask* THEN DEST[i+15:i] := TMP_DEST[i+15:i] ELSE IF *merging-masking*\n; merging-masking THEN *DEST[i+15:i] remains unchanged* ELSE *zeroing-masking* ; zeroing-masking\nDEST[i+15:i] := 0\nFI\nFI; ENDFOR; DEST[MAXVL-1:VL] := 0\nIntel C/C++ Compiler Intrinsic Equivalents\nVPACKSSDW__m512i _mm512_packs_epi32(__m512i m1, __m512i m2); VPACKSSDW__m512i _mm512_mask_packs_epi32(__m512i s, __mmask32 k, __m512i m1, __m512i m2); VPACKSSDW__m512i _mm512_maskz_packs_epi32( __mmask32 k, __m512i m1, __m512i m2); VPACKSSDW__m256i _mm256_mask_packs_epi32( __m256i s, __mmask16 k, __m256i m1, __m256i m2); VPACKSSDW__m256i _mm256_maskz_packs_epi32( __mmask16 k, __m256i m1, __m256i m2); VPACKSSDW__m128i _mm_mask_packs_epi32( __m128i s, __mmask8 k, __m128i m1, __m128i m2); VPACKSSDW__m128i _mm_maskz_packs_epi32( __mmask8 k, __m128i m1, __m128i m2); VPACKSSWB__m512i _mm512_packs_epi16(__m512i m1, __m512i m2); VPACKSSWB__m512i _mm512_mask_packs_epi16(__m512i s, __mmask32 k, __m512i m1, __m512i m2); VPACKSSWB__m512i _mm512_maskz_packs_epi16( __mmask32 k, __m512i m1, __m512i m2); VPACKSSWB__m256i _mm256_mask_packs_epi16( __m256i s, __mmask16 k, __m256i m1, __m256i m2); VPACKSSWB__m256i _mm256_maskz_packs_epi16( __mmask16 k, __m256i m1, __m256i m2); VPACKSSWB__m128i _mm_mask_packs_epi16( __m128i s, __mmask8 k, __m128i m1, __m128i m2); VPACKSSWB__m128i _mm_maskz_packs_epi16( __mmask8 k, __m128i m1, __m128i m2); PACKSSWB __m128i _mm_packs_epi16(__m128i m1, __m128i m2) PACKSSDW __m128i _mm_packs_epi32(__m128i m1, __m128i m2) VPACKSSWB __m256i _mm256_packs_epi16(__m256i m1, __m256i m2) VPACKSSDW __m256i _mm256_packs_epi32(__m256i m1, __m256i m2)\nSIMD Floating-Point Exceptions\nNone\nOther Exceptions\nNon-EVEX-encoded instruction, see Exceptions Type 4.\nEVEX-encoded VPACKSSDW, see Exceptions Type E4NF.\nEVEX-encoded VPACKSSWB, see Exceptions Type E4NF.nb."
  }
  instruction_groups {
    name: "AAD"
    short_description: "ASCII Adjust AX Before Division"
    description: "Adjusts two unpacked BCD digits (the least-significant digit in the AL register and the most-significant digit in the AH register) so that a division operation performed on the result will yield a correct unpacked BCD value. The AAD instruction is only useful when it precedes a DIV instruction that divides (binary division) the adjusted value in the AX register by an unpacked BCD value.\nThe AAD instruction sets the value in the AL register to (AL + (10 * AH)), and then clears the AH register to 00H.\nThe value in the AX register is then equal to the binary equivalent of the original unpacked two-digit (base 10) number in registers AH and AL.\nThe generalized version of this instruction allows adjustment of two unpacked digits of any number base (see the \342\200\234Operation\342\200\235 section below), by setting the im\nm8 byte to the selected number base (for example, 08H for octal, 0AH for decimal, or 0CH for base 12 numbers). The AAD mnemonic is interpreted by all assemblers to mean adjust ASCII (base 10) values. To adjust values in another number base, the instruction must be hand coded in machine code (D5 im m8).\nThis instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode."
    flags_affected {
      content: "The SF, ZF, and PF flags are set according to the resulting binary value in the AL register; the OF, AF, and CF flags are undefined."
    }
  }
  instruction_groups {
    name: "ENTER"
    short_description: "Make Stack Frame for Procedure Parameters"
    description: "Creates a stack frame (comprising of space for dynamic storage and 1-32 frame pointer storage) for a procedure.\nThe first operand (im\nm16) specifies the size of the dynamic storage in the stack frame (that is, the number of bytes of dynamically allocated on the stack for the procedure). The second operand (im m8) gives the lexical nesting level\n(0 to 31) of the procedure. The nesting level (im m8 mod 32) and the OperandSize attribute determine the size in\nbytes of the storage space for frame pointers.\nThe nesting level determines the number of frame pointers that are copied into the \342\200\234display area\342\200\235 of the new stack frame from the preceding frame. The default size of the frame pointer is the StackAddrSize attribute, but can be overridden using the 66H prefix. Thus, the OperandSize attribute determines the size of each frame pointer that will be copied into the stack frame and the data being transferred from SP/ESP/RSP register into the BP/EBP/RBP register.\nThe ENTER and companion LEAVE instructions are provided to support block structured languages. The ENTER instruction (when used) is typically the first instruction in a procedure and is used to set up a new stack frame for a procedure. The LEAVE instruction is then used at the end of the procedure (just before the RET instruction) to release the stack frame.\nIf the nesting level is 0, the processor pushes the frame pointer from the BP/EBP/RBP register onto the stack, copies the current stack pointer from the SP/ESP/RSP register into the BP/EBP/RBP register, and loads the SP/ESP/RSP register with the current stack-pointer value minus the value in the size operand. For nesting levels of 1 or greater, the processor pushes additional frame pointers on the stack before adjusting the stack pointer. These additional frame pointers provide the called procedure with access points to other nested frames on the stack. See \342\200\234Procedure Calls for Block-Structured Languages\342\200\235 in Chapter 6 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1, for more information about the actions of the ENTER instruction.\nThe ENTER instruction causes a page fault whenever a write using the final value of the stack pointer (within the current stack segment) would do so.\nIn 64-bit mode, default operation size is 64 bits; 32-bit operation size cannot be encoded. Use of 66H prefix changes frame pointer operand size to 16 bits.\nWhen the 66H prefix is used and causing the OperandSize attribute to be less than the StackAddrSize, software is responsible for the following:\n\342\200\242\tThe companion LEAVE instruction must also use the 66H prefix,\n\342\200\242\tThe value in the RBP/EBP register prior to executing \342\200\23466H ENTER\342\200\235 must be within the same 16KByte region of the current stack pointer (RSP/ESP), such that the value of RBP/EBP after \342\200\23466H ENTER\342\200\235 remains a valid address in the stack. This ensures \342\200\23466H LEAVE\342\200\235 can restore 16-bits of data from the stack."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "Jcc"
    short_description: "Jump if Condition Is Met"
    description: "Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), performs a jump to the target instruction specified by the destination operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc instruction.\nThe target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit im\nmediate value, which is added to the instruction pointer. Instruction coding is most efficient for offsets of -128 to +127. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.\nThe conditions for each Jcc mnemonic are given in the \342\200\234Description\342\200\235 column of the table on the preceding page. The terms \342\200\234less\342\200\235 and \342\200\234greater\342\200\235 are used for comparisons of signed integers and the terms \342\200\234above\342\200\235 and \342\200\234below\342\200\235 are used for unsigned integers.\nBecause a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or equal) instruction are alternate mnemonics for the opcode 77H.\nThe Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction, and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the following conditional far jump is illegal: JZ FARLABEL;\nTo accomplish this far jump, use the following two instructions: JNZ BEYOND; JMP FARLABEL; BEYOND:\nThe JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags.\nInstead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction (such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).\nAll conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cacheability.\nIn 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP Near is RIP = RIP + 32-bit offset sign extended to 64 bits."
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "RDPID"
    short_description: "Read Processor ID"
    description: "Reads the value of the IA32_TSC_AUX MSR (address C0000103H) into the destination register. The value of CS.D and operand-size prefixes (66H and REX.W) do not affect the behavior of the RDPID instruction."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "RSQRTPS"
    short_description: "Compute Reciprocals of Square Roots of Packed Single-Precision Floating-Point Values"
    description: "Performs a SIMD computation of the approximate reciprocals of the square roots of the four packed single-precision floating-point values in the source operand (second operand) and stores the packed single-precision floatingpoint results in the destination operand. The source operand can be an XMM register or a 128-bit memory location.\nThe destination operand is an XMM register. See Figure 10-5 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1, for an illustration of a SIMD single-precision floating-point operation.\nThe relative error for this approximation is:\n|Relative Error| \342\211\244 1.5 \342\210\227 2\342\210\22212\nThe RSQRTPS instruction is not affected by the rounding control bits in the MXCSR register. When a source value is a 0.0, an \342\210\236 of the sign of the source value is returned. A denormal source value is treated as a 0.0 (of the same sign). When a source value is a negative value (other than \342\210\2220.0), a floating-point indefinite is returned. When a source value is an SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned.\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.\nVEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
  }
  instruction_groups {
    name: "CVTPS2PI"
    short_description: "Convert Packed Single-Precision FP Values to Packed Dword Integers"
    description: "Converts two packed single-precision floating-point values in the source operand (second operand) to two packed signed doubleword integers in the destination operand (first operand).\nThe source operand can be an XMM register or a 128-bit memory location. The destination operand is an MMX technology register. When the source operand is an XMM register, the two single-precision floating-point values are contained in the low quadword of the register. When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.\nCVTPS2PI causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floatingpoint exception is pending, the exception is handled before the CVTPS2PI instruction is executed.\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15)."
  }
  instruction_groups {
    name: "VCVTTPD2QQ"
    short_description: "Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Quadword Integers"
  }
  instruction_groups {
    name: "DAA"
    short_description: "Decimal Adjust AL after Addition"
    description: "Adjusts the sum of two packed BCD values to create a packed BCD result. The AL register is the implied source and destination operand. The DAA instruction is only useful when it follows an ADD instruction that adds (binary addition) two 2-digit, packed BCD values and stores a byte result in the AL register. The DAA instruction then adjusts the contents of the AL register to contain the correct 2-digit, packed BCD result. If a decimal carry is detected, the CF and AF flags are set accordingly.\nThis instruction executes as described above in compatibility mode and legacy mode. It is not valid in 64-bit mode."
    flags_affected {
      content: "The CF and AF flags are set if the adjustment of the value results in a decimal carry in either digit of the result (see the \342\200\234Operation\342\200\235 section above). The SF, ZF, and PF flags are set according to the result. The OF flag is undefined."
    }
  }
  instruction_groups {
    name: "ROUNDPD"
    short_description: "Round Packed Double Precision Floating-Point Values"
    description: "Round the 2 double-precision floating-point values in the source operand (second operand) using the rounding mode specified in the im\nmediate operand (third operand) and place the results in the destination operand (first operand). The rounding process rounds each input floating-point value to an integer value and returns the integer result as a double-precision floating-point value.\nThe im mediate operand specifies control fields for the rounding operation, three bit fields are defined and shown in\nFigure 4-24. Bit 3 of the im mediate byte controls processor behavior for a precision exception, bit 2 selects the source of rounding mode control. Bits 1:0 specify a non-sticky rounding-mode value (Table 4-17 lists the encoded values for rounding-mode field).\nThe Precision Floating-Point Exception is signaled according to the im mediate operand. If any source operand is an SNaN then it will be converted to a QNaN. If DAZ is set to \342\200\2301 then denormals will be converted to zero before rounding.\n128-bit Legacy SSE version: The second source can be an XMM register or 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.\nVEX.128 encoded version: the source operand second source operand or a 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.\nVEX.256 encoded version: The source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.\n8\t3\t2\t1\t0\nReserved\nP\t-\tPrecision Mask; 0: normal, 1: inexact\nRS\t-\tRounding select; 1: MXCSR.RC, 0: Imm8.RC\nRC\t-\tRounding mode\nFigure 4-24.  Bit Control Fields of Immediate Byte for ROUNDxx Instruction\nTable 4-17.  Rounding Modes and Encoding of Rounding Control (RC) Field\nRounding Mode\tRC Field Setting\tDescription\nRound to nearest (even)\t00B\tRounded result is the closest to the infinitely precise result. If two values are equally close, the result is the even value (i.e., the integer value with the least-significant bit of zero).\nRound down (toward \342\210\222\342\210\236)\t01B\tRounded result is closest to but no greater than the infinitely precise result.\nRound up (toward +\342\210\236)\t10B\tRounded result is closest to but no less than the infinitely precise result.\nRound toward zero (Truncate)\t11B\tRounded result is closest to but no greater in absolute value than the infinitely precise result."
  }
  instruction_groups {
    name: "FSQRT"
    short_description: "Square Root"
    description: "Computes the square root of the source value in the ST(0) register and stores the result in ST(0).\nThe following table shows the results obtained when taking the square root of various classes of numbers, assuming that neither overflow nor underflow occurs.\nTable 3-37.  FSQRT Results\nSRC (ST(0))\tDEST (ST(0))\n\342\210\222 \342\210\236\t*\n\342\210\222 F\t*\n\342\210\222 0\t\342\210\222 0\n+ 0\t+ 0\n+ F\t+ F\n+ \342\210\236\t+ \342\210\236\nNaN\tNaN\nNOTES:\nF\tMeans finite floating-point value.\n*\tIndicates floating-point invalid-arithmetic-operand (#IA) exception.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C1\tSet to 0 if stack underflow occurred.\nSet if result was rounded up; cleared otherwise.\nC0, C2, C3\tUndefined."
    }
  }
  instruction_groups {
    name: "PMOVMSKB"
    short_description: "Move Byte Mask"
    description: "Creates a mask made up of the most significant bit of each byte of the source operand (second operand) and stores the result in the low byte or word of the destination operand (first operand).\nThe byte mask is 8 bits for 64-bit source operand, 16 bits for 128-bit source operand and 32 bits for 256-bit source operand. The destination operand is a general-purpose register.\nIn 64-bit mode, the instruction can access additional registers (XMM8-XMM15, R8-R15) when used with a REX.R prefix. The default operand size is 64-bit in 64-bit mode.\nLegacy SSE version: The source operand is an MMX technology register.\n128-bit Legacy SSE version: The source operand is an XMM register.\nVEX.128 encoded version: The source operand is an XMM register.\nVEX.256 encoded version: The source operand is a YMM register.\nNote: VEX.vvvv is reserved and must be 1111b."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "LAR"
    short_description: "Load Access Rights Byte"
    description: "Loads the access rights from the segment descriptor specified by the second operand (source operand) into the first operand (destination operand) and sets the ZF flag in the flag register. The source operand (which can be a register or a memory location) contains the segment selector for the segment descriptor being accessed. If the source operand is a memory address, only 16 bits of data are accessed. The destination operand is a generalpurpose register.\nThe processor performs access checks as part of the loading process. Once loaded in the destination register, software can perform additional checks on the access rights information.\nThe access rights for a segment descriptor include fields located in the second doubleword (bytes 4-7) of the segment descriptor. The following fields are loaded by the LAR instruction:\n\342\200\242\tBits 7:0 are returned as 0\n\342\200\242\tBits 11:8 return the segment type.\n\342\200\242\tBit 12 returns the S flag.\n\342\200\242\tBits 14:13 return the DPL.\n\342\200\242\tBit 15 returns the P flag.\n\342\200\242\tThe following fields are returned only if the operand size is greater than 16 bits:\n-\tBits 19:16 are undefined.\n-\tBit 20 returns the software-available bit in the descriptor.\n-\tBit 21 returns the L flag.\n-\tBit 22 returns the D/B flag.\n-\tBit 23 returns the G flag.\n-\tBits 31:24 are returned as 0.\nThis instruction performs the following checks before it loads the access rights in the destination register:\n\342\200\242\tChecks that the segment selector is not NULL.\n\342\200\242\tChecks that the segment selector points to a descriptor that is within the limits of the GDT or LDT being accessed\n\342\200\242\tChecks that the descriptor type is valid for this instruction. All code and data segment descriptors are valid for (can be accessed with) the LAR instruction. The valid system segment and gate descriptor types are given in Table 3-53.\n\342\200\242\tIf the segment is not a conforming code segment, it checks that the specified segment descriptor is visible at the CPL (that is, if the CPL and the RPL of the segment selector are less than or equal to the DPL of the segment selector).\nIf the segment descriptor cannot be accessed or is an invalid type for the instruction, the ZF flag is cleared and no access rights are loaded in the destination operand.\nThe LAR instruction can only be executed in protected mode and IA-32e mode.\nTable 3-53.  Segment and Gate Types\nType\tProtected Mode\tIA-32e Mode\nName\tValid\tName\tValid\n0\tReserved\tNo\tReserved\tNo\n1\tAvailable 16-bit TSS\tYes\tReserved\tNo\n2\tLDT\tYes\tLDT\tYes\n3\tBusy 16-bit TSS\tYes\tReserved\tNo\n4\t16-bit call gate\tYes\tReserved\tNo\n5\t16-bit/32-bit task gate\tYes\tReserved\tNo\n6\t16-bit interrupt gate\tNo\tReserved\tNo\n7\t16-bit trap gate\tNo\tReserved\tNo\n8\tReserved\tNo\tReserved\tNo\n9\tAvailable 32-bit TSS\tYes\tAvailable 64-bit TSS\tYes\nA\tReserved\tNo\tReserved\tNo\nB\tBusy 32-bit TSS\tYes\tBusy 64-bit TSS\tYes\nC\t32-bit call gate\tYes\t64-bit call gate\tYes\nD\tReserved\tNo\tReserved\tNo\nE\t32-bit interrupt gate\tNo\t64-bit interrupt gate\tNo\nF\t32-bit trap gate\tNo\t64-bit trap gate\tNo"
    flags_affected {
      content: "The ZF flag is set to 1 if the access rights are loaded successfully; otherwise, it is cleared to 0."
    }
  }
  instruction_groups {
    name: "VCVTSS2USI"
    short_description: "Convert Scalar Single-Precision Floating-Point Value to Unsigned Doubleword Integer"
  }
  instruction_groups {
    name: "VCVTTPD2UDQ"
    short_description: "Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers"
  }
  instruction_groups {
    name: "LEA"
    short_description: "Load Effective Address"
    description: "Computes the effective address of the second operand (the source operand) and stores it in the first operand (destination operand). The source operand is a memory address (offset part) specified with one of the processors addressing modes; the destination operand is a general-purpose register. The address-size and operand-size attributes affect the action performed by this instruction, as shown in the following table. The operand-size attribute of the instruction is determined by the chosen register; the address-size attribute is determined by the attribute of the code segment.\nTable 3-54.  Non-64-bit Mode LEA Operation with Address and Operand Size Attributes\nOperand Size\tAddress Size\tAction Performed\n16\t16\t16-bit effective address is calculated and stored in requested 16-bit register destination.\n16\t32\t32-bit effective address is calculated. The lower 16 bits of the address are stored in the requested 16-bit register destination.\n32\t16\t16-bit effective address is calculated. The 16-bit address is zero-extended and stored in the requested 32-bit register destination.\n32\t32\t32-bit effective address is calculated and stored in the requested 32-bit register destination.\nDifferent assemblers may use different algorithms based on the size attribute and symbolic reference of the source operand.\nIn 64-bit mode, the instruction\342\200\231s destination operand is governed by operand size attribute, the default operand size is 32 bits. Address calculation is governed by address size attribute, the default address size is 64-bits. In 64- bit mode, address size of 16 bits is not encodable. See Table 3-55.\nTable 3-55.  64-bit Mode LEA Operation with Address and Operand Size Attributes\nOperand Size\tAddress Size\tAction Performed\n16\t32\t32-bit effective address is calculated (using 67H prefix). The lower 16 bits of the address are stored in the requested 16-bit register destination (using 66H prefix).\n16\t64\t64-bit effective address is calculated (default address size). The lower 16 bits of the address are stored in the requested 16-bit register destination (using 66H prefix).\n32\t32\t32-bit effective address is calculated (using 67H prefix) and stored in the requested 32-bit register destination.\n32\t64\t64-bit effective address is calculated (default address size) and the lower 32 bits of the address are stored in the requested 32-bit register destination.\n64\t32\t32-bit effective address is calculated (using 67H prefix), zero-extended to 64-bits, and stored in the requested 64-bit register destination (using REX.W).\n64\t64\t64-bit effective address is calculated (default address size) and all 64-bits of the address are stored in the requested 64-bit register destination (using REX.W)."
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "PCMPISTRI"
    short_description: "Packed Compare Implicit Length Strings, Return Index"
    description: "The instruction compares data from two strings based on the encoded value in the Im m8 Control Byte (see Section\n4.1, \342\200\234Im m8 Control Byte Operation for PCMPESTRI / PCMPESTRM / PCMPISTRI / PCMPISTRM\342\200\235), and generates an index stored to ECX.\nEach string is represented by a single value. The value is an xm m (or possibly m128 for the second operand) which contains the data elements of the string (byte or word data). Each input byte/word is augmented with a valid/invalid tag. A byte/word is considered valid only if it has a lower index than the least significant null byte/word. (The least significant null byte/word is also considered invalid.)\nThe comparison and aggregation operations are performed according to the encoded value of Im m8 bit fields (see\nSection 4.1). The index of the first (or last, according to im m8[6]) set bit of IntRes2 is returned in ECX. If no bits\nare set in IntRes2, ECX is set to 16 (8).\nNote that the Arithmetic Flags are written in a non-standard manner in order to supply the most relevant information:\nCFlag - Reset if IntRes2 is equal to zero, set otherwise ZFlag - Set if any byte/word of xmm2/mem128 is null, reset otherwise SFlag - Set if any byte/word of xmm1 is null, reset otherwise OFlag -IntRes2[0] AFlag - Reset PFlag - Reset Note: In VEX.128 encoded version, VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD."
  }
  instruction_groups {
    name: "VRCP14PD"
    short_description: "Compute Approximate Reciprocals of Packed Float64 Values"
  }
  instruction_groups {
    name: "VRCP14SD"
    short_description: "Compute Approximate Reciprocal of Scalar Float64 Value"
  }
  instruction_groups {
    name: "VP4DPWSSDS"
    short_description: "Dot Product of Signed Words with Dword Accumulation and Saturation (4-iterations)"
  }
  instruction_groups {
    name: "EMODPR"
  }
  instruction_groups {
    name: "PMULHW"
    short_description: "Multiply Packed Signed Integers and Store High Result"
    description: "Performs a SIMD signed multiply of the packed signed word integers in the destination operand (first operand) and the source operand (second operand), and stores the high 16 bits of each intermediate 32-bit result in the destination operand. (Figure 4-12 shows this operation when using 64-bit operands.)\nn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE version 64-bit operand: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register.\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed. VEX.L must be 0, otherwise the instruction will #UD.\nVEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1."
    flags_affected {
      content: "None.\nSIMD Floating-Point Exceptions\nNone."
    }
  }
  instruction_groups {
    name: "VRSQRT14SS"
    short_description: "Compute Approximate Reciprocal of Square Root of Scalar Float32 Value"
  }
  instruction_groups {
    name: "WRPKRU"
    short_description: "Write Data to User Page Key Register"
    description: "Writes the value of EAX into PKRU. ECX and EDX must be 0 when WRPKRU is executed; otherwise, a generalprotection exception (#GP) occurs.\nWRPKRU can be executed only if CR4.PKE = 1; otherwise, an invalid-opcode exception (#UD) occurs. Software can discover the value of CR4.PKE by examining CPUID.(EAX=07H,ECX=0H):ECX.OSPKE [bit 4].\nOn processors that support the Intel64 Architecture, the high-order 32-bits of RCX, RDX and RAX are ignored.\nWRPKRU will never execute speculatively. Memory accesses affected by PKRU register will not execute (even speculatively) until all prior executions of WRPKRU have completed execution and updated the PKRU register."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "KXNORW/KXNORB/KXNORQ/KXNORD"
    short_description: "Bitwise Logical XNOR Masks"
    description: "Performs a bitwise XNOR between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1 (three-operand form)."
    flags_affected {
      content: "None\nSIMD Floating-Point Exceptions\nNone"
    }
  }
  instruction_groups {
    name: "FXTRACT"
    short_description: "Extract Exponent and Significand"
    description: "Separates the source value in the ST(0) register into its exponent and significand, stores the exponent in ST(0), and pushes the significand onto the register stack. Following this operation, the new top-of-stack register ST(0) contains the value of the original significand expressed as a floating-point value. The sign and significand of this value are the same as those found in the source operand, and the exponent is 3FFFH (biased value for a true exponent of zero). The ST(1) register contains the value of the original operand\342\200\231s true (unbiased) exponent expressed as a floating-point value. (The operation performed by this instruction is a superset of the IEEE-recom mended\nlogb(x) function.)\nThis instruction and the F2XM1 instruction are useful for performing power and range scaling operations. The FXTRACT instruction is also useful for converting numbers in double extended-precision floating-point format to decimal representations (e.g., for printing or displaying).\nIf the floating-point zero-divide exception (#Z) is masked and the source operand is zero, an exponent value of -\342\210\236 is stored in register ST(1) and 0 with the sign of the source operand is stored in register ST(0).\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C1\tSet to 0 if stack underflow occurred; set to 1 if stack overflow occurred.\nC0, C2, C3\tUndefined."
    }
  }
  instruction_groups {
    name: "CVTSI2SS"
    short_description: "Convert Doubleword Integer to Scalar Single-Precision Floating-Point Value"
    description: "Converts a signed doubleword integer (or signed quadword integer if operand size is 64 bits) in the \342\200\234convert-from\342\200\235 source operand to a single-precision floating-point value in the destination operand (first operand). The \342\200\234convertfrom\342\200\235 source operand can be a general-purpose register or a memory location. The destination operand is an XMM register. The result is stored in the low doubleword of the destination operand, and the upper three doublewords are left unchanged. When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits.\n128-bit Legacy SSE version: In 64-bit mode, Use of the REX.W prefix promotes the instruction to use 64-bit input value. The \342\200\234convert-from\342\200\235 source operand (the second operand) is a general-purpose register or memory location.\nBits (MAXVL-1:32) of the corresponding destination register remain unchanged.\nVEX.128 and EVEX encoded versions: The \342\200\234convert-from\342\200\235 source operand (the third operand) can be a generalpurpose register or a memory location. The first source and destination operands are XMM registers. Bits (127:32) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\nEVEX encoded version: the converted result in written to the low doubleword element of the destination under the writemask.\nSoftware should ensure VCVTSI2SS is encoded with VEX.L=0. Encoding VCVTSI2SS with VEX.L=1 may encounter unpredictable behavior across different processor generations."
  }
  instruction_groups {
    name: "FCOMI/FCOMIP/ FUCOMI/FUCOMIP"
    short_description: "Compare Floating Point Values and Set EFLAGS"
    description: "Performs an unordered comparison of the contents of registers ST(0) and ST(i) and sets the status flags ZF, PF, and CF in the EFLAGS register according to the results (see the table below). The sign of zero is ignored for comparisons, so that -0.0 is equal to +0.0.\nTable 3-22.  FCOMI/FCOMIP/ FUCOMI/FUCOMIP Results\nComparison Results*\tZF\tPF\tCF\nST0 > ST(i)\t0\t0\t0\nST0 < ST(i)\t0\t0\t1\nST0 = ST(i)\t1\t0\t0\nUnordered**\t1\t1\t1\nNOTES:\n* See the IA-32 Architecture Compatibility section below.\n**Flags not set if unmasked invalid-arithmetic-operand (#IA) exception is generated.\nAn unordered comparison checks the class of the numbers being compared (see \342\200\234FXAM\n-Examine Floating-Point\342\200\235 in this chapter). The FUCOMI/FUCOMIP instructions perform the same operations as the FCOMI/FCOMIP instructions. The only difference is that the FUCOMI/FUCOMIP instructions raise the invalid-arithmetic-operand exception (#IA) only when either or both operands are an SNaN or are in an unsupported format; QNaNs cause the condition code flags to be set to unordered, but do not cause an exception to be generated. The FCOMI/FCOMIP instructions raise an invalid-operation exception when either or both of the operands are a NaN value of any kind or are in an unsupported format.\nIf the operation results in an invalid-arithmetic-operand exception being raised, the status flags in the EFLAGS register are set only if the exception is masked.\nThe FCOMI/FCOMIP and FUCOMI/FUCOMIP instructions set the OF, SF and AF flags to zero in the EFLAGS register (regardless of whether an invalid-operation exception is detected).\nThe FCOMIP and FUCOMIP instructions also pop the register stack following the comparison operation. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C1\tSet to 0.\nC0, C2, C3\tNot affected."
    }
  }
  instruction_groups {
    name: "GF2P8AFFINEQB"
    short_description: "Galois Field Affine Transformation"
  }
  instruction_groups {
    name: "VPSHUFBITQMB"
    short_description: "Shuffle Bits from Quadword Elements Using Byte Indexes into Mask"
  }
  instruction_groups {
    name: "SHA256MSG2"
    short_description: "Perform a Final Calculation for the Next Four SHA256 Message Dwords"
  }
  instruction_groups {
    name: "BNDSTX"
    short_description: "Store Extended Bounds Using Address Translation"
    description: "BNDSTX uses the linear address constructed from the displacement and base register of the SIB-addressing form of the memory operand (mib) to perform address translation to store to a bound table entry. The bounds in the source operand bnd are written to the lower and upper bounds in the BTE. The content of the index register of mib is written to the pointer value field in the BTE.\nThis instruction does not cause memory access to the linear address of mib nor the effective address referenced by the base, and does not read or write any flags.\nSegment overrides apply to the linear address computation with the base of mib, and are used during address translation to generate the address of the bound table entry. By default, the address of the BTE is assumed to be linear address. There are no segmentation checks performed on the base of mib.\nThe base of mib will not be checked for canonical address violation as it does not access memory.\nAny encoding of this instruction that does not specify base or index register will treat those registers as zero (constant). The reg-reg form of this instruction will remain a NOP.\nThe scale field of the SIB byte has no effect on these instructions and is ignored.\nThe bound register may be partially updated on memory faults. The order in which memory operands are loaded is implementation specific."
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "VFIXUPIMMSS"
    short_description: "Fix Up Special Scalar Float32 Value"
  }
  instruction_groups {
    name: "VSHUFF32x4/VSHUFF64x2/VSHUFI32x4/VSHUFI64x2"
    short_description: "Shuffle Packed Values at 128-bit Granularity"
  }
  instruction_groups {
    name: "MPSADBW"
    short_description: "Compute Multiple Packed Sums of Absolute Difference"
    description: "(V)MPSADBW calculates packed word results of sum-absolute-difference (SAD) of unsigned bytes from two blocks of 32-bit dword elements, using two select fields in the im\nmediate byte to select the offsets of the two blocks within the first source operand and the second operand. Packed SAD word results are calculated within each 128-bit lane.\nEach SAD word result is calculated between a stationary block_2 (whose offset within the second source operand is selected by a two bit select control, multiplied by 32 bits) and a sliding block_1 at consecutive byte-granular position within the first source operand. The offset of the first 32-bit block of block_1 is selectable using a one bit select control, multiplied by 32 bits.\n128-bit Legacy SSE version: Im m8[1:0]*32 specifies the bit offset of block_2 within the second source operand.\nIm m[2]*32 specifies the initial bit offset of the block_1 within the first source operand. The first source operand and destination operand are the same. The first source and destination operands are XMM registers. The second source operand is either an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged. Bits 7:3 of the im mediate byte are ignored.\nVEX.128 encoded version: Im m8[1:0]*32 specifies the bit offset of block_2 within the second source operand.\nIm m[2]*32 specifies the initial bit offset of the block_1 within the first source operand. The first source and destination operands are XMM registers. The second source operand is either an XMM register or a 128-bit memory location. Bits (127:128) of the corresponding YMM register are zeroed. Bits 7:3 of the im\nmediate byte are ignored.\nVEX.256 encoded version: The sum-absolute-difference (SAD) operation is repeated 8 times for MPSADW between the same block_2 (fixed offset within the second source operand) and a variable block_1 (offset is shifted by 8 bits for each SAD operation) in the first source operand. Each 16-bit result of eight SAD operations between block_2 and block_1 is written to the respective word in the lower 128 bits of the destination operand.\nAdditionally, VMPSADBW performs another eight SAD operations on block_4 of the second source operand and block_3 of the first source operand. (Im m8[4:3]*32 + 128) specifies the bit offset of block_4 within the second\nsource operand. (Im m[5]*32+128) specifies the initial bit offset of the block_3 within the first source operand.\nEach 16-bit result of eight SAD operations between block_4 and block_3 is written to the respective word in the upper 128 bits of the destination operand.\nThe first source operand is a YMM register. The second source register can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. Bits 7:6 of the im\nmediate byte are ignored.\nNote: If VMPSADBW is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.\nImm[4:3]*32+128\n255\t224\t192\t128\nSrc2\tAbs. Diff.\tImm[5]*32+128\nSrc1\nSum\n255\t144\t128\nDestination\nImm[1:0]*32\n127\t96\t64\t0\nSrc2\tAbs. Diff.\tImm[2]*32\nSrc1\nSum\n127\t16\t0\nDestination\nFigure 4-5.  256-bit VMPSADBW Operation"
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "STMXCSR"
    short_description: "Store MXCSR Register State"
    description: "Stores the contents of the MXCSR control and status register to the destination operand. The destination operand is a 32-bit memory location. The reserved bits in the MXCSR register are stored as 0s.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode.\nVEX.L must be 0, otherwise instructions will #UD.\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
  }
  instruction_groups {
    name: "KTESTW/KTESTB/KTESTQ/KTESTD"
    short_description: "Packed Bit Test Masks and Set Flags"
    description: "Performs a bitwise comparison of the bits of the first source operand and corresponding bits in the second source operand. If the AND operation produces all zeros, the ZF is set else the ZF is clear. If the bitwise AND operation of the inverted first source operand with the second source operand produces all zeros the CF is set else the CF is clear. Only the EFLAGS register is updated.\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
  }
  instruction_groups {
    name: "MUL"
    short_description: "Unsigned Multiply"
    description: "Performs an unsigned multiplication of the first operand (destination operand) and the second operand (source operand) and stores the result in the destination operand. The destination operand is an implied operand located in register AL, AX or EAX (depending on the size of the operand); the source operand is located in a general-purpose register or a memory location. The action of this instruction and the location of the result depends on the opcode and the operand size as shown in Table 4-9.\nThe result is stored in register AX, register pair DX:AX, or register pair EDX:EAX (depending on the operand size), with the high-order bits of the product contained in register AH, DX, or EDX, respectively. If the high-order bits of the product are 0, the CF and OF flags are cleared; otherwise, the flags are set.\nIn 64-bit mode, the instruction\342\200\231s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits.\nSee the sum mary chart at the beginning of this section for encoding data and limits.\nTable 4-9.  MUL Results\nOperand Size\tSource 1\tSource 2\tDestination\nByte\tAL\tr/m8\tAX\nWord\tAX\tr/m16\tDX:AX\nDoubleword\tEAX\tr/m32\tEDX:EAX\nQuadword\tRAX\tr/m64\tRDX:RAX"
    flags_affected {
      content: "The OF and CF flags are set to 0 if the upper half of the result is 0; otherwise, they are set to 1. The SF, ZF, AF, and PF flags are undefined."
    }
  }
  instruction_groups {
    name: "VCVTSD2USI"
    short_description: "Convert Scalar Double-Precision Floating-Point Value to Unsigned Doubleword Integer"
  }
  instruction_groups {
    name: "PSLLDQ"
    short_description: "Shift Double Quadword Left Logical"
    description: "Shifts the destination operand (first operand) to the left by the number of bytes specified in the count operand (second operand). The empty low-order bytes are cleared (set to all 0s). If the value specified by the count operand is greater than 15, the destination operand is set to all 0s. The count operand is an 8-bit im\nmediate.\n128-bit Legacy SSE version: The source and destination operands are the same. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The source and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded version: The source operand is YMM register. The destination operand is an YMM register. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed. The count operand applies to both the low and high 128-bit lanes.\nEVEX encoded versions: The source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location.\nThe destination operand is a ZMM/YMM/XMM register. The count operand applies to each 128-bit lanes."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "ORPS"
    short_description: "Bitwise Logical OR of Packed Single Precision Floating-Point Values"
  }
  instruction_groups {
    name: "POPCNT"
    short_description: "Return the Count of Number of Bits Set to 1"
    description: "This instruction calculates the number of bits set to 1 in the second operand (source) and returns the count in the first operand (a destination register)."
    flags_affected {
      content: "OF, SF, ZF, AF, CF, PF are all cleared. ZF is set if SRC = 0, otherwise ZF is cleared."
    }
  }
  instruction_groups {
    name: "FXSAVE"
    short_description: "Save x87 FPU, MMX Technology, and SSE State"
    description: "Saves the current state of the x87 FPU, MMX technology, XMM, and MXCSR registers to a 512-byte memory location specified in the destination operand. The content layout of the 512 byte region depends on whether the processor is operating in non-64-bit operating modes or 64-bit sub-mode of IA-32e mode.\nBytes 464:511 are available to software use. The processor does not write to bytes 464:511 of an FXSAVE area.\nThe operation of FXSAVE in non-64-bit modes is described first."
  }
  instruction_groups {
    name: "MOVSLDUP"
    short_description: "Replicate Single FP Values"
  }
  instruction_groups {
    name: "PEXTRW"
    short_description: "Extract Word"
    description: "Copies the word in the source operand (second operand) specified by the count operand (third operand) to the destination operand (first operand). The source operand can be an MMX technology register or an XMM register.\nThe destination operand can be the low word of a general-purpose register or a 16-bit memory address. The count operand is an 8-bit im\nmediate. When specifying a word location in an MMX technology register, the 2 least-significant bits of the count operand specify the location; for an XMM register, the 3 least-significant bits specify the location. The content of the destination register above bit 16 is cleared (set to all 0s).\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15, R8-15). If the destination operand is a general-purpose register, the default operand size is 64-bits in 64-bit mode.\nNote: In VEX.128 encoded versions, VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD. In EVEX.128 encoded versions, EVEX.vvvv is reserved and must be 1111b, EVEX.L must be 0, otherwise the instruction will #UD. If the destination operand is a register, the default operand size in 64-bit mode for VPEXTRW is 64 bits, the bits above the least significant byte/word/dword data are filled with zeros."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "SQRTSD"
    short_description: "Compute Square Root of Scalar Double-Precision Floating-Point Value"
  }
  instruction_groups {
    name: "SUBSS"
    short_description: "Subtract Scalar Single-Precision Floating-Point Value"
  }
  instruction_groups {
    name: "SHLD"
    short_description: "Double Precision Shift Left"
    description: "The SHLD instruction is used for multi-precision shifts of 64 bits or more.\nThe instruction shifts the first operand (destination operand) to the left the number of bits specified by the third operand (count operand). The second operand (source operand) provides bits to shift in from the right (starting with bit 0 of the destination operand).\nThe destination operand can be a register or a memory location; the source operand is a register. The count operand is an unsigned integer that can be stored in an im\nmediate byte or in the CL register. If the count operand is CL, the shift count is the logical AND of CL and a count mask. In non-64-bit modes and default 64-bit mode; only bits 0 through 4 of the count are used. This masks the count to a value between 0 and 31. If a count is greater than the operand size, the result is undefined.\nIf the count is 1 or greater, the CF flag is filled with the last bit shifted out of the destination operand. For a 1-bit shift, the OF flag is set if a sign change occurred; otherwise, it is cleared. If the count operand is 0, flags are not affected.\nIn 64-bit mode, the instruction\342\200\231s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits (upgrading the count mask to 6 bits). See the sum mary chart at the beginning of this section for encoding data and\nlimits."
    flags_affected {
      content: "If the count is 1 or greater, the CF flag is filled with the last bit shifted out of the destination operand and the SF, ZF, and PF flags are set according to the value of the result. For a 1-bit shift, the OF flag is set if a sign change occurred; otherwise, it is cleared. For shifts greater than 1 bit, the OF flag is undefined. If a shift occurs, the AF flag is undefined. If the count operand is 0, the flags are not affected. If the count is greater than the operand size, the flags are undefined."
    }
  }
  instruction_groups {
    name: "VFPCLASSSS"
    short_description: "Tests Types Of a Scalar Float32 Values"
  }
  instruction_groups {
    name: "BTR"
    short_description: "Bit Test and Reset"
    description: "Selects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by the bit offset operand (second operand), stores the value of the bit in the CF flag, and clears the selected bit in the bit string to 0. The bit base operand can be a register or a memory location; the bit offset operand can be a register or an im mediate value:\n\342\200\242\tIf the bit base operand specifies a register, the instruction takes the modulo 16, 32, or 64 of the bit offset operand (modulo size depends on the mode and register size; 64-bit operands are available only in 64-bit mode). This allows any bit position to be selected.\n\342\200\242\tIf the bit base operand specifies a memory location, the operand represents the address of the byte in memory that contains the bit base (bit 0 of the specified byte) of the bit string. The range of the bit position that can be referenced by the offset operand depends on the operand size.\nSee also: Bit(BitBase, BitOffset) on page 3-11.\nSome assemblers support im mediate bit offsets larger than 31 by using the im mediate bit offset field in combination with the displacement field of the memory operand. See \342\200\234BT-Bit Test\342\200\235 in this chapter for more information on this addressing mechanism.\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.\nIn 64-bit mode, the instruction\342\200\231s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the sum mary chart at the beginning of this section for encoding data and limits."
    flags_affected {
      content: "The CF flag contains the value of the selected bit before it is cleared. The ZF flag is unaffected. The OF, SF, AF, and PF flags are undefined."
    }
  }
  instruction_groups {
    name: "PMINSB/PMINSW"
    short_description: "Minimum of Packed Signed Integers"
  }
  instruction_groups {
    name: "BLSMSK"
    short_description: "Get Mask Up to Lowest Set Bit"
    description: "Sets all the lower bits of the destination operand to \342\200\2341\342\200\235 up to and including lowest set bit (=1) in the source operand. If source operand is zero, BLSMSK sets all bits of the destination operand to 1 and also sets CF to 1.\nThis instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD."
    flags_affected {
      content: "SF is updated based on the result. CF is set if the source if zero. ZF and OF flags are cleared. AF and PF flag are undefined."
    }
  }
  instruction_groups {
    name: "VERR/VERW"
    short_description: "Verify a Segment for Reading or Writing"
    description: "Verifies whether the code or data segment specified with the source operand is readable (VERR) or writable (VERW) from the current privilege level (CPL). The source operand is a 16-bit register or a memory location that contains the segment selector for the segment to be verified. If the segment is accessible and readable (VERR) or writable (VERW), the ZF flag is set; otherwise, the ZF flag is cleared. Code segments are never verified as writable. This check cannot be performed on system segments.\nTo set the ZF flag, the following conditions must be met:\n\342\200\242\tThe segment selector is not NULL.\n\342\200\242\tThe selector must denote a descriptor within the bounds of the descriptor table (GDT or LDT).\n\342\200\242\tThe selector must denote the descriptor of a code or data segment (not that of a system segment or gate).\n\342\200\242\tFor the VERR instruction, the segment must be readable.\n\342\200\242\tFor the VERW instruction, the segment must be a writable data segment.\n\342\200\242\tIf the segment is not a conforming code segment, the segment\342\200\231s DPL must be greater than or equal to (have less or the same privilege as) both the CPL and the segment selector\'s RPL.\nThe validation performed is the same as is performed when a segment selector is loaded into the DS, ES, FS, or GS register, and the indicated access (read or write) is performed. The segment selector\'s value cannot result in a protection exception, enabling the software to anticipate possible segment access problems.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode. The operand size is fixed at 16 bits."
    flags_affected {
      content: "The ZF flag is set to 1 if the segment is accessible and readable (VERR) or writable (VERW); otherwise, it is set to 0."
    }
  }
  instruction_groups {
    name: "FDIV/FDIVP/FIDIV"
    short_description: "Divide"
    description: "Divides the destination operand by the source operand and stores the result in the destination location. The destination operand (dividend) is always in an FPU register; the source operand (divisor) can be a register or a memory location. Source operands in memory can be in single-precision or double-precision floating-point format, word or doubleword integer format.\nThe no-operand version of the instruction divides the contents of the ST(1) register by the contents of the ST(0) register. The one-operand version divides the contents of the ST(0) register by the contents of a memory location (either a floating-point or an integer value). The two-operand version, divides the contents of the ST(0) register by the contents of the ST(i) register or vice versa.\nThe FDIVP instructions perform the additional operation of popping the FPU register stack after storing the result.\nTo pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point divide instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FDIV rather than FDIVP.\nThe FIDIV instructions convert an integer source operand to double extended-precision floating-point format before performing the division. When the source operand is an integer 0, it is treated as a +0.\nIf an unmasked divide-by-zero exception (#Z) is generated, no result is stored; if the exception is masked, an \342\210\236 of the appropriate sign is stored in the destination operand.\nThe following table shows the results obtained when dividing various classes of numbers, assuming that neither overflow nor underflow occurs.\nTable 3-24.  FDIV/FDIVP/FIDIV Results\nDEST\n\342\210\222 \342\210\236\t\342\210\222 F\t\342\210\222 0\t+ 0\t+ F\t+ \342\210\236\tNaN\n\342\210\222 \342\210\236\t*\t+ 0\t+ 0\t\342\210\222 0\t\342\210\222 0\t*\tNaN\n\342\210\222 F\t+ \342\210\236\t+ F\t+ 0\t\342\210\222 0\t\342\210\222 F\t\342\210\222 \342\210\236\tNaN\n\342\210\222 I\t+ \342\210\236\t+ F\t+ 0\t\342\210\222 0\t\342\210\222 F\t\342\210\222 \342\210\236\tNaN\nSRC\t\342\210\222 0\t+ \342\210\236\t**\t*\t*\t**\t\342\210\222 \342\210\236\tNaN\n+ 0\t\342\210\222 \342\210\236\t**\t*\t*\t**\t+ \342\210\236\tNaN\n+ I\t\342\210\222 \342\210\236\t\342\210\222 F\t\342\210\222 0\t+ 0\t+ F\t+ \342\210\236\tNaN\n+ F\t\342\210\222 \342\210\236\t\342\210\222 F\t\342\210\222 0\t+ 0\t+ F\t+ \342\210\236\tNaN\n+ \342\210\236\t*\t\342\210\222 0\t\342\210\222 0\t+ 0\t+ 0\t*\tNaN\nNaN\tNaN\tNaN\tNaN\tNaN\tNaN\tNaN\tNaN\nNOTES:\nF\tMeans finite floating-point value.\nI\tMeans integer.\n* Indicates floating-point invalid-arithmetic-operand (#IA) exception.\n**Indicates floating-point zero-divide (#Z) exception.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C1\tSet to 0 if stack underflow occurred.\nSet if result was rounded up; cleared otherwise.\nC0, C2, C3\tUndefined."
    }
  }
  instruction_groups {
    name: "MOVHPD"
    short_description: "Move High Packed Double-Precision Floating-Point Value"
  }
  instruction_groups {
    name: "MOVZX"
    short_description: "Move with Zero-Extend"
    description: "Copies the contents of the source operand (register or memory location) to the destination operand (register) and zero extends the value. The size of the converted value depends on the operand-size attribute.\nIn 64-bit mode, the instruction\342\200\231s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bit operands. See the sum mary chart\nat the beginning of this section for encoding data and limits."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "BTC"
    short_description: "Bit Test and Complement"
    description: "Selects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by the bit offset operand (second operand), stores the value of the bit in the CF flag, and complements the selected bit in the bit string. The bit base operand can be a register or a memory location; the bit offset operand can be a register or an im mediate value:\n\342\200\242\tIf the bit base operand specifies a register, the instruction takes the modulo 16, 32, or 64 of the bit offset operand (modulo size depends on the mode and register size; 64-bit operands are available only in 64-bit mode). This allows any bit position to be selected.\n\342\200\242\tIf the bit base operand specifies a memory location, the operand represents the address of the byte in memory that contains the bit base (bit 0 of the specified byte) of the bit string. The range of the bit position that can be referenced by the offset operand depends on the operand size.\nSee also: Bit(BitBase, BitOffset) on page 3-11.\nSome assemblers support im mediate bit offsets larger than 31 by using the im mediate bit offset field in combination with the displacement field of the memory operand. See \342\200\234BT-Bit Test\342\200\235 in this chapter for more information on this addressing mechanism.\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.\nIn 64-bit mode, the instruction\342\200\231s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the sum mary chart at the beginning of this section for encoding data and limits."
    flags_affected {
      content: "The CF flag contains the value of the selected bit before it is complemented. The ZF flag is unaffected. The OF, SF, AF, and PF flags are undefined."
    }
  }
  instruction_groups {
    name: "SHUFPD"
    short_description: "Packed Interleave Shuffle of Pairs of Double-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "PCMPEQB/PCMPEQW/PCMPEQD"
    short_description: "Compare Packed Data for Equal"
    description: "Performs a SIMD compare for equality of the packed bytes, words, or doublewords in the destination operand (first operand) and the source operand (second operand). If a pair of data elements is equal, the corresponding data element in the destination operand is set to all 1s; otherwise, it is set to all 0s.\nThe (V)PCMPEQB instruction compares the corresponding bytes in the destination and source operands; the (V)PCMPEQW instruction compares the corresponding words in the destination and source operands; and the (V)PCMPEQD instruction compares the corresponding doublewords in the destination and source operands.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.\n128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.\nEVEX encoded VPCMPEQD: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.\nEVEX encoded VPCMPEQB/W: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2."
    flags_affected {
      content: "None.\nSIMD Floating-Point Exceptions\nNone."
    }
  }
  instruction_groups {
    name: "VCVTTPS2UQQ"
    short_description: "Convert with Truncation Packed Single Precision Floating-Point Values to Packed Unsigned Quadword Integer Values"
  }
  instruction_groups {
    name: "VFMADD132PD/VFMADD213PD/VFMADD231PD"
    short_description: "Fused Multiply-Add of Packed Double-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "REP/REPE/REPZ/REPNE/REPNZ"
    short_description: "Repeat String Operation Prefix"
    description: "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:\n\342\200\242\tF3H as REP/REPE/REPZ for string and input/output instruction.\n\342\200\242\tF3H is a mandatory prefix for POPCNT, LZCNT, and ADOX.\nThe REP prefixes apply only to one string instruction at a time. To repeat a block of instructions, use the LOOP instruction or another looping construct. All of these repeat prefixes cause the associated instruction to be repeated until the count in register is decremented to 0. See Table 4-16.\nTable 4-16.  Repeat Prefixes\nRepeat Prefix\tTermination Condition 1*\tTermination Condition 2\nREP\tRCX or (E)CX = 0\tNone\nREPE/REPZ\tRCX or (E)CX = 0\tZF = 0\nREPNE/REPNZ\tRCX or (E)CX = 0\tZF = 1\nNOTES:\n*\tCount register is CX, ECX or RCX by default, depending on attributes of the operating modes.\nThe REPE, REPNE, REPZ, and REPNZ prefixes also check the state of the ZF flag after each iteration and terminate the repeat loop if the ZF flag is not in the specified state. When both termination conditions are tested, the cause of a repeat termination can be determined either by testing the count register with a JECXZ instruction or by testing the ZF flag (with a JZ, JNZ, or JNE instruction).\nWhen the REPE/REPZ and REPNE/REPNZ prefixes are used, the ZF flag does not require initialization because both the CMPS and SCAS instructions affect the ZF flag according to the results of the comparisons they make.\nA repeating string operation can be suspended by an exception or interrupt. When this happens, the state of the registers is preserved to allow the string operation to be resumed upon a return from the exception or interrupt handler. The source and destination registers point to the next string elements to be operated on, the EIP register points to the string instruction, and the ECX register has the value it held following the last successful iteration of the instruction. This mechanism allows long string operations to proceed without affecting the interrupt response time of the system.\nWhen a fault occurs during the execution of a CMPS or SCAS instruction that is prefixed with REPE or REPNE, the EFLAGS value is restored to the state prior to the execution of the instruction. Since the SCAS and CMPS instructions do not use EFLAGS as an input, the processor can resume the instruction after the page fault handler.\nUse the REP INS and REP OUTS instructions with caution. Not all I/O ports can handle the rate at which these instructions execute. Note that a REP STOS instruction is the fastest way to initialize a large block of memory.\nIn 64-bit mode, the operand size of the count register is associated with the address size attribute. Thus the default count register is RCX; REX.W has no effect on the address size and the count register. In 64-bit mode, if 67H is used to override address size attribute, the count register is ECX and any implicit source/destination operand will use the corresponding 32-bit index register. See the sum mary chart at the beginning of this section for encoding\ndata and limits.\nREP INS may read from the I/O port without writing to the memory location if an exception or VM exit occurs due to the write (e.g. #PF). If this would be problematic, for example because the I/O port read has side-effects, software should ensure the write to the memory location does not cause an exception or VM exit."
    flags_affected {
      content: "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
    }
  }
  instruction_groups {
    name: "VGATHERQPS/VGATHERQPD"
    short_description: "Gather Packed Single, Packed Double with Signed Qword Indices"
  }
  instruction_groups {
    name: "PHSUBW/PHSUBD"
    short_description: "Packed Horizontal Subtract"
    description: "(V)PHSUBW performs horizontal subtraction on each adjacent pair of 16-bit signed integers by subtracting the most significant word from the least significant word of each pair in the source and destination operands, and packs the signed 16-bit results to the destination operand (first operand). (V)PHSUBD performs horizontal subtraction on each adjacent pair of 32-bit signed integers by subtracting the most significant doubleword from the least significant doubleword of each pair, and packs the signed 32-bit result to the destination operand. When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.\nLegacy SSE version: Both operands can be MMX registers. The second source operand can be an MMX register or a 64-bit memory location.\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nIn 64-bit mode, use the REX prefix to access additional registers.\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded version: The first source and destination operands are YMM registers. The second source operand can be an YMM register or a 256-bit memory location."
  }
  instruction_groups {
    name: "XSAVES"
    short_description: "Save Processor Extended States Supervisor"
    description: "Performs a full or partial save of processor state components to the XSAVE area located at the memory address specified by the destination operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components saved correspond to the bits set in the requested-feature bitmap (RFBM), the logicalAND of EDX:EAX and the logical-OR of XCR0 with the IA32_XSS MSR. XSAVES may be executed only if CPL = 0.\nThe format of the XSAVE area is detailed in Section 13.4, \342\200\234XSAVE Area,\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1. Like FXRSTOR and FXSAVE, the memory format used for x87 state depends on a REX.W prefix; see Section 13.5.1, \342\200\234x87 State\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1.\nSection 13.11, \342\200\234Operation of XSAVES,\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1 provides a detailed description of the operation of the XSAVES instruction. The following items provide a highlevel outline:\n\342\200\242\tExecution of XSAVES is similar to that of XSAVEC. XSAVES differs from XSAVEC in that it can save state components corresponding to bits set in the IA32_XSS MSR and that it may use the modified optimization.\n\342\200\242\t= 1.1 (XINUSE is a bitmap by which the processor tracks the status of various state components. See Section 13.6, \342\200\234Processor Tracking of XSAVEManaged State\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1.) Even if both bits are 1, XSAVES may optimize and not save state component i if (1)state component i has not been modified since the last execution of XRSTOR or XRSTORS; and (2)this execution of XSAVES correspond to that last execution of XRSTOR or XRSTORS as determined by XRSTOR_INFO (see the Operation section below).\nXSAVES saves state component i only if RFBM[i] = 1 and XINUSE[i]\n\342\200\242\tXSAVES does not modify bytes 511:464 of the legacy region of the XSAVE area (see Section 13.4.1, \342\200\234Legacy Region of an XSAVE Area\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1).\n\342\200\242\tXSAVES writes the logical AND of RFBM and XINUSE to the XSTATE_BV field of the XSAVE header.2 (See Section 13.4.2, \342\200\234XSAVE Header\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1.) XSAVES sets bit63 of the XCOMP_BV field and sets bits\n62:0 of that field to RFBM[62:0]. XSAVES does not write to any parts of the XSAVE header other than the XSTATE_BV and XCOMP_BV fields.\n\342\200\242\tXSAVES always uses the compacted format of the extended region of the XSAVE area (see Section 13.4.3, \342\200\234Extended Region of an XSAVE Area\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1).\nUse of a destination operand not aligned to 64-byte boundary (in either 64-bit or 32-bit modes) results in a general-protection (#GP) exception. In 64-bit mode, the upper 32 bits of RDX and RAX are ignored.\n1.\tThere is an exception for state component 1 (SSE). MXCSR is part of SSE state, but XINUSE[1] may be 0 even if MXCSR does not have its initial value of 1F80H. In this case, the init optimization does not apply and XSAVEC will save SSE state as long as RFBM[1]= 1 and the modified optimization is not being applied.\n2.\tThere is an exception for state component 1 (SSE). MXCSR is part of SSE state, but XINUSE[1] may be 0 even if MXCSR does not have its initial value of 1F80H. In this case, XSAVES sets XSTATE_BV[1] to 1 as long as RFBM[1]= 1.\nSee Section 13.6, \342\200\234Processor Tracking of XSAVE-Managed State,\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1 for discussion of the bitmap XMODIFIED and of the quantity XRSTOR_INFO."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "FUCOM/FUCOMP/FUCOMPP"
    short_description: "Unordered Compare Floating Point Values"
    description: "Performs an unordered comparison of the contents of register ST(0) and ST(i) and sets condition code flags C0, C2, and C3 in the FPU status word according to the results (see the table below). If no operand is specified, the contents of registers ST(0) and ST(1) are compared. The sign of zero is ignored, so that -0.0 is equal to +0.0.\nTable 3-41.  FUCOM/FUCOMP/FUCOMPP Results\nComparison Results*\tC3\tC2\tC0\nST0 > ST(i)\t0\t0\t0\nST0 < ST(i)\t0\t0\t1\nST0 = ST(i)\t1\t0\t0\nUnordered\t1\t1\t1\nNOTES:\n*\tFlags not set if unmasked invalid-arithmetic-operand (#IA) exception is generated.\nAn unordered comparison checks the class of the numbers being compared (see \342\200\234FXAM\n-Examine Floating-Point\342\200\235 in this chapter). The FUCOM/FUCOMP/FUCOMPP instructions perform the same operations as the FCOM/FCOMP/FCOMPP instructions. The only difference is that the FUCOM/FUCOMP/FUCOMPP instructions raise the invalid-arithmetic-operand exception (#IA) only when either or both operands are an SNaN or are in an unsupported format; QNaNs cause the condition code flags to be set to unordered, but do not cause an exception to be generated. The FCOM/FCOMP/FCOMPP instructions raise an invalid-operation exception when either or both of the operands are a NaN value of any kind or are in an unsupported format.\nAs with the FCOM/FCOMP/FCOMPP instructions, if the operation results in an invalid-arithmetic-operand exception being raised, the condition code flags are set only if the exception is masked.\nThe FUCOMP instruction pops the register stack following the comparison operation and the FUCOMPP instruction pops the register stack twice following the comparison operation. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C1\tSet to 0 if stack underflow occurred.\nC0, C2, C3\tSee Table 3-41."
    }
  }
  instruction_groups {
    name: "HADDPS"
    short_description: "Packed Single-FP Horizontal Add"
    description: "Adds the single-precision floating-point values in the first and second dwords of the destination operand and stores the result in the first dword of the destination operand.\nAdds single-precision floating-point values in the third and fourth dword of the destination operand and stores the result in the second dword of the destination operand.\nAdds single-precision floating-point values in the first and second dword of the source operand and stores the result in the third dword of the destination operand.\nAdds single-precision floating-point values in the third and fourth dword of the source operand and stores the result in the fourth dword of the destination operand.\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).\nSee Figure\t3-18 for HADDPS; see Figure\t3-19 for VHADDPS.\nHADDPS xmm1, xmm2/m128\n[127:96]\t[95:64]\t[63:32]\t[31:0]\txmm2/ m128\n[127:96]\t[95:64]\t[63:32]\t[31:0]\txmm1\nxmm2/m128 [95:64] + xmm2/ m128[127:96]\txmm2/m128 [31:0] + xmm2/ m128[63:32]\txmm1[95:64] + xmm1[127:96]\txmm1[31:0] + xmm1[63:32]\tRESULT: xmm1\n[127:96]\t[95:64]\t[63:32]\t[31:0]\nOM15994\nFigure 3-18.  HADDPS-Packed Single-FP Horizontal Add\nSRC1\tX7\tX6\tX5\tX4\tX3\tX2\tX1\tX0\nSRC2\tY7\tY6\tY5\tY4\tY3\tY2\tY1\tY0\nDEST\tY6+Y7\tY4+Y5\tX6+X7\tX4+X5\tY2+Y3\tY0+Y1\tX2+X3\tX0+X1\nFigure 3-19.  VHADDPS operation\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.\nVEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register."
  }
  instruction_groups {
    name: "MOVDIRI"
    short_description: "Move Doubleword as Direct Store"
    description: "Moves the doubleword integer in the source operand (second operand) to the destination operand (first operand) using a direct-store operation. The source operand is a general purpose register. The destination operand is a 32- bit memory location. In 64-bit mode, the instruction\342\200\231s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See sum mary chart at the beginning of this section for encoding data and limits.\nThe direct-store is implemented by using write combining (WC) memory type protocol for writing data. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. If the destination address is cached, the line is written-back (if modified) and invalidated from the cache, before the direct-store. Unlike stores with non-temporal hint that allow uncached (UC) and write-protected (WP) memory-type for the destination to override the non-temporal hint, direct-stores always follow WC memory type protocol irrespective of the destination address memory type (including UC and WP types).\nUnlike WC stores and stores with non-temporal hint, direct-stores are eligible for im mediate eviction from the write-combining buffer, and thus not combined with younger stores (including direct-stores) to the same address.\nOlder WC and non-temporal stores held in the write-combing buffer may be combined with younger direct stores to the same address. Direct stores are weakly ordered relative to other stores. Software that desires stronger ordering should use a fencing instruction (MFENCE or SFENCE) before or after a direct store to enforce the ordering desired.\nDirect-stores issued by MOVDIRI to a destination aligned to a 4-byte boundary (8-byte boundary if used with REX.W prefix) guarantee 4-byte (8-byte with REX.W prefix) write-completion atomicity. This means that the data arrives at the destination in a single undivided 4-byte (or 8-byte) write transaction. If the destination is not aligned for the write size, the direct-stores issued by MOVDIRI are split and arrive at the destination in two parts. Each part of such split direct-store will not merge with younger stores but can arrive at the destination in either order. Availability of the MOVDIRI instruction is indicated by the presence of the CPUID feature flag MOVDIRI (bit 27 of the ECX register in leaf 07H, see \342\200\234CPUID-CPU Identification\342\200\235 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 2A)."
  }
  instruction_groups {
    name: "VTESTPD/VTESTPS"
    short_description: "Packed Bit Test"
    description: "VTESTPS performs a bitwise comparison of all the sign bits of the packed single-precision elements in the first source operation and corresponding sign bits in the second source operand. If the AND of the source sign bits with the dest sign bits produces all zeros, the ZF is set else the ZF is clear. If the AND of the source sign bits with the inverted dest sign bits produces all zeros the CF is set else the CF is clear. An attempt to execute VTESTPS with VEX.W\n=1 will cause #UD.\nVTESTPD performs a bitwise comparison of all the sign bits of the double-precision elements in the first source operation and corresponding sign bits in the second source operand. If the AND of the source sign bits with the dest sign bits produces all zeros, the ZF is set else the ZF is clear. If the AND the source sign bits with the inverted dest sign bits produces all zeros the CF is set else the CF is clear. An attempt to execute VTESTPS with VEX.W =1 will\ncause #UD.\nThe first source register is specified by the ModR/M reg field.\n128-bit version: The first source register is an XMM register. The second source register can be an XMM register or a 128-bit memory location. The destination register is not modified.\nVEX.256 encoded version: The first source register is a YMM register. The second source register can be a YMM register or a 256-bit memory location. The destination register is not modified.\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
    flags_affected {
      content: "The 0F, AF, PF, SF flags are cleared and the ZF, CF flags are set according to the operation.\nSIMD Floating-Point Exceptions\nNone."
    }
  }
  instruction_groups {
    name: "VMWRITE"
    description: "Writes the contents of a primary source operand (register or memory) to a specified field in a VMCS. In VMX root operation, the instruction writes to the current VMCS. If executed in VMX non-root operation, the instruction writes to the VMCS referenced by the VMCS link pointer field in the current VMCS.\nThe VMCS field is specified by the VMCS-field encoding contained in the register secondary source operand.\nOutside IA-32e mode, the secondary source operand is always 32 bits, regardless of the value of CS.D. In 64-bit mode, the secondary source operand has 64 bits.\nThe effective size of the primary source operand, which may be a register or in memory, is always 32 bits outside IA-32e mode (the setting of CS.D is ignored with respect to operand size) and 64 bits in 64-bit mode. If the VMCS field specified by the secondary source operand is shorter than this effective operand size, the high bits of the primary source operand are ignored. If the VMCS field is longer, then the high bits of the field are cleared to 0.\nNote that any faults resulting from accessing a memory source operand occur after determining, in the operation section below, that the relevantVMCS pointer is valid but before determining if the destination VMCS field is supported."
    flags_affected {
      content: "See the operation section and Section 30.2."
    }
  }
  instruction_groups {
    name: "ENCLV"
  }
  instruction_groups {
    name: "AESIMC"
    short_description: "Perform the AES InvMixColumn Transformation"
    description: "Perform the InvMixColumns transformation on the source operand and store the result in the destination operand.\nThe destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory location.\nNote: the AESIMC instruction should be applied to the expanded AES round keys (except for the first and last round key) in order to prepare them for decryption using the \342\200\234Equivalent Inverse Cipher\342\200\235 (defined in FIPS 197).\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
  }
  instruction_groups {
    name: "VCVTPD2QQ"
    short_description: "Convert Packed Double-Precision Floating-Point Values to Packed Quadword Integers"
  }
  instruction_groups {
    name: "BNDMK"
    short_description: "Make Bounds"
    description: "Makes bounds from the second operand and stores the lower and upper bounds in the bound register bnd. The second operand must be a memory operand. The content of the base register from the memory operand is stored in the lower bound bnd.LB. The 1\'s complement of the effective address of m32/m64 is stored in the upper bound b.UB. Computation of m32/m64 has identical behavior to LEA.\nThis instruction does not cause any memory access, and does not read or write any flags.\nIf the instruction did not specify base register, the lower bound will be zero. The reg-reg form of this instruction retains legacy behavior (NOP).\nThe instruction causes an invalid-opcode exception (#UD) if executed in 64-bit mode with RIP-relative addressing."
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "SYSRET"
    short_description: "Return From Fast System Call"
    description: "SYSRET is a companion instruction to the SYSCALL instruction. It returns from an OS system-call handler to user code at privilege level 3. It does so by loading RIP from RCX and loading RFLAGS from R11.1 With a 64-bit operand size, SYSRET remains in 64-bit mode; otherwise, it enters compatibility mode and only the low 32 bits of the registers are loaded.\nSYSRET loads the CS and SS selectors with values derived from bits 63:48 of the IA32_STAR MSR. However, the CS and SS descriptor caches are not loaded from the descriptors (in GDT or LDT) referenced by those selectors.\nInstead, the descriptor caches are loaded with fixed values. See the Operation section for details. It is the responsibility of OS software to ensure that the descriptors (in GDT or LDT) referenced by those selector values correspond to the fixed values loaded into the descriptor caches; the SYSRET instruction does not ensure this correspondence.\nThe SYSRET instruction does not modify the stack pointer (ESP or RSP). For that reason, it is necessary for software to switch to the user stack. The OS may load the user stack pointer (if it was saved after SYSCALL) before executing SYSRET; alternatively, user code may load the stack pointer (if it was saved before SYSCALL) after receiving control from SYSRET.\nIf the OS loads the stack pointer before executing SYSRET, it must ensure that the handler of any interrupt or exception delivered between restoring the stack pointer and successful execution of SYSRET is not invoked with the user stack. It can do so using approaches such as the following:\n\342\200\242\tExternal interrupts. The OS can prevent an external interrupt from being delivered by clearing EFLAGS.IF before loading the user stack pointer.\n\342\200\242\tNonmaskable interrupts (NMIs). The OS can ensure that the NMI handler is invoked with the correct stack by using the interrupt stack table (IST) mechanism for gate 2 (NMI) in the IDT (see Section 6.14.5, \342\200\234Interrupt Stack Table,\342\200\235 in Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3A).\n\342\200\242\tGeneral-protection exceptions (#GP). The SYSRET instruction generates #GP(0) if the value of RCX is not canonical. The OS can address this possibility using one or more of the following approaches:\n-\tConfirming that the value of RCX is canonical before executing SYSRET.\n-\tUsing paging to ensure that the SYSCALL instruction will never save a non-canonical value into RCX.\n-\tUsing the IST mechanism for gate 13 (#GP) in the IDT.\nWhen shadow stacks are enabled at privilege level 3 the instruction loads SSP with value from IA32_PL3_SSP MSR.\nRefer to Chapter 6, \342\200\234Procedure Calls, Interrupts, and Exceptions\342\200\235 and Chapter 18, \342\200\234Control-Flow Enforcement Technology (CET)\342\200\235 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1 for additional CET details.\n1.\tRegardless of the value of R11, the RF and VM flags are always 0 in RFLAGS after execution of SYSRET. In addition, all reserved bits in RFLAGS retain the fixed values.\nInstruction ordering. Instructions following a SYSRET may be fetched from memory before earlier instructions complete execution, but they will not execute (even speculatively) until all instructions prior to the SYSRET have completed execution (the later instructions may execute before data stored by the earlier instructions have become globally visible)."
    flags_affected {
      content: "All."
    }
  }
  instruction_groups {
    name: "VPCOMPRESSD"
    short_description: "Store Sparse Packed Doubleword Integer Values into Dense Memory/Register"
  }
  instruction_groups {
    name: "DIVPD"
    short_description: "Divide Packed Double-Precision Floating-Point Values"
    description: "Performs a SIMD divide of the double-precision floating-point values in the first source operand by the floatingpoint values in the second source operand (the third operand). Results are written to the destination operand (the first operand).\nEVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\nVEX.256 encoded version: The first source operand (the second operand) is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding destination are zeroed.\nVEX.128 encoded version: The first source operand (the second operand) is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding destination are zeroed.\n128-bit Legacy SSE version: The second source operand (the second operand) can be an XMM register or an 128- bit memory location. The destination is the same as the first source operand. The upper bits (MAXVL-1:128) of the corresponding destination are unmodified."
  }
  instruction_groups {
    name: "PHMINPOSUW"
    short_description: "Packed Horizontal Word Minimum"
    description: "Determine the minimum unsigned word value in the source operand (second operand) and place the unsigned word in the low word (bits 0-15) of the destination operand (first operand). The word index of the minimum value is stored in bits 16-18 of the destination operand. The remaining upper bits of the destination are set to zero.\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding XMM destination register remain unchanged.\nVEX.128 encoded version: Bits (MAXVL-1:128) of the destination XMM register are zeroed. VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD."
    flags_affected {
      content: "None.\nSIMD Floating-Point Exceptions\nNone."
    }
  }
  instruction_groups {
    name: "ENDBR64"
    short_description: "Terminate an Indirect Branch in 64-bit Mode"
    description: "Terminate an indirect branch in 64 bit mode."
    flags_affected {
      content: "None.\nExceptions\nNone."
    }
  }
  instruction_groups {
    name: "BZHI"
    short_description: "Zero High Bits Starting with Specified Bit Position"
    description: "BZHI copies the bits of the first source operand (the second operand) into the destination operand (the first operand) and clears the higher bits in the destination according to the INDEX value specified by the second source operand (the third operand). The INDEX is specified by bits 7:0 of the second source operand. The INDEX value is saturated at the value of OperandSize -1. CF is set, if the number contained in the 8 low bits of the third operand is greater than OperandSize -1.\nThis instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD."
    flags_affected {
      content: "ZF, CF and SF flags are updated based on the result. OF flag is cleared. AF and PF flags are undefined."
    }
  }
  instruction_groups {
    name: "LTR"
    short_description: "Load Task Register"
    description: "Loads the source operand into the segment selector field of the task register. The source operand (a generalpurpose register or a memory location) contains a segment selector that points to a task state segment (TSS).\nAfter the segment selector is loaded in the task register, the processor uses the segment selector to locate the segment descriptor for the TSS in the global descriptor table (GDT). It then loads the segment limit and base address for the TSS from the segment descriptor into the task register. The task pointed to by the task register is marked busy, but a switch to the task does not occur.\nThe LTR instruction is provided for use in operating-system software; it should not be used in application programs.\nIt can only be executed in protected mode when the CPL is 0. It is com monly used in initialization code to establish\nthe first task to be executed.\nThe operand-size attribute has no effect on this instruction.\nIn 64-bit mode, the operand size is still fixed at 16 bits. The instruction references a 16-byte descriptor to load the 64-bit base."
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "VPSLLVW/VPSLLVD/VPSLLVQ"
    short_description: "Variable Bit Shift Left Logical"
  }
  instruction_groups {
    name: "LODS/LODSB/LODSW/LODSD/LODSQ"
    short_description: "Load String"
    description: "Loads a byte, word, or doubleword from the source operand into the AL, AX, or EAX register, respectively. The source operand is a memory location, the address of which is read from the DS:ESI or the DS:SI registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). The DS segment may be overridden with a segment override prefix.\nAt the assembly-code level, two forms of this instruction are allowed: the \342\200\234explicit-operands\342\200\235 form and the \342\200\234nooperands\342\200\235 form. The explicit-operands form (specified with the LODS mnemonic) allows the source operand to be specified explicitly. Here, the source operand should be a symbol that indicates the size and location of the source value. The destination operand is then automatically selected to match the size of the source operand (the AL register for byte operands, AX for word operands, and EAX for doubleword operands). This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the source operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword), but it does not have to specify the correct location. The location is always specified by the DS:(E)SI registers, which must be loaded correctly before the load string instruction is executed.\nThe no-operands form provides \342\200\234short forms\342\200\235 of the byte, word, and doubleword versions of the LODS instructions.\nHere also DS:(E)SI is assumed to be the source operand and the AL, AX, or EAX register is assumed to be the destination operand. The size of the source and destination operands is selected with the mnemonic: LODSB (byte loaded into register AL), LODSW (word loaded into AX), or LODSD (doubleword loaded into EAX).\nAfter the byte, word, or doubleword is transferred from the memory location into the AL, AX, or EAX register, the (E)SI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)SI register is incremented; if the DF flag is 1, the ESI register is decremented.) The (E)SI register is incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword operations.\nIn 64-bit mode, use of the REX.W prefix promotes operation to 64 bits. LODS/LODSQ load the quadword at address (R)SI into RAX. The (R)SI register is then incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register.\nThe LODS, LODSB, LODSW, and LODSD instructions can be preceded by the REP prefix for block loads of ECX bytes, words, or doublewords. More often, however, these instructions are\nused within a LOOP construct because further processing of the data moved into the register is usually necessary before the next transfer can be made. See \342\200\234REP/REPE/REPZ /REPNE/REPNZ-Repeat String Operation Prefix\342\200\235 in Chapter 4 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 2B, for a description of the REP prefix."
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "BNDLDX"
    short_description: "Load Extended Bounds Using Address Translation"
    description: "BNDLDX uses the linear address constructed from the base register and displacement of the SIB-addressing form of the memory operand (mib) to perform address translation to access a bound table entry and conditionally load the bounds in the BTE to the destination. The destination register is updated with the bounds in the BTE, if the content of the index register of mib matches the pointer value stored in the BTE.\nIf the pointer value comparison fails, the destination is updated with INIT bounds (lb = 0x0, ub = 0x0) (note: as articulated earlier, the upper bound is represented using 1\'s complement, therefore, the 0x0 value of upper bound allows for access to full memory).\nThis instruction does not cause memory access to the linear address of mib nor the effective address referenced by the base, and does not read or write any flags.\nSegment overrides apply to the linear address computation with the base of mib, and are used during address translation to generate the address of the bound table entry. By default, the address of the BTE is assumed to be linear address. There are no segmentation checks performed on the base of mib.\nThe base of mib will not be checked for canonical address violation as it does not access memory.\nAny encoding of this instruction that does not specify base or index register will treat those registers as zero (constant). The reg-reg form of this instruction will remain a NOP.\nThe scale field of the SIB byte has no effect on these instructions and is ignored.\nThe bound register may be partially updated on memory faults. The order in which memory operands are loaded is implementation specific."
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "BLSI"
    short_description: "Extract Lowest Set Isolated Bit"
    description: "Extracts the lowest set bit from the source operand and set the corresponding bit in the destination register. All other bits in the destination operand are zeroed. If no bits are set in the source operand, BLSI sets all the bits in the destination to 0 and sets ZF and CF.\nThis instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD."
    flags_affected {
      content: "ZF and SF are updated based on the result. CF is set if the source is not zero. OF flags are cleared. AF and PF flags are undefined."
    }
  }
  instruction_groups {
    name: "VPSRLVW/VPSRLVD/VPSRLVQ"
    short_description: "Variable Bit Shift Right Logical"
  }
  instruction_groups {
    name: "CVTPS2DQ"
    short_description: "Convert Packed Single-Precision Floating-Point Values to Packed Signed Doubleword Integer Values"
    description: "Converts four, eight or sixteen packed single-precision floating-point values in the source operand to four, eight or sixteen signed doubleword integers in the destination operand.\nWhen a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (2w-1, where w represents the number of bits in the destination format) is returned.\nEVEX encoded versions: The source operand is a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM register conditionally updated with writemask k1.\nVEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\nVEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\nVEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
  }
  instruction_groups {
    name: "CMPPS"
    short_description: "Compare Packed Single-Precision Floating-Point Values"
    description: "Performs a SIMD compare of the packed single-precision floating-point values in the second source operand and the first source operand and returns the result of the comparison to the destination operand. The comparison predicate operand (im\nmediate byte) specifies the type of comparison performed on each of the pairs of packed values.\nEVEX encoded versions: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand (first operand) is an opmask register.\nComparison results are written to the destination operand under the writemask k2. Each comparison result is a single mask bit of 1 (comparison true) or 0 (comparison false).\nVEX.256 encoded version: The first source operand (second operand) is a YMM register. The second source operand (third operand) can be a YMM register or a 256-bit memory location. The destination operand (first operand) is a YMM register. Eight comparisons are performed with results written to the destination operand. The result of each comparison is a doubleword mask of all 1s (comparison true) or all 0s (comparison false).\n128-bit Legacy SSE version: The first source and destination operand (first operand) is an XMM register. The second source operand (second operand) can be an XMM register or 128-bit memory location. Bits (MAXVL-1:128) of the corresponding ZMM destination register remain unchanged. Four comparisons are performed with results written to bits 127:0 of the destination operand. The result of each comparison is a doubleword mask of all 1s (comparison true) or all 0s (comparison false).\nVEX.128 encoded version: The first source operand (second operand) is an XMM register. The second source operand (third operand) can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destina-\ntion ZMM register are zeroed. Four comparisons are performed with results written to bits 127:0 of the destination operand.\nThe comparison predicate operand is an 8-bit im mediate:\n\342\200\242\tFor instructions encoded using the VEX prefix and EVEX prefix, bits 4:0 define the type of comparison to be performed (see Table 3-1). Bits 5 through 7 of the im mediate are reserved.\n\342\200\242\tFor instruction encodings that do not use VEX prefix, bits 2:0 define the type of comparison to be made (see the first 8 rows of Table 3-1). Bits 3 through 7 of the im\nmediate are reserved.\nThe unordered relationship is true when at least one of the two source operands being compared is a NaN; the ordered relationship is true when neither source operand is a NaN.\nA subsequent computational instruction that uses the mask result in the destination operand as an input operand will not generate an exception, because a mask of all 0s corresponds to a floating-point value of +0.0 and a mask of all 1s corresponds to a QNaN.\nNote that processors with \342\200\234CPUID.1H:ECX.AVX =0\342\200\235 do not implement the \342\200\234greater-than\342\200\235, \342\200\234greater-than-or-equal\342\200\235, \342\200\234not-greater than\342\200\235, and \342\200\234not-greater-than-or-equal relations\342\200\235 predicates. These comparisons can be made either by using the inverse relationship (that is, use the \342\200\234not-less-than-or-equal\342\200\235 to make a \342\200\234greater-than\342\200\235 comparison) or by using software emulation. When using software emulation, the program must swap the operands (copying registers when necessary to protect the data that will now be in the destination), and then perform the compare using a different predicate. The predicate to be used for these emulations is listed in the first 8 rows of Table 3-7 (Intel 64 and IA-32 Architectures Software Developer\342\200\231s Manual Volume 2A) under the heading Emulation.\nCompilers and assemblers may implement the following two-operand pseudo-ops in addition to the three-operand CMPPS instruction, for processors with \342\200\234CPUID.1H:ECX.AVX =0\342\200\235. See Table 3-4. Compiler should treat reserved Im m8 values as illegal syntax.\nTable 3-4. Pseudo-Op and CMPPS Implementation\nPseudo-Op\tCMPPS Implementation\nCMPEQPS xmm1, xmm2\tCMPPS xmm1, xmm2, 0\nCMPLTPS xmm1, xmm2\tCMPPS xmm1, xmm2, 1\nCMPLEPS xmm1, xmm2\tCMPPS xmm1, xmm2, 2\nCMPUNORDPS xmm1, xmm2\tCMPPS xmm1, xmm2, 3\nCMPNEQPS xmm1, xmm2\tCMPPS xmm1, xmm2, 4\nCMPNLTPS xmm1, xmm2\tCMPPS xmm1, xmm2, 5\nCMPNLEPS xmm1, xmm2\tCMPPS xmm1, xmm2, 6\nCMPORDPS xmm1, xmm2\tCMPPS xmm1, xmm2, 7\nThe greater-than relations that the processor does not implement require more than one instruction to emulate in software and therefore should not be implemented as pseudo-ops. (For these, the program\nmer should reverse the operands of the corresponding less than relations and use move instructions to ensure that the mask is moved to the correct destination register and that the source operand is left intact.)\nProcessors with \342\200\234CPUID.1H:ECX.AVX =1\342\200\235 implement the full complement of 32 predicates shown in Table 3-5, software emulation is no longer needed. Compilers and assemblers may implement the following three-operand pseudo-ops in addition to the four-operand VCMPPS instruction. See Table 3-5, where the notation of reg1 and reg2 represent either XMM registers or YMM registers. Compiler should treat reserved Im\nm8 values as illegal syntax. Alternately, intrinsics can map the pseudo-ops to pre-defined constants to support a simpler intrinsic interface. Compilers and assemblers may implement three-operand pseudo-ops for EVEX encoded VCMPPS instructions in a similar fashion by extending the syntax listed in Table 3-5.\nTable 3-5. Pseudo-Op and VCMPPS Implementation\nPseudo-Op\tCMPPS Implementation\nVCMPEQPS reg1, reg2, reg3\tVCMPPS reg1, reg2, reg3, 0\nVCMPLTPS reg1, reg2, reg3\tVCMPPS reg1, reg2, reg3, 1\nVCMPLEPS reg1, reg2, reg3\tVCMPPS reg1, reg2, reg3, 2\nVCMPUNORDPS reg1, reg2, reg3\tVCMPPS reg1, reg2, reg3, 3\nVCMPNEQPS reg1, reg2, reg3\tVCMPPS reg1, reg2, reg3, 4\nVCMPNLTPS reg1, reg2, reg3\tVCMPPS reg1, reg2, reg3, 5\nVCMPNLEPS reg1, reg2, reg3\tVCMPPS reg1, reg2, reg3, 6\nVCMPORDPS reg1, reg2, reg3\tVCMPPS reg1, reg2, reg3, 7\nVCMPEQ_UQPS reg1, reg2, reg3\tVCMPPS reg1, reg2, reg3, 8\nVCMPNGEPS reg1, reg2, reg3\tVCMPPS reg1, reg2, reg3, 9\nVCMPNGTPS reg1, reg2, reg3\tVCMPPS reg1, reg2, reg3, 0AH\nVCMPFALSEPS reg1, reg2, reg3\tVCMPPS reg1, reg2, reg3, 0BH\nVCMPNEQ_OQPS reg1, reg2, reg3\tVCMPPS reg1, reg2, reg3, 0CH\nVCMPGEPS reg1, reg2, reg3\tVCMPPS reg1, reg2, reg3, 0DH\nVCMPGTPS reg1, reg2, reg3\tVCMPPS reg1, reg2, reg3, 0EH\nVCMPTRUEPS reg1, reg2, reg3\tVCMPPS reg1, reg2, reg3, 0FH\nVCMPEQ_OSPS reg1, reg2, reg3\tVCMPPS reg1, reg2, reg3, 10H\nVCMPLT_OQPS reg1, reg2, reg3\tVCMPPS reg1, reg2, reg3, 11H\nVCMPLE_OQPS reg1, reg2, reg3\tVCMPPS reg1, reg2, reg3, 12H\nVCMPUNORD_SPS reg1, reg2, reg3\tVCMPPS reg1, reg2, reg3, 13H\nVCMPNEQ_USPS reg1, reg2, reg3\tVCMPPS reg1, reg2, reg3, 14H\nVCMPNLT_UQPS reg1, reg2, reg3\tVCMPPS reg1, reg2, reg3, 15H\nVCMPNLE_UQPS reg1, reg2, reg3\tVCMPPS reg1, reg2, reg3, 16H\nVCMPORD_SPS reg1, reg2, reg3\tVCMPPS reg1, reg2, reg3, 17H\nVCMPEQ_USPS reg1, reg2, reg3\tVCMPPS reg1, reg2, reg3, 18H\nVCMPNGE_UQPS reg1, reg2, reg3\tVCMPPS reg1, reg2, reg3, 19H\nVCMPNGT_UQPS reg1, reg2, reg3\tVCMPPS reg1, reg2, reg3, 1AH\nVCMPFALSE_OSPS reg1, reg2, reg3\tVCMPPS reg1, reg2, reg3, 1BH\nVCMPNEQ_OSPS reg1, reg2, reg3\tVCMPPS reg1, reg2, reg3, 1CH\nVCMPGE_OQPS reg1, reg2, reg3\tVCMPPS reg1, reg2, reg3, 1DH\nVCMPGT_OQPS reg1, reg2, reg3\tVCMPPS reg1, reg2, reg3, 1EH\nVCMPTRUE_USPS reg1, reg2, reg3\tVCMPPS reg1, reg2, reg3, 1FH"
  }
  instruction_groups {
    name: "SBB"
    short_description: "Integer Subtraction with Borrow"
    description: "Adds the source operand (second operand) and the carry (CF) flag, and subtracts the result from the destination operand (first operand). The result of the subtraction is stored in the destination operand. The destination operand can be a register or a memory location; the source operand can be an im\nmediate, a register, or a memory location.\n(However, two memory operands cannot be used in one instruction.) The state of the CF flag represents a borrow from a previous subtraction.\nWhen an im\tmediate value is used as an operand, it is sign-extended to the length of the destination operand\nformat.\nThe SBB instruction does not distinguish between signed or unsigned operands. Instead, the processor evaluates the result for both data types and sets the OF and CF flags to indicate a borrow in the signed or unsigned result, respectively. The SF flag indicates the sign of the signed result.\nThe SBB instruction is usually executed as part of a multibyte or multiword subtraction in which a SUB instruction is followed by a SBB instruction.\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.\nIn 64-bit mode, the instruction\342\200\231s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the sum mary chart at the beginning of this section for encoding data and limits."
    flags_affected {
      content: "The OF, SF, ZF, AF, PF, and CF flags are set according to the result."
    }
  }
  instruction_groups {
    name: "VPEXPANDB/VPEXPANDW"
    short_description: "Expand Byte/Word Values"
  }
  instruction_groups {
    name: "WRFSBASE/WRGSBASE"
    short_description: "Write FS/GS Segment Base"
    description: "Loads the FS or GS segment base address with the general-purpose register indicated by the modR/M:r/m field.\nThe source operand may be either a 32-bit or a 64-bit general-purpose register. The REX.W prefix indicates the operand size is 64 bits. If no REX.W prefix is used, the operand size is 32 bits; the upper 32 bits of the source register are ignored and upper 32 bits of the base address (for FS or GS) are cleared.\nThis instruction is supported only in 64-bit mode."
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "INVVPID"
    description: "Invalidates mappings in the translation lookaside buffers (TLBs) and paging-structure caches based on virtualprocessor identifier (VPID). (See Chapter 28, \342\200\234VMX Support for Address Translation\342\200\235.) Invalidation is based on the INVVPID type specified in the register operand and the INVVPID descriptor specified in the memory operand.\nOutside IA-32e mode, the register operand is always 32 bits, regardless of the value of CS.D; in 64-bit mode, the register operand has 64 bits (the instruction cannot be executed in compatibility mode).\nThe INVVPID types supported by a logical processors are reported in the IA32_VMX_EPT_VPID_CAP MSR (see Appendix A, \342\200\234VMX Capability Reporting Facility\342\200\235). There are four INVVPID types currently defined:\n\342\200\242\tIndividual-address invalidation: If the INVVPID type is 0, the logical processor invalidates mappings for the linear address and VPID specified in the INVVPID descriptor. In some cases, it may invalidate mappings for other linear addresses (or other VPIDs) as well.\n\342\200\242\tSingle-context invalidation: If the INVVPID type is 1, the logical processor invalidates all mappings tagged with the VPID specified in the INVVPID descriptor. In some cases, it may invalidate mappings for other VPIDs as well.\n\342\200\242\tAll-contexts invalidation: If the INVVPID type is 2, the logical processor invalidates all mappings tagged with all VPIDs except VPID 0000H. In some cases, it may invalidate translations with VPID 0000H as well.\n\342\200\242\tSingle-context invalidation, retaining global translations: If the INVVPID type is 3, the logical processor invalidates all mappings tagged with the VPID specified in the INVVPID descriptor except global translations. In some cases, it may invalidate global translations (and mappings with other VPIDs) as well. See the \342\200\234Caching Translation Information\342\200\235 section in Chapter 4 of the IA-32 Intel Architecture Software Developer\342\200\231s Manual, Volumes 3A for information about global translations.\nIf an unsupported INVVPID type is specified, the instruction fails.\nINVVPID invalidates all the specified mappings for the indicated VPID(s) regardless of the EPTP and PCID values with which those mappings may be associated.\nThe INVVPID descriptor comprises 128 bits and consists of a VPID and a linear address as shown in Figure 30-2.\n127\t6463\t1615\t0\nLinear Address\tReserved (must be zero)\tVPID\nFigure 30-2.  INVVPID Descriptor"
    flags_affected {
      content: "See the operation section and Section 30.2."
    }
  }
  instruction_groups {
    name: "SETcc"
    short_description: "Set Byte on Condition"
    description: "Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix (cc) indicates the condition being tested for.\nThe terms \342\200\234above\342\200\235 and \342\200\234below\342\200\235 are associated with the CF flag and refer to the relationship between two unsigned integer values. The terms \342\200\234greater\342\200\235 and \342\200\234less\342\200\235 are associated with the SF and OF flags and refer to the relationship between two signed integer values.\nMany of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, \342\200\234EFLAGS Condition Codes,\342\200\235 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1, shows the alternate mnemonics for various test conditions.\nSome languages represent a logical one as an integer with all bits set. This representation can be obtained by choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to test for overflow, use the SETNO instruction, then decrement the result.\nThe reg field of the ModR/M byte is not used for the SETCC instruction and those opcode bits are ignored by the processor.\nIn IA-64 mode, the operand size is fixed at 8 bits. Use of REX prefix enable uniform addressing to additional byte registers. Otherwise, this instruction\342\200\231s operation is the same as in legacy mode and compatibility mode."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "EADD"
  }
  instruction_groups {
    name: "MWAIT"
    short_description: "Monitor Wait"
    description: "M WAIT instruction provides hints to allow the processor to enter an implementation-dependent optimized state.\nThere are two principal targeted usages: address-range monitor and advanced power management. Both usages of M WAIT require the use of the MONITOR instruction.\nCPUID.01H:ECX.MONITOR[bit 3] indicates the availability of MONITOR and M WAIT in the processor. When set,\nM WAIT may be executed only at privilege level 0 (use at any other privilege level results in an invalid-opcode exception). The operating system or system BIOS may disable this instruction by using the IA32_MISC_ENABLE MSR; disabling M WAIT clears the CPUID feature flag and causes execution to generate an invalid-opcode excep-\ntion.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode.\nECX specifies optional extensions for the M WAIT instruction. EAX may contain hints such as the preferred optimized state the processor should enter. The first processors to implement M\nWAIT supported only the zero value for EAX and ECX. Later processors allowed setting ECX[0] to enable masked interrupts as break events for M\nWAIT (see below). Software can use the CPUID instruction to determine the extensions and hints supported by the processor.\nMWAIT for Address Range Monitoring\nFor address-range monitoring, the M WAIT instruction operates with the MONITOR instruction. The two instructions allow the definition of an address at which to wait (MONITOR) and a implementation-dependent-optimized operation to com mence at the wait address (M WAIT). The execution of M WAIT is a hint to the processor that it can enter an implementation-dependent-optimized state while waiting for an event or a store operation to the address range armed by MONITOR.\nThe following cause the processor to exit the implementation-dependent-optimized state: a store to the address range armed by the MONITOR instruction, an NMI or SMI, a debug exception, a machine check exception, the BINIT# signal, the INIT# signal, and the RESET# signal. Other implementation-dependent events may also cause the processor to exit the implementation-dependent-optimized state.\nIn addition, an external interrupt causes the processor to exit the implementation-dependent-optimized state either (1)if the interrupt would be delivered to software (e.g., as it would be if HLT had been executed instead of M\nWAIT); or (2)if ECX[0] = 1. Software can execute M WAIT with ECX[0] = 1 only if CPUID.05H:ECX[bit 1] = 1.\n(Implementation-specific conditions may result in an interrupt causing the processor to exit the implementationdependent-optimized state even if interrupts are masked and ECX[0] = 0.)\nFollowing exit from the implementation-dependent-optimized state, control passes to the instruction following the M\nWAIT instruction. A pending interrupt that is not masked (including an NMI or an SMI) may be delivered before execution of that instruction. Unlike the HLT instruction, the M WAIT instruction does not support a restart at the\nM WAIT instruction following the handling of an SMI.\nIf the preceding MONITOR instruction did not successfully arm an address range or if the MONITOR instruction has not been executed prior to executing M\nWAIT, then the processor will not enter the implementation-dependent-optimized state. Execution will resume at the instruction following the M WAIT.\nMWAIT for Power Management\nM WAIT accepts a hint and optional extension to the processor that it can enter a specified target C state while waiting for an event or a store operation to the address range armed by MONITOR. Support for M WAIT extensions\nfor power management is indicated by CPUID.05H:ECX[bit 0] reporting 1.\nEAX and ECX are used to com municate the additional information to the M WAIT instruction, such as the kind of optimized state the processor should enter. ECX specifies optional extensions for the M\nWAIT instruction. EAX may contain hints such as the preferred optimized state the processor should enter. Implementation-specific conditions may cause a processor to ignore the hint and enter a different optimized state. Future processor implementations may implement several optimized \342\200\234waiting\342\200\235 states and will select among those states based on the hint argument.\nTable\t4-10 describes the meaning of ECX and EAX registers for M WAIT extensions.\nTable 4-10.  MWAIT Extension Register (ECX)\nBits\tDescription\n0\tTreat interrupts as break events even if masked (e.g., even if EFLAGS.IF=0). May be set only if CPUID.05H:ECX[bit 1] = 1.\n31: 1\tReserved\nTable 4-11.  MWAIT Hints Register (EAX)\nBits\tDescription\n3 : 0\tSub C-state within a C-state, indicated by bits [7:4]\n7 : 4\tTarget C-state* Value of 0 means C1; 1 means C2 and so on Value of 01111B means C0\nNote: Target C states for MWAIT extensions are processor-specific C-states, not ACPI C-states\n31: 8\tReserved\nNote that if M WAIT is used to enter any of the C-states that are numerically higher than C1, a store to the address range armed by the MONITOR instruction will cause the processor to exit M\nWAIT only if the store was originated by other processor agents. A store from non-processor agent might not cause the processor to exit M WAIT in such\ncases.\nFor additional details of M WAIT extensions, see Chapter 14, \342\200\234Power and Thermal Management,\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3A."
  }
  instruction_groups {
    name: "WRUSSD/WRUSSQ"
    short_description: "Write to User Shadow Stack"
    description: "Writes bytes in register source to a user shadow stack page. The WRUSS instruction can be executed only if CPL = 0, however the processor treats its shadow-stack accesses as user accesses."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "PSRLDQ"
    short_description: "Shift Double Quadword Right Logical"
    description: "Shifts the destination operand (first operand) to the right by the number of bytes specified in the count operand (second operand). The empty high-order bytes are cleared (set to all 0s). If the value specified by the count operand is greater than 15, the destination operand is set to all 0s. The count operand is an 8-bit im mediate.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n128-bit Legacy SSE version: The source and destination operands are the same. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The source and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded version: The source operand is a YMM register. The destination operand is a YMM register. The count operand applies to both the low and high 128-bit lanes.\nVEX.256 encoded version: The source operand is YMM register. The destination operand is an YMM register. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed. The count operand applies to both the low and high 128-bit lanes.\nEVEX encoded versions: The source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location.\nThe destination operand is a ZMM/YMM/XMM register. The count operand applies to each 128-bit lanes.\nNote: VEX.vvvv/EVEX.vvvv encodes the destination register."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "VPGATHERDD/VPGATHERQD"
    short_description: "Gather Packed Dword Values Using Signed Dword/Qword Indices"
    description: "The instruction conditionally loads up to 4 or 8 dword values from memory addresses specified by the memory operand (the second operand) and using dword indices. The memory operand uses the VSIB form of the SIB byte to specify a general purpose register operand as the com mon base, a vector register for an array of indices relative\nto the base and a constant scale factor.\nThe mask operand (the third operand) specifies the conditional load operation from each memory address and the corresponding update of each data element of the destination operand (the first operand). Conditionality is specified by the most significant bit of each data element of the mask register. If an element\342\200\231s mask bit is not set, the corresponding element of the destination register is left unchanged. The width of data element in the destination register and mask register are identical. The entire mask register will be set to zero by this instruction unless the instruction causes an exception.\nUsing qword indices, the instruction conditionally loads up to 2 or 4 qword values from the VSIB addressing memory operand, and updates the lower half of the destination register. The upper 128 or 256 bits of the destination register are zero\342\200\231ed with qword indices.\nThis instruction can be suspended by an exception if at least one element is already gathered (i.e., if the exception is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination register and the mask operand are partially updated; those elements that have been gathered are placed into the destination register and have their mask bits set to zero. If any traps or interrupts are pending from already gathered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction breakpoint is not re-triggered when the instruction is continued.\nIf the data size and index size are different, part of the destination register and part of the mask register do not correspond to any elements being gathered. This instruction sets those parts to zero. It may do this to one or both of those registers even if the instruction triggers an exception, and even if the instruction triggers the exception before gathering any elements.\nVEX.128 version: For dword indices, the instruction will gather four dword values. For qword indices, the instruction will gather two values and zero the upper 64 bits of the destination.\nVEX.256 version: For dword indices, the instruction will gather eight dword values. For qword indices, the instruction will gather four values and zero the upper 128 bits of the destination.\nNote that:\n\342\200\242\tIf any pair of the index, mask, or destination registers are the same, this instruction results a UD fault.\n\342\200\242\tThe values may be read from memory in any order. Memory ordering with other instructions follows the Intel- 64 memory-ordering model.\n\342\200\242\tFaults are delivered in a right-to-left manner. That is, if a fault is triggered by an element and delivered, all elements closer to the LSB of the destination will be completed (and non-faulting). Individual elements closer to the MSB may or may not be completed. If a given element triggers multiple faults, they are delivered in the conventional order.\n\342\200\242\tElements may be gathered in any order, but faults must be delivered in a right-to-left order; thus, elements to the left of a faulting one may be gathered before the fault is delivered. A given implementation of this instruction is repeatable - given the same input values and architectural state, the same set of elements to the left of the faulting one will be gathered.\n\342\200\242\tThis instruction does not perform AC checks, and so will never deliver an AC fault.\n\342\200\242\tThis instruction will cause a #UD if the address size attribute is 16-bit.\n\342\200\242\tThis instruction will cause a #UD if the memory operand is encoded without the SIB byte.\n\342\200\242\tThis instruction should not be used to access memory mapped I/O as the ordering of the individual loads it does is implementation specific, and some implementations may use loads larger than the data element size or load elements an indeterminate number of times.\n\342\200\242\tThe scaled index may require more bits to represent than the address bits used by the processor (e.g., in 32- bit mode, if the scale is greater than one). In this case, the most significant bits beyond the number of address bits are ignored."
  }
  instruction_groups {
    name: "VFMSUB132PS/VFMSUB213PS/VFMSUB231PS"
    short_description: "Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "MOVD/MOVQ"
    short_description: "Move Doubleword/Move Quadword"
    description: "Copies a doubleword from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be general-purpose registers, MMX technology registers, XMM registers, or 32-bit memory locations. This instruction can be used to move a doubleword to and from the low doubleword of an MMX technology register and a general-purpose register or a 32-bit memory location, or to and from the low doubleword of an XMM register and a general-purpose register or a 32-bit memory location. The instruction cannot be used to transfer data between MMX technology registers, between XMM registers, between general-purpose registers, or between memory locations.\nWhen the destination operand is an MMX technology register, the source operand is written to the low doubleword of the register, and the register is zero-extended to 64 bits. When the destination operand is an XMM register, the source operand is written to the low doubleword of the register, and the register is zero-extended to 128 bits.\nIn 64-bit mode, the instruction\342\200\231s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the sum mary chart at the\nbeginning of this section for encoding data and limits.\nMOVD/Q with XMM destination: Moves a dword/qword integer from the source operand and stores it in the low 32/64-bits of the destination XMM register. The upper bits of the destination are zeroed. The source operand can be a 32/64-bit register or 32/64-bit memory location.\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged. Qword operation requires the use of REX.W\n=1.\nVEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed. Qword operation requires the use of VEX.W\n=1.\nEVEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed. Qword operation requires the use of EVEX.W =1.\nMOVD/Q with 32/64 reg/mem destination: Stores the low dword/qword of the source XMM register to 32/64-bit memory location or general-purpose register.\nQword operation requires the use of REX.W =1, VEX.W =1, or EVEX.W =1.\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.\nIf VMOVD or VMOVQ is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception."
    flags_affected {
      content: "None\nSIMD Floating-Point Exceptions\nNone"
    }
  }
  instruction_groups {
    name: "FLDENV"
    short_description: "Load x87 FPU Environment"
    description: "Loads the complete x87 FPU operating environment from memory into the FPU registers. The source operand specifies the first byte of the operating-environment data in memory. This data is typically written to the specified memory location by a FSTENV or FNSTENV instruction.\nThe FPU operating environment consists of the FPU control word, status word, tag word, instruction pointer, data pointer, and last opcode. Figures 8-9 through 8-12 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1, show the layout in memory of the loaded environment, depending on the operating mode of the processor (protected or real) and the current operand-size attribute (16-bit or 32-bit). In virtual-8086 mode, the real mode layouts are used.\nThe FLDENV instruction should be executed in the same operating mode as the corresponding FSTENV/FNSTENV instruction.\nIf one or more unmasked exception flags are set in the new FPU status word, a floating-point exception will be generated upon execution of the next floating-point instruction (except for the no-wait floating-point instructions, see the section titled \342\200\234Software Exception Handling\342\200\235 in Chapter 8 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1). To avoid generating exceptions when loading a new environment, clear all the exception flags in the FPU status word that is being loaded.\nIf a page or limit fault occurs during the execution of this instruction, the state of the x87 FPU registers as seen by the fault handler may be different than the state being loaded from memory. In such situations, the fault handler should ignore the status of the x87 FPU registers, handle the fault, and return. The FLDENV instruction will then complete the loading of the x87 FPU registers with no resulting context inconsistency.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "The C0, C1, C2, C3 flags are loaded."
    }
  }
  instruction_groups {
    name: "VFPCLASSSD"
    short_description: "Tests Types Of a Scalar Float64 Values"
  }
  instruction_groups {
    name: "PMINUB/PMINUW"
    short_description: "Minimum of Packed Unsigned Integers"
  }
  instruction_groups {
    name: "EINCVIRTCHILD"
  }
  instruction_groups {
    name: "CWD/CDQ/CQO"
    short_description: "Convert Word to Doubleword/Convert Doubleword to Quadword"
    description: "Doubles the size of the operand in register AX, EAX, or RAX (depending on the operand size) by means of sign extension and stores the result in registers DX:AX, EDX:EAX, or RDX:RAX, respectively. The CWD instruction copies the sign (bit 15) of the value in the AX register into every bit position in the DX register. The CDQ instruction copies the sign (bit 31) of the value in the EAX register into every bit position in the EDX register. The CQO instruction (available in 64-bit mode only) copies the sign (bit 63) of the value in the RAX register into every bit position in the RDX register.\nThe CWD instruction can be used to produce a doubleword dividend from a word before word division. The CDQ instruction can be used to produce a quadword dividend from a doubleword before doubleword division. The CQO instruction can be used to produce a double quadword dividend from a quadword before a quadword division.\nThe CWD and CDQ mnemonics reference the same opcode. The CWD instruction is intended for use when the operand-size attribute is 16 and the CDQ instruction for when the operand-size attribute is 32. Some assemblers may force the operand size to 16 when CWD is used and to 32 when CDQ is used. Others may treat these mnemonics as synonyms (CWD/CDQ) and use the current setting of the operand-size attribute to determine the size of values to be converted, regardless of the mnemonic used.\nIn 64-bit mode, use of the REX.W prefix promotes operation to 64 bits. The CQO mnemonics reference the same opcode as CWD/CDQ. See the sum mary chart at the beginning of this section for encoding data and limits."
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "UNPCKHPS"
    short_description: "Unpack and Interleave High Packed Single-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "FXRSTOR"
    short_description: "Restore x87 FPU, MMX, XMM, and MXCSR State"
    description: "Reloads the x87 FPU, MMX technology, XMM, and MXCSR registers from the 512-byte memory image specified in the source operand. This data should have been written to memory previously using the FXSAVE instruction, and in the same format as required by the operating modes. The first byte of the data should be located on a 16-byte boundary. There are three distinct layouts of the FXSAVE state map: one for legacy and compatibility mode, a second format for 64-bit mode FXSAVE/FXRSTOR with REX.W\n=0, and the third format is for 64-bit mode with FXSAVE64/FXRSTOR64. Table 3-43 shows the layout of the legacy/compatibility mode state information in memory and describes the fields in the memory image for the FXRSTOR and FXSAVE instructions. Table 3-46 shows the layout of the 64-bit mode state information when REX.W is set (FXSAVE64/FXRSTOR64). Table 3-47 shows the layout of the 64-bit mode state information when REX.W is clear (FXSAVE/FXRSTOR).\nThe state image referenced with an FXRSTOR instruction must have been saved using an FXSAVE instruction or be in the same format as required by Table 3-43, Table 3-46, or Table 3-47. Referencing a state image saved with an FSAVE, FNSAVE instruction or incompatible field layout will result in an incorrect state restoration.\nThe FXRSTOR instruction does not flush pending x87 FPU exceptions. To check and raise exceptions when loading x87 FPU state information with the FXRSTOR instruction, use an FWAIT instruction after the FXRSTOR instruction.\nIf the OSFXSR bit in control register CR4 is not set, the FXRSTOR instruction may not restore the states of the XMM and MXCSR registers. This behavior is implementation dependent.\nIf the MXCSR state contains an unmasked exception with a corresponding status flag also set, loading the register with the FXRSTOR instruction will not result in a SIMD floating-point error condition being generated. Only the next occurrence of this unmasked exception will result in the exception being generated.\nBits 16 through 32 of the MXCSR register are defined as reserved and should be set to 0. Attempting to write a 1 in any of these bits from the saved state image will result in a general protection exception (#GP) being generated.\nBytes 464:511 of an FXSAVE image are available for software use. FXRSTOR ignores the content of bytes 464:511 in an FXSAVE state image."
  }
  instruction_groups {
    name: "FABS"
    short_description: "Absolute Value"
    description: "Clears the sign bit of ST(0) to create the absolute value of the operand. The following table shows the results obtained when creating the absolute value of various classes of numbers.\nTable 3-17.  Results Obtained from FABS\nST(0) SRC\tST(0) DEST\n\342\210\222 \342\210\236\t+ \342\210\236\n\342\210\222 F\t+ F\n\342\210\222 0\t+ 0\n+ 0\t+ 0\n+ F\t+ F\n+ \342\210\236\t+ \342\210\236\nNaN\tNaN\nNOTES:\nF\tMeans finite floating-point value.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C1\tSet to 0.\nC0, C2, C3\tUndefined."
    }
  }
  instruction_groups {
    name: "VFIXUPIMMSD"
    short_description: "Fix Up Special Scalar Float64 Value"
  }
  instruction_groups {
    name: "VCVTUDQ2PS"
    short_description: "Convert Packed Unsigned Doubleword Integers to Packed Single-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "MINSS"
    short_description: "Return Minimum Scalar Single-Precision Floating-Point Value"
  }
  instruction_groups {
    name: "EDBGRD"
  }
  instruction_groups {
    name: "PADDSB/PADDSW"
    short_description: "Add Packed Signed Integers with Signed Saturation"
    description: "Performs a SIMD add of the packed signed integers from the source operand (second operand) and the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1, for an illustration of a SIMD operation.\nOverflow is handled with signed saturation, as described in the following paragraphs.\n(V)PADDSB performs a SIMD add of the packed signed integers with saturation from the first source operand and second source operand and stores the packed integer results in the destination operand. When an individual byte result is beyond the range of a signed byte integer (that is, greater than 7FH or less than 80H), the saturated value of 7FH or 80H, respectively, is written to the destination operand.\n(V)PADDSW performs a SIMD add of the packed signed word integers with saturation from the first source operand and second source operand and stores the packed integer results in the destination operand. When an individual word result is beyond the range of a signed word integer (that is, greater than 7FFFH or less than 8000H), the saturated value of 7FFFH or 8000H, respectively, is written to the destination operand.\nEVEX encoded versions: The first source operand is an ZMM/YMM/XMM register. The second source operand is an ZMM/YMM/XMM register or a memory location. The destination operand is an ZMM/YMM/XMM register.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.\nVEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding register destination are zeroed.\n128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified."
    flags_affected {
      content: "None.\nSIMD Floating-Point Exceptions\nNone."
    }
  }
  instruction_groups {
    name: "CVTPI2PS"
    short_description: "Convert Packed Dword Integers to Packed Single-Precision FP Values"
    description: "Converts two packed signed doubleword integers in the source operand (second operand) to two packed singleprecision floating-point values in the destination operand (first operand).\nThe source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an XMM register. The results are stored in the low quadword of the destination operand, and the high quadword remains unchanged. When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.\nThis instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the CVTPI2PS instruction is executed.\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15)."
  }
  instruction_groups {
    name: "COMISS"
    short_description: "Compare Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS"
    description: "Compares the single-precision floating-point values in the low quadwords of operand 1 (first operand) and operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result (unordered, greater than, less than, or equal). The OF, SF and AF flags in the EFLAGS register are set to 0. The unordered result is returned if either source operand is a NaN (QNaN or SNaN).\nOperand 1 is an XMM register; operand 2 can be an XMM register or a 32 bit memory location.\nThe COMISS instruction differs from the UCOMISS instruction in that it signals a SIMD floating-point invalid operation exception (#I) when a source operand is either a QNaN or SNaN. The UCOMISS instruction signals an invalid operation exception only if a source operand is an SNaN.\nThe EFLAGS register is not updated if an unmasked SIMD floating-point exception is generated.\nVEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.\nSoftware should ensure VCOMISS is encoded with VEX.L=0. Encoding VCOMISS with VEX.L=1 may encounter unpredictable behavior across different processor generations."
  }
  instruction_groups {
    name: "MOVMSKPS"
    short_description: "Extract Packed Single-Precision Floating-Point Sign Mask"
    description: "Extracts the sign bits from the packed single-precision floating-point values in the source operand (second operand), formats them into a 4- or 8-bit mask, and stores the mask in the destination operand (first operand).\nThe source operand is an XMM or YMM register, and the destination operand is a general-purpose register. The mask is stored in the 4 or 8 low-order bits of the destination operand. The upper bits of the destination operand beyond the mask are filled with zeros.\nIn 64-bit mode, the instruction can access additional registers (XMM8-XMM15, R8-R15) when used with a REX.R prefix. The default operand size is 64-bit in 64-bit mode.\n128-bit versions: The source operand is a YMM register. The destination operand is a general purpose register.\nVEX.256 encoded version: The source operand is a YMM register. The destination operand is a general purpose register.\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
  }
  instruction_groups {
    name: "WRMSR"
    short_description: "Write to Model Specific Register"
    description: "Writes the contents of registers EDX:EAX into the 64-bit model specific register (MSR) specified in the ECX register.\n(On processors that support the Intel64 architecture, the high-order 32 bits of RCX are ignored.) The contents of the EDX register are copied to high-order 32 bits of the selected MSR and the contents of the EAX register are copied to low-order 32 bits of the MSR. (On processors that support the Intel64 architecture, the high-order 32 bits of each of RAX and RDX are ignored.) Undefined or reserved bits in an MSR should be set to values previously read.\nThis instruction must be executed at privilege level 0 or in real-address mode; otherwise, a general protection exception #GP(0) is generated. Specifying a reserved or unimplemented MSR address in ECX will also cause a general protection exception. The processor will also generate a general protection exception if software attempts to write to bits in a reserved MSR.\nWhen the WRMSR instruction is used to write to an MTRR, the TLBs are invalidated. This includes global entries (see \342\200\234Translation Lookaside Buffers (TLBs)\342\200\235 in Chapter 3 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3A).\nMSRs control functions for testability, execution tracing, performance-monitoring and machine check errors.\nChapter 2, \342\200\234Model-Specific Registers (MSRs)\342\200\235 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 4, lists all MSRs that can be written with this instruction and their addresses. Note that each processor family has its own set of MSRs.\nThe WRMSR instruction is a serializing instruction (see \342\200\234Serializing Instructions\342\200\235 in Chapter 8 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3A). Note that WRMSR to the IA32_TSC_DEADLINE MSR (MSR index 6E0H) and the X2APIC MSRs (MSR indices 802H to 83FH) are not serializing.\nThe CPUID instruction should be used to determine whether MSRs are supported (CPUID.01H:EDX[5] = 1) before using this instruction."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "XSAVEOPT"
    short_description: "Save Processor Extended States Optimized"
    description: "Performs a full or partial save of processor state components to the XSAVE area located at the memory address specified by the destination operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components saved correspond to the bits set in the requested-feature bitmap (RFBM), which is the logical-AND of EDX:EAX and XCR0.\nThe format of the XSAVE area is detailed in Section 13.4, \342\200\234XSAVE Area,\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1. Like FXRSTOR and FXSAVE, the memory format used for x87 state depends on a REX.W prefix; see Section 13.5.1, \342\200\234x87 State\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1.\nSection 13.9, \342\200\234Operation of XSAVEOPT,\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1 provides a detailed description of the operation of the XSAVEOPT instruction. The following items provide a high-level outline:\n\342\200\242\tExecution of XSAVEOPT is similar to that of XSAVE. XSAVEOPT differs from XSAVE in that it may use the init and modified optimizations. The performance of XSAVEOPT will be equal to or better than that of XSAVE.\n\342\200\242\t= 1.1 (XINUSE is a bitmap by which the processor tracks the status of various state components. See Section 13.6, \342\200\234Processor Tracking of XSAVEManaged State\342\200\235of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1.) Even if both bits are 1, XSAVEOPT may optimize and not save state component i if (1)state component i has not been modified since the last execution of XRSTOR or XRSTORS; and (2)this execution of XSAVES corresponds to that last execution of XRSTOR or XRSTORS as determined by the internal value XRSTOR_INFO (see the Operation section below).\nXSAVEOPT saves state component i only if RFBM[i] = 1 and XINUSE[i]\n\342\200\242\tXSAVEOPT does not modify bytes 511:464 of the legacy region of the XSAVE area (see Section 13.4.1, \342\200\234Legacy Region of an XSAVE Area\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1).\n\342\200\242\tXSAVEOPT reads the XSTATE_BV field of the XSAVE header (see Section 13.4.2, \342\200\234XSAVE Header\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1) and writes a modified value back to memory as follows. If RFBM[i] = 1, XSAVEOPT writes XSTATE_BV[i] with the value of XINUSE[i]. If RFBM[i] = 0, XSAVEOPT writes XSTATE_BV[i] with the value that it read from memory (it does not modify the bit).\nXSAVEOPT does not write to any part of the XSAVE header other than the XSTATE_BV field.\n\342\200\242\tXSAVEOPT always uses the standard format of the extended region of the XSAVE area (see Section 13.4.3, \342\200\234Extended Region of an XSAVE Area\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1).\nUse of a destination operand not aligned to 64-byte boundary (in either 64-bit or 32-bit modes) will result in a general-protection (#GP) exception. In 64-bit mode, the upper 32 bits of RDX and RAX are ignored.\n1.\tThere is an exception made for MXCSR and MXCSR_MASK, which belong to state component 1 - SSE. XSAVEOPT always saves these to memory if RFBM[1]= 1 or RFBM[2]= 1, regardless of the value of XINUSE.\nSee Section 13.6, \342\200\234Processor Tracking of XSAVE-Managed State,\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1 for discussion of the bitmap XMODIFIED and of the quantity XRSTOR_INFO."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "PUSHA/PUSHAD"
    short_description: "Push All General-Purpose Registers"
    description: "Pushes the contents of the general-purpose registers onto the stack. The registers are stored on the stack in the following order: EAX, ECX, EDX, EBX, ESP (original value), EBP, ESI, and EDI (if the current operand-size attribute is 32) and AX, CX, DX, BX, SP (original value), BP, SI, and DI (if the operand-size attribute is 16). These instructions perform the reverse operation of the POPA/POPAD instructions. The value pushed for the ESP or SP register is its value before prior to pushing the first register (see the \342\200\234Operation\342\200\235 section below).\nThe PUSHA (push all) and PUSHAD (push all double) mnemonics reference the same opcode. The PUSHA instruction is intended for use when the operand-size attribute is 16 and the PUSHAD instruction for when the operandsize attribute is 32. Some assemblers may force the operand size to 16 when PUSHA is used and to 32 when PUSHAD is used. Others may treat these mnemonics as synonyms (PUSHA/PUSHAD) and use the current setting of the operand-size attribute to determine the size of values to be pushed from the stack, regardless of the mnemonic used.\nIn the real-address mode, if the ESP or SP register is 1, 3, or 5 when PUSHA/PUSHAD executes: an #SS exception is generated but not delivered (the stack error reported prevents #SS delivery). Next, the processor generates a #DF exception and enters a shutdown state as described in the #DF discussion in Chapter 6 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3A.\nThis instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "VEXTRACTI128/VEXTRACTI32x4/VEXTRACTI64x2/VEXTRACTI32x8/VEXTRACTI64x4"
    short_description: "Extract packed Integer Values"
  }
  instruction_groups {
    name: "AAS"
    short_description: "ASCII Adjust AL After Subtraction"
    description: "Adjusts the result of the subtraction of two unpacked BCD values to create a unpacked BCD result. The AL register is the implied source and destination operand for this instruction. The AAS instruction is only useful when it follows a SUB instruction that subtracts (binary subtraction) one unpacked BCD value from another and stores a byte result in the AL register. The AAA instruction then adjusts the contents of the AL register to contain the correct 1- digit unpacked BCD result.\nIf the subtraction produced a decimal carry, the AH register decrements by 1, and the CF and AF flags are set. If no decimal carry occurred, the CF and AF flags are cleared, and the AH register is unchanged. In either case, the AL register is left with its top four bits set to 0.\nThis instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode."
    flags_affected {
      content: "The AF and CF flags are set to 1 if there is a decimal borrow; otherwise, they are cleared to 0. The OF, SF, ZF, and PF flags are undefined."
    }
  }
  instruction_groups {
    name: "DAS"
    short_description: "Decimal Adjust AL after Subtraction"
    description: "Adjusts the result of the subtraction of two packed BCD values to create a packed BCD result. The AL register is the implied source and destination operand. The DAS instruction is only useful when it follows a SUB instruction that subtracts (binary subtraction) one 2-digit, packed BCD value from another and stores a byte result in the AL register. The DAS instruction then adjusts the contents of the AL register to contain the correct 2-digit, packed BCD result. If a decimal borrow is detected, the CF and AF flags are set accordingly.\nThis instruction executes as described above in compatibility mode and legacy mode. It is not valid in 64-bit mode."
    flags_affected {
      content: "The CF and AF flags are set if the adjustment of the value results in a decimal borrow in either digit of the result (see the \342\200\234Operation\342\200\235 section above). The SF, ZF, and PF flags are set according to the result. The OF flag is undefined."
    }
  }
  instruction_groups {
    name: "FSIN"
    short_description: "Sine"
    description: "Computes an approximation of the sine of the source operand in register ST(0) and stores the result in ST(0). The source operand must be given in radians and must be within the range \342\210\222263 to +263. The following table shows the results obtained when taking the sine of various classes of numbers, assuming that underflow does not occur.\nTable 3-35.  FSIN Results\nSRC (ST(0))\tDEST (ST(0))\n\342\210\222 \342\210\236\t*\n\342\210\222 F\t\342\210\222 1 to + 1\n\342\210\222 0\t\342\210\2220\n+ 0\t+ 0\n+ F\t\342\210\222 1 to +1\n+ \342\210\236\t*\nNaN\tNaN\nNOTES:\nF\tMeans finite floating-point value.\n*\tIndicates floating-point invalid-arithmetic-operand (#IA) exception.\nIf the source operand is outside the acceptable range, the C2 flag in the FPU status word is set, and the value in register ST(0) remains unchanged. The instruction does not raise an exception when the source operand is out of range. It is up to the program to check the C2 flag for out-of-range conditions. Source values outside the range \342\210\222 263 to +263 can be reduced to the range of the instruction by subtracting an appropriate integer multiple of 2\317\200.\nHowever, even within the range -263 to +263, inaccurate results can occur because the finite approximation of \317\200 used internally for argument reduction is not sufficient in all cases. Therefore, for accurate results it is safe to apply FSIN only to arguments reduced accurately in software, to a value smaller in absolute value than 3\317\200/4. See the sections titled \342\200\234Approximation of Pi\342\200\235 and \342\200\234Transcendental Instruction Accuracy\342\200\235 in Chapter 8 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1, for a discussion of the proper value to use for \317\200 in performing such reductions.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C1\tSet to 0 if stack underflow occurred.\nSet if result was rounded up; cleared otherwise.\nC2\tSet to 1 if outside range (\342\210\222263 < source operand < +263); otherwise, set to 0.\nC0, C3\tUndefined."
    }
  }
  instruction_groups {
    name: "VPEXPANDD"
    short_description: "Load Sparse Packed Doubleword Integer Values from Dense Memory / Register"
  }
  instruction_groups {
    name: "PREFETCHWT1"
    short_description: "Prefetch Vector Data Into Caches with Intent to Write and T1 Hint"
    description: "Fetches the line of data from memory that contains the byte specified with the source operand to a location in the cache hierarchy specified by an intent to write hint (so that data is brought into \342\200\230Exclusive\342\200\231 state via a request for ownership) and a locality hint: \342\200\242 T1 (temporal data with respect to first level cache)-prefetch data into the second level cache.\nThe source operand is a byte memory location. (The locality hints are encoded into the machine level instruction using bits 3 through 5 of the ModR/M byte. Use of any ModR/M value other than the specified ones will lead to unpredictable behavior.) If the line selected is already present in the cache hierarchy at a level closer to the processor, no data movement occurs. Prefetches from uncacheable or WC memory are ignored.\nThe PREFETCHh instruction is merely a hint and does not affect program behavior. If executed, this instruction moves data closer to the processor in anticipation of future use.\nThe implementation of prefetch locality hints is implementation-dependent, and can be overloaded or ignored by a processor implementation. The amount of data prefetched is also processor implementation-dependent. It will, however, be a minimum of 32 bytes.\nIt should be noted that processors are free to speculatively fetch and cache data from system memory regions that are assigned a memory-type that permits speculative reads (that is, the WB, WC, and WT memory types). A PREFETCHh instruction is considered a hint to this speculative behavior. Because this speculative fetching can occur at any time and is not tied to instruction execution, a PREFETCHh instruction is not ordered with respect to the fence instructions (MFENCE, SFENCE, and LFENCE) or locked memory references. A PREFETCHh instruction is also unordered with respect to CLFLUSH and CLFLUSHOPT instructions, other PREFETCHh instructions, or any other general instruction. It is ordered with respect to serializing instructions such as CPUID, WRMSR, OUT, and MOV CR.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "All flags are affected"
    }
  }
  instruction_groups {
    name: "MULPD"
    short_description: "Multiply Packed Double-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "PHADDW/PHADDD"
    short_description: "Packed Horizontal Add"
    description: "(V)PHADDW adds two adjacent 16-bit signed integers horizontally from the source and destination operands and packs the 16-bit signed results to the destination operand (first operand). (V)PHADDD adds two adjacent 32-bit signed integers horizontally from the source and destination operands and packs the 32-bit signed results to the destination operand (first operand). When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.\nNote that these instructions can operate on either unsigned or signed (two\342\200\231s complement notation) integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of the values operated on.\nLegacy SSE instructions: Both operands can be MMX registers. The second source operand can be an MMX register or a 64-bit memory location.\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nIn 64-bit mode, use the REX prefix to access additional registers.\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.\nVEX.256 encoded version: Horizontal addition of two adjacent data elements of the low 16-bytes of the first and second source operands are packed into the low 16-bytes of the destination operand. Horizontal addition of two adjacent data elements of the high 16-bytes of the first and second source operands are packed into the high 16- bytes of the destination operand. The first source and destination operands are YMM registers. The second source operand can be an YMM register or a 256-bit memory location.\nSRC2\tY7\tY6\tY5\tY4\tY3\tY2\tY1\tY0\tX7\tX6\tX5\tX4\tX3\tX2\tX1\tX0\tSRC1\nS7\tS3\tS3\tS4\tS3\tS2\tS1\tS0\n255\t0\nDest\nFigure 4-10.  256-bit VPHADDD Instruction Operation"
  }
  instruction_groups {
    name: "VPERMT2W/D/Q/PS/PD"
    short_description: "Full Permute from Two Tables Overwriting one Table"
  }
  instruction_groups {
    name: "FSUB/FSUBP/FISUB"
    short_description: "Subtract"
    description: "Subtracts the source operand from the destination operand and stores the difference in the destination location.\nThe destination operand is always an FPU data register; the source operand can be a register or a memory location.\nSource operands in memory can be in single-precision or double-precision floating-point format or in word or doubleword integer format.\nThe no-operand version of the instruction subtracts the contents of the ST(0) register from the ST(1) register and stores the result in ST(1). The one-operand version subtracts the contents of a memory location (either a floatingpoint or an integer value) from the contents of the ST(0) register and stores the result in ST(0). The two-operand version, subtracts the contents of the ST(0) register from the ST(i) register or vice versa.\nThe FSUBP instructions perform the additional operation of popping the FPU register stack following the subtraction. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point subtract instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FSUB rather than FSUBP.\nThe FISUB instructions convert an integer source operand to double extended-precision floating-point format before performing the subtraction.\nTable 3-38 shows the results obtained when subtracting various classes of numbers from one another, assuming that neither overflow nor underflow occurs. Here, the SRC value is subtracted from the DEST value (DEST \342\210\222 SRC = result).\nWhen the difference between two operands of like sign is 0, the result is +0, except for the round toward \342\210\222\342\210\236 mode, in which case the result is \342\210\2220. This instruction also guarantees that +0 \342\210\222 (\342\210\2220) = +0, and that \342\210\2220 \342\210\222 (+0) = \342\210\2220. When the source operand is an integer 0, it is treated as a +0.\nWhen one operand is \342\210\236, the result is \342\210\236 of the expected sign. If both operands are \342\210\236 of the same sign, an invalidoperation exception is generated.\nTable 3-38.  FSUB/FSUBP/FISUB Results\nSRC\n\342\210\222 \342\210\236\t\342\210\222 F or \342\210\222 I\t\342\210\222 0\t+ 0\t+ F or + I\t+ \342\210\236\tNaN\n\342\210\222 \342\210\236\t*\t\342\210\222 \342\210\236\t\342\210\222 \342\210\236\t\342\210\222 \342\210\236\t\342\210\222 \342\210\236\t\342\210\222 \342\210\236\tNaN\n\342\210\222 F\t+ \342\210\236\t\302\261F or \302\2610\tDEST\tDEST\t\342\210\222 F\t\342\210\222 \342\210\236\tNaN\nDEST\t\342\210\222 0\t+ \342\210\236\t\342\210\222SRC\t\302\2610\t\342\210\222 0\t\342\210\222 SRC\t\342\210\222 \342\210\236\tNaN\n+ 0\t+ \342\210\236\t\342\210\222SRC\t+ 0\t\302\2610\t\342\210\222 SRC\t\342\210\222 \342\210\236\tNaN\n+ F\t+ \342\210\236\t+ F\tDEST\tDEST\t\302\261F or \302\2610\t\342\210\222 \342\210\236\tNaN\n+ \342\210\236\t+ \342\210\236\t+ \342\210\236\t+ \342\210\236\t+ \342\210\236\t+ \342\210\236\t*\tNaN\nNaN\tNaN\tNaN\tNaN\tNaN\tNaN\tNaN\tNaN\nNOTES:\nF\tMeans finite floating-point value.\nI\tMeans integer.\n*\tIndicates floating-point invalid-arithmetic-operand (#IA) exception.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C1\tSet to 0 if stack underflow occurred.\nSet if result was rounded up; cleared otherwise.\nC0, C2, C3\tUndefined."
    }
  }
  instruction_groups {
    name: "BLSR"
    short_description: "Reset Lowest Set Bit"
    description: "Copies all bits from the source operand to the destination operand and resets (=0) the bit position in the destination operand that corresponds to the lowest set bit of the source operand. If the source operand is zero BLSR sets CF.\nThis instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD."
    flags_affected {
      content: "ZF and SF flags are updated based on the result. CF is set if the source is zero. OF flag is cleared. AF and PF flags are undefined."
    }
  }
  instruction_groups {
    name: "PABSB/PABSW/PABSD/PABSQ"
    short_description: "Packed Absolute Value"
    description: "PABSB/W/D computes the absolute value of each data element of the source operand (the second operand) and stores the UNSIGNED results in the destination operand (the first operand). PABSB operates on signed bytes, PABSW operates on signed 16-bit words, and PABSD operates on signed 32-bit integers.\nEVEX encoded VPABSD/Q: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.\nEVEX encoded VPABSB/W: The source operand is a ZMM/YMM/XMM register, or a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.\nVEX.256 encoded versions: The source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding register destination are zeroed.\nVEX.128 encoded versions: The source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding register destination are zeroed.\n128-bit Legacy SSE version: The source operand can be an XMM register or an 128-bit memory location. The destination is an XMM register. The upper bits (VL_MAX-1:128) of the corresponding register destination are unmodified.\nVEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.\nOperation\nPABSB with 128 bit operands: Unsigned DEST[7:0] := ABS(SRC[7: 0]) Repeat operation for 2nd through 15th bytes Unsigned DEST[127:120] := ABS(SRC[127:120])\nVPABSB with 128 bit operands: Unsigned DEST[7:0] := ABS(SRC[7: 0]) Repeat operation for 2nd through 15th bytes Unsigned DEST[127:120] := ABS(SRC[127:120])\nVPABSB with 256 bit operands: Unsigned DEST[7:0] := ABS(SRC[7: 0]) Repeat operation for 2nd through 31st bytes Unsigned DEST[255:248] := ABS(SRC[255:248])\nVPABSB (EVEX encoded versions) (KL, VL) = (16, 128), (32, 256), (64, 512)\nFOR j := 0 TO KL-1 i := j * 8 IF k1[j] OR *no writemask* THEN Unsigned DEST[i+7:i] := ABS(SRC[i+7:i]) ELSE IF *merging-masking*\n; merging-masking THEN *DEST[i+7:i] remains unchanged* ELSE *zeroing-masking* ; zeroing-masking\nDEST[i+7:i] := 0\nFI\nFI; ENDFOR; DEST[MAXVL-1:VL] := 0\nPABSW with 128 bit operands: Unsigned DEST[15:0] := ABS(SRC[15:0]) Repeat operation for 2nd through 7th 16-bit words Unsigned DEST[127:112] := ABS(SRC[127:112])\nVPABSW with 128 bit operands: Unsigned DEST[15:0] := ABS(SRC[15:0]) Repeat operation for 2nd through 7th 16-bit words Unsigned DEST[127:112] := ABS(SRC[127:112])\nVPABSW with 256 bit operands: Unsigned DEST[15:0] := ABS(SRC[15:0]) Repeat operation for 2nd through 15th 16-bit words Unsigned DEST[255:240] := ABS(SRC[255:240])\nVPABSW (EVEX encoded versions) (KL, VL) = (8, 128), (16, 256), (32, 512)\nFOR j := 0 TO KL-1 i := j * 16 IF k1[j] OR *no writemask* THEN Unsigned DEST[i+15:i] := ABS(SRC[i+15:i]) ELSE IF *merging-masking*\n; merging-masking THEN *DEST[i+15:i] remains unchanged* ELSE *zeroing-masking* ; zeroing-masking\nDEST[i+15:i] := 0\nFI\nFI; ENDFOR; DEST[MAXVL-1:VL] := 0\nPABSD with 128 bit operands: Unsigned DEST[31:0] := ABS(SRC[31:0]) Repeat operation for 2nd through 3rd 32-bit double words Unsigned DEST[127:96] := ABS(SRC[127:96])\nVPABSD with 128 bit operands: Unsigned DEST[31:0] := ABS(SRC[31:0]) Repeat operation for 2nd through 3rd 32-bit double words Unsigned DEST[127:96] := ABS(SRC[127:96])\nVPABSD with 256 bit operands: Unsigned DEST[31:0] := ABS(SRC[31:0]) Repeat operation for 2nd through 7th 32-bit double words Unsigned DEST[255:224] := ABS(SRC[255:224])\nVPABSD (EVEX encoded versions) (KL, VL) = (4, 128), (8, 256), (16, 512) FOR j := 0 TO KL-1 i := j * 32 IF k1[j] OR *no writemask* THEN IF (EVEX.b = 1) AND (SRC *is memory*) THEN Unsigned DEST[i+31:i] := ABS(SRC[31:0]) ELSE Unsigned DEST[i+31:i] := ABS(SRC[i+31:i])\nFI; ELSE IF *merging-masking*\n; merging-masking THEN *DEST[i+31:i] remains unchanged* ELSE *zeroing-masking* ; zeroing-masking\nDEST[i+31:i] := 0\nFI\nFI; ENDFOR; DEST[MAXVL-1:VL] := 0\nVPABSQ (EVEX encoded versions) (KL, VL) = (2, 128), (4, 256), (8, 512) FOR j := 0 TO KL-1 i := j * 64 IF k1[j] OR *no writemask* THEN IF (EVEX.b = 1) AND (SRC *is memory*) THEN Unsigned DEST[i+63:i] := ABS(SRC[63:0]) ELSE Unsigned DEST[i+63:i] := ABS(SRC[i+63:i])\nFI; ELSE IF *merging-masking*\n; merging-masking THEN *DEST[i+63:i] remains unchanged* ELSE *zeroing-masking* ; zeroing-masking\nDEST[i+63:i] := 0\nFI\nFI; ENDFOR; DEST[MAXVL-1:VL] := 0\nIntel C/C++ Compiler Intrinsic Equivalents\nVPABSB__m512i _mm512_abs_epi8 ( __m512i a) VPABSW__m512i _mm512_abs_epi16 ( __m512i a) VPABSB__m512i _mm512_mask_abs_epi8 ( __m512i s, __mmask64 m, __m512i a) VPABSW__m512i _mm512_mask_abs_epi16 ( __m512i s, __mmask32 m, __m512i a) VPABSB__m512i _mm512_maskz_abs_epi8 (__mmask64 m, __m512i a) VPABSW__m512i _mm512_maskz_abs_epi16 (__mmask32 m, __m512i a) VPABSB__m256i _mm256_mask_abs_epi8 (__m256i s, __mmask32 m, __m256i a) VPABSW__m256i _mm256_mask_abs_epi16 (__m256i s, __mmask16 m, __m256i a) VPABSB__m256i _mm256_maskz_abs_epi8 (__mmask32 m, __m256i a) VPABSW__m256i _mm256_maskz_abs_epi16 (__mmask16 m, __m256i a) VPABSB__m128i _mm_mask_abs_epi8 (__m128i s, __mmask16 m, __m128i a) VPABSW__m128i _mm_mask_abs_epi16 (__m128i s, __mmask8 m, __m128i a) VPABSB__m128i _mm_maskz_abs_epi8 (__mmask16 m, __m128i a) VPABSW__m128i _mm_maskz_abs_epi16 (__mmask8 m, __m128i a) VPABSD __m256i _mm256_mask_abs_epi32(__m256i s, __mmask8 k, __m256i a); VPABSD __m256i _mm256_maskz_abs_epi32( __mmask8 k, __m256i a); VPABSD __m128i _mm_mask_abs_epi32(__m128i s, __mmask8 k, __m128i a); VPABSD __m128i _mm_maskz_abs_epi32( __mmask8 k, __m128i a); VPABSD  __m512i _mm512_abs_epi32( __m512i a); VPABSD  __m512i _mm512_mask_abs_epi32(__m512i s, __mmask16 k, __m512i a); VPABSD  __m512i _mm512_maskz_abs_epi32( __mmask16 k, __m512i a); VPABSQ __m512i _mm512_abs_epi64( __m512i a); VPABSQ __m512i _mm512_mask_abs_epi64(__m512i s, __mmask8 k, __m512i a); VPABSQ __m512i _mm512_maskz_abs_epi64( __mmask8 k, __m512i a); VPABSQ __m256i _mm256_mask_abs_epi64(__m256i s, __mmask8 k, __m256i a); VPABSQ __m256i _mm256_maskz_abs_epi64( __mmask8 k, __m256i a); VPABSQ __m128i _mm_mask_abs_epi64(__m128i s, __mmask8 k, __m128i a); VPABSQ __m128i _mm_maskz_abs_epi64( __mmask8 k, __m128i a); PABSB __m128i _mm_abs_epi8 (__m128i a) VPABSB __m128i _mm_abs_epi8 (__m128i a)\nVPABSB __m256i _mm256_abs_epi8 (__m256i a) PABSW __m128i _mm_abs_epi16 (__m128i a) VPABSW __m128i _mm_abs_epi16 (__m128i a) VPABSW __m256i _mm256_abs_epi16 (__m256i a) PABSD __m128i _mm_abs_epi32 (__m128i a) VPABSD __m128i _mm_abs_epi32 (__m128i a) VPABSD __m256i _mm256_abs_epi32 (__m256i a)\nSIMD Floating-Point Exceptions\nNone\nOther Exceptions\nNon-EVEX-encoded instruction, see Exceptions Type 4.\nEVEX-encoded VPABSD/Q, see Exceptions Type E4.\nEVEX-encoded VPABSB/W, see Exceptions Type E4.nb."
  }
  instruction_groups {
    name: "PSIGNB/PSIGNW/PSIGND"
    short_description: "Packed SIGN"
    description: "(V)PSIGNB/(V)PSIGNW/(V)PSIGND negates each data element of the destination operand (the first operand) if the signed integer value of the corresponding data element in the source operand (the second operand) is less than zero. If the signed integer value of a data element in the source operand is positive, the corresponding data element in the destination operand is unchanged. If a data element in the source operand is zero, the corresponding data element in the destination operand is set to zero.\n(V)PSIGNB operates on signed bytes. (V)PSIGNW operates on 16-bit signed words. (V)PSIGND operates on signed 32-bit integers. When the source operand is a 128bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.\nLegacy SSE instructions: Both operands can be MMX registers. In 64-bit mode, use the REX prefix to access additional registers.\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed. VEX.L must be 0, otherwise instructions will #UD.\nVEX.256 encoded version: The first source and destination operands are YMM registers. The second source operand is an YMM register or a 256-bit memory location."
  }
  instruction_groups {
    name: "VRCP28PD"
    short_description: "Approximation to the Reciprocal of Packed Double-Precision Floating-Point Values with Less Than 2^-28 Relative Error"
  }
  instruction_groups {
    name: "INVEPT"
    description: "Invalidates mappings in the translation lookaside buffers (TLBs) and paging-structure caches that were derived from extended page tables (EPT). (See Chapter 28, \342\200\234VMX Support for Address Translation\342\200\235.) Invalidation is based on the INVEPT type specified in the register operand and the INVEPT descriptor specified in the memory operand.\nOutside IA-32e mode, the register operand is always 32 bits, regardless of the value of CS.D; in 64-bit mode, the register operand has 64 bits (the instruction cannot be executed in compatibility mode).\nThe INVEPT types supported by a logical processors are reported in the IA32_VMX_EPT_VPID_CAP MSR (see Appendix A, \342\200\234VMX Capability Reporting Facility\342\200\235). There are two INVEPT types currently defined:\n\342\200\242\tSingle-context invalidation. If the INVEPT type is 1, the logical processor invalidates all mappings associated with bits 51:12 of the EPT pointer (EPTP) specified in the INVEPT descriptor. It may invalidate other mappings\nas well.\n\342\200\242\tGlobal invalidation: If the INVEPT type is 2, the logical processor invalidates mappings associated with all EPTPs.\nIf an unsupported INVEPT type is specified, the instruction fails.\nINVEPT invalidates all the specified mappings for the indicated EPTP(s) regardless of the VPID and PCID values with which those mappings may be associated.\nThe INVEPT descriptor comprises 128 bits and contains a 64-bit EPTP value in bits\t63:0 (see Figure\t30-1).\n127\t6463\t0\nReserved (must be zero)\tEPT pointer (EPTP)\nFigure 30-1.  INVEPT Descriptor"
    flags_affected {
      content: "See the operation section and Section 30.2."
    }
  }
  instruction_groups {
    name: "FSTSW/FNSTSW"
    short_description: "Store x87 FPU Status Word"
    description: "Stores the current value of the x87 FPU status word in the destination location. The destination operand can be either a two-byte memory location or the AX register. The FSTSW instruction checks for and handles pending unmasked floating-point exceptions before storing the status word; the FNSTSW instruction does not.\nThe FNSTSW AX form of the instruction is used primarily in conditional branching (for instance, after an FPU comparison instruction or an FPREM, FPREM1, or FXAM instruction), where the direction of the branch depends on the state of the FPU condition code flags. (See the section titled \342\200\234Branching and Conditional Moves on FPU Condition Codes\342\200\235 in Chapter 8 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1.) This instruction can also be used to invoke exception handlers (by examining the exception flags) in environments that do not use interrupts. When the FNSTSW AX instruction is executed, the AX register is updated before the processor executes any further instructions. The status stored in the AX register is thus guaranteed to be from the completion of the prior FPU instruction.\nThe assembler issues two instructions for the FSTSW instruction (an FWAIT instruction followed by an FNSTSW instruction), and the processor executes each of these instructions separately. If an exception is generated for either of these instructions, the save EIP points to the instruction that caused the exception.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "The C0, C1, C2, and C3 are undefined."
    }
  }
  instruction_groups {
    name: "VCVTUQQ2PS"
    short_description: "Convert Packed Unsigned Quadword Integers to Packed Single-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "XSAVE"
    short_description: "Save Processor Extended States"
    description: "Performs a full or partial save of processor state components to the XSAVE area located at the memory address specified by the destination operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components saved correspond to the bits set in the requested-feature bitmap (RFBM), which is the logical-AND of EDX:EAX and XCR0.\nThe format of the XSAVE area is detailed in Section 13.4, \342\200\234XSAVE Area,\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1. Like FXRSTOR and FXSAVE, the memory format used for x87 state depends on a REX.W prefix; see Section 13.5.1, \342\200\234x87 State\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1.\nSection 13.7, \342\200\234Operation of XSAVE,\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1 provides a detailed description of the operation of the XSAVE instruction. The following items provide a high-level outline:\n\342\200\242\tXSAVE saves state component i if and only if RFBM[i]\t= 1.1\n\342\200\242\tXSAVE does not modify bytes 511:464 of the legacy region of the XSAVE area (see Section 13.4.1, \342\200\234Legacy Region of an XSAVE Area\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1).\n\342\200\242\tXSAVE reads the XSTATE_BV field of the XSAVE header (see Section 13.4.2, \342\200\234XSAVE Header\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1) and writes a modified value back to memory as follows. If RFBM[i]\n= 1, XSAVE writes XSTATE_BV[i] with the value of XINUSE[i]. (XINUSE is a bitmap by which the processor tracks the status of various state components. See Section 13.6, \342\200\234Processor Tracking of XSAVEManaged State\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1.) If RFBM[i]\n= 0, XSAVE writes XSTATE_BV[i] with the value that it read from memory (it does not modify the bit). XSAVE does not write to any part of the XSAVE header other than the XSTATE_BV field.\n\342\200\242\tXSAVE always uses the standard format of the extended region of the XSAVE area (see Section 13.4.3, \342\200\234Extended Region of an XSAVE Area\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1).\nUse of a destination operand not aligned to 64-byte boundary (in either 64-bit or 32-bit modes) results in a general-protection (#GP) exception. In 64-bit mode, the upper 32 bits of RDX and RAX are ignored.\n1.\tAn exception is made for MXCSR and MXCSR_MASK, which belong to state component 1 - SSE. XSAVE saves these values to memory if either RFBM[1] or RFBM[2] is 1."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "PEXTRB/PEXTRD/PEXTRQ"
    short_description: "Extract Byte/Dword/Qword"
    description: "Extract a byte/dword/qword integer value from the source XMM register at a byte/dword/qword offset determined from im\nm8[3:0]. The destination can be a register or byte/dword/qword memory location. If the destination is a register, the upper bits of the register are zero extended.\nIn legacy non-VEX encoded version and if the destination operand is a register, the default operand size in 64-bit mode for PEXTRB/PEXTRD is 64 bits, the bits above the least significant byte/dword data are filled with zeros.\nPEXTRQ is not encodable in non-64-bit modes and requires REX.W in 64-bit mode.\nNote: In VEX.128 encoded versions, VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD. In EVEX.128 encoded versions, EVEX.vvvv is reserved and must be 1111b, EVEX.L\342\200\235L must be\n0, otherwise the instruction will #UD. If the destination operand is a register, the default operand size in 64-bit mode for VPEXTRB/VPEXTRD is 64 bits, the bits above the least significant byte/word/dword data are filled with zeros."
    flags_affected {
      content: "None.\nSIMD Floating-Point Exceptions\nNone."
    }
  }
  instruction_groups {
    name: "UMWAIT"
    short_description: "User Level Monitor Wait"
    description: "UM WAIT instructs the processor to enter an implementation-dependent optimized state while monitoring a range of addresses. The optimized state may be either a light-weight power/performance optimized state or an improved power/performance optimized state. The selection between the two states is governed by the explicit input register bit[0] source operand.\nUM WAIT is available when CPUID.7.0:ECX.WAITPKG[bit 5] is enumerated as 1. UM WAIT may be executed at any privilege level. This instruction\342\200\231s operation is the same in non-64-bit modes and in 64-bit mode.\nThe input register contains information such as the preferred optimized state the processor should enter as described in the following table. Bits other than bit 0 are reserved and will result in #GP if nonzero.\nTable 4-20.  UMWAIT Input Register Bit Definitions\nBit Value\tState Name\tWakeup Time\tPower Savings\tOther Benefits\nbit[0] = 0\tC0.2\tSlower\tLarger\tImproves performance of the other SMT thread(s) on the same core.\nbit[0] = 1\tC0.1\tFaster\tSmaller\tNA\nbits[31:1]\tNA\tNA\tNA\tReserved\nThe instruction wakes up when the time-stamp counter reaches or exceeds the implicit EDX:EAX 64-bit input value (if the monitoring hardware did not trigger beforehand).\nPrior to executing the UM\nWAIT instruction, an operating system may specify the maximum delay it allows the processor to suspend its operation. It can do so by writing TSC-quanta value to the following 32bit MSR (IA32_UM WAIT_CONTROL at MSR index E1H):\n\342\200\242\tIA32_UM WAIT_CONTROL[31:2] - Determines the maximum time in TSC-quanta that the processor can reside in either C0.1 or C0.2. A zero value indicates no maximum time. The maximum time value is a 32-bit value where the upper 30 bits come from this field and the lower two bits are zero.\n\342\200\242\tIA32_UM WAIT_CONTROL[1] - Reserved.\n\342\200\242\tIA32_UM WAIT_CONTROL[0] - C0.2 is not allowed by the OS. Value of \342\200\2341\342\200\235 means all C0.2 requests revert to\nC0.1.\nIf the processor that executed a UM\nWAIT instruction wakes due to the expiration of the operating system timelimit, the instructions sets RFLAGS.CF; otherwise, that flag is cleared.\nThe UM WAIT instruction causes a transactional abort when used inside a transactional region.\nThe UM WAIT instruction operates with the UMONITOR instruction. The two instructions allow the definition of an address at which to wait (UMONITOR) and an implementation-dependent optimized operation to perform while waiting (UM WAIT). The execution of UM WAIT is a hint to the processor that it can enter an implementation-dependent-optimized state while waiting for an event or a store operation to the address range armed by UMONITOR.\nThe UM WAIT instruction will not wait (will not enter an implementation-dependent optimized state) if any of the\n1.\tThe Mod field of the ModR/M byte must have value 11B.\nfollowing instructions were executed before UM WAIT and after the most recent execution of UMONITOR: IRET, MONITOR, SYSEXIT, SYSRET, and far RET (the last if it is changing CPL).\nThe following additional events cause the processor to exit the implementation-dependent optimized state: a store to the address range armed by the UMONITOR instruction, an NMI or SMI, a debug exception, a machine check exception, the BINIT# signal, the INIT# signal, and the RESET# signal. Other implementation-dependent events may also cause the processor to exit the implementation-dependent optimized state.\nIn addition, an external interrupt causes the processor to exit the implementation-dependent optimized state regardless of whether maskable-interrupts are inhibited (EFLAGS.IF =0).\nFollowing exit from the implementation-dependent-optimized state, control passes to the instruction after the UM\nWAIT instruction. A pending interrupt that is not masked (including an NMI or an SMI) may be delivered before execution of that instruction.\nUnlike the HLT instruction, the UM WAIT instruction does not restart at the UM WAIT instruction following the\nhandling of an SMI.\nIf the preceding UMONITOR instruction did not successfully arm an address range or if UMONITOR was not executed prior to executing UM WAIT and following the most recent execution of the legacy MONITOR instruction\n(UM WAIT does not interoperate with MONITOR), then the processor will not enter an optimized state. Execution will continue to the instruction following UM\nWAIT.\nA store to the address range armed by the UMONITOR instruction will cause the processor to exit UM\nWAIT if either the store was originated by other processor agents or the store was originated by a non-processor agent."
  }
  instruction_groups {
    name: "VMPTRLD"
    description: "Marks the current-VMCS pointer valid and loads it with the physical address in the instruction operand. The instruction fails if its operand is not properly aligned, sets unsupported physical-address bits, or is equal to the VMXON pointer. In addition, the instruction fails if the 32 bits in memory referenced by the operand do not match the VMCS revision identifier supported by this processor.2\nThe operand of this instruction is always 64 bits and is always in memory."
    flags_affected {
      content: "See the operation section and Section 30.2.\n2.\tSoftware should consult the VMX capability MSR VMX_BASIC to discover the VMCS revision identifier supported by this processor (see Appendix A, \342\200\234VMX Capability Reporting Facility\342\200\235).\n3.\tIf IA32_VMX_BASIC[48] is read as 1, VMfail occurs if addr sets any bits in the range 63:32; see Appendix A.1."
    }
  }
  instruction_groups {
    name: "CLTS"
    short_description: "Clear Task-Switched Flag in CR0"
    description: "Clears the task-switched (TS) flag in the CR0 register. This instruction is intended for use in operating-system procedures. It is a privileged instruction that can only be executed at a CPL of 0. It is allowed to be executed in realaddress mode to allow initialization for protected mode.\nThe processor sets the TS flag every time a task switch occurs. The flag is used to synchronize the saving of FPU context in multitasking applications. See the description of the TS flag in the section titled \342\200\234Control Registers\342\200\235 in Chapter 2 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3A, for more information about this flag.\nCLTS operation is the same in non-64-bit modes and 64-bit mode.\nSee Chapter 25, \342\200\234VMX Non-Root Operation,\342\200\235 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3C, for more information about the behavior of this instruction in VMX non-root operation."
    flags_affected {
      content: "The TS flag in CR0 register is cleared."
    }
  }
  instruction_groups {
    name: "VRSQRT14PS"
    short_description: "Compute Approximate Reciprocals of Square Roots of Packed Float32 Values"
  }
  instruction_groups {
    name: "VEXPANDPS"
    short_description: "Load Sparse Packed Single-Precision Floating-Point Values from Dense Memory"
  }
  instruction_groups {
    name: "AAA"
    short_description: "ASCII Adjust After Addition"
    description: "Adjusts the sum of two unpacked BCD values to create an unpacked BCD result. The AL register is the implied source and destination operand for this instruction. The AAA instruction is only useful when it follows an ADD instruction that adds (binary addition) two unpacked BCD values and stores a byte result in the AL register. The AAA instruction then adjusts the contents of the AL register to contain the correct 1-digit unpacked BCD result.\nIf the addition produces a decimal carry, the AH register increments by 1, and the CF and AF flags are set. If there was no decimal carry, the CF and AF flags are cleared and the AH register is unchanged. In either case, bits 4 through 7 of the AL register are set to 0.\nThis instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode."
    flags_affected {
      content: "The AF and CF flags are set to 1 if the adjustment results in a decimal carry; otherwise they are set to 0. The OF, SF, ZF, and PF flags are undefined."
    }
  }
  instruction_groups {
    name: "VGETEXPPD"
    short_description: "Convert Exponents of Packed DP FP Values to DP FP Values"
  }
  instruction_groups {
    name: "VPCOMPRESSB/VCOMPRESSW"
    short_description: "Store Sparse Packed Byte/Word Integer Values into Dense Memory/Register"
  }
  instruction_groups {
    name: "VPGATHERDD/VPGATHERDQ"
    short_description: "Gather Packed Dword, Packed Qword with Signed Dword Indices"
  }
  instruction_groups {
    name: "FICOM/FICOMP"
    short_description: "Compare Integer"
    description: "Compares the value in ST(0) with an integer source operand and sets the condition code flags C0, C2, and C3 in the FPU status word according to the results (see table below). The integer value is converted to double extendedprecision floating-point format before the comparison is made.\nTable 3-26.  FICOM/FICOMP Results\nCondition\tC3\tC2\tC0\nST(0) > SRC\t0\t0\t0\nST(0) < SRC\t0\t0\t1\nST(0) = SRC\t1\t0\t0\nUnordered\t1\t1\t1\nThese instructions perform an \342\200\234unordered comparison.\342\200\235 An unordered comparison also checks the class of the numbers being compared (see \342\200\234FXAM\n-Examine Floating-Point\342\200\235 in this chapter). If either operand is a NaN or is in an undefined format, the condition flags are set to \342\200\234unordered.\342\200\235\nThe sign of zero is ignored, so that -0.0 := +0.0.\nThe FICOMP instructions pop the register stack following the comparison. To pop the register stack, the processor marks the ST(0) register empty and increments the stack pointer (TOP) by 1.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C1\tSet to 0.\nC0, C2, C3\tSee table on previous page."
    }
  }
  instruction_groups {
    name: "SUBPS"
    short_description: "Subtract Packed Single-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "V4FMADDPS/V4FNMADDPS"
    short_description: "Packed Single-Precision Floating-Point Fused Multiply-Add (4-iterations)"
  }
  instruction_groups {
    name: "VPTERNLOGD/VPTERNLOGQ"
    short_description: "Bitwise Ternary Logic"
  }
  instruction_groups {
    name: "MOVHLPS"
    short_description: "Move Packed Single-Precision Floating-Point Values High to Low"
  }
  instruction_groups {
    name: "PSLLW/PSLLD/PSLLQ"
    short_description: "Shift Packed Data Left Logical"
    description: "Shifts the bits in the individual data elements (words, doublewords, or quadword) in the destination operand (first operand) to the left by the number of bits specified in the count operand (second operand). As the bits in the data elements are shifted left, the empty low-order bits are cleared (set to 0). If the value specified by the count operand is greater than 15 (for words), 31(for doublewords), or 63 (for a quadword), then the destination operand is set to all 0s. Figure 4-17 gives an example of shifting words in a 64-bit operand.\nPre-Shift\nX3\tX2\tX1\tX0\nDEST\nShift Left\nwith Zero Extension\nPost-Shift DEST\tX3 << COUNT\tX2 << COUNT\tX1 << COUNT\tX0 << COUNT\nFigure 4-17.  PSLLW, PSLLD, and PSLLQ Instruction Operation Using 64-bit Operand\nThe (V)PSLLW instruction shifts each of the words in the destination operand to the left by the number of bits specified in the count operand; the (V)PSLLD instruction shifts each of the doublewords in the destination operand; and the (V)PSLLQ instruction shifts the quadword (or quadwords) in the destination operand.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE instructions 64-bit operand: The destination operand is an MMX technology register; the count operand can be either an MMX technology register or an 64-bit memory location.\n128-bit Legacy SSE version: The destination and first source operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged. The count operand can be either an XMM register or a 128-bit memory location or an 8-bit im mediate. If the count operand is a memory address, 128 bits are loaded\nbut the upper 64 bits are ignored.\nVEX.128 encoded version: The destination and first source operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed. The count operand can be either an XMM register or a 128-bit memory location or an 8-bit im mediate. If the count operand is a memory address, 128 bits are loaded but the upper 64 bits are\nignored.\nVEX.256 encoded version: The destination operand is a YMM register. The source operand is a YMM register or a memory location. The count operand can come either from an XMM register or a memory location or an 8-bit im me-\ndiate. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.\nEVEX encoded versions: The destination operand is a ZMM register updated according to the writemask. The count operand is either an 8-bit im mediate (the im mediate count version) or an 8-bit value from an XMM register or a memory location (the variable count version). For the im\nmediate count version, the source operand (the second operand) can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location. For the variable count version, the first source operand (the second operand) is a ZMM register, the second source operand (the third operand, 8-bit variable count) can be an XMM register or a memory location.\nNote: In VEX/EVEX encoded versions of shifts with an im\nmediate count, vvvv of VEX/EVEX encode the destination register, and VEX.B/EVEX.B + ModRM.r/m encodes the source register.\nNote: For shifts with an im mediate count (VEX.128.66.0F 71-73 /6, or EVEX.128.66.0F 71-73 /6), VEX.vvvv/EVEX.vvvv encodes the destination register."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "VPBLENDD"
    short_description: "Blend Packed Dwords"
    description: "Dword elements from the source operand (second operand) are conditionally written to the destination operand (first operand) depending on bits in the im mediate operand (third operand). The im mediate bits (bits 7:0) form a mask that determines whether the corresponding word in the destination is copied from the source. If a bit in the mask, corresponding to a word, is \342\200\2341\", then the word is copied, else the word is unchanged.\nVEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register."
  }
  instruction_groups {
    name: "VRANGESS"
    short_description: "Range Restriction Calculation From a Pair of Scalar Float32 Values"
  }
  instruction_groups {
    name: "VCVTTSS2USI"
    short_description: "Convert with Truncation Scalar Single-Precision Floating-Point Value to Unsigned Integer"
  }
  instruction_groups {
    name: "SQRTPS"
    short_description: "Square Root of Single-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "INCSSPD/INCSSPQ"
    short_description: "Increment Shadow Stack Pointer"
    description: "This instruction can be used to increment the current shadow stack pointer by the operand size of the instruction times the unsigned 8-bit value specified by bits 7:0 in the source operand. The instruction performs a pop and discard of the first and last element on the shadow stack in the range specified by the unsigned 8-bit value in bits 7:0 of the source operand."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "VRCP14PS"
    short_description: "Compute Approximate Reciprocals of Packed Float32 Values"
  }
  instruction_groups {
    name: "KNOTW/KNOTB/KNOTQ/KNOTD"
    short_description: "NOT Mask Register"
    description: "Performs a bitwise NOT of vector mask k2 and writes the result into vector mask k1."
    flags_affected {
      content: "None\nSIMD Floating-Point Exceptions\nNone"
    }
  }
  instruction_groups {
    name: "MOVSS"
    short_description: "Move or Merge Scalar Single-Precision Floating-Point Value"
  }
  instruction_groups {
    name: "PSHUFD"
    short_description: "Shuffle Packed Doublewords"
    description: "Copies doublewords from source operand (second operand) and inserts them in the destination operand (first operand) at the locations selected with the order operand (third operand). Figure 4-16 shows the operation of the 256-bit VPSHUFD instruction and the encoding of the order operand. Each 2-bit field in the order operand selects the contents of one doubleword location within a 128-bit lane and copy to the target element in the destination operand. For example, bits 0 and 1 of the order operand targets the first doubleword element in the low and high 128-bit lane of the destination operand for 256-bit VPSHUFD. The encoded value of bits 1:0 of the order operand (see the field encoding in Figure 4-16) determines which doubleword element (from the respective 128-bit lane) of the source operand will be copied to doubleword 0 of the destination operand.\nFor 128-bit operation, only the low 128-bit lane are operative. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. The order operand is an 8-bit im\nmediate.\nNote that this instruction permits a doubleword in the source operand to be copied to more than one doubleword location in the destination operand.\nSRC\tX7\tX6\tX5\tX4\tX3\tX2\tX1\tX0\nDEST\tY7\tY6\tY5\tY4\tY3\tY2\tY1\tY0\nEncoding of Fields in ORDER Operand\t00B - X4 01B - X5 10B - X6 11B - X7\tORDER\t7\t6\t5\t4\t3\t2\t1\t0\tEncoding of Fields in ORDER Operand\t00B - X0 01B - X1 10B - X2 11B - X3\nFigure 4-16.  256-bit VPSHUFD Instruction Operation\nThe source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. The order operand is an 8-bit im\nmediate. Note that this instruction permits a doubleword in the source operand to be copied to more than one doubleword location in the destination operand.\nIn 64-bit mode and not encoded in VEX/EVEX, using REX.R permits this instruction to access XMM8-XMM15.\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. Bits (MAXVL-1:128) of the corresponding ZMM register are zeroed.\nVEX.256 encoded version: The source operand can be an YMM register or a 256-bit memory location. The destination operand is an YMM register. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed. Bits (255- 1:128) of the destination stores the shuffled results of the upper 16 bytes of the source operand using the im me-\ndiate byte as the order operand.\nEVEX encoded version: The source operand can be an ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.\nEach 128-bit lane of the destination stores the shuffled results of the respective lane of the source operand using the im\nmediate byte as the order operand.\nNote: EVEX.vvvv and VEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
    flags_affected {
      content: "None.\nSIMD Floating-Point Exceptions\nNone."
    }
  }
  instruction_groups {
    name: "XBEGIN"
    short_description: "Transactional Begin"
    description: "The XBEGIN instruction specifies the start of an RTM code region. If the logical processor was not already in transactional execution, then the XBEGIN instruction causes the logical processor to transition into transactional execution. The XBEGIN instruction that transitions the logical processor into transactional execution is referred to as the outermost XBEGIN instruction. The instruction also specifies a relative offset to compute the address of the fallback code path following a transactional abort. (Use of the 16-bit operand size does not cause this address to be truncated to 16 bits, unlike a near jump to a relative offset.) On an RTM abort, the logical processor discards all architectural register and memory updates performed during the RTM execution and restores architectural state to that corresponding to the outermost XBEGIN instruction. The fallback address following an abort is computed from the outermost XBEGIN instruction."
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "RDSEED"
    short_description: "Read Random SEED"
    description: "Loads a hardware generated random value and store it in the destination register. The random value is generated from an Enhanced NRBG (Non Deterministic Random Bit Generator) that is compliant to NIST SP800-90B and NIST SP800-90C in the XOR construction mode. The size of the random value is determined by the destination register size and operating mode. The Carry Flag indicates whether a random value is available at the time the instruction is executed. CF=1 indicates that the data in the destination is valid. Otherwise CF=0 and the data in the destination operand will be returned as zeros for the specified width. All other flags are forced to 0 in either situation. Software must check the state of CF=1 for determining if a valid random seed value has been returned, otherwise it is expected to loop and retry execution of RDSEED (see Section 1.2).\nThe RDSEED instruction is available at all privilege levels. The RDSEED instruction executes normally either inside or outside a transaction region.\nIn 64-bit mode, the instruction\'s default operation size is 32 bits. Using a REX prefix in the form of REX.B permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bit operands. See the sum mary chart at the beginning of this section for encoding data and limits."
    flags_affected {
      content: "The CF flag is set according to the result (see the \"Operation\" section above). The OF, SF, ZF, AF, and PF flags are set to 0."
    }
  }
  instruction_groups {
    name: "PMOVSX"
    short_description: "Packed Move with Sign Extend"
  }
  instruction_groups {
    name: "VCVTQQ2PS"
    short_description: "Convert Packed Quadword Integers to Packed Single-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "MULX"
    short_description: "Unsigned Multiply Without Affecting Flags"
    description: "Performs an unsigned multiplication of the implicit source operand (EDX/RDX) and the specified source operand (the third operand) and stores the low half of the result in the second destination (second operand), the high half of the result in the first destination operand (first operand), without reading or writing the arithmetic flags. This enables efficient program\nming where the software can interleave add with carry operations and multiplications.\nIf the first and second operand are identical, it will contain the high half of the multiplication result.\nThis instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD."
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "SMSW"
    short_description: "Store Machine Status Word"
    description: "Stores the machine status word (bits 0 through 15 of control register CR0) into the destination operand. The destination operand can be a general-purpose register or a memory location.\nIn non-64-bit modes, when the destination operand is a 32-bit register, the low-order 16 bits of register CR0 are copied into the low-order 16 bits of the register and the high-order 16 bits are undefined. When the destination operand is a memory location, the low-order 16 bits of register CR0 are written to memory as a 16-bit quantity, regardless of the operand size.\nIn 64-bit mode, the behavior of the SMSW instruction is defined by the following examples:\n\342\200\242\tSMSW r16 operand size 16, store CR0[15:0] in r16\n\342\200\242\tSMSW r32 operand size 32, zero-extend CR0[31:0], and store in r32\n\342\200\242\tSMSW r64 operand size 64, zero-extend CR0[63:0], and store in r64\n\342\200\242\tSMSW m16 operand size 16, store CR0[15:0] in m16\n\342\200\242\tSMSW m16 operand size 32, store CR0[15:0] in m16 (not m32)\n\342\200\242\tSMSW m16 operands size 64, store CR0[15:0] in m16 (not m64)\nSMSW is only useful in operating-system software. However, it is not a privileged instruction and can be used in application programs if CR4.UMIP\n= 0. It is provided for compatibility with the Intel 286 processor. Programs and procedures intended to run on IA-32 and Intel 64 processors beginning with the Intel386 processors should use the MOV CR instruction to load the machine status word.\nSee \342\200\234Changes to Instruction Behavior in VMX Non-Root Operation\342\200\235 in Chapter 25 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3C, for more information about the behavior of this instruction in VMX non-root operation."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "CVTDQ2PD"
    short_description: "Convert Packed Doubleword Integers to Packed Double-Precision Floating-Point Values"
    description: "Converts two, four or eight packed signed doubleword integers in the source operand (the second operand) to two, four or eight packed double-precision floating-point values in the destination operand (the first operand).\nEVEX encoded versions: The source operand can be a YMM/XMM/XMM (low 64 bits) register, a 256/128/64-bit memory location or a 256/128/64-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1. Attempt to encode this instruction with EVEX embedded rounding is ignored.\nVEX.256 encoded version: The source operand is an XMM register or 128- bit memory location. The destination operand is a YMM register.\nVEX.128 encoded version: The source operand is an XMM register or 64- bit memory location. The destination operand is a XMM register. The upper Bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n128-bit Legacy SSE version: The source operand is an XMM register or 64- bit memory location. The destination operand is an XMM register. The upper Bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\nVEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.\nSRC\tX3\tX2\tX1\tX0\nDEST\tX3\tX2\tX1\tX0\nFigure 3-11.  CVTDQ2PD (VEX.256 encoded version)"
  }
  instruction_groups {
    name: "CLC"
    short_description: "Clear Carry Flag"
    description: "Clears the CF flag in the EFLAGS register. Operation is the same in all modes."
    flags_affected {
      content: "The CF flag is set to 0. The OF, ZF, SF, AF, and PF flags are unaffected."
    }
  }
  instruction_groups {
    name: "SIDT"
    short_description: "Store Interrupt Descriptor Table Register"
    description: "Stores the content the interrupt descriptor table register (IDTR) in the destination operand. The destination operand specifies a 6-byte memory location.\nIn non-64-bit modes, the 16-bit limit field of the register is stored in the low 2 bytes of the memory location and the 32-bit base address is stored in the high 4 bytes.\nIn 64-bit mode, the operand size fixed at 8+2 bytes. The instruction stores 8-byte base and 2-byte limit values.\nSIDT is only useful in operating-system software; however, it can be used in application programs without causing an exception to be generated if CR4.UMIP\n= 0. See \342\200\234LGDT/LIDT-Load Global/Interrupt Descriptor Table Register\342\200\235 in Chapter 3, Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 2A, for information on loading the GDTR and IDTR."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "VCVTTSD2USI"
    short_description: "Convert with Truncation Scalar Double-Precision Floating-Point Value to Unsigned Integer"
  }
  instruction_groups {
    name: "PCLMULQDQ"
    short_description: "Carry-Less Multiplication Quadword"
    description: "Performs a carry-less multiplication of two quadwords, selected from the first source and second source operand according to the value of the im mediate byte. Bits 4 and 0 are used to select which 64-bit half of each operand to\nuse according to Table 4-13, other bits of the im mediate byte are ignored.\nThe EVEX encoded form of this instruction does not support memory fault suppression.\nTable 4-13.  PCLMULQDQ Quadword Selection of Immediate Byte\nImm[4]\tImm[0]\tPCLMULQDQ Operation\n0\t0\tCL_MUL( SRC21[63:0], SRC1[63:0] )\n0\t1\tCL_MUL( SRC2[63:0], SRC1[127:64] )\n1\t0\tCL_MUL( SRC2[127:64], SRC1[63:0] )\n1\t1\tCL_MUL( SRC2[127:64], SRC1[127:64] )\nNOTES:\n1. SRC2 denotes the second source operand, which can be a register or memory; SRC1 denotes the first source and destination operand.\nThe first source operand and the destination operand are the same and must be a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location. Bits (VL_MAX- 1:128) of the corresponding YMM destination register remain unchanged.\nCompilers and assemblers may implement the following pseudo-op syntax to simplify program ming and emit the\nrequired encoding for im m8.\nTable 4-14.  Pseudo-Op and PCLMULQDQ Implementation\nPseudo-Op\tImm8 Encoding\nPCLMULLQLQDQ xmm1, xmm2\t0000_0000B\nPCLMULHQLQDQ xmm1, xmm2\t0000_0001B\nPCLMULLQHQDQ xmm1, xmm2\t0001_0000B\nPCLMULHQHQDQ xmm1, xmm2\t0001_0001B"
  }
  instruction_groups {
    name: "CMPSD"
    short_description: "Compare Scalar Double-Precision Floating-Point Value"
    description: "Compares the low double-precision floating-point values in the second source operand and the first source operand and returns the result of the comparison to the destination operand. The comparison predicate operand (im me-\ndiate operand) specifies the type of comparison performed.\n128-bit Legacy SSE version: The first source and destination operand (first operand) is an XMM register. The second source operand (second operand) can be an XMM register or 64-bit memory location. Bits (MAXVL-1:64) of the corresponding YMM destination register remain unchanged. The comparison result is a quadword mask of all 1s (comparison true) or all 0s (comparison false).\nVEX.128 encoded version: The first source operand (second operand) is an XMM register. The second source operand (third operand) can be an XMM register or a 64-bit memory location. The result is stored in the low quadword of the destination operand; the high quadword is filled with the contents of the high quadword of the first source operand. Bits (MAXVL-1:128) of the destination ZMM register are zeroed. The comparison result is a quadword mask of all 1s (comparison true) or all 0s (comparison false).\nEVEX encoded version: The first source operand (second operand) is an XMM register. The second source operand can be a XMM register or a 64-bit memory location. The destination operand (first operand) is an opmask register.\nThe comparison result is a single mask bit of 1 (comparison true) or 0 (comparison false), written to the destination starting from the LSB according to the writemask k2. Bits (MAX_KL-1:128) of the destination register are cleared.\nThe comparison predicate operand is an 8-bit im mediate:\n\342\200\242\tFor instructions encoded using the VEX prefix, bits 4:0 define the type of comparison to be performed (see Table 3-1). Bits 5 through 7 of the im mediate are reserved.\n\342\200\242\tFor instruction encodings that do not use VEX prefix, bits 2:0 define the type of comparison to be made (see the first 8 rows of Table 3-1). Bits 3 through 7 of the im\nmediate are reserved.\nThe unordered relationship is true when at least one of the two source operands being compared is a NaN; the ordered relationship is true when neither source operand is a NaN.\nA subsequent computational instruction that uses the mask result in the destination operand as an input operand will not generate an exception, because a mask of all 0s corresponds to a floating-point value of +0.0 and a mask of all 1s corresponds to a QNaN.\nNote that processors with \342\200\234CPUID.1H:ECX.AVX =0\342\200\235 do not implement the \342\200\234greater-than\342\200\235, \342\200\234greater-than-or-equal\342\200\235, \342\200\234not-greater than\342\200\235, and \342\200\234not-greater-than-or-equal relations\342\200\235 predicates. These comparisons can be made either by using the inverse relationship (that is, use the \342\200\234not-less-than-or-equal\342\200\235 to make a \342\200\234greater-than\342\200\235 comparison)\nor by using software emulation. When using software emulation, the program must swap the operands (copying registers when necessary to protect the data that will now be in the destination), and then perform the compare using a different predicate. The predicate to be used for these emulations is listed in the first 8 rows of Table 3-7 (Intel 64 and IA-32 Architectures Software Developer\342\200\231s Manual Volume 2A) under the heading Emulation.\nCompilers and assemblers may implement the following two-operand pseudo-ops in addition to the three-operand CMPSD instruction, for processors with \342\200\234CPUID.1H:ECX.AVX =0\342\200\235. See Table 3-6. Compiler should treat reserved Im m8 values as illegal syntax.\nTable 3-6. Pseudo-Op and CMPSD Implementation\nPseudo-Op\tCMPSD Implementation\nCMPEQSD xmm1, xmm2\tCMPSD xmm1, xmm2, 0\nCMPLTSD xmm1, xmm2\tCMPSD xmm1, xmm2, 1\nCMPLESD xmm1, xmm2\tCMPSD xmm1, xmm2, 2\nCMPUNORDSD xmm1, xmm2\tCMPSD xmm1, xmm2, 3\nCMPNEQSD xmm1, xmm2\tCMPSD xmm1, xmm2, 4\nCMPNLTSD xmm1, xmm2\tCMPSD xmm1, xmm2, 5\nCMPNLESD xmm1, xmm2\tCMPSD xmm1, xmm2, 6\nCMPORDSD xmm1, xmm2\tCMPSD xmm1, xmm2, 7\nThe greater-than relations that the processor does not implement require more than one instruction to emulate in software and therefore should not be implemented as pseudo-ops. (For these, the program\nmer should reverse the operands of the corresponding less than relations and use move instructions to ensure that the mask is moved to the correct destination register and that the source operand is left intact.)\nProcessors with \342\200\234CPUID.1H:ECX.AVX =1\342\200\235 implement the full complement of 32 predicates shown in Table 3-7, software emulation is no longer needed. Compilers and assemblers may implement the following three-operand pseudo-ops in addition to the four-operand VCMPSD instruction. See Table 3-7, where the notations of reg1 reg2, and reg3 represent either XMM registers or YMM registers. Compiler should treat reserved Im\nm8 values as illegal syntax. Alternately, intrinsics can map the pseudo-ops to pre-defined constants to support a simpler intrinsic interface. Compilers and assemblers may implement three-operand pseudo-ops for EVEX encoded VCMPSD instructions in a similar fashion by extending the syntax listed in Table 3-7.\nTable 3-7. Pseudo-Op and VCMPSD Implementation\nPseudo-Op\tCMPSD Implementation\nVCMPEQSD reg1, reg2, reg3\tVCMPSD reg1, reg2, reg3, 0\nVCMPLTSD reg1, reg2, reg3\tVCMPSD reg1, reg2, reg3, 1\nVCMPLESD reg1, reg2, reg3\tVCMPSD reg1, reg2, reg3, 2\nVCMPUNORDSD reg1, reg2, reg3\tVCMPSD reg1, reg2, reg3, 3\nVCMPNEQSD reg1, reg2, reg3\tVCMPSD reg1, reg2, reg3, 4\nVCMPNLTSD reg1, reg2, reg3\tVCMPSD reg1, reg2, reg3, 5\nVCMPNLESD reg1, reg2, reg3\tVCMPSD reg1, reg2, reg3, 6\nVCMPORDSD reg1, reg2, reg3\tVCMPSD reg1, reg2, reg3, 7\nVCMPEQ_UQSD reg1, reg2, reg3\tVCMPSD reg1, reg2, reg3, 8\nVCMPNGESD reg1, reg2, reg3\tVCMPSD reg1, reg2, reg3, 9\nVCMPNGTSD reg1, reg2, reg3\tVCMPSD reg1, reg2, reg3, 0AH\nVCMPFALSESD reg1, reg2, reg3\tVCMPSD reg1, reg2, reg3, 0BH\nVCMPNEQ_OQSD reg1, reg2, reg3\tVCMPSD reg1, reg2, reg3, 0CH\nVCMPGESD reg1, reg2, reg3\tVCMPSD reg1, reg2, reg3, 0DH\nTable 3-7. Pseudo-Op and VCMPSD Implementation\nPseudo-Op\tCMPSD Implementation\nVCMPGTSD reg1, reg2, reg3\tVCMPSD reg1, reg2, reg3, 0EH\nVCMPTRUESD reg1, reg2, reg3\tVCMPSD reg1, reg2, reg3, 0FH\nVCMPEQ_OSSD reg1, reg2, reg3\tVCMPSD reg1, reg2, reg3, 10H\nVCMPLT_OQSD reg1, reg2, reg3\tVCMPSD reg1, reg2, reg3, 11H\nVCMPLE_OQSD reg1, reg2, reg3\tVCMPSD reg1, reg2, reg3, 12H\nVCMPUNORD_SSD reg1, reg2, reg3\tVCMPSD reg1, reg2, reg3, 13H\nVCMPNEQ_USSD reg1, reg2, reg3\tVCMPSD reg1, reg2, reg3, 14H\nVCMPNLT_UQSD reg1, reg2, reg3\tVCMPSD reg1, reg2, reg3, 15H\nVCMPNLE_UQSD reg1, reg2, reg3\tVCMPSD reg1, reg2, reg3, 16H\nVCMPORD_SSD reg1, reg2, reg3\tVCMPSD reg1, reg2, reg3, 17H\nVCMPEQ_USSD reg1, reg2, reg3\tVCMPSD reg1, reg2, reg3, 18H\nVCMPNGE_UQSD reg1, reg2, reg3\tVCMPSD reg1, reg2, reg3, 19H\nVCMPNGT_UQSD reg1, reg2, reg3\tVCMPSD reg1, reg2, reg3, 1AH\nVCMPFALSE_OSSD reg1, reg2, reg3\tVCMPSD reg1, reg2, reg3, 1BH\nVCMPNEQ_OSSD reg1, reg2, reg3\tVCMPSD reg1, reg2, reg3, 1CH\nVCMPGE_OQSD reg1, reg2, reg3\tVCMPSD reg1, reg2, reg3, 1DH\nVCMPGT_OQSD reg1, reg2, reg3\tVCMPSD reg1, reg2, reg3, 1EH\nVCMPTRUE_USSD reg1, reg2, reg3\tVCMPSD reg1, reg2, reg3, 1FH\nSoftware should ensure VCMPSD is encoded with VEX.L=0. Encoding VCMPSD with VEX.L=1 may encounter unpredictable behavior across different processor generations."
  }
  instruction_groups {
    name: "LSL"
    short_description: "Load Segment Limit"
    description: "Loads the unscrambled segment limit from the segment descriptor specified with the second operand (source operand) into the first operand (destination operand) and sets the ZF flag in the EFLAGS register. The source operand (which can be a register or a memory location) contains the segment selector for the segment descriptor being accessed. The destination operand is a general-purpose register.\nThe processor performs access checks as part of the loading process. Once loaded in the destination register, software can compare the segment limit with the offset of a pointer.\nThe segment limit is a 20-bit value contained in bytes 0 and 1 and in the first 4 bits of byte 6 of the segment descriptor. If the descriptor has a byte granular segment limit (the granularity flag is set to 0), the destination operand is loaded with a byte granular value (byte limit). If the descriptor has a page granular segment limit (the granularity flag is set to 1), the LSL instruction will translate the page granular limit (page limit) into a byte limit before loading it into the destination operand. The translation is performed by shifting the 20-bit \342\200\234raw\342\200\235 limit left 12 bits and filling the low-order 12 bits with 1s.\nWhen the operand size is 32 bits, the 32-bit byte limit is stored in the destination operand. When the operand size is 16 bits, a valid 32-bit limit is computed; however, the upper 16 bits are truncated and only the low-order 16 bits are loaded into the destination operand.\nThis instruction performs the following checks before it loads the segment limit into the destination register:\n\342\200\242\tChecks that the segment selector is not NULL.\n\342\200\242\tChecks that the segment selector points to a descriptor that is within the limits of the GDT or LDT being accessed\n\342\200\242\tChecks that the descriptor type is valid for this instruction. All code and data segment descriptors are valid for (can be accessed with) the LSL instruction. The valid special segment and gate descriptor types are given in the following table.\n\342\200\242\tIf the segment is not a conforming code segment, the instruction checks that the specified segment descriptor is visible at the CPL (that is, if the CPL and the RPL of the segment selector are less than or equal to the DPL of the segment selector).\nIf the segment descriptor cannot be accessed or is an invalid type for the instruction, the ZF flag is cleared and no value is loaded in the destination operand.\nTable 3-56.  Segment and Gate Descriptor Types\nType\tProtected Mode\tIA-32e Mode\nName\tValid\tName\tValid\n0\tReserved\tNo\tReserved\tNo\n1\tAvailable 16-bit TSS\tYes\tReserved\tNo\n2\tLDT\tYes\tLDT1\tYes\n3\tBusy 16-bit TSS\tYes\tReserved\tNo\n4\t16-bit call gate\tNo\tReserved\tNo\n5\t16-bit/32-bit task gate\tNo\tReserved\tNo\n6\t16-bit interrupt gate\tNo\tReserved\tNo\n7\t16-bit trap gate\tNo\tReserved\tNo\n8\tReserved\tNo\tReserved\tNo\n9\tAvailable 32-bit TSS\tYes\t64-bit TSS1\tYes\nA\tReserved\tNo\tReserved\tNo\nB\tBusy 32-bit TSS\tYes\tBusy 64-bit TSS1\tYes\nC\t32-bit call gate\tNo\t64-bit call gate\tNo\nD\tReserved\tNo\tReserved\tNo\nE\t32-bit interrupt gate\tNo\t64-bit interrupt gate\tNo\nF\t32-bit trap gate\tNo\t64-bit trap gate\tNo\nNOTES:\n1. In this case, the descriptor comprises 16 bytes; bits 12:8 of the upper 4 bytes must be 0."
    flags_affected {
      content: "The ZF flag is set to 1 if the segment limit is loaded successfully; otherwise, it is set to 0."
    }
  }
  instruction_groups {
    name: "MULPS"
    short_description: "Multiply Packed Single-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "SARX/SHLX/SHRX"
    short_description: "Shift Without Affecting Flags"
    description: "Shifts the bits of the first source operand (the second operand) to the left or right by a COUNT value specified in the second source operand (the third operand). The result is written to the destination operand (the first operand).\nThe shift arithmetic right (SARX) and shift logical right (SHRX) instructions shift the bits of the destination operand to the right (toward less significant bit locations), SARX keeps and propagates the most significant bit (sign bit) while shifting.\nThe logical shift left (SHLX) shifts the bits of the destination operand to the left (toward more significant bit locations).\nThis instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.\nIf the value specified in the first source operand exceeds OperandSize -1, the COUNT value is masked.\nSARX,SHRX, and SHLX instructions do not update flags."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "FFREE"
    short_description: "Free Floating-Point Register"
    description: "Sets the tag in the FPU tag register associated with register ST(i) to empty (11B). The contents of ST(i) and the FPU stack-top pointer (TOP) are not affected.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C0, C1, C2, C3 undefined."
    }
  }
  instruction_groups {
    name: "VCVTPD2UDQ"
    short_description: "Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers"
  }
  instruction_groups {
    name: "VPERM2F128"
    short_description: "Permute Floating-Point Values"
    description: "Permute 128 bit floating-point-containing fields from the first source operand (second operand) and second source operand (third operand) using bits in the 8-bit im\nmediate and store results in the destination operand (first operand). The first source operand is a YMM register, the second source operand is a YMM register or a 256-bit memory location, and the destination operand is a YMM register.\nSRC2\tY1\tY0\nSRC1\tX1\tX0\nDEST\tX0, X1, Y0, or Y1\tX0, X1, Y0, or Y1\nFigure 5-21.  VPERM2F128 Operation\nIm m8[1:0] select the source for the first destination 128-bit field, im m8[5:4] select the source for the second\ndestination field. If im m8[3] is set, the low 128-bit field is zeroed. If im m8[7] is set, the high 128-bit field is zeroed.\nVEX.L must be 1, otherwise the instruction will #UD."
  }
  instruction_groups {
    name: "VPMADD52HUQ"
    short_description: "Packed Multiply of Unsigned 52-bit Unsigned Integers and Add High 52-bit Products to 64-bit Accumulators"
  }
  instruction_groups {
    name: "WRSSD/WRSSQ"
    short_description: "Write to Shadow Stack"
    description: "Writes bytes in register source to the shadow stack."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "PTWRITE"
    short_description: "Write Data to a Processor Trace Packet"
    description: "This instruction reads data in the source operand and sends it to the Intel Processor Trace hardware to be encoded in a PTW packet if TriggerEn, ContextEn, FilterEn, and PTWEn are all set to 1. For more details on these values, see Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3C, Section 35.2.2, \342\200\234Software Trace Instrumentation with PTWRITE\342\200\235. The size of data is 64-bit if using REX.W in 64-bit mode, otherwise 32-bits of data are copied from the source operand.\nNote: The instruction will #UD if prefix 66H is used."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "RDTSCP"
    short_description: "Read Time-Stamp Counter and Processor ID"
    description: "Reads the current value of the processor\342\200\231s time-stamp counter (a 64-bit MSR) into the EDX:EAX registers and also reads the value of the IA32_TSC_AUX MSR (address C0000103H) into the ECX register. The EDX register is loaded with the high-order 32 bits of the IA32_TSC MSR; the EAX register is loaded with the low-order 32 bits of the IA32_TSC MSR; and the ECX register is loaded with the low-order 32-bits of IA32_TSC_AUX MSR. On processors that support the Intel64 architecture, the high-order 32 bits of each of RAX, RDX, and RCX are cleared.\nThe processor monotonically increments the time-stamp counter MSR every clock cycle and resets it to 0 whenever the processor is reset. See \342\200\234Time Stamp Counter\342\200\235 in Chapter 17 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3B, for specific details of the time stamp counter behavior.\nThe time stamp disable (TSD) flag in register CR4 restricts the use of the RDTSCP instruction as follows. When the flag is clear, the RDTSCP instruction can be executed at any privilege level; when the flag is set, the instruction can only be executed at privilege level 0.\nThe RDTSCP instruction is not a serializing instruction, but it does wait until all previous instructions have executed and all previous loads are globally visible.1 But it does not wait for previous stores to be globally visible, and subsequent instructions may begin execution before the read operation is performed. The following items may guide software seeking to order executions of RDTSCP:\n\342\200\242\tIf software requires RDTSCP to be executed only after all previous stores are globally visible, it can execute MFENCE im mediately before RDTSCP.\n\342\200\242\tIf software requires RDTSCP to be executed prior to execution of any subsequent instruction (including any memory accesses), it can execute LFENCE im mediately after RDTSCP.\nSee \342\200\234Changes to Instruction Behavior in VMX Non-Root Operation\342\200\235 in Chapter 25 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3C, for more information about the behavior of this instruction in VMX non-root operation."
    flags_affected {
      content: "None.\n1.\tA load is considered to become globally visible when the value to be loaded is determined."
    }
  }
  instruction_groups {
    name: "VPBROADCASTM"
    short_description: "Broadcast Mask to Vector Register"
  }
  instruction_groups {
    name: "PINSRB/PINSRD/PINSRQ"
    short_description: "Insert Byte/Dword/Qword"
    description: "Copies a byte/dword/qword from the source operand (second operand) and inserts it in the destination operand (first operand) at the location specified with the count operand (third operand). (The other elements in the destination register are left untouched.) The source operand can be a general-purpose register or a memory location.\n(When the source operand is a general-purpose register, PINSRB copies the low byte of the register.) The destination operand is an XMM register. The count operand is an 8-bit im\nmediate. When specifying a qword[dword, byte] location in an XMM register, the [2, 4] least-significant bit(s) of the count operand specify the location.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15, R8-15). Use of REX.W permits the use of 64 bit general purpose registers.\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed. VEX.L must be 0, otherwise the instruction will #UD. Attempt to execute VPINSRQ in non-64-bit mode will cause #UD.\nEVEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed. EVEX.L\342\200\231L must be 0, otherwise the instruction will #UD."
    flags_affected {
      content: "None.\nSIMD Floating-Point Exceptions\nNone."
    }
  }
  instruction_groups {
    name: "VPSHRD"
    short_description: "Concatenate and Shift Packed Data Right Logical"
  }
  instruction_groups {
    name: "BNDMOV"
    short_description: "Move Bounds"
    description: "BNDMOV moves a pair of lower and upper bound values from the source operand (the second operand) to the destination (the first operand). Each operation is 128-bit move. The exceptions are same as the MOV instruction.\nThe memory format for loading/store bounds in 64-bit mode is shown in Figure 3-5.\nBNDMOV to memory in 64-bit mode\nUpper Bound (UB)\tLower Bound (LB)\n16\t8\t0\tByte offset\nBNDMOV to memory in 32-bit mode\nUpper Bound (UB)\tLower Bound (LB)\n16\t8\t4\t0\tByte offset\nFigure 3-5.  Memory Layout of BNDMOV to/from Memory\nThis instruction does not change flags."
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "MOV"
    short_description: "Move to/from Debug Registers"
    description: "Moves the contents of a debug register (DR0, DR1, DR2, DR3, DR4, DR5, DR6, or DR7) to a general-purpose register or vice versa. The operand size for these instructions is always 32 bits in non-64-bit modes, regardless of the operand-size attribute. (See Section 17.2, \342\200\234Debug Registers\342\200\235, of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3A, for a detailed description of the flags and fields in the debug registers.)\nThe instructions must be executed at privilege level 0 or in real-address mode.\nWhen the debug extension (DE) flag in register CR4 is clear, these instructions operate on debug registers in a manner that is compatible with Intel386 and Intel486 processors. In this mode, references to DR4 and DR5 refer to DR6 and DR7, respectively. When the DE flag in CR4 is set, attempts to reference DR4 and DR5 result in an undefined opcode (#UD) exception. (The CR4 register was added to the IA-32 Architecture beginning with the Pentium processor.)\nAt the opcode level, the reg field within the ModR/M byte specifies which of the debug registers is loaded or read.\nThe two bits in the mod field are ignored. The r/m field specifies the general-purpose register loaded or read.\nIn 64-bit mode, the instruction\342\200\231s default operation size is 64 bits. Use of the REX.B prefix permits access to additional registers (R8-R15). Use of the REX.W or 66H prefix is ignored. Use of the REX.R prefix causes an invalidopcode exception. See the sum mary chart at the beginning of this section for encoding data and limits."
    flags_affected {
      content: "The OF, SF, ZF, AF, PF, and CF flags are undefined."
    }
  }
  instruction_groups {
    name: "PMAXUD/PMAXUQ"
    short_description: "Maximum of Packed Unsigned Integers"
  }
  instruction_groups {
    name: "PREFETCHW"
    short_description: "Prefetch Data into Caches in Anticipation of a Write"
    description: "Fetches the cache line of data from memory that contains the byte specified with the source operand to a location in the 1st or 2nd level cache and invalidates other cached instances of the line.\nThe source operand is a byte memory location. If the line selected is already present in the lowest level cache and is already in an exclusively owned state, no data movement occurs. Prefetches from non-writeback memory are ignored.\nThe PREFETCHW instruction is merely a hint and does not affect program behavior. If executed, this instruction moves data closer to the processor and invalidates other cached copies in anticipation of the line being written to in the future.\nThe characteristic of prefetch locality hints is implementation-dependent, and can be overloaded or ignored by a processor implementation. The amount of data prefetched is also processor implementation-dependent. It will, however, be a minimum of 32 bytes. Additional details of the implementation-dependent locality hints are described in Section 7.4 of Intel\302\256 64 and IA-32 Architectures Optimization Reference Manual.\nIt should be noted that processors are free to speculatively fetch and cache data with exclusive ownership from system memory regions that permit such accesses (that is, the WB memory type). A PREFETCHW instruction is considered a hint to this speculative behavior. Because this speculative fetching can occur at any time and is not tied to instruction execution, a PREFETCHW instruction is not ordered with respect to the fence instructions (MFENCE, SFENCE, and LFENCE) or locked memory references. A PREFETCHW instruction is also unordered with respect to CLFLUSH and CLFLUSHOPT instructions, other PREFETCHW instructions, or any other general instruction It is ordered with respect to serializing instructions such as CPUID, WRMSR, OUT, and MOV CR.\nThis instruction\'s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "All flags are affected."
    }
  }
  instruction_groups {
    name: "RCL/RCR/ROL/ROR"
    short_description: "Rotate"
    description: "Shifts (rotates) the bits of the first operand (destination operand) the number of bit positions specified in the second operand (count operand) and stores the result in the destination operand. The destination operand can be a register or a memory location; the count operand is an unsigned integer that can be an im mediate or a value in\nthe CL register. The count is masked to 5 bits (or 6 bits if in 64-bit mode and REX.W = 1).\nThe rotate left (ROL) and rotate through carry left (RCL) instructions shift all the bits toward more-significant bit positions, except for the most-significant bit, which is rotated to the least-significant bit location. The rotate right (ROR) and rotate through carry right (RCR) instructions shift all the bits toward less significant bit positions, except for the least-significant bit, which is rotated to the most-significant bit location.\nThe RCL and RCR instructions include the CF flag in the rotation. The RCL instruction shifts the CF flag into the least-significant bit and shifts the most-significant bit into the CF flag. The RCR instruction shifts the CF flag into the most-significant bit and shifts the least-significant bit into the CF flag. For the ROL and ROR instructions, the original value of the CF flag is not a part of the result, but the CF flag receives a copy of the bit that was shifted from one end to the other.\nThe OF flag is defined only for the 1-bit rotates; it is undefined in all other cases (except RCL and RCR instructions only: a zero-bit rotate does nothing, that is affects no flags). For left rotates, the OF flag is set to the exclusive OR of the CF bit (after the rotate) and the most-significant bit of the result. For right rotates, the OF flag is set to the exclusive OR of the two most-significant bits of the result.\nIn 64-bit mode, using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Use of REX.W promotes the first operand to 64 bits and causes the count operand to become a 6-bit counter."
    flags_affected {
      content: "If the masked count is 0, the flags are not affected. If the masked count is 1, then the OF flag is affected, otherwise (masked count is greater than 1) the OF flag is undefined. The CF flag is affected when the masked count is nonzero. The SF, ZF, AF, and PF flags are always unaffected."
    }
  }
  instruction_groups {
    name: "VPMASKMOV"
    short_description: "Conditional SIMD Integer Packed Loads and Stores"
    description: "Conditionally moves packed data elements from the second source operand into the corresponding data element of the destination operand, depending on the mask bits associated with each data element. The mask bits are specified in the first source operand.\nThe mask bit for each data element is the most significant bit of that element in the first source operand. If a mask is 1, the corresponding data element is copied from the second source operand to the destination operand. If the mask is 0, the corresponding data element is set to zero in the load form of these instructions, and unmodified in the store form.\nThe second source operand is a memory address for the load form of these instructions. The destination operand is a memory address for the store form of these instructions. The other operands are either XMM registers (for VEX.128 version) or YMM registers (for VEX.256 version).\nFaults occur only due to mask-bit required memory accesses that caused the faults. Faults will not occur due to referencing any memory location if the corresponding mask bit for that memory location is 0. For example, no faults will be detected if the mask bits are all zero.\nUnlike previous MASKMOV instructions (MASKMOVQ and MASKMOVDQU), a nontemporal hint is not applied to these instructions.\nInstruction behavior on alignment check reporting with mask bits of less than all 1s are the same as with mask bits of all 1s.\nVMASKMOV should not be used to access memory mapped I/O as the ordering of the individual loads or stores it does is implementation specific.\nIn cases where mask bits indicate data should not be loaded or stored paging A and D bits will be set in an implementation dependent way. However, A and D bits are always set for pages where data is actually loaded/stored.\nNote: for load forms, the first source (the mask) is encoded in VEX.vvvv; the second source is encoded in rm_field, and the destination register is encoded in reg_field.\nNote: for store forms, the first source (the mask) is encoded in VEX.vvvv; the second source register is encoded in reg_field, and the destination memory location is encoded in rm_field."
  }
  instruction_groups {
    name: "MOVSX/MOVSXD"
    short_description: "Move with Sign-Extension"
    description: "Copies the contents of the source operand (register or memory location) to the destination operand (register) and sign extends the value to 16 or 32 bits (see Figure 7-6 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1). The size of the converted value depends on the operand-size attribute.\nIn 64-bit mode, the instruction\342\200\231s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the sum mary chart at the\nbeginning of this section for encoding data and limits."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "VFNMSUB132PS/VFNMSUB213PS/VFNMSUB231PS"
    short_description: "Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Val-"
  }
  instruction_groups {
    name: "LFENCE"
    short_description: "Load Fence"
    description: "Performs a serializing operation on all load-from-memory instructions that were issued prior the LFENCE instruction. Specifically, LFENCE does not execute until all prior instructions have completed locally, and no later instruction begins execution until LFENCE completes. In particular, an instruction that loads from memory and that precedes an LFENCE receives data from memory prior to completion of the LFENCE. (An LFENCE that follows an instruction that stores to memory might complete before the data being stored have become globally visible.) Instructions following an LFENCE may be fetched from memory before the LFENCE, but they will not execute (even speculatively) until the LFENCE completes.\nWeakly ordered memory types can be used to achieve higher processor performance through such techniques as out-of-order issue and speculative reads. The degree to which a consumer of data recognizes or knows that the data is weakly ordered varies among applications and may be unknown to the producer of this data. The LFENCE instruction provides a performance-efficient way of ensuring load ordering between routines that produce weaklyordered results and routines that consume that data.\nProcessors are free to fetch and cache data speculatively from regions of system memory that use the WB, WC, and WT memory types. This speculative fetching can occur at any time and is not tied to instruction execution.\nThus, it is not ordered with respect to executions of the LFENCE instruction; data can be brought into the caches speculatively just before, during, or after the execution of an LFENCE instruction.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode.\nSpecification of the instruction\'s opcode above indicates a ModR/M byte of E8. For this instruction, the processor ignores the r/m field of the ModR/M byte. Thus, LFENCE is encoded by any opcode of the form 0F AE Ex, where x is in the range 8-F."
  }
  instruction_groups {
    name: "VSCATTERPF1DPS/VSCATTERPF1QPS/VSCATTERPF1DPD/VSCATTERPF1QPD"
    short_description: "Sparse Prefetch Packed SP/DP Data Values with"
  }
  instruction_groups {
    name: "UNPCKLPD"
    short_description: "Unpack and Interleave Low Packed Double-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "SHRD"
    short_description: "Double Precision Shift Right"
    description: "The SHRD instruction is useful for multi-precision shifts of 64 bits or more.\nThe instruction shifts the first operand (destination operand) to the right the number of bits specified by the third operand (count operand). The second operand (source operand) provides bits to shift in from the left (starting with the most significant bit of the destination operand).\nThe destination operand can be a register or a memory location; the source operand is a register. The count operand is an unsigned integer that can be stored in an im\nmediate byte or the CL register. If the count operand is CL, the shift count is the logical AND of CL and a count mask. In non-64-bit modes and default 64-bit mode, the width of the count mask is 5 bits. Only bits 0 through 4 of the count register are used (masking the count to a value between 0 and 31). If the count is greater than the operand size, the result is undefined.\nIf the count is 1 or greater, the CF flag is filled with the last bit shifted out of the destination operand. For a 1-bit shift, the OF flag is set if a sign change occurred; otherwise, it is cleared. If the count operand is 0, flags are not affected.\nIn 64-bit mode, the instruction\342\200\231s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits (upgrading the count mask to 6 bits). See the sum mary chart at the beginning of this section for encoding data and\nlimits."
    flags_affected {
      content: "If the count is 1 or greater, the CF flag is filled with the last bit shifted out of the destination operand and the SF, ZF, and PF flags are set according to the value of the result. For a 1-bit shift, the OF flag is set if a sign change occurred; otherwise, it is cleared. For shifts greater than 1 bit, the OF flag is undefined. If a shift occurs, the AF flag is undefined. If the count operand is 0, the flags are not affected. If the count is greater than the operand size, the flags are undefined."
    }
  }
  instruction_groups {
    name: "PALIGNR"
    short_description: "Packed Align Right"
    description: "(V)PALIGNR concatenates the destination operand (the first operand) and the source operand (the second operand) into an intermediate composite, shifts the composite at byte granularity to the right by a constant im\nmediate, and extracts the right-aligned result into the destination. The first and the second operands can be an MMX,\nXMM or a YMM register. The im mediate value is considered unsigned. Im mediate shift counts larger than the 2L (i.e. 32 for 128-bit operands, or 16 for 64-bit operands) produce a zero result. Both operands can be MMX registers, XMM registers or YMM registers. When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.\nIn 64-bit mode and not encoded by VEX/EVEX prefix, use the REX prefix to access additional registers.\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nEVEX.512 encoded version: The first source operand is a ZMM register and contains four 16-byte blocks. The second source operand is a ZMM register or a 512-bit memory location containing four 16-byte block. The destination operand is a ZMM register and contain four 16-byte results. The im m8[7:0] is the com mon shift count used for each of the four successive 16-byte block sources. The low 16-byte block of the two source operands produce the low 16-byte result of the destination operand, the high 16-byte block of the two source operands produce the high 16-byte result of the destination operand and so on for the blocks in the middle.\nVEX.256 and EVEX.256 encoded versions: The first source operand is a YMM register and contains two 16-byte blocks. The second source operand is a YMM register or a 256-bit memory location containing two 16-byte block.\nThe destination operand is a YMM register and contain two 16-byte results. The im m8[7:0] is the com mon shift count used for the two lower 16-byte block sources and the two upper 16-byte block sources. The low 16-byte block of the two source operands produce the low 16-byte result of the destination operand, the high 16-byte block of the two source operands produce the high 16-byte result of the destination operand. The upper bits (MAXVL- 1:256) of the corresponding ZMM register destination are zeroed.\nVEX.128 and EVEX.128 encoded versions: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL- 1:128) of the corresponding ZMM register destination are zeroed.\nConcatenation is done with 128-bit data in the first and second source operand for both 128-bit and 256-bit instructions. The high 128-bits of the intermediate composite 256-bit result came from the 128-bit data from the first source operand; the low 128-bits of the intermediate result came from the 128-bit data of the second source operand.\n127\t0\t127\t0\nSRC1\tSRC2\nImm8[7:0]*8\n255\t128\t255\t128\nSRC1\tSRC2\nImm8[7:0]*8\n255\t128\t127\t0\nDEST\tDEST\nFigure 4-7.  256-bit VPALIGN Instruction Operation"
  }
  instruction_groups {
    name: "VFPCLASSPS"
    short_description: "Tests Types Of a Packed Float32 Values"
  }
  instruction_groups {
    name: "VGETMANTPS"
    short_description: "Extract Float32 Vector of Normalized Mantissas from Float32 Vector"
  }
  instruction_groups {
    name: "VPGATHERQD/VPGATHERQQ"
    short_description: "Gather Packed Dword, Packed Qword with Signed Qword Indices"
  }
  instruction_groups {
    name: "DEC"
    short_description: "Decrement by 1"
    description: "Subtracts 1 from the destination operand, while preserving the state of the CF flag. The destination operand can be a register or a memory location. This instruction allows a loop counter to be updated without disturbing the CF flag.\n(To perform a decrement operation that updates the CF flag, use a SUB instruction with an im mediate operand of\n1.)\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.\nIn 64-bit mode, DEC r16 and DEC r32 are not encodable (because opcodes 48H through 4FH are REX prefixes).\nOtherwise, the instruction\342\200\231s 64-bit mode default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits.\nSee the sum mary chart at the beginning of this section for encoding data and limits."
    flags_affected {
      content: "The CF flag is not affected. The OF, SF, ZF, AF, and PF flags are set according to the result."
    }
  }
  instruction_groups {
    name: "CRC32"
    short_description: "Accumulate CRC32 Value"
    description: "Starting with an initial value in the first operand (destination operand), accumulates a CRC32 (polynomial 11EDC6F41H) value for the second operand (source operand) and stores the result in the destination operand. The source operand can be a register or a memory location. The destination operand must be an r32 or r64 register. If the destination is an r64 register, then the 32-bit result is stored in the least significant double word and 00000000H is stored in the most significant double word of the r64 register.\nThe initial value supplied in the destination operand is a double word integer stored in the r32 register or the least significant double word of the r64 register. To incrementally accumulate a CRC32 value, software retains the result of the previous CRC32 operation in the destination operand, then executes the CRC32 instruction again with new input data in the source operand. Data contained in the source operand is processed in reflected bit order. This means that the most significant bit of the source operand is treated as the least significant bit of the quotient, and so on, for all the bits of the source operand. Likewise, the result of the CRC operation is stored in the destination operand in reflected bit order. This means that the most significant bit of the resulting CRC (bit 31) is stored in the least significant bit of the destination operand (bit 0), and so on, for all the bits of the CRC."
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "LDMXCSR"
    short_description: "Load MXCSR Register"
    description: "Loads the source operand into the MXCSR control/status register. The source operand is a 32-bit memory location.\nSee \342\200\234MXCSR Control and Status Register\342\200\235 in Chapter 10, of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1, for a description of the MXCSR register and its contents.\nThe LDMXCSR instruction is typically used in conjunction with the (V)STMXCSR instruction, which stores the contents of the MXCSR register in memory.\nThe default MXCSR value at reset is 1F80H.\nIf a (V)LDMXCSR instruction clears a SIMD floating-point exception mask bit and sets the corresponding exception flag bit, a SIMD floating-point exception will not be im\nmediately generated. The exception will be generated only upon the execution of the next instruction that meets both conditions below:\n\342\200\242\tthe instruction must operate on an XMM or YMM register operand,\n\342\200\242\tthe instruction causes that particular SIMD floating-point exception to be reported.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode.\nIf VLDMXCSR is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
  }
  instruction_groups {
    name: "VPMOVDB/VPMOVSDB/VPMOVUSDB"
    short_description: "Down Convert DWord to Byte"
  }
  instruction_groups {
    name: "KORW/KORB/KORQ/KORD"
    short_description: "Bitwise Logical OR Masks"
    description: "Performs a bitwise OR between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1 (three-operand form)."
    flags_affected {
      content: "None\nSIMD Floating-Point Exceptions\nNone"
    }
  }
  instruction_groups {
    name: "VRSQRT14PD"
    short_description: "Compute Approximate Reciprocals of Square Roots of Packed Float64 Values"
  }
  instruction_groups {
    name: "CPUID"
    short_description: "CPU Identification"
    description: "The ID flag (bit 21) in the EFLAGS register indicates support for the CPUID instruction. If a software procedure can set and clear this flag, the processor executing the procedure supports the CPUID instruction. This instruction operates the same in non-64-bit modes and 64-bit mode.\nCPUID returns processor identification and feature information in the EAX, EBX, ECX, and EDX registers.1 The instruction\342\200\231s output is dependent on the contents of the EAX register upon execution (in some cases, ECX as well).\nFor example, the following pseudocode loads EAX with 00H and causes CPUID to return a Maximum Return Value and the Vendor Identification String in the appropriate registers:\nMOV EAX, 00H CPUID\nTable 3-8 shows information returned, depending on the initial value loaded into the EAX register.\nTwo types of information are returned: basic and extended function information. If a value entered for CPUID.EAX is higher than the maximum input value for basic or extended function for that processor then the data for the highest basic information leaf is returned. For example, using some Intel processors, the following is true: CPUID.EAX = 05H (* Returns MONITOR/MWAIT leaf. *) CPUID.EAX = 0AH (* Returns Architectural Performance Monitoring leaf. *) CPUID.EAX = 0BH (* Returns Extended Topology Enumeration leaf. *)2 CPUID.EAX =1FH (* Returns V2 Extended Topology Enumeration leaf. *)2 CPUID.EAX = 80000008H (* Returns linear/physical address size data. *) CPUID.EAX = 8000000AH (* INVALID: Returns same information as CPUID.EAX = 0BH. *)\nIf a value entered for CPUID.EAX is less than or equal to the maximum input value and the leaf is not supported on that processor then 0 is returned in all the registers.\nWhen CPUID returns the highest basic leaf information as a result of an invalid input EAX value, any dependence on input ECX value in the basic leaf is honored.\nCPUID can be executed at any privilege level to serialize instruction execution. Serializing instruction execution guarantees that any modifications to flags, registers, and memory for previous instructions are completed before the next instruction is fetched and executed.\nSee also:\n\342\200\234Serializing Instructions\342\200\235 in Chapter 8, \342\200\234Multiple-Processor Management,\342\200\235 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3A.\n\342\200\234Caching Translation Information\342\200\235 in Chapter 4, \342\200\234Paging,\342\200\235 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3A.\n1.\tOn Intel 64 processors, CPUID clears the high 32 bits of the RAX/RBX/RCX/RDX registers in all modes.\n2.\tCPUID leaf 1FH is a preferred superset to leaf 0BH. Intel recommends first checking for the existence of CPUID leaf 1FH before using leaf 0BH.\nTable 3-8.  Information Returned by CPUID Instruction\nInitial EAX Value\tInformation Provided about the Processor\nBasic CPUID Information\n0H\tEAX\tMaximum Input Value for Basic CPUID Information.\nEBX\t\342\200\234Genu\342\200\235\nECX\t\342\200\234ntel\342\200\235\nEDX\t\342\200\234ineI\342\200\235\n01H\tEAX\tVersion Information: Type, Family, Model, and Stepping ID (see Figure3-6).\nEBX\tBits 07 - 00: Brand Index.\nBits 15 - 08: CLFLUSH line size (Value \342\210\227 8 = cache line size in bytes; used also by CLFLUSHOPT).\nBits 23 - 16: Maximum number of addressable IDs for logical processors in this physical package*.\nBits 31 - 24: Initial APIC ID**.\nECX\tFeature Information (see Figure3-7 and Table 3-10).\nEDX\tFeature Information (see Figure3-8 and Table 3-11).\nNOTES:\n* The nearest power-of-2 integer that is not smaller than EBX[23:16] is the number of unique initial APIC IDs reserved for addressing different logical processors in a physical package. This field is only valid if CPUID.1.EDX.HTT[bit 28]= 1.\n**The 8-bit initial APIC ID in EBX[31:24] is replaced by the 32-bit x2APIC ID, available in Leaf 0BH and Leaf 1FH.\n02H\tEAX\tCache and TLB Information (see Table 3-12).\nEBX\tCache and TLB Information.\nECX\tCache and TLB Information.\nEDX\tCache and TLB Information.\n03H\tEAX\tReserved.\nEBX\tReserved.\nECX\tBits 00 - 31 of 96 bit processor serial number. (Available in Pentium III processor only; otherwise, the value in this register is reserved.)\nEDX\tBits 32 - 63 of 96 bit processor serial number. (Available in Pentium III processor only; otherwise, the value in this register is reserved.)\nNOTES:\nProcessor serial number (PSN) is not supported in the Pentium 4 processor or later. On all models, use the PSN flag (returned using CPUID) to check for PSN support before accessing the feature.\nCPUID leaves above 2 and below 80000000H are visible only when IA32_MISC_ENABLE[bit 22] has its default value of 0.\nDeterministic Cache Parameters Leaf\n04H\tNOTES:\nLeaf 04H output depends on the initial value in ECX.* See also: \342\200\234INPUT EAX = 04H: Returns Deterministic Cache Parameters for Each Level\342\200\235 on page227.\nEAX\tBits 04 - 00: Cache Type Field.\n0 = Null - No more caches.\n1 = Data Cache.\n2 = Instruction Cache.\n3 = Unified Cache.\n4-31 = Reserved.\nTable 3-8.  Information Returned by CPUID Instruction (Contd.)\nInitial EAX Value\tInformation Provided about the Processor\nBits 07 - 05: Cache Level (starts at 1).\nBit 08: Self Initializing cache level (does not need SW initialization).\nBit 09: Fully Associative cache.\nBits 13 - 10: Reserved.\nBits 25 - 14: Maximum number of addressable IDs for logical processors sharing this cache**,***.\nBits 31 - 26: Maximum number of addressable IDs for processor cores in the physical package**,****,*****.\nEBX\tBits 11 - 00: L = System Coherency Line Size**.\nBits 21 - 12: P = Physical Line partitions**.\nBits 31 - 22: W = Ways of associativity**.\nECX\tBits 31-00: S = Number of Sets**.\nEDX\tBit 00: Write-Back Invalidate/Invalidate.\n0=\nWBINVD/INVD from threads sharing this cache acts upon lower level caches for threads sharing this cache.\n1=\nWBINVD/INVD is not guaranteed to act upon lower level caches of non-originating threads sharing this cache.\nBit 01: Cache Inclusiveness.\n0=Cache is not inclusive of lower cache levels.\n1=Cache is inclusive of lower cache levels.\nBit 02: Complex Cache Indexing.\n0=Direct mapped cache.\n1=A complex function is used to index the cache, potentially using all address bits.\nBits 31 - 03: Reserved = 0.\nNOTES:\n* If ECX contains an invalid sub leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf index n+1 is invalid if subleaf n returns EAX[4:0] as 0.\n**Add one to the return value to get the result.\n***The nearest power-of-2 integer that is not smaller than (1 + EAX[25:14]) is the number of unique initial APIC IDs reserved for addressing different logical processors sharing this cache.\n**** The nearest power-of-2 integer that is not smaller than (1 + EAX[31:26]) is the number of unique Core_IDs reserved for addressing different processor cores in a physical package. Core ID is a subset of bits of the initial APIC ID.\n***** The returned value is constant for valid initial values in ECX. Valid ECX values start from 0.\nMONITOR/MWAIT Leaf\n05H\tEAX\tBits 15 - 00: Smallest monitor-line size in bytes (default is processor\'s monitor granularity).\nBits 31 - 16: Reserved = 0.\nEBX\tBits 15 - 00: Largest monitor-line size in bytes (default is processor\'s monitor granularity).\nBits 31 - 16: Reserved = 0.\nECX\tBit 00: Enumeration of Monitor-Mwait extensions (beyond EAX and EBX registers) supported.\nBit 01: Supports treating interrupts as break-event for MWAIT, even when interrupts disabled.\nBits 31 - 02: Reserved.\nTable 3-8.  Information Returned by CPUID Instruction (Contd.)\nInitial EAX Value\tInformation Provided about the Processor\nEDX\tBits 03 - 00: Number of C0* sub C-states supported using MWAIT.\nBits 07 - 04: Number of C1* sub C-states supported using MWAIT.\nBits 11 - 08: Number of C2* sub C-states supported using MWAIT.\nBits 15 - 12: Number of C3* sub C-states supported using MWAIT.\nBits 19 - 16: Number of C4* sub C-states supported using MWAIT.\nBits 23 - 20: Number of C5* sub C-states supported using MWAIT.\nBits 27 - 24: Number of C6* sub C-states supported using MWAIT.\nBits 31 - 28: Number of C7* sub C-states supported using MWAIT.\nNOTE:\n* The definition of C0 through C7 states for MWAIT extension are processor-specific C-states, not ACPI Cstates.\nThermal and Power Management Leaf\n06H\tEAX\tBit 00: Digital temperature sensor is supported if set.\nBit 01: Intel Turbo Boost Technology available (see description of IA32_MISC_ENABLE[38]).\nBit 02: ARAT. APIC-Timer-always-running feature is supported if set.\nBit 03: Reserved.\nBit 04: PLN. Power limit notification controls are supported if set.\nBit 05: ECMD. Clock modulation duty cycle extension is supported if set.\nBit 06: PTM. Package thermal management is supported if set.\nBit 07: HWP. HWP base registers (IA32_PM_ENABLE[bit 0], IA32_HWP_CAPABILITIES, IA32_HWP_REQUEST, IA32_HWP_STATUS) are supported if set.\nBit 08: HWP_Notification. IA32_HWP_INTERRUPT MSR is supported if set.\nBit 09: HWP_Activity_Window. IA32_HWP_REQUEST[bits 41:32] is supported if set.\nBit 10: HWP_Energy_Performance_Preference. IA32_HWP_REQUEST[bits 31:24] is supported if set.\nBit 11: HWP_Package_Level_Request. IA32_HWP_REQUEST_PKG MSR is supported if set.\nBit 12: Reserved.\nBit 13: HDC. HDC base registers IA32_PKG_HDC_CTL, IA32_PM_CTL1, IA32_THREAD_STALL MSRs are supported if set.\nBit 14: Intel\302\256 Turbo Boost Max Technology 3.0 available.\nBit 15: HWP Capabilities. Highest Performance change is supported if set.\nBit 16: HWP PECI override is supported if set.\nBit 17: Flexible HWP is supported if set.\nBit 18: Fast access mode for the IA32_HWP_REQUEST MSR is supported if set.\nBit 19: HW_FEEDBACK. IA32_HW_FEEDBACK_PTR MSR, IA32_HW_FEEDBACK_CONFIG MSR, IA32_PACKAGE_THERM_STATUS MSR bit 26, and IA32_PACKAGE_THERM_INTERRUPT MSR bit 25 are supported if set.\nBit 20: Ignoring Idle Logical Processor HWP request is supported if set.\nBits 31 - 21: Reserved.\nEBX\tBits 03 - 00: Number of Interrupt Thresholds in Digital Thermal Sensor.\nBits 31 - 04: Reserved.\nECX\tBit 00: Hardware Coordination Feedback Capability (Presence of IA32_MPERF and IA32_APERF). The capability to provide a measure of delivered processor performance (since last reset of the counters), as a percentage of the expected processor performance when running at the TSC frequency.\nBits 02 - 01: Reserved = 0.\nBit 03: The processor supports performance-energy bias preference if CPUID.06H:ECX.SETBH[bit 3] is set and it also implies the presence of a new architectural MSR called IA32_ENERGY_PERF_BIAS (1B0H).\nBits 31 - 04: Reserved = 0.\nTable 3-8.  Information Returned by CPUID Instruction (Contd.)\nInitial EAX Value\tInformation Provided about the Processor\nEDX\tBits 7-0: Bitmap of supported hardware feedback interface capabilities.\n0 = When set to 1, indicates support for performance capability reporting.\n1 = When set to 1, indicates support for energy efficiency capability reporting.\n2-7 = Reserved Bits 11-8: Enumerates the size of the hardware feedback interface structure in number of 4 KB pages; add one to the return value to get the result.\nBits 31-16: Index (starting at 0) of this logical processor\'s row in the hardware feedback interface structure. Note that on some parts the index may be same for multiple logical processors. On some parts the indices may not be contiguous, i.e., there may be unused rows in the hardware feedback interface structure.\nNOTE:\nBits 0 and 1 will always be set together.\nStructured Extended Feature Flags Enumeration Leaf (Output depends on ECX input value)\n07H\tSub-leaf 0 (Input ECX = 0). *\nEAX\tBits 31 - 00: Reports the maximum input value for supported leaf 7 sub-leaves.\nEBX\tBit 00: FSGSBASE. Supports RDFSBASE/RDGSBASE/WRFSBASE/WRGSBASE if 1.\nBit 01: IA32_TSC_ADJUST MSR is supported if 1.\nBit 02: SGX. Supports Intel\302\256 Software Guard Extensions (Intel\302\256 SGX Extensions) if 1.\nBit 03: BMI1.\nBit 04: HLE.\nBit 05: AVX2.\nBit 06: FDP_EXCPTN_ONLY. x87 FPU Data Pointer updated only on x87 exceptions if 1.\nBit 07: SMEP. Supports Supervisor-Mode Execution Prevention if 1.\nBit 08: BMI2.\nBit 09: Supports Enhanced REP MOVSB/STOSB if 1.\nBit 10: INVPCID. If 1, supports INVPCID instruction for system software that manages process-context identifiers.\nBit 11: RTM.\nBit 12: RDT-M. Supports Intel\302\256 Resource Director Technology (Intel\302\256 RDT) Monitoring capability if 1.\nBit 13: Deprecates FPU CS and FPU DS values if 1.\nBit 14: MPX. Supports Intel\302\256 Memory Protection Extensions if 1.\nBit 15: RDT-A. Supports Intel\302\256 Resource Director Technology (Intel\302\256 RDT) Allocation capability if 1.\nBit 16: AVX512F.\nBit 17: AVX512DQ.\nBit 18: RDSEED.\nBit 19: ADX.\nBit 20: SMAP. Supports Supervisor-Mode Access Prevention (and the CLAC/STAC instructions) if 1.\nBit 21: AVX512_IFMA.\nBit 22: Reserved.\nBit 23: CLFLUSHOPT.\nBit 24: CLWB.\nBit 25: Intel Processor Trace.\nBit 26: AVX512PF. (Intel\302\256 Xeon Phi\342\204\242 only.) Bit 27: AVX512ER. (Intel\302\256 Xeon Phi\342\204\242 only.) Bit 28: AVX512CD.\nBit 29: SHA. supports Intel\302\256 Secure Hash Algorithm Extensions (Intel\302\256 SHA Extensions) if 1.\nBit 30: AVX512BW.\nBit 31: AVX512VL.\nTable 3-8.  Information Returned by CPUID Instruction (Contd.)\nInitial EAX Value\tInformation Provided about the Processor\nECX\tBit 00: PREFETCHWT1. (Intel\302\256 Xeon Phi\342\204\242 only.) Bit 01: AVX512_VBMI.\nBit 02: UMIP. Supports user-mode instruction prevention if 1.\nBit 03: PKU. Supports protection keys for user-mode pages if 1.\nBit 04: OSPKE. If 1, OS has set CR4.PKE to enable protection keys (and the RDPKRU/WRPKRU instructions).\nBit 05: WAITPKG.\nBit 06: AVX512_VBMI2.\nBit 07: CET_SS. Supports CET shadow stack features if 1. Processors that set this bit define bits 1:0 of the IA32_U_CET and IA32_S_CET MSRs. Enumerates support for the following MSRs: IA32_INTERRUPT_SPP_TABLE_ADDR, IA32_PL3_SSP, IA32_PL2_SSP, IA32_PL1_SSP, and IA32_PL0_SSP.\nBit 08: GFNI.\nBit 09: VAES.\nBit 10: VPCLMULQDQ.\nBit 11: AVX512_VNNI.\nBit 12: AVX512_BITALG.\nBits 13: Reserved.\nBit 14: AVX512_VPOPCNTDQ. (Intel\302\256 Xeon Phi\342\204\242 only.) Bits 16 - 15: Reserved.\nBits 21 - 17: The value of MAWAU used by the BNDLDX and BNDSTX instructions in 64-bit mode.\nBit 22: RDPID and IA32_TSC_AUX are available if 1.\nBits 24 - 23: Reserved.\nBit 25: CLDEMOTE. Supports cache line demote if 1.\nBit 26: Reserved.\nBit 27: MOVDIRI. Supports MOVDIRI if 1.\nBit 28: MOVDIR64B. Supports MOVDIR64B if 1.\nBit 29: Reserved.\nBit 30: SGX_LC. Supports SGX Launch Configuration if 1.\nBit 31: PKS. Supports protection keys for supervisor-mode pages if 1.\nEDX\tBit 01: Reserved.\nBit 02: AVX512_4VNNIW. (Intel\302\256 Xeon Phi\342\204\242 only.) Bit 03: AVX512_4FMAPS. (Intel\302\256 Xeon Phi\342\204\242 only.) Bit 04: Fast Short REP MOV.\nBits 09-05: Reserved.\nBit 10: MD_CLEAR supported.\nBits 14-11: Reserved.\nBit 15: Hybrid. If 1, the processor is identified as a hybrid part.\nBits 19-16: Reserved.\nBit 20: CET_IBT. Supports CET indirect branch tracking features if 1. Processors that set this bit define bits 5:2 and bits 63:10 of the IA32_U_CET and IA32_S_CET MSRs.\nBits 25 - 21: Reserved.\nBit 26: Enumerates support for indirect branch restricted speculation (IBRS) and the indirect branch predictor barrier (IBPB). Processors that set this bit support the IA32_SPEC_CTRL MSR and the IA32_PRED_CMD MSR. They allow software to set IA32_SPEC_CTRL[0] (IBRS) and IA32_PRED_CMD[0] (IBPB).\nBit 27: Enumerates support for single thread indirect branch predictors (STIBP). Processors that set this bit support the IA32_SPEC_CTRL MSR. They allow software to set IA32_SPEC_CTRL[1] (STIBP).\nBit 28: Enumerates support for L1D_FLUSH. Processors that set this bit support the IA32_FLUSH_CMD MSR. They allow software to set IA32_FLUSH_CMD[0] (L1D_FLUSH).\nBit 29: Enumerates support for the IA32_ARCH_CAPABILITIES MSR.\nTable 3-8.  Information Returned by CPUID Instruction (Contd.)\nInitial EAX Value\tInformation Provided about the Processor\nBit 30: Enumerates support for the IA32_CORE_CAPABILITIES MSR.\nIA32_CORE_CAPABILITIES is an architectural MSR that enumerates model-specific features. A bit being set in this MSR indicates that a model specific feature is supported; software must still consult CPUID family/model/stepping to determine the behavior of the enumerated feature as features enumerated in IA32_CORE_CAPABILITIES may have different behavior on different processor models.\nAdditionally, on hybrid parts (CPUID.07H.0H:EDX[15]=1), software must consult the native model ID and core type from the Hybrid Information Enumeration Leaf.\nBit 31: Enumerates support for Speculative Store Bypass Disable (SSBD). Processors that set this bit support the IA32_SPEC_CTRL MSR. They allow software to set IA32_SPEC_CTRL[2] (SSBD).\nNOTE:\n* If ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf index n is invalid if n exceeds the value that sub-leaf 0 returns in EAX.\nDirect Cache Access Information Leaf\n09H\tEAX\tValue of bits [31:0] of IA32_PLATFORM_DCA_CAP MSR (address 1F8H).\nEBX\tReserved.\nECX\tReserved.\nEDX\tReserved.\nArchitectural Performance Monitoring Leaf\n0AH\tEAX\tBits 07 - 00: Version ID of architectural performance monitoring.\nBits 15 - 08: Number of general-purpose performance monitoring counter per logical processor.\nBits 23 - 16: Bit width of general-purpose, performance monitoring counter.\nBits 31 - 24: Length of EBX bit vector to enumerate architectural performance monitoring events.\nEBX\tBit 00: Core cycle event not available if 1.\nBit 01: Instruction retired event not available if 1.\nBit 02: Reference cycles event not available if 1.\nBit 03: Last-level cache reference event not available if 1.\nBit 04: Last-level cache misses event not available if 1.\nBit 05: Branch instruction retired event not available if 1.\nBit 06: Branch mispredict retired event not available if 1.\nBits 31 - 07: Reserved = 0.\nECX\tReserved = 0.\nEDX\tBits 04 - 00: Number of fixed-function performance counters (if Version ID > 1).\nBits 12 - 05: Bit width of fixed-function performance counters (if Version ID > 1).\nBits 14 - 13: Reserved = 0.\nBit 15: AnyThread deprecation.\nBits 31 - 16: Reserved = 0.\nTable 3-8.  Information Returned by CPUID Instruction (Contd.)\nInitial EAX Value\tInformation Provided about the Processor\nExtended Topology Enumeration Leaf\n0BH\tNOTES:\nCPUID leaf 1FH is a preferred superset to leaf 0BH. Intel recommends first checking for the existence of Leaf 1FH before using leaf 0BH.\nMost of Leaf 0BH output depends on the initial value in ECX.\nThe EDX output of leaf 0BH is always valid and does not vary with input value in ECX.\nOutput value in ECX[7:0] always equals input value in ECX[7:0].\nSub-leaf index 0 enumerates SMT level. Each subsequent higher sub-leaf index enumerates a higherlevel topological entity in hierarchical order.\nFor sub-leaves that return an invalid level-type of 0 in ECX[15:8]; EAX and EBX will return 0.\nIf an input value n in ECX returns the invalid level-type of 0 in ECX[15:8], other input values with ECX > n also return 0 in ECX[15:8].\nEAX\tBits 04 - 00: Number of bits to shift right on x2APIC ID to get a unique topology ID of the next level type*.\nAll logical processors with the same next level ID share current level.\nBits 31 - 05: Reserved.\nEBX\tBits 15 - 00: Number of logical processors at this level type. The number reflects configuration as shipped by Intel**.\nBits 31- 16: Reserved.\nECX\tBits 07 - 00: Level number. Same value in ECX input.\nBits 15 - 08: Level type***.\nBits 31 - 16: Reserved.\nEDX\tBits 31- 00: x2APIC ID the current logical processor.\nNOTES:\n* Software should use this field (EAX[4:0]) to enumerate processor topology of the system.\n** Software must not use EBX[15:0] to enumerate processor topology of the system. This value in this field (EBX[15:0]) is only intended for display/diagnostic purposes. The actual number of logical processors available to BIOS/OS/Applications may be different from the value of EBX[15:0], depending on software and platform hardware configurations.\n*** The value of the \342\200\234level type\342\200\235 field is not related to level numbers in any way, higher \342\200\234level type\342\200\235 values do not mean higher levels. Level type field has the following encoding: 0: Invalid.\n1: SMT.\n2: Core.\n3-255: Reserved.\nTable 3-8.  Information Returned by CPUID Instruction (Contd.)\nInitial EAX Value\tInformation Provided about the Processor\nProcessor Extended State Enumeration Main Leaf (EAX = 0DH, ECX = 0)\n0DH\tNOTES:\nLeaf 0DH main leaf (ECX = 0).\nEAX\tBits 31 - 00: Reports the supported bits of the lower 32 bits of XCR0. XCR0[n] can be set to 1 only if EAX[n] is 1.\nBit 00: x87 state.\nBit 01: SSE state.\nBit 02: AVX state.\nBits 04 - 03: MPX state.\nBits 07 - 05: AVX-512 state.\nBit 08: Used for IA32_XSS.\nBit 09: PKRU state.\nBits 12 - 10: Reserved.\nBit 13: Used for IA32_XSS.\nBits 15 - 14: Reserved.\nBit 16: Used for IA32_XSS.\nBits 31 - 17: Reserved.\nEBX\tBits 31 - 00: Maximum size (bytes, from the beginning of the XSAVE/XRSTOR save area) required by enabled features in XCR0. May be different than ECX if some features at the end of the XSAVE save area are not enabled.\nECX\tBit 31 - 00: Maximum size (bytes, from the beginning of the XSAVE/XRSTOR save area) of the XSAVE/XRSTOR save area required by all supported features in the processor, i.e., all the valid bit fields in XCR0.\nEDX\tBit 31 - 00: Reports the supported bits of the upper 32 bits of XCR0. XCR0[n+32] can be set to 1 only if EDX[n] is 1.\nBits 31 - 00: Reserved.\nProcessor Extended State Enumeration Sub-leaf (EAX = 0DH, ECX = 1)\n0DH\tEAX\tBit 00: XSAVEOPT is available.\nBit 01: Supports XSAVEC and the compacted form of XRSTOR if set.\nBit 02: Supports XGETBV with ECX = 1 if set.\nBit 03: Supports XSAVES/XRSTORS and IA32_XSS if set.\nBits 31 - 04: Reserved.\nEBX\tBits 31 - 00: The size in bytes of the XSAVE area containing all states enabled by XCRO | IA32_XSS.\nECX\tBits 31 - 00: Reports the supported bits of the lower 32 bits of the IA32_XSS MSR. IA32_XSS[n] can be set to 1 only if ECX[n] is 1.\nBits 07 - 00: Used for XCR0.\nBit 08: PT state.\nBit 09: Used for XCR0.\nBit 10: Reserved.\nBit 11: CET user state.\nBit 12: CET supervisor state.\nBit 13: HDC state.\nBits 15 - 14: Reserved.\nBit 16: HWP state.\nBits 31 - 17: Reserved.\nEDX\tBits 31 - 00: Reports the supported bits of the upper 32 bits of the IA32_XSS MSR. IA32_XSS[n+32] can be set to 1 only if EDX[n] is 1.\nBits 31 - 00: Reserved.\nTable 3-8.  Information Returned by CPUID Instruction (Contd.)\nInitial EAX Value\tInformation Provided about the Processor\nProcessor Extended State Enumeration Sub-leaves (EAX = 0DH, ECX = n, n > 1)\n0DH\tNOTES:\nLeaf 0DH output depends on the initial value in ECX.\nEach sub-leaf index (starting at position 2) is supported if it corresponds to a supported bit in either the XCR0 register or the IA32_XSS MSR.\n* If ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf n (0 \342\211\244 n \342\211\244 31) is invalid if sub-leaf 0 returns 0 in EAX[n] and sub-leaf 1 returns 0 in ECX[n]. Sub-leaf n (32 \342\211\244 n \342\211\244 63) is invalid if sub-leaf 0 returns 0 in EDX[n-32] and sub-leaf 1 returns 0 in EDX[n-32].\nEAX\tBits 31 - 0: The size in bytes (from the offset specified in EBX) of the save area for an extended state feature associated with a valid sub-leaf index, n.\nEBX\tBits 31 - 0: The offset in bytes of this extended state component\342\200\231s save area from the beginning of the XSAVE/XRSTOR area.\nThis field reports 0 if the sub-leaf index, n, does not map to a valid bit in the XCR0 register*.\nECX\tBit 00 is set if the bit n (corresponding to the sub-leaf index) is supported in the IA32_XSS MSR; it is clear if bit n is instead supported in XCR0.\nBit 01 is set if, when the compacted format of an XSAVE area is used, this extended state component located on the next 64-byte boundary following the preceding state component (otherwise, it is located immediately following the preceding state component).\nBits 31 - 02 are reserved.\nThis field reports 0 if the sub-leaf index, n, is invalid*.\nEDX\tThis field reports 0 if the sub-leaf index, n, is invalid*; otherwise it is reserved.\nIntel Resource Director Technology (Intel RDT) Monitoring Enumeration Sub-leaf (EAX = 0FH, ECX = 0)\n0FH\tNOTES:\nLeaf 0FH output depends on the initial value in ECX.\nSub-leaf index 0 reports valid resource type starting at bit position 1 of EDX.\nEAX\tReserved.\nEBX\tBits 31 - 00: Maximum range (zero-based) of RMID within this physical processor of all types.\nECX\tReserved.\nEDX\tBit 00: Reserved.\nBit 01: Supports L3 Cache Intel RDT Monitoring if 1.\nBits 31 - 02: Reserved.\nTable 3-8.  Information Returned by CPUID Instruction (Contd.)\nInitial EAX Value\tInformation Provided about the Processor\nL3 Cache Intel RDT Monitoring Capability Enumeration Sub-leaf (EAX = 0FH, ECX = 1)\n0FH\tNOTES:\nLeaf 0FH output depends on the initial value in ECX.\nEAX\tReserved.\nEBX\tBits 31 - 00: Conversion factor from reported IA32_QM_CTR value to occupancy metric (bytes) and Memory Bandwidth Monitoring (MBM) metrics.\nECX\tMaximum range (zero-based) of RMID of this resource type.\nEDX\tBit 00: Supports L3 occupancy monitoring if 1.\nBit 01: Supports L3 Total Bandwidth monitoring if 1.\nBit 02: Supports L3 Local Bandwidth monitoring if 1.\nBits 31 - 03: Reserved.\nIntel Resource Director Technology (Intel RDT) Allocation Enumeration Sub-leaf (EAX = 10H, ECX = 0)\n10H\tNOTES:\nLeaf 10H output depends on the initial value in ECX.\nSub-leaf index 0 reports valid resource identification (ResID) starting at bit position 1 of EBX.\nEAX\tReserved.\nEBX\tBit 00: Reserved.\nBit 01: Supports L3 Cache Allocation Technology if 1.\nBit 02: Supports L2 Cache Allocation Technology if 1.\nBit 03: Supports Memory Bandwidth Allocation if 1.\nBits 31 - 04: Reserved.\nECX\tReserved.\nEDX\tReserved.\nL3 Cache Allocation Technology Enumeration Sub-leaf (EAX = 10H, ECX = ResID =1)\n10H\tNOTES:\nLeaf 10H output depends on the initial value in ECX.\nEAX\tBits 04 - 00: Length of the capacity bit mask for the corresponding ResID using minus-one notation.\nBits 31 - 05: Reserved.\nEBX\tBits 31 - 00: Bit-granular map of isolation/contention of allocation units.\nECX\tBits 01- 00: Reserved.\nBit 02: Code and Data Prioritization Technology supported if 1.\nBits 31 - 03: Reserved.\nEDX\tBits 15 - 00: Highest COS number supported for this ResID.\nBits 31 - 16: Reserved.\nL2 Cache Allocation Technology Enumeration Sub-leaf (EAX = 10H, ECX = ResID =2)\n10H\tNOTES:\nLeaf 10H output depends on the initial value in ECX.\nEAX\tBits 04 - 00: Length of the capacity bit mask for the corresponding ResID using minus-one notation.\nBits 31 - 05: Reserved.\nEBX\tBits 31 - 00: Bit-granular map of isolation/contention of allocation units.\nECX\tBits 31 - 00: Reserved.\nEDX\tBits 15 - 00: Highest COS number supported for this ResID.\nBits 31 - 16: Reserved.\nTable 3-8.  Information Returned by CPUID Instruction (Contd.)\nInitial EAX Value\tInformation Provided about the Processor\nMemory Bandwidth Allocation Enumeration Sub-leaf (EAX = 10H, ECX = ResID =3)\n10H\tNOTES:\nLeaf 10H output depends on the initial value in ECX.\nEAX\tBits 11 - 00: Reports the maximum MBA throttling value supported for the corresponding ResID using minus-one notation.\nBits 31 - 12: Reserved.\nEBX\tBits 31 - 00: Reserved.\nECX\tBits 01 - 00: Reserved.\nBit 02: Reports whether the response of the delay values is linear.\nBits 31 - 03: Reserved.\nEDX\tBits 15 - 00: Highest COS number supported for this ResID.\nBits 31 - 16: Reserved.\nIntel SGX Capability Enumeration Leaf, sub-leaf 0 (EAX = 12H, ECX = 0)\n12H\tNOTES:\nLeaf 12H sub-leaf 0 (ECX = 0) is supported if CPUID.(EAX=07H, ECX=0H):EBX[SGX] = 1.\nEAX\tBit 00: SGX1. If 1, Indicates Intel SGX supports the collection of SGX1 leaf functions.\nBit 01: SGX2. If 1, Indicates Intel SGX supports the collection of SGX2 leaf functions.\nBits 04 - 02: Reserved.\nBit 05: If 1, indicates Intel SGX supports ENCLV instruction leaves EINCVIRTCHILD, EDECVIRTCHILD, and ESETCONTEXT.\nBit 06: If 1, indicates Intel SGX supports ENCLS instruction leaves ETRACKC, ERDINFO, ELDBC, and ELDUC.\nBits 31 - 07: Reserved.\nEBX\tBits 31 - 00: MISCSELECT. Bit vector of supported extended SGX features.\nECX\tBits 31 - 00: Reserved.\nEDX\tBits 07 - 00: MaxEnclaveSize_Not64. The maximum supported enclave size in non-64-bit mode is 2^(EDX[7:0]).\nBits 15 - 08: MaxEnclaveSize_64. The maximum supported enclave size in 64-bit mode is 2^(EDX[15:8]).\nBits 31 - 16: Reserved.\nIntel SGX Attributes Enumeration Leaf, sub-leaf 1 (EAX = 12H, ECX = 1)\n12H\tNOTES:\nLeaf 12H sub-leaf 1 (ECX = 1) is supported if CPUID.(EAX=07H, ECX=0H):EBX[SGX] = 1.\nEAX\tBit 31 - 00: Reports the valid bits of SECS.ATTRIBUTES[31:0] that software can set with ECREATE.\nEBX\tBit 31 - 00: Reports the valid bits of SECS.ATTRIBUTES[63:32] that software can set with ECREATE.\nECX\tBit 31 - 00: Reports the valid bits of SECS.ATTRIBUTES[95:64] that software can set with ECREATE.\nEDX\tBit 31 - 00: Reports the valid bits of SECS.ATTRIBUTES[127:96] that software can set with ECREATE.\nIntel SGX EPC Enumeration Leaf, sub-leaves (EAX = 12H, ECX = 2 or higher)\n12H\tNOTES:\nLeaf 12H sub-leaf 2 or higher (ECX >= 2) is supported if CPUID.(EAX=07H, ECX=0H):EBX[SGX] = 1.\nFor sub-leaves (ECX = 2 or higher), definition of EDX,ECX,EBX,EAX[31:4] depends on the sub-leaf type listed below.\nTable 3-8.  Information Returned by CPUID Instruction (Contd.)\nInitial EAX Value\tInformation Provided about the Processor\nEAX\tBit 03 - 00: Sub-leaf Type 0000b: Indicates this sub-leaf is invalid.\n0001b: This sub-leaf enumerates an EPC section. EBX:EAX and EDX:ECX provide information on the Enclave Page Cache (EPC) section.\nAll other type encodings are reserved.\nType\t0000b. This sub-leaf is invalid.\nEDX:ECX:EBX:EAX return 0.\nType\t0001b. This sub-leaf enumerates an EPC sections with EDX:ECX, EBX:EAX defined as follows.\nEAX[11:04]: Reserved (enumerate 0).\nEAX[31:12]: Bits 31:12 of the physical address of the base of the EPC section.\nEBX[19:00]: Bits 51:32 of the physical address of the base of the EPC section.\nEBX[31:20]: Reserved.\nECX[03:00]: EPC section property encoding defined as follows: If EAX[3:0] 0000b, then all bits of the EDX:ECX pair are enumerated as 0.\nIf EAX[3:0] 0001b, then this section has confidentiality and integrity protection.\nAll other encodings are reserved.\nECX[11:04]: Reserved (enumerate 0).\nECX[31:12]: Bits 31:12 of the size of the corresponding EPC section within the Processor Reserved Memory.\nEDX[19:00]: Bits 51:32 of the size of the corresponding EPC section within the Processor Reserved Memory.\nEDX[31:20]: Reserved.\nIntel Processor Trace Enumeration Main Leaf (EAX = 14H, ECX = 0)\n14H\tNOTES:\nLeaf 14H main leaf (ECX = 0).\nEAX\tBits 31 - 00: Reports the maximum sub-leaf supported in leaf 14H.\nEBX\tBit 00: If 1, indicates that IA32_RTIT_CTL.CR3Filter can be set to 1, and that IA32_RTIT_CR3_MATCH MSR can be accessed.\nBit 01: If 1, indicates support of Configurable PSB and Cycle-Accurate Mode.\nBit 02: If 1, indicates support of IP Filtering, TraceStop filtering, and preservation of Intel PT MSRs across warm reset.\nBit 03: If 1, indicates support of MTC timing packet and suppression of COFI-based packets.\nBit 04: If 1, indicates support of PTWRITE. Writes can set IA32_RTIT_CTL[12] (PTWEn) and IA32_RTIT_CTL[5] (FUPonPTW), and PTWRITE can generate packets.\nBit 05: If 1, indicates support of Power Event Trace. Writes can set IA32_RTIT_CTL[4] (PwrEvtEn), enabling Power Event Trace packet generation.\nBit 31 - 06: Reserved.\nECX\tBit 00: If 1, Tracing can be enabled with IA32_RTIT_CTL.ToPA = 1, hence utilizing the ToPA output scheme; IA32_RTIT_OUTPUT_BASE and IA32_RTIT_OUTPUT_MASK_PTRS MSRs can be accessed.\nBit 01: If 1, ToPA tables can hold any number of output entries, up to the maximum allowed by the MaskOrTableOffset field of IA32_RTIT_OUTPUT_MASK_PTRS.\nBit 02: If 1, indicates support of Single-Range Output scheme.\nBit 03: If 1, indicates support of output to Trace Transport subsystem.\nBit 30 - 04: Reserved.\nBit 31: If 1, generated packets which contain IP payloads have LIP values, which include the CS base component.\nEDX\tBits 31 - 00: Reserved.\nTable 3-8.  Information Returned by CPUID Instruction (Contd.)\nInitial EAX Value\tInformation Provided about the Processor\nIntel Processor Trace Enumeration Sub-leaf (EAX = 14H, ECX = 1)\n14H\tEAX\tBits 02 - 00: Number of configurable Address Ranges for filtering.\nBits 15 - 03: Reserved.\nBits 31 - 16: Bitmap of supported MTC period encodings.\nEBX\tBits 15 - 00: Bitmap of supported Cycle Threshold value encodings.\nBit 31 - 16: Bitmap of supported Configurable PSB frequency encodings.\nECX\tBits 31 - 00: Reserved.\nEDX\tBits 31 - 00: Reserved.\nTime Stamp Counter and Nominal Core Crystal Clock Information Leaf\n15H\tNOTES:\nIf EBX[31:0] is 0, the TSC/\342\200\235core crystal clock\342\200\235 ratio is not enumerated.\nEBX[31:0]/EAX[31:0] indicates the ratio of the TSC frequency and the core crystal clock frequency.\nIf ECX is 0, the nominal core crystal clock frequency is not enumerated.\n\342\200\234TSC frequency\342\200\235 = \342\200\234core crystal clock frequency\342\200\235 * EBX/EAX.\nThe core crystal clock may differ from the reference clock, bus clock, or core clock frequencies.\nEAX\tBits 31 - 00: An unsigned integer which is the denominator of the TSC/\342\200\235core crystal clock\342\200\235 ratio.\nEBX\tBits 31 - 00: An unsigned integer which is the numerator of the TSC/\342\200\235core crystal clock\342\200\235 ratio.\nECX\tBits 31 - 00: An unsigned integer which is the nominal frequency of the core crystal clock in Hz.\nEDX\tBits 31 - 00: Reserved = 0.\nProcessor Frequency Information Leaf\n16H\tEAX\tBits 15 - 00: Processor Base Frequency (in MHz).\nBits 31 - 16: Reserved =0.\nEBX\tBits 15 - 00: Maximum Frequency (in MHz).\nBits 31 - 16: Reserved = 0.\nECX\tBits 15 - 00: Bus (Reference) Frequency (in MHz).\nBits 31 - 16: Reserved = 0.\nEDX\tReserved.\nNOTES:\n* Data is returned from this interface in accordance with the processor\'s specification and does not reflect actual values. Suitable use of this data includes the display of processor information in like manner to the processor brand string and for determining the appropriate range to use when displaying processor information e.g. frequency history graphs. The returned information should not be used for any other purpose as the returned information does not accurately correlate to information / counters returned by other processor interfaces.\nWhile a processor may support the Processor Frequency Information leaf, fields that return a value of zero are not supported.\nSystem-On-Chip Vendor Attribute Enumeration Main Leaf (EAX = 17H, ECX = 0)\n17H\tNOTES:\nLeaf 17H main leaf (ECX = 0).\nLeaf 17H output depends on the initial value in ECX.\nLeaf 17H sub-leaves 1 through 3 reports SOC Vendor Brand String.\nLeaf 17H is valid if MaxSOCID_Index >= 3.\nLeaf 17H sub-leaves 4 and above are reserved.\nTable 3-8.  Information Returned by CPUID Instruction (Contd.)\nInitial EAX Value\tInformation Provided about the Processor\nEAX\tBits 31 - 00: MaxSOCID_Index. Reports the maximum input value of supported sub-leaf in leaf 17H.\nEBX\tBits 15 - 00: SOC Vendor ID.\nBit 16: IsVendorScheme. If 1, the SOC Vendor ID field is assigned via an industry standard enumeration scheme. Otherwise, the SOC Vendor ID field is assigned by Intel.\nBits 31 - 17: Reserved = 0.\nECX\tBits 31 - 00: Project ID. A unique number an SOC vendor assigns to its SOC projects.\nEDX\tBits 31 - 00: Stepping ID. A unique number within an SOC project that an SOC vendor assigns.\nSystem-On-Chip Vendor Attribute Enumeration Sub-leaf (EAX = 17H, ECX = 1..3)\n17H\tEAX\tBit 31 - 00: SOC Vendor Brand String. UTF-8 encoded string.\nEBX\tBit 31 - 00: SOC Vendor Brand String. UTF-8 encoded string.\nECX\tBit 31 - 00: SOC Vendor Brand String. UTF-8 encoded string.\nEDX\tBit 31 - 00: SOC Vendor Brand String. UTF-8 encoded string.\nNOTES:\nLeaf 17H output depends on the initial value in ECX.\nSOC Vendor Brand String is a UTF-8 encoded string padded with trailing bytes of 00H.\nThe complete SOC Vendor Brand String is constructed by concatenating in ascending order of EAX:EBX:ECX:EDX and from the sub-leaf 1 fragment towards sub-leaf 3.\nSystem-On-Chip Vendor Attribute Enumeration Sub-leaves (EAX = 17H, ECX > MaxSOCID_Index)\n17H\tNOTES:\nLeaf 17H output depends on the initial value in ECX.\nEAX\tBits 31 - 00: Reserved = 0.\nEBX\tBits 31 - 00: Reserved = 0.\nECX\tBits 31 - 00: Reserved = 0.\nEDX\tBits 31 - 00: Reserved = 0.\nDeterministic Address Translation Parameters Main Leaf (EAX = 18H, ECX = 0)\n18H\tNOTES:\nEach sub-leaf enumerates a different address translation structure.\nIf ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf index n is invalid if n exceeds the value that sub-leaf 0 returns in EAX. A sub-leaf index is also invalid if EDX[4:0] returns 0.\nValid sub-leaves do not need to be contiguous or in any particular order. A valid sub-leaf may be in a higher input ECX value than an invalid sub-leaf or than a valid sub-leaf of a higher or lower-level structure.\n* Some unified TLBs will allow a single TLB entry to satisfy data read/write and instruction fetches.\nOthers will require separate entries (e.g., one loaded on data read/write and another loaded on an instruction fetch) . Please see the Intel\302\256 64 and IA-32 Architectures Optimization Reference Manual for details of a particular product.\n** Add one to the return value to get the result.\nEAX\tBits 31 - 00: Reports the maximum input value of supported sub-leaf in leaf 18H.\nTable 3-8.  Information Returned by CPUID Instruction (Contd.)\nInitial EAX Value\tInformation Provided about the Processor\nEBX\tBit 00: 4K page size entries supported by this structure.\nBit 01: 2MB page size entries supported by this structure.\nBit 02: 4MB page size entries supported by this structure.\nBit 03: 1 GB page size entries supported by this structure.\nBits 07 - 04: Reserved.\nBits 10 - 08: Partitioning (0: Soft partitioning between the logical processors sharing this structure).\nBits 15 - 11: Reserved.\nBits 31 - 16: W = Ways of associativity.\nECX\tBits 31 - 00: S = Number of Sets.\nEDX\tBits 04 - 00: Translation cache type field.\n00000b: Null (indicates this sub-leaf is not valid).\n00001b: Data TLB.\n00010b: Instruction TLB.\n00011b: Unified TLB*.\n00100b: Load Only TLB. Hit on loads; fills on both loads and stores.\n00101b: Store Only TLB. Hit on stores; fill on stores.\nAll other encodings are reserved.\nBits 07 - 05: Translation cache level (starts at 1).\nBit 08: Fully associative structure.\nBits 13 - 09: Reserved.\nBits 25- 14: Maximum number of addressable IDs for logical processors sharing this translation cache** Bits 31 - 26: Reserved.\nDeterministic Address Translation Parameters Sub-leaf (EAX = 18H, ECX \342\211\245 1)\n18H\tNOTES:\nEach sub-leaf enumerates a different address translation structure.\nIf ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf index n is invalid if n exceeds the value that sub-leaf 0 returns in EAX. A sub-leaf index is also invalid if EDX[4:0] returns 0.\nValid sub-leaves do not need to be contiguous or in any particular order. A valid sub-leaf may be in a higher input ECX value than an invalid sub-leaf or than a valid sub-leaf of a higher or lower-level structure.\n* Some unified TLBs will allow a single TLB entry to satisfy data read/write and instruction fetches.\nOthers will require separate entries (e.g., one loaded on data read/write and another loaded on an instruction fetch) . Please see the Intel\302\256 64 and IA-32 Architectures Optimization Reference Manual for details of a particular product.\n** Add one to the return value to get the result.\nEAX\tBits 31 - 00: Reserved.\nEBX\tBit 00: 4K page size entries supported by this structure.\nBit 01: 2MB page size entries supported by this structure.\nBit 02: 4MB page size entries supported by this structure.\nBit 03: 1 GB page size entries supported by this structure.\nBits 07 - 04: Reserved.\nBits 10 - 08: Partitioning (0: Soft partitioning between the logical processors sharing this structure).\nBits 15 - 11: Reserved.\nBits 31 - 16: W = Ways of associativity.\nECX\tBits 31 - 00: S = Number of Sets.\nTable 3-8.  Information Returned by CPUID Instruction (Contd.)\nInitial EAX Value\tInformation Provided about the Processor\nEDX\tBits 04 - 00: Translation cache type field.\n0000b: Null (indicates this sub-leaf is not valid).\n0001b: Data TLB.\n0010b: Instruction TLB.\n0011b: Unified TLB*.\nAll other encodings are reserved.\nBits 07 - 05: Translation cache level (starts at 1).\nBit 08: Fully associative structure.\nBits 13 - 09: Reserved.\nBits 25- 14: Maximum number of addressable IDs for logical processors sharing this translation cache** Bits 31 - 26: Reserved.\nHybrid Information Enumeration Leaf (EAX = 1AH, ECX = 0)\n1AH\tEAX\tEnumerates the native model ID and core type.\nBits 31-24: Core type 10H: Reserved 20H: Intel Atom\302\256 30H: Reserved 40H: Intel\302\256 Core\342\204\242 Bits 23-0: Native model ID of the core. The core-type and native mode ID can be used to uniquely identify the microarchitecture of the core. This native model ID is not unique across core types, and not related to the model ID reported in CPUID leaf 01H, and does not identify the SOC.\nEBX\tReserved.\nECX\tReserved.\nEDX\tReserved.\nV2 Extended Topology Enumeration Leaf\n1FH\tNOTES:\nCPUID leaf 1FH is a preferred superset to leaf 0BH. Intel recommends first checking for the existence of Leaf 1FH and using this if available.\nMost of Leaf 1FH output depends on the initial value in ECX.\nThe EDX output of leaf 1FH is always valid and does not vary with input value in ECX.\nOutput value in ECX[7:0] always equals input value in ECX[7:0].\nSub-leaf index 0 enumerates SMT level. Each subsequent higher sub-leaf index enumerates a higherlevel topological entity in hierarchical order.\nFor sub-leaves that return an invalid level-type of 0 in ECX[15:8]; EAX and EBX will return 0.\nIf an input value n in ECX returns the invalid level-type of 0 in ECX[15:8], other input values with ECX > n also return 0 in ECX[15:8].\nEAX\tBits 04 - 00: Number of bits to shift right on x2APIC ID to get a unique topology ID of the next level type*.\nAll logical processors with the same next level ID share current level.\nBits 31 - 05: Reserved.\nEBX\tBits 15 - 00: Number of logical processors at this level type. The number reflects configuration as shipped by Intel**.\nBits 31- 16: Reserved.\nECX\tBits 07 - 00: Level number. Same value in ECX input.\nBits 15 - 08: Level type***.\nBits 31 - 16: Reserved.\nEDX\tBits 31- 00: x2APIC ID the current logical processor.\nTable 3-8.  Information Returned by CPUID Instruction (Contd.)\nInitial EAX Value\tInformation Provided about the Processor\nNOTES:\n* Software should use this field (EAX[4:0]) to enumerate processor topology of the system.\n** Software must not use EBX[15:0] to enumerate processor topology of the system. This value in this field (EBX[15:0]) is only intended for display/diagnostic purposes. The actual number of logical processors available to BIOS/OS/Applications may be different from the value of EBX[15:0], depending on software and platform hardware configurations.\n*** The value of the \342\200\234level type\342\200\235 field is not related to level numbers in any way, higher \342\200\234level type\342\200\235 values do not mean higher levels. Level type field has the following encoding: 0: Invalid.\n1: SMT.\n2: Core.\n3: Module.\n4: Tile.\n5: Die.\n6-255: Reserved.\nUnimplemented CPUID Leaf Functions\n40000000H\n- 4FFFFFFFH\tInvalid. No existing or future CPU will return processor identification or feature information if the initial EAX value is in the range 40000000H to 4FFFFFFFH.\nExtended Function CPUID Information\n80000000H\tEAX\tMaximum Input Value for Extended Function CPUID Information.\nEBX\tReserved.\nECX\tReserved.\nEDX\tReserved.\n80000001H\tEAX\tExtended Processor Signature and Feature Bits.\nEBX\tReserved.\nECX\tBit 00: LAHF/SAHF available in 64-bit mode.* Bits 04 - 01: Reserved.\nBit 05: LZCNT.\nBits 07 - 06: Reserved.\nBit 08: PREFETCHW.\nBits 31 - 09: Reserved.\nEDX\tBits 10 - 00: Reserved.\nBit 11: SYSCALL/SYSRET.** Bits 19 - 12: Reserved = 0.\nBit 20: Execute Disable Bit available.\nBits 25 - 21: Reserved = 0.\nBit26: 1-GByte pages are available if 1.\nBit 27: RDTSCP and IA32_TSC_AUX are available if 1.\nBit 28: Reserved = 0.\nBit 29: Intel\302\256 64 Architecture available if 1.\nBits 31 - 30: Reserved = 0.\nNOTES:\n* LAHF and SAHF are always available in other modes, regardless of the enumeration of this feature flag.\n** Intel processors support SYSCALL and SYSRET only in 64-bit mode. This feature flag is always enumerated as 0 outside 64-bit mode.\nTable 3-8.  Information Returned by CPUID Instruction (Contd.)\nInitial EAX Value\tInformation Provided about the Processor\n80000002H\tEAX EBX ECX EDX\tProcessor Brand String.\nProcessor Brand String Continued.\nProcessor Brand String Continued.\nProcessor Brand String Continued.\n80000003H\tEAX EBX ECX EDX\tProcessor Brand String Continued.\nProcessor Brand String Continued.\nProcessor Brand String Continued.\nProcessor Brand String Continued.\n80000004H\tEAX EBX ECX EDX\tProcessor Brand String Continued.\nProcessor Brand String Continued.\nProcessor Brand String Continued.\nProcessor Brand String Continued.\n80000005H\tEAX EBX ECX EDX\tReserved = 0.\nReserved = 0.\nReserved = 0.\nReserved = 0.\n80000006H\tEAX EBX\tReserved = 0.\nReserved = 0.\nECX EDX\tBits 07 - 00: Cache Line size in bytes.\nBits 11 - 08: Reserved.\nBits 15 - 12: L2 Associativity field *.\nBits 31 - 16: Cache size in 1K units.\nReserved = 0.\nNOTES:\n* L2 associativity field encodings:\n00H - Disabled\t08H - 16 ways\n01H - 1 way (direct mapped)\t09H - Reserved\n02H - 2 ways\t0AH - 32 ways\n03H - Reserved\t0BH - 48 ways\n04H - 4 ways\t0CH - 64 ways\n05H - Reserved\t0DH - 96 ways\n06H - 8 ways\t0EH - 128 ways\n07H - See CPUID leaf 04H, sub-leaf 2**\t0FH - Fully associative\n** CPUID leaf 04H provides details of deterministic cache parameters, including the L2 cache in sub-leaf 2\n80000007H\tEAX EBX ECX EDX\tReserved = 0.\nReserved = 0.\nReserved = 0.\nBits 07 - 00: Reserved = 0.\nBit 08: Invariant TSC available if 1.\nBits 31 - 09: Reserved = 0.\n80000008H\tEAX\tLinear/Physical Address size.\nBits 07 - 00: #Physical Address Bits*.\nBits 15 - 08: #Linear Address Bits.\nBits 31 - 16: Reserved = 0.\nTable 3-8.  Information Returned by CPUID Instruction (Contd.)\nInitial EAX Value\tInformation Provided about the Processor\nEBX ECX EDX\tReserved = 0.\nReserved = 0.\nReserved = 0.\nNOTES:\n* If CPUID.80000008H:EAX[7:0] is supported, the maximum physical address number supported should come from this field.\nINPUT EAX = 0: Returns CPUID\342\200\231s Highest Value for Basic Processor Information and the Vendor Identification String\nWhen CPUID executes with EAX set to 0, the processor returns the highest value the CPUID recognizes for returning basic processor information. The value is returned in the EAX register and is processor specific.\nA vendor identification string is also returned in EBX, EDX, and ECX. For Intel processors, the string is \342\200\234GenuineIntel\342\200\235 and is expressed: EBX := 756e6547h (* \342\200\234Genu\342\200\235, with G in the low eight bits of BL *) EDX := 49656e69h (* \342\200\234ineI\342\200\235, with i in the low eight bits of DL *) ECX := 6c65746eh (* \342\200\234ntel\342\200\235, with n in the low eight bits of CL *)\nINPUT EAX = 80000000H: Returns CPUID\342\200\231s Highest Value for Extended Processor Information\nWhen CPUID executes with EAX set to 80000000H, the processor returns the highest value the processor recognizes for returning extended processor information. The value is returned in the EAX register and is processor specific.\nIA32_BIOS_SIGN_ID Returns Microcode Update Signature\nFor processors that support the microcode update facility, the IA32_BIOS_SIGN_ID MSR is loaded with the update signature whenever CPUID executes. The signature is returned in the upper DWORD. For details, see Chapter 9 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3A.\nINPUT EAX = 01H: Returns Model, Family, Stepping Information\nWhen CPUID executes with EAX set to 01H, version information is returned in EAX (see Figure\t3-6). For example:\nmodel, family, and processor type for the Intel Xeon processor 5100 series is as follows:\n\342\200\242\tModel - 1111B\n\342\200\242\tFamily - 0101B\n\342\200\242\tProcessor Type - 00B\nSee Table 3-9 for available processor type values. Stepping IDs are provided as needed.\n31\t28\t27\t20\t19\t16\t15\t14\t13\t12\t11\t8\t7\t4\t3\t0\nEAX\tExtended Family ID\tExtended Model ID\tFamily ID\tModel\tStepping ID\nExtended Family ID (0) Extended Model ID (0)\nProcessor Type\nFamily (0FH for the Pentium 4 Processor Family) Model\nReserved\nOM16525\nFigure 3-6.  Version Information Returned by CPUID in EAX\nTable 3-9.  Processor Type Field\nType\tEncoding\nOriginal OEM Processor\t00B\nIntel OverDrive\302\256 Processor\t01B\nDual processor (not applicable to Intel486 processors)\t10B\nIntel reserved\t11B\nNOTE\nSee Chapter 20 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1, for information on identifying earlier IA-32 processors.\nThe Extended Family ID needs to be examined only when the Family ID is 0FH. Integrate the fields into a display using the following rule:\nIF Family_ID \342\211\240 0FH THEN DisplayFamily = Family_ID; ELSE DisplayFamily = Extended_Family_ID + Family_ID; (* Right justify and zero-extend 4-bit field. *)\nFI; (* Show DisplayFamily as HEX field. *)\nThe Extended Model ID needs to be examined only when the Family ID is 06H or 0FH. Integrate the field into a display using the following rule:\nIF (Family_ID = 06H or Family_ID = 0FH) THEN DisplayModel = (Extended_Model_ID \302\253 4) + Model_ID; (* Right justify and zero-extend 4-bit field; display Model_ID as HEX field.*) ELSE DisplayModel = Model_ID;\nFI; (* Show DisplayModel as HEX field. *)\nINPUT EAX = 01H: Returns Additional Information in EBX\nWhen CPUID executes with EAX set to 01H, additional information is returned to the EBX register:\n\342\200\242\tBrand index (low byte of EBX) - this number provides an entry into a brand string table that contains brand strings for IA-32 processors. More information about this field is provided later in this section.\n\342\200\242\tCLFLUSH instruction cache line size (second byte of EBX) - this number indicates the size of the cache line flushed by the CLFLUSH and CLFLUSHOPT instructions in 8-byte increments. This field was introduced in the Pentium 4 processor.\n\342\200\242\tLocal APIC ID (high byte of EBX) - this number is the 8-bit ID that is assigned to the local APIC on the processor during power up. This field was introduced in the Pentium 4 processor.\nINPUT EAX = 01H: Returns Feature Information in ECX and EDX\nWhen CPUID executes with EAX set to 01H, feature information is returned in ECX and EDX.\n\342\200\242\tFigure\t3-7 and Table 3-10 show encodings for ECX.\n\342\200\242\tFigure\t3-8 and Table 3-11 show encodings for EDX.\nFor all feature flags, a 1 indicates that the feature is supported. Use Intel to properly interpret feature flags.\nNOTE\nSoftware must confirm that a processor feature is present using feature flags returned by CPUID prior to using the feature. Software should not depend on future offerings retaining all features.\n31\t30\t29\t28\t27\t26\t25\t24\t23\t22\t21\t20\t19\t18\t17\t16\t15\t14\t13\t12\t11\t10\t9\t8\t7\t6\t5\t4\t3\t2\t1\t0\nECX\n0\nRDRAND\nF16C\nAVX\nOSXSAVE\nXSAVE\nAES\nTSC-Deadline\nPOPCNT\nMOVBE\nx2APIC\nSSE4_2 -  SSE4.2\nSSE4_1 -  SSE4.1\nDCA -  Direct Cache Access\nPCID -  Process-context Identifiers\nPDCM -  Perf/Debug Capability MSR\nxTPR Update Control\nCMPXCHG16B\nFMA -  Fused Multiply Add\nSDBG\nCNXT-ID - L1 Context ID\nSSSE3 -  SSSE3 Extensions\nTM2 - Thermal Monitor 2 EIST -  Enhanced  Intel  SpeedStep\302\256  Technology\nSMX - Safer Mode Extensions\nVMX - Virtual Machine Extensions\nDS-CPL - CPL Qualified Debug Store MONITOR - MONITOR/M WAIT\nDTES64  -  64-bit DS Area\nPCLMULQDQ  -  Carryless Multiplication\nSSE3  -  SSE3 Extensions\nOM16524b\nReserved\nFigure 3-7.  Feature Information Returned in the ECX Register\nTable 3-10.  Feature Information Returned in the ECX Register\nBit #\tMnemonic\tDescription\n0\tSSE3\tStreaming SIMD Extensions 3 (SSE3). A value of 1 indicates the processor supports this technology.\n1\tPCLMULQDQ\tPCLMULQDQ. A value of 1 indicates the processor supports the PCLMULQDQ instruction.\n2\tDTES64\t64-bit DS Area. A value of 1 indicates the processor supports DS area using 64-bit layout.\n3\tMONITOR\tMONITOR/MWAIT. A value of 1 indicates the processor supports this feature.\n4\tDS-CPL\tCPL Qualified Debug Store. A value of 1 indicates the processor supports the extensions to the Debug Store feature to allow for branch message storage qualified by CPL.\n5\tVMX\tVirtual Machine Extensions. A value of 1 indicates that the processor supports this technology.\n6\tSMX\tSafer Mode Extensions. A value of 1 indicates that the processor supports this technology. See Chapter 6, \342\200\234Safer Mode Extensions Reference\342\200\235.\n7\tEIST\tEnhanced Intel SpeedStep\302\256 technology. A value of 1 indicates that the processor supports this technology.\n8\tTM2\tThermal Monitor 2. A value of 1 indicates whether the processor supports this technology.\n9\tSSSE3\tA value of 1 indicates the presence of the Supplemental Streaming SIMD Extensions 3 (SSSE3). A value of 0 indicates the instruction extensions are not present in the processor.\n10\tCNXT-ID\tL1 Context ID. A value of 1 indicates the L1 data cache mode can be set to either adaptive mode or shared mode. A value of 0 indicates this feature is not supported. See definition of the IA32_MISC_ENABLE MSR Bit 24 (L1 Data Cache Context Mode) for details.\n11\tSDBG\tA value of 1 indicates the processor supports IA32_DEBUG_INTERFACE MSR for silicon debug.\n12\tFMA\tA value of 1 indicates the processor supports FMA extensions using YMM state.\n13\tCMPXCHG16B\tCMPXCHG16B Available. A value of 1 indicates that the feature is available. See the \342\200\234CMPXCHG8B/CMPXCHG16B-Compare and Exchange Bytes\342\200\235 section in this chapter for a description.\n14\txTPR Update Control\txTPR Update Control. A value of 1 indicates that the processor supports changing IA32_MISC_ENABLE[bit 23].\n15\tPDCM\tPerfmon and Debug Capability: A value of 1 indicates the processor supports the performance and debug feature indication MSR IA32_PERF_CAPABILITIES.\n16\tReserved\tReserved\n17\tPCID\tProcess-context identifiers. A value of 1 indicates that the processor supports PCIDs and that software may set CR4.PCIDE to 1.\n18\tDCA\tA value of 1 indicates the processor supports the ability to prefetch data from a memory mapped device.\n19\tSSE4_1\tA value of 1 indicates that the processor supports SSE4.1.\n20\tSSE4_2\tA value of 1 indicates that the processor supports SSE4.2.\n21\tx2APIC\tA value of 1 indicates that the processor supports x2APIC feature.\n22\tMOVBE\tA value of 1 indicates that the processor supports MOVBE instruction.\n23\tPOPCNT\tA value of 1 indicates that the processor supports the POPCNT instruction.\n24\tTSC-Deadline\tA value of 1 indicates that the processor\342\200\231s local APIC timer supports one-shot operation using a TSC deadline value.\n25\tAESNI\tA value of 1 indicates that the processor supports the AESNI instruction extensions.\n26\tXSAVE\tA value of 1 indicates that the processor supports the XSAVE/XRSTOR processor extended states feature, the XSETBV/XGETBV instructions, and XCR0.\n27\tOSXSAVE\tA value of 1 indicates that the OS has set CR4.OSXSAVE[bit 18] to enable XSETBV/XGETBV instructions to access XCR0 and to support processor extended state management using XSAVE/XRSTOR.\n28\tAVX\tA value of 1 indicates the processor supports the AVX instruction extensions.\nTable 3-10.  Feature Information Returned in the ECX Register  (Contd.)\nBit #\tMnemonic\tDescription\n29\tF16C\tA value of 1 indicates that processor supports 16-bit floating-point conversion instructions.\n30\tRDRAND\tA value of 1 indicates that processor supports RDRAND instruction.\n31\tNot Used\tAlways returns 0.\n\n31302928272625242322212019181716151413121110\t9\t8\t7\t6\t5\t4\t3\t2\t1\t0\nEDX\nPBE-Pend. Brk. EN.\nTM-Therm. Monitor HTT-Multi-threading SS-Self Snoop SSE2-SSE2 Extensions SSE-SSE Extensions FXSR-FXSAVE/FXRSTOR MMX-MMX Technology ACPI-Thermal Monitor and Clock Ctrl DS-Debug Store CLFSH-CLFLUSH instruction PSN-Processor Serial Number PSE-36 - Page Size Extension PAT-Page Attribute Table CMOV-Conditional Move/Compare Instruction MCA-Machine Check Architecture PGE-PTE Global Bit MTRR-Memory Type Range Registers SEP-SYSENTER and SYSEXIT APIC-APIC on Chip CX8-CMPXCHG8B Inst.\nMCE-Machine Check Exception PAE-Physical Address Extensions MSR-RDMSR and WRMSR Support TSC-Time Stamp Counter PSE-Page Size Extensions DE-Debugging Extensions VME-Virtual-8086 Mode Enhancement FPU-x87 FPU on Chip\nReserved\nOM16523\nFigure 3-8.  Feature Information Returned in the EDX Register\nTable 3-11.  More on Feature Information Returned in the EDX Register\nBit #\tMnemonic\tDescription\n0\tFPU\tFloating Point Unit On-Chip. The processor contains an x87 FPU.\n1\tVME\tVirtual 8086 Mode Enhancements. Virtual 8086 mode enhancements, including CR4.VME for controlling the feature, CR4.PVI for protected mode virtual interrupts, software interrupt indirection, expansion of the TSS with the software indirection bitmap, and EFLAGS.VIF and EFLAGS.VIP flags.\n2\tDE\tDebugging Extensions. Support for I/O breakpoints, including CR4.DE for controlling the feature, and optional trapping of accesses to DR4 and DR5.\n3\tPSE\tPage Size Extension. Large pages of size 4 MByte are supported, including CR4.PSE for controlling the feature, the defined dirty bit in PDE (Page Directory Entries), optional reserved bit trapping in CR3, PDEs, and PTEs.\n4\tTSC\tTime Stamp Counter. The RDTSC instruction is supported, including CR4.TSD for controlling privilege.\n5\tMSR\tModel Specific Registers RDMSR and WRMSR Instructions. The RDMSR and WRMSR instructions are supported. Some of the MSRs are implementation dependent.\n6\tPAE\tPhysical Address Extension. Physical addresses greater than 32 bits are supported: extended page table entry formats, an extra level in the page translation tables is defined, 2-MByte pages are supported instead of 4 Mbyte pages if PAE bit is 1.\n7\tMCE\tMachine Check Exception. Exception 18 is defined for Machine Checks, including CR4.MCE for controlling the feature. This feature does not define the model-specific implementations of machine-check error logging, reporting, and processor shutdowns. Machine Check exception handlers may have to depend on processor version to do model specific processing of the exception, or test for the presence of the Machine Check feature.\n8\tCX8\tCMPXCHG8B Instruction. The compare-and-exchange 8 bytes (64 bits) instruction is supported (implicitly locked and atomic).\n9\tAPIC\tAPIC On-Chip. The processor contains an Advanced Programmable Interrupt Controller (APIC), responding to memory mapped commands in the physical address range FFFE0000H to FFFE0FFFH (by default - some processors permit the APIC to be relocated).\n10\tReserved\tReserved\n11\tSEP\tSYSENTER and SYSEXIT Instructions. The SYSENTER and SYSEXIT and associated MSRs are supported.\n12\tMTRR\tMemory Type Range Registers. MTRRs are supported. The MTRRcap MSR contains feature bits that describe what memory types are supported, how many variable MTRRs are supported, and whether fixed MTRRs are supported.\n13\tPGE\tPage Global Bit. The global bit is supported in paging-structure entries that map a page, indicating TLB entries that are common to different processes and need not be flushed. The CR4.PGE bit controls this feature.\n14\tMCA\tMachine Check Architecture. A value of 1 indicates the Machine Check Architecture of reporting machine errors is supported. The MCG_CAP MSR contains feature bits describing how many banks of error reporting MSRs are supported.\n15\tCMOV\tConditional Move Instructions. The conditional move instruction CMOV is supported. In addition, if x87 FPU is present as indicated by the CPUID.FPU feature bit, then the FCOMI and FCMOV instructions are supported\n16\tPAT\tPage Attribute Table. Page Attribute Table is supported. This feature augments the Memory Type Range Registers (MTRRs), allowing an operating system to specify attributes of memory accessed through a linear address on a 4KB granularity.\n17\tPSE-36\t36-Bit Page Size Extension. 4-MByte pages addressing physical memory beyond 4 GBytes are supported with 32-bit paging. This feature indicates that upper bits of the physical address of a 4-MByte page are encoded in bits20:13 of the page-directory entry. Such physical addresses are limited by MAXPHYADDR and may be up to 40 bits in size.\n18\tPSN\tProcessor Serial Number. The processor supports the 96-bit processor identification number feature and the feature is enabled.\n19\tCLFSH\tCLFLUSH Instruction. CLFLUSH Instruction is supported.\n20\tReserved\tReserved\nTable 3-11.  More on Feature Information Returned in the EDX Register (Contd.)\nBit #\tMnemonic\tDescription\n21\tDS\tDebug Store. The processor supports the ability to write debug information into a memory resident buffer.\nThis feature is used by the branch trace store (BTS) and processor event-based sampling (PEBS) facilities (see Chapter 23, \342\200\234Introduction to Virtual-Machine Extensions,\342\200\235 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3C).\n22\tACPI\tThermal Monitor and Software Controlled Clock Facilities. The processor implements internal MSRs that allow processor temperature to be monitored and processor performance to be modulated in predefined duty cycles under software control.\n23\tMMX\tIntel MMX Technology. The processor supports the Intel MMX technology.\n24\tFXSR\tFXSAVE and FXRSTOR Instructions. The FXSAVE and FXRSTOR instructions are supported for fast save and restore of the floating point context. Presence of this bit also indicates that CR4.OSFXSR is available for an operating system to indicate that it supports the FXSAVE and FXRSTOR instructions.\n25\tSSE\tSSE. The processor supports the SSE extensions.\n26\tSSE2\tSSE2. The processor supports the SSE2 extensions.\n27\tSS\tSelf Snoop. The processor supports the management of conflicting memory types by performing a snoop of its own cache structure for transactions issued to the bus.\n28\tHTT\tMax APIC IDs reserved field is Valid. A value of 0 for HTT indicates there is only a single logical processor in the package and software should assume only a single APIC ID is reserved. A value of 1 for HTT indicates the value in CPUID.1.EBX[23:16] (the Maximum number of addressable IDs for logical processors in this package) is valid for the package.\n29\tTM\tThermal Monitor. The processor implements the thermal monitor automatic thermal control circuitry (TCC).\n30\tReserved\tReserved\n31\tPBE\tPending Break Enable. The processor supports the use of the FERR#/PBE# pin when the processor is in the stop-clock state (STPCLK# is asserted) to signal the processor that an interrupt is pending and that the processor should return to normal operation to handle the interrupt.\nINPUT EAX = 02H: TLB/Cache/Prefetch Information Returned in EAX, EBX, ECX, EDX\nWhen CPUID executes with EAX set to 02H, the processor returns information about the processor\342\200\231s internal TLBs, cache and prefetch hardware in the EAX, EBX, ECX, and EDX registers. The information is reported in encoded form and fall into the following categories:\n\342\200\242\tThe least-significant byte in register EAX (register AL) will always return 01H. Software should ignore this value and not interpret it as an informational descriptor.\n\342\200\242\tThe most significant bit (bit 31) of each register indicates whether the register contains valid information (set to 0) or is reserved (set to 1).\n\342\200\242\tIf a register contains valid information, the information is contained in 1 byte descriptors. There are four types of encoding values for the byte descriptor, the encoding type is noted in the second column of Table 3-12. Table 3-12 lists the encoding of these descriptors. Note that the order of descriptors in the EAX, EBX, ECX, and EDX registers is not defined; that is, specific bytes are not designated to contain descriptors for specific cache, prefetch, or TLB types. The descriptors may appear in any order. Note also a processor may report a general descriptor type (FFH) and not report any byte descriptor of \342\200\234cache type\342\200\235 via CPUID leaf 2.\nTable 3-12.  Encoding of CPUID Leaf 2 Descriptors\nValue\tType\tDescription\n00H\tGeneral\tNull descriptor, this byte contains no information\n01H\tTLB\tInstruction TLB: 4 KByte pages, 4-way set associative, 32 entries\n02H\tTLB\tInstruction TLB: 4 MByte pages, fully associative, 2 entries\n03H\tTLB\tData TLB: 4 KByte pages, 4-way set associative, 64 entries\n04H\tTLB\tData TLB: 4 MByte pages, 4-way set associative, 8 entries\n05H\tTLB\tData TLB1: 4 MByte pages, 4-way set associative, 32 entries\n06H\tCache\t1st-level instruction cache: 8 KBytes, 4-way set associative, 32 byte line size\n08H\tCache\t1st-level instruction cache: 16 KBytes, 4-way set associative, 32 byte line size\n09H\tCache\t1st-level instruction cache: 32KBytes, 4-way set associative, 64 byte line size\n0AH\tCache\t1st-level data cache: 8 KBytes, 2-way set associative, 32 byte line size\n0BH\tTLB\tInstruction TLB: 4 MByte pages, 4-way set associative, 4 entries\n0CH\tCache\t1st-level data cache: 16 KBytes, 4-way set associative, 32 byte line size\n0DH\tCache\t1st-level data cache: 16 KBytes, 4-way set associative, 64 byte line size\n0EH\tCache\t1st-level data cache: 24 KBytes, 6-way set associative, 64 byte line size\n1DH\tCache\t2nd-level cache: 128 KBytes, 2-way set associative, 64 byte line size\n21H\tCache\t2nd-level cache: 256 KBytes, 8-way set associative, 64 byte line size\n22H\tCache\t3rd-level cache: 512 KBytes, 4-way set associative, 64 byte line size, 2 lines per sector\n23H\tCache\t3rd-level cache: 1 MBytes, 8-way set associative, 64 byte line size, 2 lines per sector\n24H\tCache\t2nd-level cache: 1 MBytes, 16-way set associative, 64 byte line size\n25H\tCache\t3rd-level cache: 2 MBytes, 8-way set associative, 64 byte line size, 2 lines per sector\n29H\tCache\t3rd-level cache: 4 MBytes, 8-way set associative, 64 byte line size, 2 lines per sector\n2CH\tCache\t1st-level data cache: 32 KBytes, 8-way set associative, 64 byte line size\n30H\tCache\t1st-level instruction cache: 32 KBytes, 8-way set associative, 64 byte line size\n40H\tCache\tNo 2nd-level cache or, if processor contains a valid 2nd-level cache, no 3rd-level cache\n41H\tCache\t2nd-level cache: 128 KBytes, 4-way set associative, 32 byte line size\n42H\tCache\t2nd-level cache: 256 KBytes, 4-way set associative, 32 byte line size\n43H\tCache\t2nd-level cache: 512 KBytes, 4-way set associative, 32 byte line size\n44H\tCache\t2nd-level cache: 1 MByte, 4-way set associative, 32 byte line size\n45H\tCache\t2nd-level cache: 2 MByte, 4-way set associative, 32 byte line size\n46H\tCache\t3rd-level cache: 4 MByte, 4-way set associative, 64 byte line size\n47H\tCache\t3rd-level cache: 8 MByte, 8-way set associative, 64 byte line size\n48H\tCache\t2nd-level cache: 3MByte, 12-way set associative, 64 byte line size\n49H\tCache\t3rd-level cache: 4MB, 16-way set associative, 64-byte line size (Intel Xeon processor MP, Family 0FH, Model 06H); 2nd-level cache: 4 MByte, 16-way set associative, 64 byte line size\n4AH\tCache\t3rd-level cache: 6MByte, 12-way set associative, 64 byte line size\n4BH\tCache\t3rd-level cache: 8MByte, 16-way set associative, 64 byte line size\n4CH\tCache\t3rd-level cache: 12MByte, 12-way set associative, 64 byte line size\n4DH\tCache\t3rd-level cache: 16MByte, 16-way set associative, 64 byte line size\n4EH\tCache\t2nd-level cache: 6MByte, 24-way set associative, 64 byte line size\n4FH\tTLB\tInstruction TLB: 4 KByte pages, 32 entries\nTable 3-12.  Encoding of CPUID Leaf 2 Descriptors  (Contd.)\nValue\tType\tDescription\n50H\tTLB\tInstruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 64 entries\n51H\tTLB\tInstruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 128 entries\n52H\tTLB\tInstruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 256 entries\n55H\tTLB\tInstruction TLB: 2-MByte or 4-MByte pages, fully associative, 7 entries\n56H\tTLB\tData TLB0: 4 MByte pages, 4-way set associative, 16 entries\n57H\tTLB\tData TLB0: 4 KByte pages, 4-way associative, 16 entries\n59H\tTLB\tData TLB0: 4 KByte pages, fully associative, 16 entries\n5AH\tTLB\tData TLB0: 2 MByte or 4 MByte pages, 4-way set associative, 32 entries\n5BH\tTLB\tData TLB: 4 KByte and 4 MByte pages, 64 entries\n5CH\tTLB\tData TLB: 4 KByte and 4 MByte pages,128 entries\n5DH\tTLB\tData TLB: 4 KByte and 4 MByte pages,256 entries\n60H\tCache\t1st-level data cache: 16 KByte, 8-way set associative, 64 byte line size\n61H\tTLB\tInstruction TLB: 4 KByte pages, fully associative, 48 entries\n63H\tTLB\tData TLB: 2 MByte or 4 MByte pages, 4-way set associative, 32 entries and a separate array with 1 GByte pages, 4-way set associative, 4 entries\n64H\tTLB\tData TLB: 4 KByte pages, 4-way set associative, 512 entries\n66H\tCache\t1st-level data cache: 8 KByte, 4-way set associative, 64 byte line size\n67H\tCache\t1st-level data cache: 16 KByte, 4-way set associative, 64 byte line size\n68H\tCache\t1st-level data cache: 32 KByte, 4-way set associative, 64 byte line size\n6AH\tCache\tuTLB: 4 KByte pages, 8-way set associative, 64 entries\n6BH\tCache\tDTLB: 4 KByte pages, 8-way set associative, 256 entries\n6CH\tCache\tDTLB: 2M/4M pages, 8-way set associative, 128 entries\n6DH\tCache\tDTLB: 1 GByte pages, fully associative, 16 entries\n70H\tCache\tTrace cache: 12 K-\316\274op, 8-way set associative\n71H\tCache\tTrace cache: 16 K-\316\274op, 8-way set associative\n72H\tCache\tTrace cache: 32 K-\316\274op, 8-way set associative\n76H\tTLB\tInstruction TLB: 2M/4M pages, fully associative, 8 entries\n78H\tCache\t2nd-level cache: 1 MByte, 4-way set associative, 64byte line size\n79H\tCache\t2nd-level cache: 128 KByte, 8-way set associative, 64 byte line size, 2 lines per sector\n7AH\tCache\t2nd-level cache: 256 KByte, 8-way set associative, 64 byte line size, 2 lines per sector\n7BH\tCache\t2nd-level cache: 512 KByte, 8-way set associative, 64 byte line size, 2 lines per sector\n7CH\tCache\t2nd-level cache: 1 MByte, 8-way set associative, 64 byte line size, 2 lines per sector\n7DH\tCache\t2nd-level cache: 2 MByte, 8-way set associative, 64byte line size\n7FH\tCache\t2nd-level cache: 512 KByte, 2-way set associative, 64-byte line size\n80H\tCache\t2nd-level cache: 512 KByte, 8-way set associative, 64-byte line size\n82H\tCache\t2nd-level cache: 256 KByte, 8-way set associative, 32 byte line size\n83H\tCache\t2nd-level cache: 512 KByte, 8-way set associative, 32 byte line size\n84H\tCache\t2nd-level cache: 1 MByte, 8-way set associative, 32 byte line size\n85H\tCache\t2nd-level cache: 2 MByte, 8-way set associative, 32 byte line size\n86H\tCache\t2nd-level cache: 512 KByte, 4-way set associative, 64 byte line size\n87H\tCache\t2nd-level cache: 1 MByte, 8-way set associative, 64 byte line size\nTable 3-12.  Encoding of CPUID Leaf 2 Descriptors  (Contd.)\nValue\tType\tDescription\nA0H\tDTLB\tDTLB: 4k pages, fully associative, 32 entries\nB0H\tTLB\tInstruction TLB: 4 KByte pages, 4-way set associative, 128 entries\nB1H\tTLB\tInstruction TLB: 2M pages, 4-way, 8 entries or 4M pages, 4-way, 4 entries\nB2H\tTLB\tInstruction TLB: 4KByte pages, 4-way set associative, 64 entries\nB3H\tTLB\tData TLB: 4 KByte pages, 4-way set associative, 128 entries\nB4H\tTLB\tData TLB1: 4 KByte pages, 4-way associative, 256 entries\nB5H\tTLB\tInstruction TLB: 4KByte pages, 8-way set associative, 64 entries\nB6H\tTLB\tInstruction TLB: 4KByte pages, 8-way set associative, 128 entries\nBAH\tTLB\tData TLB1: 4 KByte pages, 4-way associative, 64 entries\nC0H\tTLB\tData TLB: 4 KByte and 4 MByte pages, 4-way associative, 8 entries\nC1H\tSTLB\tShared 2nd-Level TLB: 4 KByte/2MByte pages, 8-way associative, 1024 entries\nC2H\tDTLB\tDTLB: 4 KByte/2 MByte pages, 4-way associative, 16 entries\nC3H\tSTLB\tShared 2nd-Level TLB: 4 KByte /2 MByte pages, 6-way associative, 1536 entries. Also 1GBbyte pages, 4-way, 16 entries.\nC4H\tDTLB\tDTLB: 2M/4M Byte pages, 4-way associative, 32 entries\nCAH\tSTLB\tShared 2nd-Level TLB: 4 KByte pages, 4-way associative, 512 entries\nD0H\tCache\t3rd-level cache: 512 KByte, 4-way set associative, 64 byte line size\nD1H\tCache\t3rd-level cache: 1 MByte, 4-way set associative, 64 byte line size\nD2H\tCache\t3rd-level cache: 2 MByte, 4-way set associative, 64 byte line size\nD6H\tCache\t3rd-level cache: 1 MByte, 8-way set associative, 64 byte line size\nD7H\tCache\t3rd-level cache: 2 MByte, 8-way set associative, 64 byte line size\nD8H\tCache\t3rd-level cache: 4 MByte, 8-way set associative, 64 byte line size\nDCH\tCache\t3rd-level cache: 1.5 MByte, 12-way set associative, 64 byte line size\nDDH\tCache\t3rd-level cache: 3 MByte, 12-way set associative, 64 byte line size\nDEH\tCache\t3rd-level cache: 6 MByte, 12-way set associative, 64 byte line size\nE2H\tCache\t3rd-level cache: 2 MByte, 16-way set associative, 64 byte line size\nE3H\tCache\t3rd-level cache: 4 MByte, 16-way set associative, 64 byte line size\nE4H\tCache\t3rd-level cache: 8 MByte, 16-way set associative, 64 byte line size\nEAH\tCache\t3rd-level cache: 12MByte, 24-way set associative, 64 byte line size\nEBH\tCache\t3rd-level cache: 18MByte, 24-way set associative, 64 byte line size\nECH\tCache\t3rd-level cache: 24MByte, 24-way set associative, 64 byte line size\nF0H\tPrefetch\t64-Byte prefetching\nF1H\tPrefetch\t128-Byte prefetching\nFEH\tGeneral\tCPUID leaf 2 does not report TLB descriptor information; use CPUID leaf 18H to query TLB and other address translation parameters.\nFFH\tGeneral\tCPUID leaf 2 does not report cache descriptor information, use CPUID leaf 4 to query cache parameters\nExample 3-1.  Example of Cache and TLB Interpretation\nThe first member of the family of Pentium 4 processors returns the following information about caches and TLBs when the CPUID executes with an input value of 2:\nEAX\t66 5B 50 01H\nEBX\t0H\nECX\t0H\nEDX\t00 7A 70 00H\nWhich means:\n\342\200\242\tThe least-significant byte (byte 0) of register EAX is set to 01H. This value should be ignored.\n\342\200\242\tThe most-significant bit of all four registers (EAX, EBX, ECX, and EDX) is set to 0, indicating that each register contains valid 1-byte descriptors.\n\342\200\242\tBytes 1, 2, and 3 of register EAX indicate that the processor has:\n-\t50H - a 64-entry instruction TLB, for mapping 4-KByte and 2-MByte or 4-MByte pages.\n-\t5BH - a 64-entry data TLB, for mapping 4-KByte and 4-MByte pages.\n-\t66H - an 8-KByte 1st level data cache, 4-way set associative, with a 64-Byte cache line size.\n\342\200\242\tThe descriptors in registers EBX and ECX are valid, but contain NULL descriptors.\n\342\200\242\tBytes 0, 1, 2, and 3 of register EDX indicate that the processor has:\n-\t00H - NULL descriptor.\n-\t70H - Trace cache: 12 K-\316\274op, 8-way set associative.\n-\t7AH - a 256-KByte 2nd level cache, 8-way set associative, with a sectored, 64-byte cache line size.\n-\t00H - NULL descriptor.\nINPUT EAX = 04H: Returns Deterministic Cache Parameters for Each Level\nWhen CPUID executes with EAX set to 04H and ECX contains an index value, the processor returns encoded data that describe a set of deterministic cache parameters (for the cache level associated with the input in ECX). Valid index values start from 0.\nSoftware can enumerate the deterministic cache parameters for each level of the cache hierarchy starting with an index value of 0, until the parameters report the value associated with the cache type field is 0. The architecturally defined fields reported by deterministic cache parameters are documented in Table 3-8.\nThis Cache Size in Bytes\n= (Ways + 1) * (Partitions + 1) * (Line_Size + 1) * (Sets + 1)\n= (EBX[31:22] + 1) * (EBX[21:12] + 1) * (EBX[11:0] + 1) * (ECX + 1)\nThe CPUID leaf 04H also reports data that can be used to derive the topology of processor cores in a physical package. This information is constant for all valid index values. Software can query the raw data reported by executing CPUID with EAX=04H and ECX=0 and use it as part of the topology enumeration algorithm described in Chapter 8, \342\200\234Multiple-Processor Management,\342\200\235 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3A.\nINPUT EAX = 05H: Returns MONITOR and MWAIT Features\nWhen CPUID executes with EAX set to 05H, the processor returns information about features available to MONITOR/M WAIT instructions. The MONITOR instruction is used for address-range monitoring in conjunction with\nM WAIT instruction. The M WAIT instruction optionally provides additional extensions for advanced power manage-\nment. See Table 3-8.\nINPUT EAX = 06H: Returns Thermal and Power Management Features\nWhen CPUID executes with EAX set to 06H, the processor returns information about thermal and power management features. See Table 3-8.\nINPUT EAX = 07H: Returns Structured Extended Feature Enumeration Information\nWhen CPUID executes with EAX set to 07H and ECX = 0, the processor returns information about the maximum input value for sub-leaves that contain extended feature flags. See Table 3-8.\nWhen CPUID executes with EAX set to 07H and the input value of ECX is invalid (see leaf 07H entry in Table 3-8), the processor returns 0 in EAX/EBX/ECX/EDX. In subleaf 0, EAX returns the maximum input value of the highest leaf 7 sub-leaf, and EBX, ECX & EDX contain information of extended feature flags.\nINPUT EAX = 09H: Returns Direct Cache Access Information\nWhen CPUID executes with EAX set to 09H, the processor returns information about Direct Cache Access capabilities. See Table 3-8.\nINPUT EAX = 0AH: Returns Architectural Performance Monitoring Features\nWhen CPUID executes with EAX set to 0AH, the processor returns information about support for architectural performance monitoring capabilities. Architectural performance monitoring is supported if the version ID (see Table 3-8) is greater than Pn 0. See Table 3-8.\nFor each version of architectural performance monitoring capability, software must enumerate this leaf to discover the program\nming facilities and the architectural performance events available in the processor. The details are described in Chapter 23, \342\200\234Introduction to Virtual-Machine Extensions,\342\200\235 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3C.\nINPUT EAX = 0BH: Returns Extended Topology Information\nCPUID leaf 1FH is a preferred superset to leaf 0BH. Intel recom mends first checking for the existence of Leaf 1FH\nbefore using leaf 0BH.\nWhen CPUID executes with EAX set to 0BH, the processor returns information about extended topology enumeration data. Software must detect the presence of CPUID leaf 0BH by verifying (a) the highest leaf index supported by CPUID is >= 0BH, and (b) CPUID.0BH:EBX[15:0] reports a non-zero value. See Table 3-8.\nINPUT EAX = 0DH: Returns Processor Extended States Enumeration Information\nWhen CPUID executes with EAX set to 0DH and ECX = 0, the processor returns information about the bit-vector representation of all processor state extensions that are supported in the processor and storage size requirements of the XSAVE/XRSTOR area. See Table 3-8.\nWhen CPUID executes with EAX set to 0DH and ECX = n (n > 1, and is a valid sub-leaf index), the processor returns information about the size and offset of each processor extended state save area within the XSAVE/XRSTOR area.\nSee Table 3-8. Software can use the forward-extendable technique depicted below to query the valid sub-leaves and obtain size and offset information for each processor extended state save area:\nFor i = 2 to 62 // sub-leaf 1 is reserved IF (CPUID.(EAX=0DH, ECX=0):VECTOR[i] = 1 ) // VECTOR is the 64-bit value of EDX:EAX Execute CPUID.(EAX=0DH, ECX = i) to examine size and offset for sub-leaf i;\nFI;\nINPUT EAX = 0FH: Returns Intel Resource Director Technology (Intel RDT) Monitoring Enumeration Information\nWhen CPUID executes with EAX set to 0FH and ECX = 0, the processor returns information about the bit-vector representation of QoS monitoring resource types that are supported in the processor and maximum range of RMID values the processor can use to monitor of any supported resource types. Each bit, starting from bit 1, corresponds to a specific resource type if the bit is set. The bit position corresponds to the sub-leaf index (or ResID) that software must use to query QoS monitoring capability available for that type. See Table 3-8.\nWhen CPUID executes with EAX set to 0FH and ECX = n (n >= 1, and is a valid ResID), the processor returns information software can use to program IA32_PQR_ASSOC, IA32_QM_EVTSEL MSRs before reading QoS data from the IA32_QM_CTR MSR.\nINPUT EAX = 10H: Returns Intel Resource Director Technology (Intel RDT) Allocation Enumeration Information\nWhen CPUID executes with EAX set to 10H and ECX = 0, the processor returns information about the bit-vector representation of QoS Enforcement resource types that are supported in the processor. Each bit, starting from bit 1, corresponds to a specific resource type if the bit is set. The bit position corresponds to the sub-leaf index (or ResID) that software must use to query QoS enforcement capability available for that type. See Table 3-8.\nWhen CPUID executes with EAX set to 10H and ECX = n (n >= 1, and is a valid ResID), the processor returns information about available classes of service and range of QoS mask MSRs that software can use to configure each class of services using capability bit masks in the QoS Mask registers, IA32_resourceType_Mask_n.\nINPUT EAX = 12H: Returns Intel SGX Enumeration Information\nWhen CPUID executes with EAX set to 12H and ECX = 0H, the processor returns information about Intel SGX capabilities. See Table 3-8.\nWhen CPUID executes with EAX set to 12H and ECX = 1H, the processor returns information about Intel SGX attributes. See Table 3-8.\nWhen CPUID executes with EAX set to 12H and ECX = n (n > 1), the processor returns information about Intel SGX Enclave Page Cache. See Table 3-8.\nINPUT EAX = 14H: Returns Intel Processor Trace Enumeration Information\nWhen CPUID executes with EAX set to 14H and ECX = 0H, the processor returns information about Intel Processor Trace extensions. See Table 3-8.\nWhen CPUID executes with EAX set to 14H and ECX = n (n > 0 and less than the number of non-zero bits in CPUID.(EAX=14H, ECX= 0H).EAX), the processor returns information about packet generation in Intel Processor Trace. See Table 3-8.\nINPUT EAX = 15H: Returns Time Stamp Counter and Nominal Core Crystal Clock Information\nWhen CPUID executes with EAX set to 15H and ECX = 0H, the processor returns information about Time Stamp Counter and Core Crystal Clock. See Table 3-8.\nINPUT EAX = 16H: Returns Processor Frequency Information\nWhen CPUID executes with EAX set to 16H, the processor returns information about Processor Frequency Information. See Table 3-8.\nINPUT EAX = 17H: Returns System-On-Chip Information\nWhen CPUID executes with EAX set to 17H, the processor returns information about the System-On-Chip Vendor Attribute Enumeration. See Table 3-8.\nINPUT EAX = 18H: Returns Deterministic Address Translation Parameters Information\nWhen CPUID executes with EAX set to 18H, the processor returns information about the Deterministic Address Translation Parameters. See Table 3-8.\nINPUT EAX = 1AH: Returns Hybrid Information\nWhen CPUID executes with EAX set to 1AH, the processor returns information about hybrid capabilities. See Table 3-8.\nINPUT EAX = 1FH: Returns V2 Extended Topology Information\nWhen CPUID executes with EAX set to 1FH, the processor returns information about extended topology enumeration data. Software must detect the presence of CPUID leaf 1FH by verifying (a) the highest leaf index supported by CPUID is >= 1FH, and (b) CPUID.1FH:EBX[15:0] reports a non-zero value. See Table 3-8.\nMETHODS FOR RETURNING BRANDING INFORMATION\nUse the following techniques to access branding information:\n1.\tProcessor brand string method.\n2.\tProcessor brand index; this method uses a software supplied brand string table.\nThese two methods are discussed in the following sections. For methods that are available in early processors, see Section: \342\200\234Identification of Earlier IA-32 Processors\342\200\235 in Chapter 20 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1.\nThe Processor Brand String Method\nFigure 3-9 describes the algorithm used for detection of the brand string. Processor brand identification software should execute this algorithm on all Intel 64 and IA-32 processors.\nThis method (introduced with Pentium 4 processors) returns an ASCII brand identification string and the Processor Base frequency of the processor to the EAX, EBX, ECX, and EDX registers.\nInput: EAX= 0x80000000\nCPUID\nIF (EAX & 0x80000000)\tFalse\tProcessor Brand String Not Supported\nCPUID Function Supported\tTrue \342\211\245 Extended\nEAX Return Value = Max. Extended CPUID Function Index\nIF (EAX Return Value \342\211\245\n0x80000004)\tTrue\tProcessor Brand String Supported\nOM15194\nFigure 3-9.  Determination of Support for the Processor Brand String\nHow Brand Strings Work\nTo use the brand string method, execute CPUID with EAX input of 8000002H through 80000004H. For each input value, CPUID returns 16 ASCII characters using EAX, EBX, ECX, and EDX. The returned string will be NULL-terminated.\nTable 3-13 shows the brand string that is returned by the first processor in the Pentium 4 processor family.\nTable 3-13.  Processor Brand String Returned with Pentium 4 Processor\nEAX Input Value\tReturn Values\tASCII Equivalent\n80000002H\tEAX = 20202020H EBX = 20202020H ECX = 20202020H EDX = 6E492020H\t\342\200\234 \342\200\235\n\342\200\234 \342\200\235\n\342\200\234 \342\200\235\n\342\200\234nI  \342\200\235\n80000003H\tEAX = 286C6574H EBX = 50202952H ECX = 69746E65H EDX = 52286D75H\t\342\200\234(let\342\200\235 \342\200\234P )R\342\200\235 \342\200\234itne\342\200\235 \342\200\234R(mu\342\200\235\n80000004H\tEAX = 20342029H EBX = 20555043H ECX = 30303531H EDX = 007A484DH\t\342\200\234 4 )\342\200\235 \342\200\234 UPC\342\200\235 \342\200\2340051\342\200\235 \342\200\234\\0zHM\342\200\235\nExtracting the Processor Frequency from Brand Strings\nFigure 3-10 provides an algorithm which software can use to extract the Processor Base frequency from the processor brand string.\nScan \"Brand String\" in Reverse Byte Order\n\"zHM\", or \"zHG\", or \"zHT\"\tMatch Substring\nFalse\nIF Substring Matched\tReport Error\nDetermine \"Freq\" and \"Multiplier\"\tTrue\tIf \"zHM\"\tMultiplier = 1 x 106\nIf \"zHG\"\nMultiplier = 1 x 109\nDetermine \"Multiplier\"\tIf \"zHT\"\nMultiplier = 1 x 1012\nScan Digits Until Blank\nDetermine \"Freq\"\tIn Reverse Order\tReverse Digits To Decimal Value\nProcessor Base Frequency = \"Freq\" x \"Multiplier\"\t\"Freq\" = X.YZ if Digits = \"ZY.X\"\nOM15195\nFigure 3-10.  Algorithm for Extracting Processor Frequency\nThe Processor Brand Index Method\nThe brand index method (introduced with Pentium\302\256 III Xeon\302\256 processors) provides an entry point into a brand identification table that is maintained in memory by system software and is accessible from system- and user-level code. In this table, each brand index is associate with an ASCII brand identification string that identifies the official Intel family and model number of a processor.\nWhen CPUID executes with EAX set to 1, the processor returns a brand index to the low byte in EBX. Software can then use this index to locate the brand identification string for the processor in the brand identification table. The first entry (brand index 0) in this table is reserved, allowing for backward compatibility with processors that do not support the brand identification feature. Starting with processor signature family ID = 0FH, model = 03H, brand index method is no longer supported. Use brand string method instead.\nTable 3-14 shows brand indices that have identification strings associated with them.\nTable 3-14.  Mapping of Brand Indices; and Intel 64 and IA-32 Processor Brand Strings\nBrand Index\tBrand String\n00H\tThis processor does not support the brand identification feature\n01H\tIntel(R) Celeron(R) processor1\n02H\tIntel(R) Pentium(R) III processor1\n03H\tIntel(R) Pentium(R) III Xeon(R) processor; If processor signature = 000006B1h, then Intel(R) Celeron(R) processor\n04H\tIntel(R) Pentium(R) III processor\n06H\tMobile Intel(R) Pentium(R) III processor-M\n07H\tMobile Intel(R) Celeron(R) processor1\n08H\tIntel(R) Pentium(R) 4 processor\n09H\tIntel(R) Pentium(R) 4 processor\n0AH\tIntel(R) Celeron(R) processor1\n0BH\tIntel(R) Xeon(R) processor; If processor signature = 00000F13h, then Intel(R) Xeon(R) processor MP\n0CH\tIntel(R) Xeon(R) processor MP\n0EH\tMobile Intel(R) Pentium(R) 4 processor-M; If processor signature = 00000F13h, then Intel(R) Xeon(R) processor\n0FH\tMobile Intel(R) Celeron(R) processor1\n11H\tMobile Genuine Intel(R) processor\n12H\tIntel(R) Celeron(R) M processor\n13H\tMobile Intel(R) Celeron(R) processor1\n14H\tIntel(R) Celeron(R) processor\n15H\tMobile Genuine Intel(R) processor\n16H\tIntel(R) Pentium(R) M processor\n17H\tMobile Intel(R) Celeron(R) processor1\n18H - 0FFH\tRESERVED\nNOTES: 1.Indicates versions of these processors that were introduced after the Pentium III"
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "PMAXSB/PMAXSW/PMAXSD/PMAXSQ"
    short_description: "Maximum of Packed Signed Integers"
  }
  instruction_groups {
    name: "FCOS"
    short_description: "Cosine"
    description: "Computes the approximate cosine of the source operand in register ST(0) and stores the result in ST(0). The source operand must be given in radians and must be within the range \342\210\222263 to +263. The following table shows the results obtained when taking the cosine of various classes of numbers.\nTable 3-23.  FCOS Results\nST(0) SRC\tST(0) DEST\n\342\210\222 \342\210\236\t*\n\342\210\222 F\t\342\210\2221 to +1\n\342\210\222 0\t+ 1\n+ 0\t+ 1\n+ F\t\342\210\222 1 to + 1\n+ \342\210\236\t*\nNaN\tNaN\nNOTES:\nF Means finite floating-point value.\n* Indicates floating-point invalid-arithmetic-operand (#IA) exception.\nIf the source operand is outside the acceptable range, the C2 flag in the FPU status word is set, and the value in register ST(0) remains unchanged. The instruction does not raise an exception when the source operand is out of range. It is up to the program to check the C2 flag for out-of-range conditions. Source values outside the range \342\210\222 263 to +263 can be reduced to the range of the instruction by subtracting an appropriate integer multiple of 2\317\200.\nHowever, even within the range -263 to +263, inaccurate results can occur because the finite approximation of \317\200 used internally for argument reduction is not sufficient in all cases. Therefore, for accurate results it is safe to apply FCOS only to arguments reduced accurately in software, to a value smaller in absolute value than 3\317\200/8. See the sections titled \342\200\234Approximation of Pi\342\200\235 and \342\200\234Transcendental Instruction Accuracy\342\200\235 in Chapter 8 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1, for a discussion of the proper value to use for \317\200 in performing such reductions.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C1\tSet to 0 if stack underflow occurred.\nSet if result was rounded up; cleared otherwise.\nUndefined if C2 is 1.\nC2\tSet to 1 if outside range (\342\210\222263 < source operand < +263); otherwise, set to 0.\nC0, C3\tUndefined."
    }
  }
  instruction_groups {
    name: "SHA256MSG1"
    short_description: "Perform an Intermediate Calculation for the Next Four SHA256 Message Dwords"
  }
  instruction_groups {
    name: "CVTTPS2PI"
    short_description: "Convert with Truncation Packed Single-Precision FP Values to Packed Dword Integers"
    description: "Converts two packed single-precision floating-point values in the source operand (second operand) to two packed signed doubleword integers in the destination operand (first operand). The source operand can be an XMM register or a 64-bit memory location. The destination operand is an MMX technology register. When the source operand is an XMM register, the two single-precision floating-point values are contained in the low quadword of the register.\nWhen a conversion is inexact, a truncated (round toward zero) result is returned. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.\nThis instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the CVTTPS2PI instruction is executed.\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15)."
  }
  instruction_groups {
    name: "CVTTPD2PI"
    short_description: "Convert with Truncation Packed Double-Precision FP Values to Packed Dword Integers"
    description: "Converts two packed double-precision floating-point values in the source operand (second operand) to two packed signed doubleword integers in the destination operand (first operand). The source operand can be an XMM register or a 128-bit memory location. The destination operand is an MMX technology register.\nWhen a conversion is inexact, a truncated (round toward zero) result is returned. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.\nThis instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the CVTTPD2PI instruction is executed.\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15)."
  }
  instruction_groups {
    name: "VPERMD/VPERMW"
    short_description: "Permute Packed Doublewords/Words Elements"
  }
  instruction_groups {
    name: "CVTPD2DQ"
    short_description: "Convert Packed Double-Precision Floating-Point Values to Packed Doubleword Integers"
    description: "Converts packed double-precision floating-point values in the source operand (second operand) to packed signed doubleword integers in the destination operand (first operand).\nWhen a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (2w-1, where w represents the number of bits in the destination format) is returned.\nEVEX encoded versions: The source operand is a ZMM/YMM/XMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1. The upper bits (MAXVL-1:256/128/64) of the corresponding destination are zeroed.\nVEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\nVEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:64) of the corresponding ZMM register destination are zeroed.\n128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination operand is an XMM register. Bits[127:64] of the destination XMM register are zeroed. However, the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\nVEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.\nSRC\tX3\tX2\tX1\tX0\nDEST\t0\tX3\tX2\tX1\tX0\nFigure 3-12.  VCVTPD2DQ (VEX.256 encoded version)"
  }
  instruction_groups {
    name: "FXCH"
    short_description: "Exchange Register Contents"
    description: "Exchanges the contents of registers ST(0) and ST(i). If no source operand is specified, the contents of ST(0) and ST(1) are exchanged.\nThis instruction provides a simple means of moving values in the FPU register stack to the top of the stack [ST(0)], so that they can be operated on by those floating-point instructions that can only operate on values in ST(0). For example, the following instruction sequence takes the square root of the third register from the top of the register stack: FXCH ST(3); FSQRT; FXCH ST(3);\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C1\tSet to 0.\nC0, C2, C3\tUndefined."
    }
  }
  instruction_groups {
    name: "VPSCATTERDD/VPSCATTERDQ/VPSCATTERQD/VPSCATTERQQ"
    short_description: "Scatter Packed Dword, Packed Qword with Signed Dword, Signed"
  }
  instruction_groups {
    name: "SYSCALL"
    short_description: "Fast System Call"
    description: "SYSCALL invokes an OS system-call handler at privilege level 0. It does so by loading RIP from the IA32_LSTAR MSR (after saving the address of the instruction following SYSCALL into RCX). (The WRMSR instruction ensures that the IA32_LSTAR MSR always contain a canonical address.)\nSYSCALL also saves RFLAGS into R11 and then masks RFLAGS using the IA32_FMASK MSR (MSR address C0000084H); specifically, the processor clears in RFLAGS every bit corresponding to a bit that is set in the IA32_FMASK MSR.\nSYSCALL loads the CS and SS selectors with values derived from bits 47:32 of the IA32_STAR MSR. However, the CS and SS descriptor caches are not loaded from the descriptors (in GDT or LDT) referenced by those selectors.\nInstead, the descriptor caches are loaded with fixed values. See the Operation section for details. It is the responsibility of OS software to ensure that the descriptors (in GDT or LDT) referenced by those selector values correspond to the fixed values loaded into the descriptor caches; the SYSCALL instruction does not ensure this correspondence.\nThe SYSCALL instruction does not save the stack pointer (RSP). If the OS system-call handler will change the stack pointer, it is the responsibility of software to save the previous value of the stack pointer. This might be done prior to executing SYSCALL, with software restoring the stack pointer with the instruction following SYSCALL (which will be executed after SYSRET). Alternatively, the OS system-call handler may save the stack pointer and restore it before executing SYSRET.\nWhen shadow stacks are enabled at a privilege level where the SYSCALL instruction is invoked, the SSP is saved to the IA32_PL3_SSP MSR. If shadow stacks are enabled at privilege level 0, the SSP is loaded with 0. Refer to Chapter 6, \342\200\234Procedure Calls, Interrupts, and Exceptions\342\200\235 and Chapter 18, \342\200\234Control-Flow Enforcement Technology (CET)\342\200\235 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1 for additional CET details.\nInstruction ordering. Instructions following a SYSCALL may be fetched from memory before earlier instructions complete execution, but they will not execute (even speculatively) until all instructions prior to the SYSCALL have completed execution (the later instructions may execute before data stored by the earlier instructions have become globally visible)."
    flags_affected {
      content: "All."
    }
  }
  instruction_groups {
    name: "STC"
    short_description: "Set Carry Flag"
    description: "Sets the CF flag in the EFLAGS register. Operation is the same in all modes."
    flags_affected {
      content: "The CF flag is set. The OF, ZF, SF, AF, and PF flags are unaffected."
    }
  }
  instruction_groups {
    name: "VPTESTNMB/W/D/Q"
    short_description: "Logical NAND and Set"
  }
  instruction_groups {
    name: "MOVAPD"
    short_description: "Move Aligned Packed Double-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "VPDPBUSDS"
    short_description: "Multiply and Add Unsigned and Signed Bytes with Saturation"
  }
  instruction_groups {
    name: "CVTSD2SS"
    short_description: "Convert Scalar Double-Precision Floating-Point Value to Scalar Single-Precision Floating-Point Value"
    description: "Converts a double-precision floating-point value in the \342\200\234convert-from\342\200\235 source operand (the second operand in SSE2 version, otherwise the third operand) to a single-precision floating-point value in the destination operand.\nWhen the \342\200\234convert-from\342\200\235 operand is an XMM register, the double-precision floating-point value is contained in the low quadword of the register. The result is stored in the low doubleword of the destination operand. When the conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.\n128-bit Legacy SSE version: The \342\200\234convert-from\342\200\235 source operand (the second operand) is an XMM register or memory location. Bits (MAXVL-1:32) of the corresponding destination register remain unchanged. The destination operand is an XMM register.\nVEX.128 and EVEX encoded versions: The \342\200\234convert-from\342\200\235 source operand (the third operand) can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers. Bits (127:32) of the XMM register destination are copied from the corresponding bits in the first source operand. Bits (MAXVL- 1:128) of the destination register are zeroed.\nEVEX encoded version: the converted result in written to the low doubleword element of the destination under the writemask.\nSoftware should ensure VCVTSD2SS is encoded with VEX.L=0. Encoding VCVTSD2SS with VEX.L=1 may encounter unpredictable behavior across different processor generations."
  }
  instruction_groups {
    name: "CMPXCHG"
    short_description: "Compare and Exchange"
    description: "Compares the value in the AL, AX, EAX, or RAX register with the first operand (destination operand). If the two values are equal, the second operand (source operand) is loaded into the destination operand. Otherwise, the destination operand is loaded into the AL, AX, EAX or RAX register. RAX register is available only in 64-bit mode.\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically. To simplify the interface to the processor\342\200\231s bus, the destination operand receives a write cycle without regard to the result of the comparison. The destination operand is written back if the comparison fails; otherwise, the source operand is written into the destination. (The processor never produces a locked read without also producing a locked write.)\nIn 64-bit mode, the instruction\342\200\231s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the sum mary chart at the\nbeginning of this section for encoding data and limits."
    flags_affected {
      content: "The ZF flag is set if the values in the destination operand and register AL, AX, or EAX are equal; otherwise it is cleared. The CF, PF, AF, SF, and OF flags are set according to the results of the comparison operation."
    }
  }
  instruction_groups {
    name: "VFNMSUB132PD/VFNMSUB213PD/VFNMSUB231PD"
    short_description: "Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point"
  }
  instruction_groups {
    name: "UNPCKLPS"
    short_description: "Unpack and Interleave Low Packed Single-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "MOV"
    short_description: "Move"
    description: "Copies the second operand (source operand) to the first operand (destination operand). The source operand can be an im\nmediate value, general-purpose register, segment register, or memory location; the destination register can be a general-purpose register, segment register, or memory location. Both operands must be the same size, which can be a byte, a word, a doubleword, or a quadword.\nThe MOV instruction cannot be used to load the CS register. Attempting to do so results in an invalid opcode exception (#UD). To load the CS register, use the far JMP, CALL, or RET instruction.\nIf the destination operand is a segment register (DS, ES, FS, GS, or SS), the source operand must be a valid segment selector. In protected mode, moving a segment selector into a segment register automatically causes the segment descriptor information associated with that segment selector to be loaded into the hidden (shadow) part of the segment register. While loading this information, the segment selector and segment descriptor information is validated (see the \342\200\234Operation\342\200\235 algorithm below). The segment descriptor data is obtained from the GDT or LDT entry for the specified segment selector.\nA NULL segment selector (values 0000-0003) can be loaded into the DS, ES, FS, and GS registers without causing a protection exception. However, any subsequent attempt to reference a segment whose corresponding segment register is loaded with a NULL value causes a general protection exception (#GP) and no memory reference occurs.\nLoading the SS register with a MOV instruction suppresses or inhibits some debug exceptions and inhibits interrupts on the following instruction boundary. (The inhibition ends after delivery of an exception or the execution of the next instruction.) This behavior allows a stack pointer to be loaded into the ESP register with the next instruction (MOV ESP, stack-pointer value) before an event can be delivered. See Section 6.8.3, \342\200\234Masking Exceptions and Interrupts When Switching Stacks,\342\200\235 in Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3A. Intel recom mends that software use the LSS instruction to load the SS register and ESP together.\nWhen executing MOV Reg, Sreg, the processor copies the content of Sreg to the 16 least significant bits of the general-purpose register. The upper bits of the destination register are zero for most IA-32 processors (Pentium Pro processors and later) and all Intel 64 processors, with the exception that bits 31:16 are undefined for Intel Quark X1000 processors, Pentium and earlier processors.\nIn 64-bit mode, the instruction\342\200\231s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the sum mary chart at the\nbeginning of this section for encoding data and limits."
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "FSCALE"
    short_description: "Scale"
    description: "Truncates the value in the source operand (toward 0) to an integral value and adds that value to the exponent of the destination operand. The destination and source operands are floating-point values located in registers ST(0) and ST(1), respectively. This instruction provides rapid multiplication or division by integral powers of 2. The following table shows the results obtained when scaling various classes of numbers, assuming that neither overflow nor underflow occurs.\nTable 3-34.  FSCALE Results\nST(1)\n\342\210\222 \342\210\236\t\342\210\222 F\t\342\210\222 0\t+ 0\t+ F\t+ \342\210\236\tNaN\n\342\210\222 \342\210\236\tNaN\t\342\210\222 \342\210\236\t\342\210\222 \342\210\236\t\342\210\222 \342\210\236\t\342\210\222 \342\210\236\t\342\210\222 \342\210\236\tNaN\nST(0)\t\342\210\222 F\t\342\210\222 0\t\342\210\222 F\t\342\210\222 F\t\342\210\222 F\t\342\210\222 F\t\342\210\222 \342\210\236\tNaN\n\342\210\222 0\t\342\210\222 0\t\342\210\222 0\t\342\210\222 0\t\342\210\222 0\t\342\210\222 0\tNaN\tNaN\n+ 0\t+ 0\t+ 0\t+ 0\t+ 0\t+ 0\tNaN\tNaN\n+ F\t+ 0\t+ F\t+ F\t+ F\t+ F\t+ \342\210\236\tNaN\n+ \342\210\236\tNaN\t+ \342\210\236\t+ \342\210\236\t+ \342\210\236\t+ \342\210\236\t+ \342\210\236\tNaN\nNaN\tNaN\tNaN\tNaN\tNaN\tNaN\tNaN\tNaN\nNOTES:\nF\tMeans finite floating-point value.\nIn most cases, only the exponent is changed and the mantissa (significand) remains unchanged. However, when the value being scaled in ST(0) is a denormal value, the mantissa is also changed and the result may turn out to be a normalized number. Similarly, if overflow or underflow results from a scale operation, the resulting mantissa will differ from the source\342\200\231s mantissa.\nThe FSCALE instruction can also be used to reverse the action of the FXTRACT instruction, as shown in the following example: FXTRACT; FSCALE; FSTP ST(1);\nIn this example, the FXTRACT instruction extracts the significand and exponent from the value in ST(0) and stores them in ST(0) and ST(1) respectively. The FSCALE then scales the significand in ST(0) by the exponent in ST(1), recreating the original value before the FXTRACT operation was performed. The FSTP ST(1) instruction overwrites the exponent (extracted by the FXTRACT instruction) with the recreated value, which returns the stack to its original state with only one register [ST(0)] occupied.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C1\tSet to 0 if stack underflow occurred.\nSet if result was rounded up; cleared otherwise.\nC0, C2, C3\tUndefined."
    }
  }
  instruction_groups {
    name: "PCMPISTRM"
    short_description: "Packed Compare Implicit Length Strings, Return Mask"
    description: "The instruction compares data from two strings based on the encoded value in the im\tm8 byte (see Section 4.1,\n\342\200\234Im m8 Control Byte Operation for PCMPESTRI / PCMPESTRM / PCMPISTRI / PCMPISTRM\342\200\235) generating a mask stored to XMM0.\nEach string is represented by a single value. The value is an xm m (or possibly m128 for the second operand) which contains the data elements of the string (byte or word data). Each input byte/word is augmented with a valid/invalid tag. A byte/word is considered valid only if it has a lower index than the least significant null byte/word. (The least significant null byte/word is also considered invalid.)\nThe comparison and aggregation operation are performed according to the encoded value of Im m8 bit fields (see\nSection 4.1). As defined by im m8[6], IntRes2 is then either stored to the least significant bits of XMM0 (zero extended to 128 bits) or expanded into a byte/word-mask and then stored to XMM0.\nNote that the Arithmetic Flags are written in a non-standard manner in order to supply the most relevant information:\nCFlag - Reset if IntRes2 is equal to zero, set otherwise ZFlag - Set if any byte/word of xmm2/mem128 is null, reset otherwise SFlag - Set if any byte/word of xmm1 is null, reset otherwise OFlag - IntRes2[0] AFlag - Reset PFlag - Reset Note: In VEX.128 encoded versions, bits (MAXVL-1:128) of XMM0 are zeroed. VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD."
  }
  instruction_groups {
    name: "SHA1MSG2"
    short_description: "Perform a Final Calculation for the Next Four SHA1 Message Dwords"
  }
  instruction_groups {
    name: "XABORT"
    short_description: "Transactional Abort"
    description: "XABORT forces an RTM abort. Following an RTM abort, the logical processor resumes execution at the fallback address computed through the outermost XBEGIN instruction. The EAX register is updated to reflect an XABORT instruction caused the abort, and the im m8 argument will be provided in bits 31:24 of EAX."
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "XCHG"
    short_description: "Exchange Register/Memory with Register"
    description: "Exchanges the contents of the destination (first) and source (second) operands. The operands can be two generalpurpose registers or a register and a memory location. If a memory operand is referenced, the processor\342\200\231s locking protocol is automatically implemented for the duration of the exchange operation, regardless of the presence or absence of the LOCK prefix or of the value of the IOPL. (See the LOCK prefix description in this chapter for more information on the locking protocol.)\nThis instruction is useful for implementing semaphores or similar data structures for process synchronization. (See \342\200\234Bus Locking\342\200\235 in Chapter 8 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3A, for more information on bus locking.)\nThe XCHG instruction can also be used instead of the BSWAP instruction for 16-bit operands.\nIn 64-bit mode, the instruction\342\200\231s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the sum mary chart at the beginning of this section for encoding data and limits.\nNOTE\nXCHG (E)AX, (E)AX (encoded instruction byte is 90H) is an alias for NOP regardless of data size prefixes, including REX.W."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "FILD"
    short_description: "Load Integer"
    description: "Converts the signed-integer source operand into double extended-precision floating-point format and pushes the value onto the FPU register stack. The source operand can be a word, doubleword, or quadword integer. It is loaded without rounding errors. The sign of the source operand is preserved.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C1\tSet to 1 if stack overflow occurred; set to 0 otherwise.\nC0, C2, C3\tUndefined."
    }
  }
  instruction_groups {
    name: "ROUNDPS"
    short_description: "Round Packed Single Precision Floating-Point Values"
    description: "Round the 4 single-precision floating-point values in the source operand (second operand) using the rounding mode specified in the im\nmediate operand (third operand) and place the results in the destination operand (first operand). The rounding process rounds each input floating-point value to an integer value and returns the integer result as a single-precision floating-point value.\nThe im mediate operand specifies control fields for the rounding operation, three bit fields are defined and shown in\nFigure 4-24. Bit 3 of the im mediate byte controls processor behavior for a precision exception, bit 2 selects the source of rounding mode control. Bits 1:0 specify a non-sticky rounding-mode value (Table 4-17 lists the encoded values for rounding-mode field).\nThe Precision Floating-Point Exception is signaled according to the im mediate operand. If any source operand is an SNaN then it will be converted to a QNaN. If DAZ is set to \342\200\2301 then denormals will be converted to zero before rounding.\n128-bit Legacy SSE version: The second source can be an XMM register or 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.\nVEX.128 encoded version: the source operand second source operand or a 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.\nVEX.256 encoded version: The source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
  }
  instruction_groups {
    name: "VINSERTF128/VINSERTF32x4/VINSERTF64x2/VINSERTF32x8/VINSERTF64x4"
    short_description: "Insert Packed Floating-Point Values"
  }
  instruction_groups {
    name: "CLFLUSH"
    short_description: "Flush Cache Line"
    description: "Invalidates from every level of the cache hierarchy in the cache coherence domain the cache line that contains the linear address specified with the memory operand. If that cache line contains modified data at any level of the cache hierarchy, that data is written back to memory. The source operand is a byte memory location.\nThe availability of CLFLUSH is indicated by the presence of the CPUID feature flag CLFSH (CPUID.01H:EDX[bit19]). The aligned cache line size affected is also indicated with the CPUID instruction (bits 8 through 15 of the EBX register when the initial value in the EAX register is 1).\nThe memory attribute of the page containing the affected line has no effect on the behavior of this instruction. It should be noted that processors are free to speculatively fetch and cache data from system memory regions assigned a memory-type allowing for speculative reads (such as, the WB, WC, and WT memory types). PREFETCHh instructions can be used to provide the processor with hints for this speculative behavior. Because this speculative fetching can occur at any time and is not tied to instruction execution, the CLFLUSH instruction is not ordered with respect to PREFETCHh instructions or any of the speculative fetching mechanisms (that is, data can be speculatively loaded into a cache line just before, during, or after the execution of a CLFLUSH instruction that references the cache line).\nExecutions of the CLFLUSH instruction are ordered with respect to each other and with respect to writes, locked read-modify-write instructions, and fence instructions.1 They are not ordered with respect to executions of CLFLUSHOPT and CLWB. Software can use the SFENCE instruction to order an execution of CLFLUSH relative to one of those operations.\nThe CLFLUSH instruction can be used at all privilege levels and is subject to all permission checking and faults associated with a byte load (and in addition, a CLFLUSH instruction is allowed to flush a linear address in an executeonly segment). Like a load, the CLFLUSH instruction sets the A bit but not the D bit in the page tables.\nIn some implementations, the CLFLUSH instruction may always cause transactional abort with Transactional Synchronization Extensions (TSX). The CLFLUSH instruction is not expected to be com monly used inside typical\ntransactional regions. However, program mers must not rely on CLFLUSH instruction to force a transactional abort, since whether they cause transactional abort is implementation dependent.\nThe CLFLUSH instruction was introduced with the SSE2 extensions; however, because it has its own CPUID feature flag, it can be implemented in IA-32 processors that do not include the SSE2 extensions. Also, detecting the presence of the SSE2 extensions with the CPUID instruction does not guarantee that the CLFLUSH instruction is implemented in the processor.\nCLFLUSH operation is the same in non-64-bit modes and 64-bit mode."
  }
  instruction_groups {
    name: "RDPMC"
    short_description: "Read Performance-Monitoring Counters"
    description: "The EAX register is loaded with the low-order 32 bits. The EDX register is loaded with the supported high-order bits of the counter. The number of high-order bits loaded into EDX is implementation specific on processors that do no support architectural performance monitoring. The width of fixed-function and general-purpose performance counters on processors supporting architectural performance monitoring are reported by CPUID 0AH leaf. See below for the treatment of the EDX register for \342\200\234fast\342\200\235 reads.\nThe ECX register specifies the counter type (if the processor supports architectural performance monitoring) and counter index. Counter type is specified in ECX[30] to select one of two type of performance counters. If the processor does not support architectural performance monitoring, ECX[30:0] specifies the counter index; otherwise ECX[29:0] specifies the index relative to the base of each counter type. ECX[31] selects \342\200\234fast\342\200\235 read mode if supported. The two counter types are:\n\342\200\242\tGeneral-purpose or special-purpose performance counters are specified with ECX[30] = 0: The number of general-purpose performance counters on processor supporting architectural performance monitoring are reported by CPUID 0AH leaf. The availability of special-purpose counters, as well as the number of generalpurpose counters if the processor does not support architectural performance monitoring, is model specific; see Chapter 18, \342\200\234Performance Monitoring\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3B.\n\342\200\242\tFixed-function performance counters are specified with ECX[30] = 1. The number fixed-function performance counters is enumerated by CPUID 0AH leaf. See Chapter 18, \342\200\234Performance Monitoring\342\200\235 of Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3B. This counter type is selected if ECX[30] is set.\nThe width of fixed-function performance counters and general-purpose performance counters on processors supporting architectural performance monitoring are reported by CPUID 0AH leaf. The width of general-purpose performance counters are 40-bits for processors that do not support architectural performance monitoring counters. The width of special-purpose performance counters are implementation specific.\nWhen in protected or virtual 8086 mode, the performance-monitoring counters enabled (PCE) flag in register CR4 restricts the use of the RDPMC instruction as follows. When the PCE flag is set, the RDPMC instruction can be executed at any privilege level; when the flag is clear, the instruction can only be executed at privilege level 0.\n(When in real-address mode, the RDPMC instruction is always enabled.)\nThe performance-monitoring counters can also be read with the RDMSR instruction, when executing at privilege level 0.\nThe performance-monitoring counters are event counters that can be program med to count events such as the number of instructions decoded, number of interrupts received, or number of cache loads. Chapter 19, \342\200\234Performance Monitoring Events,\342\200\235 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3B, lists the events that can be counted for various processors in the Intel 64 and IA-32 architecture families.\nThe RDPMC instruction is not a serializing instruction; that is, it does not imply that all the events caused by the preceding instructions have been completed or that events caused by subsequent instructions have not begun. If an exact event count is desired, software must insert a serializing instruction (such as the CPUID instruction) before and/or after the RDPMC instruction.\nPerforming back-to-back fast reads are not guaranteed to be monotonic. To guarantee monotonicity on back-toback reads, a serializing instruction must be placed between the two RDPMC instructions.\nThe RDPMC instruction can execute in 16-bit addressing mode or virtual-8086 mode; however, the full contents of the ECX register are used to select the counter, and the event count is stored in the full EAX and EDX registers. The RDPMC instruction was introduced into the IA-32 Architecture in the Pentium Pro processor and the Pentium processor with MMX technology. The earlier Pentium processors have performance-monitoring counters, but they must be read with the RDMSR instruction."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "VPBROADCASTB/W/D/Q"
    short_description: "Load with Broadcast Integer Data from General Purpose Register"
  }
  instruction_groups {
    name: "VGETMANTSD"
    short_description: "Extract Float64 of Normalized Mantissas from Float64 Scalar"
  }
  instruction_groups {
    name: "MOVDQ2Q"
    short_description: "Move Quadword from XMM to MMX Technology Register"
    description: "Moves the low quadword from the source operand (second operand) to the destination operand (first operand). The source operand is an XMM register and the destination operand is an MMX technology register.\nThis instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the MOVDQ2Q instruction is executed.\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15)."
  }
  instruction_groups {
    name: "VPCOMPRESSQ"
    short_description: "Store Sparse Packed Quadword Integer Values into Dense Memory/Register"
  }
  instruction_groups {
    name: "VRANGEPS"
    short_description: "Range Restriction Calculation For Packed Pairs of Float32 Values"
  }
  instruction_groups {
    name: "VRCP14SS"
    short_description: "Compute Approximate Reciprocal of Scalar Float32 Value"
  }
  instruction_groups {
    name: "SHA1RNDS4"
    short_description: "Perform Four Rounds of SHA1 Operation"
  }
  instruction_groups {
    name: "MASKMOVDQU"
    short_description: "Store Selected Bytes of Double Quadword"
    description: "Stores selected bytes from the source operand (first operand) into an 128-bit memory location. The mask operand (second operand) selects which bytes from the source operand are written to memory. The source and mask operands are XMM registers. The memory location specified by the effective address in the DI/EDI/RDI register (the default segment register is DS, but this may be overridden with a segment-override prefix). The memory location does not need to be aligned on a natural boundary. (The size of the store address depends on the address-size attribute.)\nThe most significant bit in each byte of the mask operand determines whether the corresponding byte in the source operand is written to the corresponding byte location in memory: 0 indicates no write and 1 indicates write.\nThe MASKMOVDQU instruction generates a non-temporal hint to the processor to minimize cache pollution. The non-temporal hint is implemented by using a write combining (WC) memory type protocol (see \342\200\234Caching of Temporal vs. Non-Temporal Data\342\200\235 in Chapter 10, of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1). Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with the SFENCE or MFENCE instruction should be used in conjunction with MASKMOVDQU instructions if multiple processors might use different memory types to read/write the destination memory locations.\nBehavior with a mask of all 0s is as follows:\n\342\200\242\tNo data will be written to memory.\n\342\200\242\tSignaling of breakpoints (code or data) is not guaranteed; different processor implementations may signal or not signal these breakpoints.\n\342\200\242\tExceptions associated with addressing memory and page faults may still be signaled (implementation dependent).\n\342\200\242\tIf the destination memory region is mapped as UC or WP, enforcement of associated semantics for these memory types is not guaranteed (that is, is reserved) and is implementation-specific.\nThe MASKMOVDQU instruction can be used to improve performance of algorithms that need to merge data on a byte-by-byte basis. MASKMOVDQU should not cause a read for ownership; doing so generates unnecessary bandwidth since data is to be written directly using the byte-mask without allocating old data prior to the store.\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\nIf VMASKMOVDQU is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.\n1.ModRM.MOD = 011B required"
  }
  instruction_groups {
    name: "PUSH"
    short_description: "Push Word, Doubleword or Quadword Onto the Stack"
    description: "Decrements the stack pointer and then stores the source operand on the top of the stack. Address and operand sizes are determined and used as follows:\n\342\200\242\tAddress size. The D flag in the current code-segment descriptor determines the default address size; it may be overridden by an instruction prefix (67H).\nThe address size is used only when referencing a source operand in memory.\n\342\200\242\tOperand size. The D flag in the current code-segment descriptor determines the default operand size; it may be overridden by instruction prefixes (66H or REX.W).\nThe operand size (16, 32, or 64 bits) determines the amount by which the stack pointer is decremented (2, 4 or 8).\nIf the source operand is an im\nmediate of size less than the operand size, a sign-extended value is pushed on the stack. If the source operand is a segment register (16 bits) and the operand size is 64-bits, a zeroextended value is pushed on the stack; if the operand size is 32-bits, either a zero-extended value is pushed on the stack or the segment selector is written on the stack using a 16-bit move. For the last case, all recent Core and Atom processors perform a 16-bit move, leaving the upper portion of the stack location unmodified.\n\342\200\242\tStack-address size. Outside of 64-bit mode, the B flag in the current stack-segment descriptor determines the size of the stack pointer (16 or 32 bits); in 64-bit mode, the size of the stack pointer is always 64 bits.\nThe stack-address size determines the width of the stack pointer when writing to the stack in memory and when decrementing the stack pointer. (As stated above, the amount by which the stack pointer is\ndecremented is determined by the operand size.) If the operand size is less than the stack-address size, the PUSH instruction may result in a misaligned stack pointer (a stack pointer that is not aligned on a doubleword or quadword boundary).\nThe PUSH ESP instruction pushes the value of the ESP register as it existed before the instruction was executed. If a PUSH instruction uses a memory operand in which the ESP register is used for computing the operand address, the address of the operand is computed before the ESP register is decremented.\nIf the ESP or SP register is 1 when the PUSH instruction is executed in real-address mode, a stack-fault exception (#SS) is generated (because the limit of the stack segment is violated). Its delivery encounters a second stackfault exception (for the same reason), causing generation of a double-fault exception (#DF). Delivery of the double-fault exception encounters a third stack-fault exception, and the logical processor enters shutdown mode.\nSee the discussion of the double-fault exception in Chapter 6 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3A."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "VCVTPS2UDQ"
    short_description: "Convert Packed Single-Precision Floating-Point Values to Packed Unsigned Doubleword Integer Values"
  }
  instruction_groups {
    name: "VPSHLDV"
    short_description: "Concatenate and Variable Shift Packed Data Left Logical"
  }
  instruction_groups {
    name: "FINIT/FNINIT"
    short_description: "Initialize Floating-Point Unit"
    description: "Sets the FPU control, status, tag, instruction pointer, and data pointer registers to their default states. The FPU control word is set to 037FH (round to nearest, all exceptions masked, 64-bit precision). The status word is cleared (no exception flags set, TOP is set to 0). The data registers in the register stack are left unchanged, but they are all tagged as empty (11B). Both the instruction and data pointers are cleared.\nThe FINIT instruction checks for and handles any pending unmasked floating-point exceptions before performing the initialization; the FNINIT instruction does not.\nThe assembler issues two instructions for the FINIT instruction (an FWAIT instruction followed by an FNINIT instruction), and the processor executes each of these instructions in separately. If an exception is generated for either of these instructions, the save EIP points to the instruction that caused the exception.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C0, C1, C2, C3 set to 0."
    }
  }
  instruction_groups {
    name: "VRNDSCALESS"
    short_description: "Round Scalar Float32 Value To Include A Given Number Of Fraction Bits"
  }
  instruction_groups {
    name: "INS/INSB/INSW/INSD"
    short_description: "Input from Port to String"
    description: "Copies the data from the I/O port specified with the source operand (second operand) to the destination operand (first operand). The source operand is an I/O port address (from 0 to 65,535) that is read from the DX register. The destination operand is a memory location, the address of which is read from either the ES:DI, ES:EDI or the RDI registers (depending on the address-size attribute of the instruction, 16, 32 or 64, respectively). (The ES segment cannot be overridden with a segment override prefix.) The size of the I/O port being accessed (that is, the size of the source and destination operands) is determined by the opcode for an 8-bit I/O port or by the operand-size attribute of the instruction for a 16- or 32-bit I/O port.\nAt the assembly-code level, two forms of this instruction are allowed: the \342\200\234explicit-operands\342\200\235 form and the \342\200\234nooperands\342\200\235 form. The explicit-operands form (specified with the INS mnemonic) allows the source and destination operands to be specified explicitly. Here, the source operand must be \342\200\234DX,\342\200\235 and the destination operand should be a symbol that indicates the size of the I/O port and the destination address. This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the destination operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword), but it does not have to specify the correct location. The location is always specified by the ES:(E)DI registers, which must be loaded correctly before the INS instruction is executed.\nThe no-operands form provides \342\200\234short forms\342\200\235 of the byte, word, and doubleword versions of the INS instructions.\nHere also DX is assumed by the processor to be the source operand and ES:(E)DI is assumed to be the destination operand. The size of the I/O port is specified with the choice of mnemonic: INSB (byte), INSW (word), or INSD (doubleword).\nAfter the byte, word, or doubleword is transfer from the I/O port to the memory location, the DI/EDI/RDI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)DI register is incremented; if the DF flag is 1, the (E)DI register is decremented.) The (E)DI register is incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword operations.\nThe INS, INSB, INSW, and INSD instructions can be preceded by the REP prefix for block input of ECX bytes, words, or doublewords. See \342\200\234REP/REPE/REPZ /REPNE/REPNZ-Repeat String Operation Prefix\342\200\235 in Chapter 4 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 2B, for a description of the REP prefix.\nThese instructions are only useful for accessing I/O ports located in the processor\342\200\231s I/O address space. See Chapter 19, \342\200\234Input/Output,\342\200\235 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1, for more information on accessing I/O ports in the I/O address space.\nIn 64-bit mode, default address size is 64 bits, 32 bit address size is supported using the prefix 67H. The address of the memory destination is specified by RDI or EDI. 16-bit address size is not supported in 64-bit mode. The operand size is not promoted.\nThese instructions may read from the I/O port without writing to the memory location if an exception or VM exit occurs due to the write (e.g. #PF). If this would be problematic, for example because the I/O port read has sideeffects, software should ensure the write to the memory location does not cause an exception or VM exit."
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "STI"
    short_description: "Set Interrupt Flag"
    description: "In most cases, STI sets the interrupt flag (IF) in the EFLAGS register. This allows the processor to respond to maskable hardware interrupts.\nIf IF = 0, maskable hardware interrupts remain inhibited on the instruction boundary following an execution of STI.\n(The delayed effect of this instruction is provided to allow interrupts to be enabled just before returning from a procedure or subroutine. For instance, if an STI instruction is followed by an RET instruction, the RET instruction is allowed to execute before external interrupts are recognized. No interrupts can be recognized if an execution of CLI im\nmediately follow such an execution of STI.) The inhibition ends after delivery of another event (e.g., exception) or the execution of the next instruction.\nThe IF flag and the STI and CLI instructions do not prohibit the generation of exceptions and nonmaskable interrupts (NMIs). However, NMIs (and system-management interrupts) may be inhibited on the instruction boundary following an execution of STI that begins with IF = 0.\nOperation is different in two modes defined as follows:\n\342\200\242\tPVI mode (protected-mode virtual interrupts): CR0.PE\t= 1, EFLAGS.VM\t= 0, CPL\t= 3, and CR4.PVI\t= 1;\n\342\200\242\tVME mode (virtual-8086 mode extensions): CR0.PE\t= 1, EFLAGS.VM\t= 1, and CR4.VME\t= 1.\nIf IOPL < 3, EFLAGS.VIP = 1, and either VME mode or PVI mode is active, STI sets the VIF flag in the EFLAGS register, leaving IF unaffected.\nTable 4-18 indicates the action of the STI instruction depending on the processor operating mode, IOPL, CPL, and EFLAGS.VIP.\nTable 4-18.  Decision Table for STI Results\nMode\tIOPL\tEFLAGS.VIP\tSTI Result\nReal-address\tX1\tX\tIF = 1\n\342\211\245 CPL\tX\tIF = 1\nProtected, not PVI2\n< CPL\tX\t#GP fault\n3\tX\tIF = 1\nProtected, PVI3\t0\tVIF = 1\n0-2\n1\t#GP fault\n3\tX\tIF = 1\nVirtual-8086, not VME3\n0-2\tX\t#GP fault\n3\tX\tIF = 1\nVirtual-8086, VME3\t0\tVIF = 1\n0-2\n1\t#GP fault\nNOTES:\n1. X = This setting has no effect on instruction operation.\n2. For this table, \342\200\234protected mode\342\200\235 applies whenever CR0.PE= 1 and EFLAGS.VM= 0; it includes compatibility mode and 64-bit mode.\n3. PVI mode and virtual-8086 mode each imply CPL= 3."
    flags_affected {
      content: "Either the IF flag or the VIF flag is set to 1. Other flags are unaffected."
    }
  }
  instruction_groups {
    name: "VEXP2PS"
    short_description: "Approximation to the Exponential 2^x of Packed Single-Precision Floating-Point Values with Less Than 2^-23 Relative Er-"
  }
  instruction_groups {
    name: "VMXOFF"
    description: "Takes the logical processor out of VMX operation, unblocks INIT signals, conditionally re-enables A20M, and clears any address-range monitoring.7"
    flags_affected {
      content: "See the operation section and Section 30.2."
    }
  }
  instruction_groups {
    name: "ENCLS"
  }
  instruction_groups {
    name: "EEXTEND"
  }
  instruction_groups {
    name: "SETSSBSY"
    short_description: "Mark Shadow Stack Busy"
    description: "The SETSSBSY instruction verifies the presence of a non-busy supervisor shadow stack token at the address in the IA32_PL0_SSP MSR and marks it busy. Following successful execution of the instruction, the SSP is set to the value of the IA32_PL0_SSP MSR."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "EXTRACTPS"
    short_description: "Extract Packed Floating-Point Values"
    description: "Extracts a single-precision floating-point value from the source operand (second operand) at the 32-bit offset specified from im m8. Im mediate bits higher than the most significant offset for the vector length are ignored.\nThe extracted single-precision floating-point value is stored in the low 32-bits of the destination operand In 64-bit mode, destination register operand has default operand size of 64 bits. The upper 32-bits of the register are filled with zero. REX.W is ignored.\nVEX.128 and EVEX encoded version: When VEX.W1 or EVEX.W1 form is used in 64-bit mode with a general purpose register (GPR) as a destination operand, the packed single quantity is zero extended to 64 bits.\nVEX.vvvv/EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n128-bit Legacy SSE version: When a REX.W prefix is used in 64-bit mode with a general purpose register (GPR) as a destination operand, the packed single quantity is zero extended to 64 bits.\nThe source register is an XMM register. Im m8[1:0] determine the starting DWORD offset from which to extract the\n32-bit floating-point value.\nIf VEXTRACTPS is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception."
  }
  instruction_groups {
    name: "CMPXCHG8B/CMPXCHG16B"
    short_description: "Compare and Exchange Bytes"
    description: "Compares the 64-bit value in EDX:EAX (or 128-bit value in RDX:RAX if operand size is 128 bits) with the operand (destination operand). If the values are equal, the 64-bit value in ECX:EBX (or 128-bit value in RCX:RBX) is stored in the destination operand. Otherwise, the value in the destination operand is loaded into EDX:EAX (or RDX:RAX).\nThe destination operand is an 8-byte memory location (or 16-byte memory location if operand size is 128 bits). For the EDX:EAX and ECX:EBX register pairs, EDX and ECX contain the high-order 32 bits and EAX and EBX contain the low-order 32 bits of a 64-bit value. For the RDX:RAX and RCX:RBX register pairs, RDX and RCX contain the highorder 64 bits and RAX and RBX contain the low-order 64bits of a 128-bit value.\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically. To simplify the interface to the processor\342\200\231s bus, the destination operand receives a write cycle without regard to the result of the comparison. The destination operand is written back if the comparison fails; otherwise, the source operand is written into the destination. (The processor never produces a locked read without also producing a locked write.)\nIn 64-bit mode, default operation size is 64 bits. Use of the REX.W prefix promotes operation to 128 bits. Note that CMPXCHG16B requires that the destination (memory) operand be 16-byte aligned. See the sum\nmary chart at the beginning of this section for encoding data and limits. For information on the CPUID flag that indicates CMPXCHG16B, see page 3-220."
    flags_affected {
      content: "The ZF flag is set if the destination operand and EDX:EAX are equal; otherwise it is cleared. The CF, PF, AF, SF, and OF flags are unaffected."
    }
  }
  instruction_groups {
    name: "CMP"
    short_description: "Compare Two Operands"
    description: "Compares the first source operand with the second source operand and sets the status flags in the EFLAGS register according to the results. The comparison is performed by subtracting the second operand from the first operand and then setting the status flags in the same manner as the SUB instruction. When an im mediate value is used as\nan operand, it is sign-extended to the length of the first operand.\nThe condition codes used by the Jcc, CMOVcc, and SETcc instructions are based on the results of a CMP instruction.\nAppendix B, \342\200\234EFLAGS Condition Codes,\342\200\235 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1, shows the relationship of the status flags and the condition codes.\nIn 64-bit mode, the instruction\342\200\231s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the sum mary chart at the\nbeginning of this section for encoding data and limits."
    flags_affected {
      content: "The CF, OF, SF, ZF, AF, and PF flags are set according to the result."
    }
  }
  instruction_groups {
    name: "FLDCW"
    short_description: "Load x87 FPU Control Word"
    description: "Loads the 16-bit source operand into the FPU control word. The source operand is a memory location. This instruction is typically used to establish or change the FPU\342\200\231s mode of operation.\nIf one or more exception flags are set in the FPU status word prior to loading a new FPU control word and the new control word unmasks one or more of those exceptions, a floating-point exception will be generated upon execution of the next floating-point instruction (except for the no-wait floating-point instructions, see the section titled \342\200\234Software Exception Handling\342\200\235 in Chapter 8 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1). To avoid raising exceptions when changing FPU operating modes, clear any pending exceptions (using the FCLEX or FNCLEX instruction) before loading the new control word.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C0, C1, C2, C3 undefined."
    }
  }
  instruction_groups {
    name: "HADDPD"
    short_description: "Packed Double-FP Horizontal Add"
    description: "Adds the double-precision floating-point values in the high and low quadwords of the destination operand and stores the result in the low quadword of the destination operand.\nAdds the double-precision floating-point values in the high and low quadwords of the source operand and stores the result in the high quadword of the destination operand.\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).\nSee Figure\t3-16 for HADDPD; see Figure\t3-17 for VHADDPD.\nHADDPD xmm1, xmm2/m128\n[127:64]\t[63:0]\txmm2 /m128\n[127:64]\t[63:0]\txmm1\nxmm2/m128[63:0] + xmm2/m128[127:64]\txmm1[63:0] + xmm1[127:64]\tResult: xmm1\n[127:64]\t[63:0]\nOM15993\nFigure 3-16.  HADDPD-Packed Double-FP Horizontal Add\nSRC1\tX3\tX2\tX1\tX0\nSRC2\tY3\tY2\tY1\tY0\nDEST\tY2 + Y3\tX2 + X3\tY0 + Y1\tX0 + X1\nFigure 3-17.  VHADDPD operation\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.\nVEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register."
  }
  instruction_groups {
    name: "IMUL"
    short_description: "Signed Multiply"
    description: "Performs a signed multiplication of two operands. This instruction has three forms, depending on the number of operands.\n\342\200\242\tOne-operand form - This form is identical to that used by the MUL instruction. Here, the source operand (in a general-purpose register or memory location) is multiplied by the value in the AL, AX, EAX, or RAX register (depending on the operand size) and the product (twice the size of the input operand) is stored in the AX, DX:AX, EDX:EAX, or RDX:RAX registers, respectively.\n\342\200\242\tTwo-operand form - With this form the destination operand (the first operand) is multiplied by the source operand (second operand). The destination operand is a general-purpose register and the source operand is an im\nmediate value, a general-purpose register, or a memory location. The intermediate product (twice the size of the input operand) is truncated and stored in the destination operand location.\n\342\200\242\tThree-operand form - This form requires a destination operand (the first operand) and two source operands (the second and the third operands). Here, the first source operand (which can be a general-purpose register or a memory location) is multiplied by the second source operand (an im\nmediate value). The intermediate product (twice the size of the first source operand) is truncated and stored in the destination operand (a general-purpose register).\nWhen an im\tmediate value is used as an operand, it is sign-extended to the length of the destination operand\nformat.\nThe CF and OF flags are set when the signed integer value of the intermediate product differs from the sign extended operand-size-truncated product, otherwise the CF and OF flags are cleared.\nThe three forms of the IMUL instruction are similar in that the length of the product is calculated to twice the length of the operands. With the one-operand form, the product is stored exactly in the destination. With the two- and three- operand forms, however, the result is truncated to the length of the destination before it is stored in the destination register. Because of this truncation, the CF or OF flag should be tested to ensure that no significant bits are lost.\nThe two- and three-operand forms may also be used with unsigned operands because the lower half of the product is the same regardless if the operands are signed or unsigned. The CF and OF flags, however, cannot be used to determine if the upper half of the result is non-zero.\nIn 64-bit mode, the instruction\342\200\231s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. Use of REX.W modifies the three forms of the instruction as follows.\n\342\200\242\tOne-operand form -The source operand (in a 64-bit general-purpose register or memory location) is multiplied by the value in the RAX register and the product is stored in the RDX:RAX registers.\n\342\200\242\tTwo-operand form - The source operand is promoted to 64 bits if it is a register or a memory location. The destination operand is promoted to 64 bits.\n\342\200\242\tThree-operand form - The first source operand (either a register or a memory location) and destination operand are promoted to 64 bits. If the source operand is an im mediate, it is sign extended to 64 bits."
    flags_affected {
      content: "For the one operand form of the instruction, the CF and OF flags are set when significant bits are carried into the upper half of the result and cleared when the result fits exactly in the lower half of the result. For the two- and three-operand forms of the instruction, the CF and OF flags are set when the result must be truncated to fit in the destination operand size and cleared when the result fits exactly in the destination operand size. The SF, ZF, AF, and PF flags are undefined."
    }
  }
  instruction_groups {
    name: "LOCK"
    short_description: "Assert LOCK# Signal Prefix"
    description: "Causes the processor\342\200\231s LOCK# signal to be asserted during execution of the accompanying instruction (turns the instruction into an atomic instruction). In a multiprocessor environment, the LOCK# signal ensures that the processor has exclusive use of any shared memory while the signal is asserted.\nIn most IA-32 and all Intel 64 processors, locking may occur without the LOCK# signal being asserted. See the \342\200\234IA- 32 Architecture Compatibility\342\200\235 section below for more details.\nThe LOCK prefix can be prepended only to the following instructions and only to those forms of the instructions where the destination operand is a memory operand: ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCH8B, CMPXCHG16B, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD, and XCHG. If the LOCK prefix is used with one of these instructions and the source operand is a memory operand, an undefined opcode exception (#UD) may be generated. An undefined opcode exception will also be generated if the LOCK prefix is used with any instruction not in the above list. The XCHG instruction always asserts the LOCK# signal regardless of the presence or absence of the LOCK prefix.\nThe LOCK prefix is typically used with the BTS instruction to perform a read-modify-write operation on a memory location in shared memory environment.\nThe integrity of the LOCK prefix is not affected by the alignment of the memory field. Memory locking is observed for arbitrarily misaligned fields.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "FSTENV/FNSTENV"
    short_description: "Store x87 FPU Environment"
    description: "Saves the current FPU operating environment at the memory location specified with the destination operand, and then masks all floating-point exceptions. The FPU operating environment consists of the FPU control word, status word, tag word, instruction pointer, data pointer, and last opcode. Figures 8-9 through 8-12 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1, show the layout in memory of the stored environment, depending on the operating mode of the processor (protected or real) and the current operand-size attribute (16-bit or 32-bit). In virtual-8086 mode, the real mode layouts are used.\nThe FSTENV instruction checks for and handles any pending unmasked floating-point exceptions before storing the FPU environment; the FNSTENV instruction does not. The saved image reflects the state of the FPU after all floating-point instructions preceding the FSTENV/FNSTENV instruction in the instruction stream have been executed.\nThese instructions are often used by exception handlers because they provide access to the FPU instruction and data pointers. The environment is typically saved in the stack. Masking all exceptions after saving the environment prevents floating-point exceptions from interrupting the exception handler.\nThe assembler issues two instructions for the FSTENV instruction (an FWAIT instruction followed by an FNSTENV instruction), and the processor executes each of these instructions separately. If an exception is generated for either of these instructions, the save EIP points to the instruction that caused the exception.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "The C0, C1, C2, and C3 are undefined."
    }
  }
  instruction_groups {
    name: "FSTCW/FNSTCW"
    short_description: "Store x87 FPU Control Word"
    description: "Stores the current value of the FPU control word at the specified destination in memory. The FSTCW instruction checks for and handles pending unmasked floating-point exceptions before storing the control word; the FNSTCW instruction does not.\nThe assembler issues two instructions for the FSTCW instruction (an FWAIT instruction followed by an FNSTCW instruction), and the processor executes each of these instructions in separately. If an exception is generated for either of these instructions, the save EIP points to the instruction that caused the exception.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "The C0, C1, C2, and C3 flags are undefined."
    }
  }
  instruction_groups {
    name: "PHSUBSW"
    short_description: "Packed Horizontal Subtract and Saturate"
    description: "(V)PHSUBSW performs horizontal subtraction on each adjacent pair of 16-bit signed integers by subtracting the most significant word from the least significant word of each pair in the source and destination operands. The signed, saturated 16-bit results are packed to the destination operand (first operand). When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.\nLegacy SSE version: Both operands can be MMX registers. The second source operand can be an MMX register or a 64-bit memory location.\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nIn 64-bit mode, use the REX prefix to access additional registers.\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded version: The first source and destination operands are YMM registers. The second source operand can be an YMM register or a 256-bit memory location."
  }
  instruction_groups {
    name: "BLENDPS"
    short_description: "Blend Packed Single Precision Floating-Point Values"
    description: "Packed single-precision floating-point values from the second source operand (third operand) are conditionally merged with values from the first source operand (second operand) and written to the destination operand (first operand). The im\nmediate bits [7:0] determine whether the corresponding single precision floating-point value in the destination is copied from the second source or first source. If a bit in the mask, corresponding to a word, is \342\200\2341\342\200\235, then the single-precision floating-point value in the second source operand is copied, else the value in the first source operand is copied.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.\nVEX.128 encoded version: The first source operand an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register."
  }
  instruction_groups {
    name: "VFMADDSUB132PS/VFMADDSUB213PS/VFMADDSUB231PS"
    short_description: "Fused Multiply-Alternating Add/Subtract of Packed Single-Precision"
  }
  instruction_groups {
    name: "VSCATTERDPS/VSCATTERDPD/VSCATTERQPS/VSCATTERQPD"
    short_description: "Scatter Packed Single, Packed Double with Signed Dword and Qword"
  }
  instruction_groups {
    name: "RDFSBASE/RDGSBASE"
    short_description: "Read FS/GS Segment Base"
    description: "Loads the general-purpose register indicated by the modR/M:r/m field with the FS or GS segment base address.\nThe destination operand may be either a 32-bit or a 64-bit general-purpose register. The REX.W prefix indicates the operand size is 64 bits. If no REX.W prefix is used, the operand size is 32 bits; the upper 32 bits of the source base address (for FS or GS) are ignored and upper 32 bits of the destination register are cleared.\nThis instruction is supported only in 64-bit mode."
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "VMXON"
    description: "Puts the logical processor in VMX operation with no current VMCS, blocks INIT signals, disables A20M, and clears any address-range monitoring established by the MONITOR instruction.10\nThe operand of this instruction is a 4KB-aligned physical address (the VMXON pointer) that references the VMXON region, which the logical processor may use to support VMX operation. This operand is always 64 bits and is always in memory."
    flags_affected {
      content: "See the operation section and Section 30.2."
    }
  }
  instruction_groups {
    name: "FPTAN"
    short_description: "Partial Tangent"
    description: "Computes the approximate tangent of the source operand in register ST(0), stores the result in ST(0), and pushes a 1.0 onto the FPU register stack. The source operand must be given in radians and must be less than \302\261263. The following table shows the unmasked results obtained when computing the partial tangent of various classes of numbers, assuming that underflow does not occur.\nTable 3-33.  FPTAN Results\nST(0) SRC\tST(0) DEST\n\342\210\222 \342\210\236\t*\n\342\210\222 F\t\342\210\222 F to + F\n\342\210\222 0\t- 0\n+ 0\t+ 0\n+ F\t\342\210\222 F to + F\n+ \342\210\236\t*\nNaN\tNaN\nNOTES:\nF\tMeans finite floating-point value.\n*\tIndicates floating-point invalid-arithmetic-operand (#IA) exception.\nIf the source operand is outside the acceptable range, the C2 flag in the FPU status word is set, and the value in register ST(0) remains unchanged. The instruction does not raise an exception when the source operand is out of range. It is up to the program to check the C2 flag for out-of-range conditions. Source values outside the range \342\210\222 263 to +263 can be reduced to the range of the instruction by subtracting an appropriate integer multiple of 2\317\200.\nHowever, even within the range -263 to +263, inaccurate results can occur because the finite approximation of \317\200 used internally for argument reduction is not sufficient in all cases. Therefore, for accurate results it is safe to apply FPTAN only to arguments reduced accurately in software, to a value smaller in absolute value than 3\317\200/8. See the sections titled \342\200\234Approximation of Pi\342\200\235 and \342\200\234Transcendental Instruction Accuracy\342\200\235 in Chapter 8 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1, for a discussion of the proper value to use for \317\200 in performing such reductions.\nThe value 1.0 is pushed onto the register stack after the tangent has been computed to maintain compatibility with the Intel 8087 and Intel287 math coprocessors. This operation also simplifies the calculation of other trigonometric functions. For instance, the cotangent (which is the reciprocal of the tangent) can be computed by executing a FDIVR instruction after the FPTAN instruction.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C1\tSet to 0 if stack underflow occurred; set to 1 if stack overflow occurred.\nSet if result was rounded up; cleared otherwise.\nC2\tSet to 1 if outside range (\342\210\222263 < source operand < +263); otherwise, set to 0.\nC0, C3\tUndefined."
    }
  }
  instruction_groups {
    name: "LMSW"
    short_description: "Load Machine Status Word"
    description: "Loads the source operand into the machine status word, bits 0 through 15 of register CR0. The source operand can be a 16-bit general-purpose register or a memory location. Only the low-order 4 bits of the source operand (which contains the PE, MP, EM, and TS flags) are loaded into CR0. The PG, CD, NW, AM, WP, NE, and ET flags of CR0 are not affected. The operand-size attribute has no effect on this instruction.\nIf the PE flag of the source operand (bit 0) is set to 1, the instruction causes the processor to switch to protected mode. While in protected mode, the LMSW instruction cannot be used to clear the PE flag and force a switch back to real-address mode.\nThe LMSW instruction is provided for use in operating-system software; it should not be used in application programs. In protected or virtual-8086 mode, it can only be executed at CPL 0.\nThis instruction is provided for compatibility with the Intel 286 processor; programs and procedures intended to run on IA-32 and Intel 64 processors beginning with Intel386 processors should use the MOV (control registers) instruction to load the whole CR0 register. The MOV CR0 instruction can be used to set and clear the PE flag in CR0, allowing a procedure or program to switch between protected and real-address modes.\nThis instruction is a serializing instruction.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode. Note that the operand size is fixed at 16 bits.\nSee \342\200\234Changes to Instruction Behavior in VMX Non-Root Operation\342\200\235 in Chapter 25 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3C, for more information about the behavior of this instruction in VMX non-root operation."
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "BSR"
    short_description: "Bit Scan Reverse"
    description: "Searches the source operand (second operand) for the most significant set bit (1 bit). If a most significant 1 bit is found, its bit index is stored in the destination operand (first operand). The source operand can be a register or a memory location; the destination operand is a register. The bit index is an unsigned offset from bit 0 of the source operand. If the content source operand is 0, the content of the destination operand is undefined.\nIn 64-bit mode, the instruction\342\200\231s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the sum mary chart at the beginning of this section for encoding data and limits."
    flags_affected {
      content: "The ZF flag is set to 1 if the source operand is 0; otherwise, the ZF flag is cleared. The CF, OF, SF, AF, and PF flags are undefined."
    }
  }
  instruction_groups {
    name: "PADDUSB/PADDUSW"
    short_description: "Add Packed Unsigned Integers with Unsigned Saturation"
    description: "Performs a SIMD add of the packed unsigned integers from the source operand (second operand) and the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1, for an illustration of a SIMD operation.\nOverflow is handled with unsigned saturation, as described in the following paragraphs.\n(V)PADDUSB performs a SIMD add of the packed unsigned integers with saturation from the first source operand and second source operand and stores the packed integer results in the destination operand. When an individual byte result is beyond the range of an unsigned byte integer (that is, greater than FFH), the saturated value of FFH is written to the destination operand.\n(V)PADDUSW performs a SIMD add of the packed unsigned word integers with saturation from the first source operand and second source operand and stores the packed integer results in the destination operand. When an individual word result is beyond the range of an unsigned word integer (that is, greater than FFFFH), the saturated value of FFFFH is written to the destination operand.\nEVEX encoded versions: The first source operand is an ZMM/YMM/XMM register. The second source operand is an ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination is an ZMM/YMM/XMM register.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.\nVEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding destination register destination are zeroed.\n128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "CVTPD2PS"
    short_description: "Convert Packed Double-Precision Floating-Point Values to Packed Single-Precision Floating-Point Values"
    description: "Converts two, four or eight packed double-precision floating-point values in the source operand (second operand) to two, four or eight packed single-precision floating-point values in the destination operand (first operand).\nWhen a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits.\nEVEX encoded versions: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a YMM/XMM/XMM (low 64-bits) register conditionally updated with writemask k1. The upper bits (MAXVL- 1:256/128/64) of the corresponding destination are zeroed.\nVEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\nVEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:64) of the corresponding ZMM register destination are zeroed.\n128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination operand is an XMM register. Bits[127:64] of the destination XMM register are zeroed. However, the upper Bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\nVEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.\nSRC\tX3\tX2\tX1\tX0\nDEST\t0\tX3\tX2\tX1\tX0\nFigure 3-13.  VCVTPD2PS (VEX.256 encoded version)"
  }
  instruction_groups {
    name: "SAHF"
    short_description: "Store AH into Flags"
    description: "Loads the SF, ZF, AF, PF, and CF flags of the EFLAGS register with values from the corresponding bits in the AH register (bits 7, 6, 4, 2, and 0, respectively). Bits 1, 3, and 5 of register AH are ignored; the corresponding reserved bits (1, 3, and 5) in the EFLAGS register remain as shown in the \342\200\234Operation\342\200\235 section below.\nThis instruction executes as described above in compatibility mode and legacy mode. It is valid in 64-bit mode only if CPUID.80000001H:ECX.LAHF-SAHF[bit 0] = 1."
    flags_affected {
      content: "The SF, ZF, AF, PF, and CF flags are loaded with values from the AH register. Bits 1, 3, and 5 of the EFLAGS register are unaffected, with the values remaining 1, 0, and 0, respectively."
    }
  }
  instruction_groups {
    name: "BSWAP"
    short_description: "Byte Swap"
    description: "Reverses the byte order of a 32-bit or 64-bit (destination) register. This instruction is provided for converting littleendian values to big-endian format and vice versa. To swap bytes in a word value (16-bit register), use the XCHG instruction. When the BSWAP instruction references a 16-bit register, the result is undefined.\nIn 64-bit mode, the instruction\342\200\231s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the sum mary chart at the beginning of this section for encoding data and limits."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "MOVDQU,VMOVDQU8/16/32/64"
    short_description: "Move Unaligned Packed Integer Values"
  }
  instruction_groups {
    name: "PTEST"
    short_description: "Logical Compare"
    description: "PTEST and VPTEST set the ZF flag if all bits in the result are 0 of the bitwise AND of the first source operand (first operand) and the second source operand (second operand). VPTEST sets the CF flag if all bits in the result are 0 of the bitwise AND of the second source operand (second operand) and the logical NOT of the destination operand.\nThe first source register is specified by the ModR/M reg field.\n128-bit versions: The first source register is an XMM register. The second source register can be an XMM register or a 128-bit memory location. The destination register is not modified.\nVEX.256 encoded version: The first source register is a YMM register. The second source register can be a YMM register or a 256-bit memory location. The destination register is not modified.\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
    flags_affected {
      content: "The 0F, AF, PF, SF flags are cleared and the ZF, CF flags are set according to the operation.\nSIMD Floating-Point Exceptions\nNone."
    }
  }
  instruction_groups {
    name: "FDECSTP"
    short_description: "Decrement Stack-Top Pointer"
    description: "Subtracts one from the TOP field of the FPU status word (decrements the top-of-stack pointer). If the TOP field contains a 0, it is set to 7. The effect of this instruction is to rotate the stack by one position. The contents of the FPU data registers and tag register are not affected.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "The C1 flag is set to 0. The C0, C2, and C3 flags are undefined."
    }
  }
  instruction_groups {
    name: "FADD/FADDP/FIADD"
    short_description: "Add"
    description: "Adds the destination and source operands and stores the sum in the destination location. The destination operand is always an FPU register; the source operand can be a register or a memory location. Source operands in memory can be in single-precision or double-precision floating-point format or in word or doubleword integer format.\nThe no-operand version of the instruction adds the contents of the ST(0) register to the ST(1) register. The oneoperand version adds the contents of a memory location (either a floating-point or an integer value) to the contents of the ST(0) register. The two-operand version, adds the contents of the ST(0) register to the ST(i) register or vice versa. The value in ST(0) can be doubled by coding:\nFADD ST(0), ST(0);\nThe FADDP instructions perform the additional operation of popping the FPU register stack after storing the result.\nTo pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. (The no-operand version of the floating-point add instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FADD rather than FADDP.)\nThe FIADD instructions convert an integer source operand to double extended-precision floating-point format before performing the addition.\nThe table on the following page shows the results obtained when adding various classes of numbers, assuming that neither overflow nor underflow occurs.\nWhen the sum of two operands with opposite signs is 0, the result is +0, except for the round toward \342\210\222\342\210\236 mode, in which case the result is \342\210\2220. When the source operand is an integer 0, it is treated as a +0.\nWhen both operand are infinities of the same sign, the result is \342\210\236 of the expected sign. If both operands are infinities of opposite signs, an invalid-operation exception is generated. See Table 3-18.\nTable 3-18.  FADD/FADDP/FIADD Results\nDEST\n\342\210\222 \342\210\236\t\342\210\222 F\t\342\210\222 0\t+ 0\t+ F\t+ \342\210\236\tNaN\n\342\210\222 \342\210\236\t\342\210\222 \342\210\236\t\342\210\222 \342\210\236\t\342\210\222 \342\210\236\t\342\210\222 \342\210\236\t\342\210\222 \342\210\236\t*\tNaN\n\342\210\222 F or \342\210\222 I\t\342\210\222 \342\210\236\t\342\210\222 F\tSRC\tSRC\t\302\261 F or \302\261 0\t+ \342\210\236\tNaN\nSRC\t\342\210\2220\t\342\210\222 \342\210\236\tDEST\t\342\210\222 0\t\302\261 0\tDEST\t+ \342\210\236\tNaN\n+ 0\t\342\210\222 \342\210\236\tDEST\t\302\261 0\t+ 0\tDEST\t+ \342\210\236\tNaN\n+ F or + I\t\342\210\222 \342\210\236\t\302\261 F or \302\261 0\tSRC\tSRC\t+ F\t+ \342\210\236\tNaN\n+ \342\210\236\t*\t+ \342\210\236\t+ \342\210\236\t+ \342\210\236\t+ \342\210\236\t+ \342\210\236\tNaN\nNaN\tNaN\tNaN\tNaN\tNaN\tNaN\tNaN\tNaN\nNOTES:\nF\tMeans finite floating-point value.\nI\tMeans integer.\n*\tIndicates floating-point invalid-arithmetic-operand (#IA) exception.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C1\tSet to 0 if stack underflow occurred.\nSet if result was rounded up; cleared otherwise.\nC0, C2, C3\tUndefined."
    }
  }
  instruction_groups {
    name: "EWB"
  }
  instruction_groups {
    name: "CMPSS"
    short_description: "Compare Scalar Single-Precision Floating-Point Value"
    description: "Compares the low single-precision floating-point values in the second source operand and the first source operand and returns the result of the comparison to the destination operand. The comparison predicate operand (im me-\ndiate operand) specifies the type of comparison performed.\n128-bit Legacy SSE version: The first source and destination operand (first operand) is an XMM register. The second source operand (second operand) can be an XMM register or 32-bit memory location. Bits (MAXVL-1:32) of the corresponding YMM destination register remain unchanged. The comparison result is a doubleword mask of all 1s (comparison true) or all 0s (comparison false).\nVEX.128 encoded version: The first source operand (second operand) is an XMM register. The second source operand (third operand) can be an XMM register or a 32-bit memory location. The result is stored in the low 32 bits of the destination operand; bits 128:32 of the destination operand are copied from the first source operand. Bits (MAXVL-1:128) of the destination ZMM register are zeroed. The comparison result is a doubleword mask of all 1s (comparison true) or all 0s (comparison false).\nEVEX encoded version: The first source operand (second operand) is an XMM register. The second source operand can be a XMM register or a 32-bit memory location. The destination operand (first operand) is an opmask register.\nThe comparison result is a single mask bit of 1 (comparison true) or 0 (comparison false), written to the destination starting from the LSB according to the writemask k2. Bits (MAX_KL-1:128) of the destination register are cleared.\nThe comparison predicate operand is an 8-bit im mediate:\n\342\200\242\tFor instructions encoded using the VEX prefix, bits 4:0 define the type of comparison to be performed (see Table 3-1). Bits 5 through 7 of the im mediate are reserved.\n\342\200\242\tFor instruction encodings that do not use VEX prefix, bits 2:0 define the type of comparison to be made (see the first 8 rows of Table 3-1). Bits 3 through 7 of the im mediate are reserved.\nThe unordered relationship is true when at least one of the two source operands being compared is a NaN; the ordered relationship is true when neither source operand is a NaN.\nA subsequent computational instruction that uses the mask result in the destination operand as an input operand will not generate an exception, because a mask of all 0s corresponds to a floating-point value of +0.0 and a mask of all 1s corresponds to a QNaN.\nNote that processors with \342\200\234CPUID.1H:ECX.AVX =0\342\200\235 do not implement the \342\200\234greater-than\342\200\235, \342\200\234greater-than-or-equal\342\200\235, \342\200\234not-greater than\342\200\235, and \342\200\234not-greater-than-or-equal relations\342\200\235 predicates. These comparisons can be made either\nby using the inverse relationship (that is, use the \342\200\234not-less-than-or-equal\342\200\235 to make a \342\200\234greater-than\342\200\235 comparison) or by using software emulation. When using software emulation, the program must swap the operands (copying registers when necessary to protect the data that will now be in the destination), and then perform the compare using a different predicate. The predicate to be used for these emulations is listed in the first 8 rows of Table 3-7 (Intel 64 and IA-32 Architectures Software Developer\342\200\231s Manual Volume 2A) under the heading Emulation.\nCompilers and assemblers may implement the following two-operand pseudo-ops in addition to the three-operand CMPSS instruction, for processors with \342\200\234CPUID.1H:ECX.AVX =0\342\200\235. See Table 3-8. Compiler should treat reserved Im m8 values as illegal syntax.\nTable 3-8. Pseudo-Op and CMPSS Implementation\nPseudo-Op\tCMPSS Implementation\nCMPEQSS xmm1, xmm2\tCMPSS xmm1, xmm2, 0\nCMPLTSS xmm1, xmm2\tCMPSS xmm1, xmm2, 1\nCMPLESS xmm1, xmm2\tCMPSS xmm1, xmm2, 2\nCMPUNORDSS xmm1, xmm2\tCMPSS xmm1, xmm2, 3\nCMPNEQSS xmm1, xmm2\tCMPSS xmm1, xmm2, 4\nCMPNLTSS xmm1, xmm2\tCMPSS xmm1, xmm2, 5\nCMPNLESS xmm1, xmm2\tCMPSS xmm1, xmm2, 6\nCMPORDSS xmm1, xmm2\tCMPSS xmm1, xmm2, 7\nThe greater-than relations that the processor does not implement require more than one instruction to emulate in software and therefore should not be implemented as pseudo-ops. (For these, the program\nmer should reverse the operands of the corresponding less than relations and use move instructions to ensure that the mask is moved to the correct destination register and that the source operand is left intact.)\nProcessors with \342\200\234CPUID.1H:ECX.AVX =1\342\200\235 implement the full complement of 32 predicates shown in Table 3-7, software emulation is no longer needed. Compilers and assemblers may implement the following three-operand pseudo-ops in addition to the four-operand VCMPSS instruction. See Table 3-9, where the notations of reg1 reg2, and reg3 represent either XMM registers or YMM registers. Compiler should treat reserved Im\nm8 values as illegal syntax. Alternately, intrinsics can map the pseudo-ops to pre-defined constants to support a simpler intrinsic interface. Compilers and assemblers may implement three-operand pseudo-ops for EVEX encoded VCMPSS instructions in a similar fashion by extending the syntax listed in Table 3-9.\nTable 3-9. Pseudo-Op and VCMPSS Implementation\nPseudo-Op\tCMPSS Implementation\nVCMPEQSS reg1, reg2, reg3\tVCMPSS reg1, reg2, reg3, 0\nVCMPLTSS reg1, reg2, reg3\tVCMPSS reg1, reg2, reg3, 1\nVCMPLESS reg1, reg2, reg3\tVCMPSS reg1, reg2, reg3, 2\nVCMPUNORDSS reg1, reg2, reg3\tVCMPSS reg1, reg2, reg3, 3\nVCMPNEQSS reg1, reg2, reg3\tVCMPSS reg1, reg2, reg3, 4\nVCMPNLTSS reg1, reg2, reg3\tVCMPSS reg1, reg2, reg3, 5\nVCMPNLESS reg1, reg2, reg3\tVCMPSS reg1, reg2, reg3, 6\nVCMPORDSS reg1, reg2, reg3\tVCMPSS reg1, reg2, reg3, 7\nVCMPEQ_UQSS reg1, reg2, reg3\tVCMPSS reg1, reg2, reg3, 8\nVCMPNGESS reg1, reg2, reg3\tVCMPSS reg1, reg2, reg3, 9\nVCMPNGTSS reg1, reg2, reg3\tVCMPSS reg1, reg2, reg3, 0AH\nVCMPFALSESS reg1, reg2, reg3\tVCMPSS reg1, reg2, reg3, 0BH\nVCMPNEQ_OQSS reg1, reg2, reg3\tVCMPSS reg1, reg2, reg3, 0CH\nVCMPGESS reg1, reg2, reg3\tVCMPSS reg1, reg2, reg3, 0DH\nTable 3-9. Pseudo-Op and VCMPSS Implementation\nPseudo-Op\tCMPSS Implementation\nVCMPGTSS reg1, reg2, reg3\tVCMPSS reg1, reg2, reg3, 0EH\nVCMPTRUESS reg1, reg2, reg3\tVCMPSS reg1, reg2, reg3, 0FH\nVCMPEQ_OSSS reg1, reg2, reg3\tVCMPSS reg1, reg2, reg3, 10H\nVCMPLT_OQSS reg1, reg2, reg3\tVCMPSS reg1, reg2, reg3, 11H\nVCMPLE_OQSS reg1, reg2, reg3\tVCMPSS reg1, reg2, reg3, 12H\nVCMPUNORD_SSS reg1, reg2, reg3\tVCMPSS reg1, reg2, reg3, 13H\nVCMPNEQ_USSS reg1, reg2, reg3\tVCMPSS reg1, reg2, reg3, 14H\nVCMPNLT_UQSS reg1, reg2, reg3\tVCMPSS reg1, reg2, reg3, 15H\nVCMPNLE_UQSS reg1, reg2, reg3\tVCMPSS reg1, reg2, reg3, 16H\nVCMPORD_SSS reg1, reg2, reg3\tVCMPSS reg1, reg2, reg3, 17H\nVCMPEQ_USSS reg1, reg2, reg3\tVCMPSS reg1, reg2, reg3, 18H\nVCMPNGE_UQSS reg1, reg2, reg3\tVCMPSS reg1, reg2, reg3, 19H\nVCMPNGT_UQSS reg1, reg2, reg3\tVCMPSS reg1, reg2, reg3, 1AH\nVCMPFALSE_OSSS reg1, reg2, reg3\tVCMPSS reg1, reg2, reg3, 1BH\nVCMPNEQ_OSSS reg1, reg2, reg3\tVCMPSS reg1, reg2, reg3, 1CH\nVCMPGE_OQSS reg1, reg2, reg3\tVCMPSS reg1, reg2, reg3, 1DH\nVCMPGT_OQSS reg1, reg2, reg3\tVCMPSS reg1, reg2, reg3, 1EH\nVCMPTRUE_USSS reg1, reg2, reg3\tVCMPSS reg1, reg2, reg3, 1FH\nSoftware should ensure VCMPSS is encoded with VEX.L=0. Encoding VCMPSS with VEX.L=1 may encounter unpredictable behavior across different processor generations."
  }
  instruction_groups {
    name: "ESETCONTEXT"
  }
  instruction_groups {
    name: "ARPL"
    short_description: "Adjust RPL Field of Segment Selector"
    description: "Compares the RPL fields of two segment selectors. The first operand (the destination operand) contains one segment selector and the second operand (source operand) contains the other. (The RPL field is located in bits 0 and 1 of each operand.) If the RPL field of the destination operand is less than the RPL field of the source operand, the ZF flag is set and the RPL field of the destination operand is increased to match that of the source operand.\nOtherwise, the ZF flag is cleared and no change is made to the destination operand. (The destination operand can be a word register or a memory location; the source operand must be a word register.)\nThe ARPL instruction is provided for use by operating-system procedures (however, it can also be used by applications). It is generally used to adjust the RPL of a segment selector that has been passed to the operating system by an application program to match the privilege level of the application program. Here the segment selector passed to the operating system is placed in the destination operand and segment selector for the application program\342\200\231s code segment is placed in the source operand. (The RPL field in the source operand represents the privilege level of the application program.) Execution of the ARPL instruction then ensures that the RPL of the segment selector received by the operating system is no lower (does not have a higher privilege) than the privilege level of the application program (the segment selector for the application program\342\200\231s code segment can be read from the stack following a procedure call).\nThis instruction executes as described in compatibility mode and legacy mode. It is not encodable in 64-bit mode.\nSee \342\200\234Checking Caller Access Privileges\342\200\235 in Chapter 3, \342\200\234Protected-Mode Memory Management,\342\200\235 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3A, for more information about the use of this instruction."
    flags_affected {
      content: "The ZF flag is set to 1 if the RPL field of the destination operand is less than that of the source operand; otherwise, it is set to 0."
    }
  }
  instruction_groups {
    name: "RDSSPD/RDSSPQ"
    short_description: "Read Shadow Stack Pointer"
    description: "Copies the current shadow stack pointer (SSP) register to the register destination. This opcode is a NOP when CET shadow stacks are not enabled and on processors that do not support CET."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "PMOVZX"
    short_description: "Packed Move with Zero Extend"
  }
  instruction_groups {
    name: "SGDT"
    short_description: "Store Global Descriptor Table Register"
    description: "Stores the content of the global descriptor table register (GDTR) in the destination operand. The destination operand specifies a memory location.\nIn legacy or compatibility mode, the destination operand is a 6-byte memory location. If the operand-size attribute is 16 or 32 bits, the 16-bit limit field of the register is stored in the low 2 bytes of the memory location and the 32- bit base address is stored in the high 4 bytes.\nIn 64-bit mode, the operand size is fixed at 8+2 bytes. The instruction stores an 8-byte base and a 2-byte limit.\nSGDT is useful only by operating-system software. However, it can be used in application programs without causing an exception to be generated if CR4.UMIP\n= 0. See \342\200\234LGDT/LIDT-Load Global/Interrupt Descriptor Table Register\342\200\235 in Chapter 3, Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 2A, for information on loading the GDTR and IDTR."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "PADDB/PADDW/PADDD/PADDQ"
    short_description: "Add Packed Integers"
  }
  instruction_groups {
    name: "FYL2XP1"
    short_description: "Compute y * log2(x +1)"
    description: "Computes (ST(1) \342\210\227 log2(ST(0) + 1.0)), stores the result in register ST(1), and pops the FPU register stack. The source operand in ST(0) must be in the range:\n-(1-\t2\342\201\2042))to(1-\t2\342\201\2042)\nThe source operand in ST(1) can range from \342\210\222\342\210\236 to +\342\210\236. If the ST(0) operand is outside of its acceptable range, the result is undefined and software should not rely on an exception being generated. Under some circumstances exceptions may be generated when ST(0) is out of range, but this behavior is implementation specific and not guaranteed.\nThe following table shows the results obtained when taking the log epsilon of various classes of numbers, assuming that underflow does not occur.\nTable 3-49.  FYL2XP1 Results\nST(0)\n\342\210\222(1 \342\210\222 (\t2\342\201\2042\t)) to \342\210\2220\t-0\t+0\t+0 to +(1 - (\t2\342\201\2042\t))\tNaN\n\342\210\222 \342\210\236\t+\342\210\236\t*\t*\t\342\210\222 \342\210\236\tNaN\nST(1)\t\342\210\222 F\t+F\t+0\t-0\t\342\210\222 F\tNaN\n\342\210\222 0\t+0\t+0\t-0\t\342\210\222 0\tNaN\n+0\t\342\210\222 0\t\342\210\222 0\t+0\t+0\tNaN\n+F\t\342\210\222 F\t\342\210\222 0\t+0\t+F\tNaN\n+\342\210\236\t\342\210\222 \342\210\236\t*\t*\t+\342\210\236\tNaN\nNaN\tNaN\tNaN\tNaN\tNaN\tNaN\nNOTES:\nF\tMeans finite floating-point value.\n*\tIndicates floating-point invalid-operation (#IA) exception.\nThis instruction provides optimal accuracy for values of epsilon [the value in register ST(0)] that are close to 0. For small epsilon (\316\265) values, more significant digits can be retained by using the FYL2XP1 instruction than by using (\316\265+1) as an argument to the FYL2X instruction. The (\316\265+1) expression is com\nmonly found in compound interest and annuity calculations. The result can be simply converted into a value in another logarithm base by including a scale factor in the ST(1) source operand. The following equation is used to calculate the scale factor for a particular logarithm base, where n is the logarithm base desired for the result of the FYL2XP1 instruction:\nscale factor := logn\t2\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C1\tSet to 0 if stack underflow occurred.\nSet if result was rounded up; cleared otherwise.\nC0, C2, C3\tUndefined."
    }
  }
  instruction_groups {
    name: "CLAC"
    short_description: "Clear AC Flag in EFLAGS Register"
    description: "Clears the AC flag bit in EFLAGS register. This disables any alignment checking of user-mode data accesses. If the SMAP bit is set in the CR4 register, this disallows explicit supervisor-mode data accesses to user-mode pages.\nThis instruction\'s operation is the same in non-64-bit modes and 64-bit mode. Attempts to execute CLAC when CPL > 0 cause #UD."
    flags_affected {
      content: "AC cleared. Other flags are unaffected."
    }
  }
  instruction_groups {
    name: "VGETEXPSS"
    short_description: "Convert Exponents of Scalar SP FP Values to SP FP Value"
  }
  instruction_groups {
    name: "VPEXPANDQ"
    short_description: "Load Sparse Packed Quadword Integer Values from Dense Memory / Register"
  }
  instruction_groups {
    name: "VPOPCNT"
    short_description: "Return the Count of Number of Bits Set to 1 in BYTE/WORD/DWORD/QWORD"
  }
  instruction_groups {
    name: "KUNPCKBW/KUNPCKWD/KUNPCKDQ"
    short_description: "Unpack for Mask Registers"
    description: "Unpacks the lower 8/16/32 bits of the second and third operands (source operands) into the low part of the first operand (destination operand), starting from the low bytes. The result is zero-extended in the destination."
    flags_affected {
      content: "None\nSIMD Floating-Point Exceptions\nNone"
    }
  }
  instruction_groups {
    name: "FRNDINT"
    short_description: "Round to Integer"
    description: "Rounds the source value in the ST(0) register to the nearest integral value, depending on the current rounding mode (setting of the RC field of the FPU control word), and stores the result in ST(0).\nIf the source value is \342\210\236, the value is not changed. If the source value is not an integral value, the floating-point inexact-result exception (#P) is generated.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C1\tSet to 0 if stack underflow occurred.\nSet if result was rounded up; cleared otherwise.\nC0, C2, C3\tUndefined."
    }
  }
  instruction_groups {
    name: "EREPORT"
  }
  instruction_groups {
    name: "RDPKRU"
    short_description: "Read Protection Key Rights for User Pages"
    description: "Reads the value of PKRU into EAX and clears EDX. ECX must be 0 when RDPKRU is executed; otherwise, a generalprotection exception (#GP) occurs.\nRDPKRU can be executed only if CR4.PKE = 1; otherwise, an invalid-opcode exception (#UD) occurs. Software can discover the value of CR4.PKE by examining CPUID.(EAX=07H,ECX=0H):ECX.OSPKE [bit 4].\nOn processors that support the Intel64 Architecture, the high-order 32-bits of RCX are ignored and the high-order 32-bits of RDX and RAX are cleared."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "BLENDVPD"
    short_description: "Variable Blend Packed Double Precision Floating-Point Values"
    description: "Conditionally copy each quadword data element of double-precision floating-point value from the second source operand and the first source operand depending on mask bits defined in the mask register operand. The mask bits are the most significant bit in each quadword element of the mask register.\nEach quadword element of the destination operand is copied from:\n\342\200\242\tthe corresponding quadword element in the second source operand, if a mask bit is \342\200\2341\342\200\235; or\n\342\200\242 the corresponding quadword element in the first source operand, if a mask bit is \342\200\2340\342\200\235 The register assignment of the implicit mask operand for BLENDVPD is defined to be the architectural register XMM0.\n128-bit Legacy SSE version: The first source operand and the destination operand is the same. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged. The mask register operand is implicitly defined to be the architectural register XMM0. An attempt to execute BLENDVPD with a VEX prefix will cause #UD.\nVEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second source operand is an XMM register or 128-bit memory location. The mask operand is the third source register, and encoded in bits[7:4] of the im mediate byte(im m8). The bits[3:0] of im m8 are ignored. In 32-bit mode, im m8[7] is ignored. The upper bits (MAXVL-1:128) of the corresponding YMM register (destination register) are zeroed.\nVEX.W must be 0, otherwise, the instruction will #UD.\nVEX.256 encoded version: The first source operand and destination operand are YMM registers. The second source operand can be a YMM register or a 256-bit memory location. The mask operand is the third source register, and encoded in bits[7:4] of the im mediate byte(im m8). The bits[3:0] of im m8 are ignored. In 32-bit mode, im m8[7] is\nignored. VEX.W must be 0, otherwise, the instruction will #UD.\nVBLENDVPD permits the mask to be any XMM or YMM register. In contrast, BLENDVPD treats XMM0 implicitly as the mask and do not support non-destructive destination operation."
  }
  instruction_groups {
    name: "CVTTSD2SI"
    short_description: "Convert with Truncation Scalar Double-Precision Floating-Point Value to Signed Integer"
    description: "Converts a double-precision floating-point value in the source operand (the second operand) to a signed doubleword integer (or signed quadword integer if operand size is 64 bits) in the destination operand (the first operand).\nThe source operand can be an XMM register or a 64-bit memory location. The destination operand is a general purpose register. When the source operand is an XMM register, the double-precision floating-point value is contained in the low quadword of the register.\nWhen a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.\nIf a converted result exceeds the range limits of signed doubleword integer (in non-64-bit modes or 64-bit mode with REX.W/VEX.W/EVEX.W\n=0), the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.\nIf a converted result exceeds the range limits of signed quadword integer (in 64-bit mode and REX.W/VEX.W/EVEX.W = 1), the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000_00000000H) is returned.\nLegacy SSE instructions: In 64-bit mode, Use of the REX.W prefix promotes the instruction to 64-bit operation. See the sum\nmary chart at the beginning of this section for encoding data and limits.\nVEX.W1 and EVEX.W1 versions: promotes the instruction to produce 64-bit data in 64-bit mode.\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.\nSoftware should ensure VCVTTSD2SI is encoded with VEX.L=0. Encoding VCVTTSD2SI with VEX.L=1 may encounter unpredictable behavior across different processor generations."
  }
  instruction_groups {
    name: "PEXT"
    short_description: "Parallel Bits Extract"
    description: "PEXT uses a mask in the second source operand (the third operand) to transfer either contiguous or non-contiguous bits in the first source operand (the second operand) to contiguous low order bit positions in the destination (the first operand). For each bit set in the MASK, PEXT extracts the corresponding bits from the first source operand and writes them into contiguous lower bits of destination operand. The remaining upper bits of destination are zeroed.\nSRC1\tS31\tS30\tS29\tS28\tS27\tS7\tS6\tS5\tS4\tS3\tS2\tS1\tS0\nSRC2 (mask)\t0\t0\t0\t1\t0\t1\t0\t1\t0\t0\t1\t0\t0\nDEST\t0\t0\t0\t0\t0\t0\t0\t0\t0\tS28\tS7\tS5\tS2\nbit 31\tbit 0\nFigure 4-9.  PEXT Example\nThis instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "CLRSSBSY"
    short_description: "Clear Busy Flag in a Supervisor Shadow Stack Token"
    description: "Clear busy flag in supervisor shadow stack token reference by m64. Subsequent to marking the shadow stack as not busy the SSP is loaded with value 0."
    flags_affected {
      content: "CF is set if an invalid token was detected, else it is cleared. ZF, PF, AF, OF, and SF are cleared."
    }
  }
  instruction_groups {
    name: "SAL/SAR/SHL/SHR"
    short_description: "Shift"
    description: "Shifts the bits in the first operand (destination operand) to the left or right by the number of bits specified in the second operand (count operand). Bits shifted beyond the destination operand boundary are first shifted into the CF flag, then discarded. At the end of the shift operation, the CF flag contains the last bit shifted out of the destination operand.\nThe destination operand can be a register or a memory location. The count operand can be an im mediate value or the CL register. The count is masked to 5 bits (or 6 bits if in 64-bit mode and REX.W is used). The count range is limited to 0 to 31 (or 63 if 64-bit mode and REX.W is used). A special opcode encoding is provided for a count of 1.\nThe shift arithmetic left (SAL) and shift logical left (SHL) instructions perform the same operation; they shift the bits in the destination operand to the left (toward more significant bit locations). For each shift count, the most significant bit of the destination operand is shifted into the CF flag, and the least significant bit is cleared (see Figure 7-7 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1).\nThe shift arithmetic right (SAR) and shift logical right (SHR) instructions shift the bits of the destination operand to the right (toward less significant bit locations). For each shift count, the least significant bit of the destination operand is shifted into the CF flag, and the most significant bit is either set or cleared depending on the instruction type. The SHR instruction clears the most significant bit (see Figure 7-8 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1); the SAR instruction sets or clears the most significant bit to correspond to the sign (most significant bit) of the original value in the destination operand. In effect, the SAR instruction fills the empty bit position\342\200\231s shifted value with the sign of the unshifted value (see Figure 7-9 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1).\nThe SAR and SHR instructions can be used to perform signed or unsigned division, respectively, of the destination operand by powers of 2. For example, using the SAR instruction to shift a signed integer 1 bit to the right divides the value by 2.\nUsing the SAR instruction to perform a division operation does not produce the same result as the IDIV instruction.\nThe quotient from the IDIV instruction is rounded toward zero, whereas the \342\200\234quotient\342\200\235 of the SAR instruction is rounded toward negative infinity. This difference is apparent only for negative numbers. For example, when the IDIV instruction is used to divide -9 by 4, the result is -2 with a remainder of -1. If the SAR instruction is used to shift -9 right by two bits, the result is -3 and the \342\200\234remainder\342\200\235 is +3; however, the SAR instruction stores only the most significant bit of the remainder (in the CF flag).\nThe OF flag is affected only on 1-bit shifts. For left shifts, the OF flag is set to 0 if the most-significant bit of the result is the same as the CF flag (that is, the top two bits of the original operand were the same); otherwise, it is set to 1. For the SAR instruction, the OF flag is cleared for all 1-bit shifts. For the SHR instruction, the OF flag is set to the most-significant bit of the original operand.\nIn 64-bit mode, the instruction\342\200\231s default operation size is 32 bits and the mask width for CL is 5 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64-bits and sets the mask width for CL to 6 bits. See the sum mary chart at the beginning of\nthis section for encoding data and limits."
    flags_affected {
      content: "The CF flag contains the value of the last bit shifted out of the destination operand; it is undefined for SHL and SHR instructions where the count is greater than or equal to the size (in bits) of the destination operand. The OF flag is affected only for 1-bit shifts (see \342\200\234Description\342\200\235 above); otherwise, it is undefined. The SF, ZF, and PF flags are set according to the result. If the count is 0, the flags are not affected. For a non-zero count, the AF flag is undefined."
    }
  }
  instruction_groups {
    name: "AESENC"
    short_description: "Perform One Round of an AES Encryption Flow"
    description: "This instruction performs a single round of an AES encryption flow using a round key from the second source operand, operating on 128-bit data (state) from the first source operand, and store the result in the destination operand.\nUse the AESENC instruction for all but the last encryption rounds. For the last encryption round, use the AESENCCLAST instruction.\nVEX and EVEX encoded versions of the instruction allow 3-operand (non-destructive) operation. The legacy encoded versions of the instruction require that the first source operand and the destination operand are the same and must be an XMM register.\nThe EVEX encoded form of this instruction does not support memory fault suppression."
  }
  instruction_groups {
    name: "EREMOVE"
  }
  instruction_groups {
    name: "RSQRTSS"
    short_description: "Compute Reciprocal of Square Root of Scalar Single-Precision Floating-Point Value"
    description: "Computes an approximate reciprocal of the square root of the low single-precision floating-point value in the source operand (second operand) stores the single-precision floating-point result in the destination operand. The source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register.\nThe three high-order doublewords of the destination operand remain unchanged. See Figure 10-6 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1, for an illustration of a scalar single-precision floating-point operation.\nThe relative error for this approximation is:\n|Relative Error| \342\211\244 1.5 \342\210\227 2\342\210\22212\nThe RSQRTSS instruction is not affected by the rounding control bits in the MXCSR register. When a source value is a 0.0, an \342\210\236 of the sign of the source value is returned. A denormal source value is treated as a 0.0 (of the same sign). When a source value is a negative value (other than \342\210\2220.0), a floating-point indefinite is returned. When a source value is an SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned.\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL- 1:32) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: Bits (MAXVL-1:128) of the destination YMM register are zeroed."
  }
  instruction_groups {
    name: "EACCEPT"
  }
  instruction_groups {
    name: "FSUBR/FSUBRP/FISUBR"
    short_description: "Reverse Subtract"
    description: "Subtracts the destination operand from the source operand and stores the difference in the destination location.\nThe destination operand is always an FPU register; the source operand can be a register or a memory location.\nSource operands in memory can be in single-precision or double-precision floating-point format or in word or doubleword integer format.\nThese instructions perform the reverse operations of the FSUB, FSUBP, and FISUB instructions. They are provided to support more efficient coding.\nThe no-operand version of the instruction subtracts the contents of the ST(1) register from the ST(0) register and stores the result in ST(1). The one-operand version subtracts the contents of the ST(0) register from the contents of a memory location (either a floating-point or an integer value) and stores the result in ST(0). The two-operand version, subtracts the contents of the ST(i) register from the ST(0) register or vice versa.\nThe FSUBRP instructions perform the additional operation of popping the FPU register stack following the subtraction. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point reverse subtract instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FSUBR rather than FSUBRP.\nThe FISUBR instructions convert an integer source operand to double extended-precision floating-point format before performing the subtraction.\nThe following table shows the results obtained when subtracting various classes of numbers from one another, assuming that neither overflow nor underflow occurs. Here, the DEST value is subtracted from the SRC value (SRC \342\210\222 DEST = result).\nWhen the difference between two operands of like sign is 0, the result is +0, except for the round toward \342\210\222\342\210\236 mode, in which case the result is \342\210\2220. This instruction also guarantees that +0 \342\210\222 (\342\210\2220) = +0, and that \342\210\2220 \342\210\222 (+0) = \342\210\2220. When the source operand is an integer 0, it is treated as a +0.\nWhen one operand is \342\210\236, the result is \342\210\236 of the expected sign. If both operands are \342\210\236 of the same sign, an invalidoperation exception is generated.\nTable 3-39.  FSUBR/FSUBRP/FISUBR Results\nSRC\n\342\210\222 \342\210\236\t\342\210\222F or \342\210\222I\t\342\210\2220\t+0\t+F or +I\t+ \342\210\236\tNaN\n\342\210\222 \342\210\236\t*\t+ \342\210\236\t+ \342\210\236\t+ \342\210\236\t+ \342\210\236\t+ \342\210\236\tNaN\n\342\210\222 F\t\342\210\222 \342\210\236\t\302\261F or \302\2610\t\342\210\222DEST\t\342\210\222DEST\t+ F\t+ \342\210\236\tNaN\nDEST\t\342\210\222 0\t\342\210\222 \342\210\236\tSRC\t\302\2610\t+ 0\tSRC\t+ \342\210\236\tNaN\n+ 0\t\342\210\222 \342\210\236\tSRC\t\342\210\222 0\t\302\2610\tSRC\t+ \342\210\236\tNaN\n+ F\t\342\210\222 \342\210\236\t\342\210\222 F\t\342\210\222DEST\t\342\210\222DEST\t\302\261F or \302\2610\t+ \342\210\236\tNaN\n+ \342\210\236\t\342\210\222 \342\210\236\t\342\210\222 \342\210\236\t\342\210\222 \342\210\236\t\342\210\222 \342\210\236\t\342\210\222 \342\210\236\t*\tNaN\nNaN\tNaN\tNaN\tNaN\tNaN\tNaN\tNaN\tNaN\nNOTES:\nF\tMeans finite floating-point value.\nI\tMeans integer.\n*\tIndicates floating-point invalid-arithmetic-operand (#IA) exception.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C1\tSet to 0 if stack underflow occurred.\nSet if result was rounded up; cleared otherwise.\nC0, C2, C3\tUndefined."
    }
  }
  instruction_groups {
    name: "MOVNTPS"
    short_description: "Store Packed Single-Precision Floating-Point Values Using Non-Temporal Hint"
  }
  instruction_groups {
    name: "MOVUPD"
    short_description: "Move Unaligned Packed Double-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "VP4DPWSSD"
    short_description: "Dot Product of Signed Words with Dword Accumulation (4-iterations)"
  }
  instruction_groups {
    name: "FCMOVcc"
    short_description: "Floating-Point Conditional Move"
    description: "Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Description column above and in Chapter 8 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1. The source operand is always in the ST(i) register and the destination operand is always ST(0).\nThe FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching overhead for IF operations and the possibility of branch mispredictions by the processor.\nA processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are supported by checking the processor\342\200\231s feature information with the CPUID instruction (see \342\200\234COMISS-Compare Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS\342\200\235 in this chapter). If both the CMOV and FPU feature bits are set, the FCMOVcc instructions are supported.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C1\tSet to 0 if stack underflow occurred.\nC0, C2, C3\tUndefined."
    }
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "CVTDQ2PS"
    short_description: "Convert Packed Doubleword Integers to Packed Single-Precision Floating-Point Values"
    description: "Converts four, eight or sixteen packed signed doubleword integers in the source operand to four, eight or sixteen packed single-precision floating-point values in the destination operand.\nEVEX encoded versions: The source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\nVEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination operand is a YMM register. Bits (MAXVL-1:256) of the corresponding register destination are zeroed.\nVEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding register destination are zeroed.\n128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination operand is an XMM register. The upper Bits (MAXVL-1:128) of the corresponding register destination are unmodified.\nVEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD."
  }
  instruction_groups {
    name: "VCVTTPD2UQQ"
    short_description: "Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Unsigned Quadword Integers"
  }
  instruction_groups {
    name: "VGATHERDPS/VGATHERQPS"
    short_description: "Gather Packed SP FP values Using Signed Dword/Qword Indices"
    description: "The instruction conditionally loads up to 4 or 8 single-precision floating-point values from memory addresses specified by the memory operand (the second operand) and using dword indices. The memory operand uses the VSIB form of the SIB byte to specify a general purpose register operand as the com mon base, a vector register for an\narray of indices relative to the base and a constant scale factor.\nThe mask operand (the third operand) specifies the conditional load operation from each memory address and the corresponding update of each data element of the destination operand (the first operand). Conditionality is specified by the most significant bit of each data element of the mask register. If an element\342\200\231s mask bit is not set, the corresponding element of the destination register is left unchanged. The width of data element in the destination register and mask register are identical. The entire mask register will be set to zero by this instruction unless the instruction causes an exception.\nUsing qword indices, the instruction conditionally loads up to 2 or 4 single-precision floating-point values from the VSIB addressing memory operand, and updates the lower half of the destination register. The upper 128 or 256 bits of the destination register are zero\342\200\231ed with qword indices.\nThis instruction can be suspended by an exception if at least one element is already gathered (i.e., if the exception is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination register and the mask operand are partially updated; those elements that have been gathered are placed into the destination register and have their mask bits set to zero. If any traps or interrupts are pending from already gathered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction breakpoint is not re-triggered when the instruction is continued.\nIf the data size and index size are different, part of the destination register and part of the mask register do not correspond to any elements being gathered. This instruction sets those parts to zero. It may do this to one or both of those registers even if the instruction triggers an exception, and even if the instruction triggers the exception before gathering any elements.\nVEX.128 version: For dword indices, the instruction will gather four single-precision floating-point values. For qword indices, the instruction will gather two values and zero the upper 64 bits of the destination.\nVEX.256 version: For dword indices, the instruction will gather eight single-precision floating-point values. For qword indices, the instruction will gather four values and zero the upper 128 bits of the destination.\nNote that:\n\342\200\242\tIf any pair of the index, mask, or destination registers are the same, this instruction results a UD fault.\n\342\200\242\tThe values may be read from memory in any order. Memory ordering with other instructions follows the Intel- 64 memory-ordering model.\n\342\200\242\tFaults are delivered in a right-to-left manner. That is, if a fault is triggered by an element and delivered, all elements closer to the LSB of the destination will be completed (and non-faulting). Individual elements closer to the MSB may or may not be completed. If a given element triggers multiple faults, they are delivered in the conventional order.\n\342\200\242\tElements may be gathered in any order, but faults must be delivered in a right-to-left order; thus, elements to the left of a faulting one may be gathered before the fault is delivered. A given implementation of this instruction is repeatable - given the same input values and architectural state, the same set of elements to the left of the faulting one will be gathered.\n\342\200\242\tThis instruction does not perform AC checks, and so will never deliver an AC fault.\n\342\200\242\tThis instruction will cause a #UD if the address size attribute is 16-bit.\n\342\200\242\tThis instruction will cause a #UD if the memory operand is encoded without the SIB byte.\n\342\200\242\tThis instruction should not be used to access memory mapped I/O as the ordering of the individual loads it does is implementation specific, and some implementations may use loads larger than the data element size or load elements an indeterminate number of times.\n\342\200\242\tThe scaled index may require more bits to represent than the address bits used by the processor (e.g., in 32- bit mode, if the scale is greater than one). In this case, the most significant bits beyond the number of address bits are ignored."
  }
  instruction_groups {
    name: "VPERMILPS"
    short_description: "Permute In-Lane of Quadruples of Single-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "MINPS"
    short_description: "Minimum of Packed Single-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "TPAUSE"
    short_description: "Timed PAUSE"
    description: "TPAUSE instructs the processor to enter an implementation-dependent optimized state. There are two such optimized states to choose from: light-weight power/performance optimized state, and improved power/performance optimized state. The selection between the two is governed by the explicit input register bit[0] source operand.\nTPAUSE is available when CPUID.7.0:ECX.WAITPKG[bit 5] is enumerated as 1. TPAUSE may be executed at any privilege level. This instruction\342\200\231s operation is the same in non-64-bit modes and in 64-bit mode.\nUnlike PAUSE, the TPAUSE instruction will not cause an abort when used inside a transactional region, described in the chapter Chapter 16, \342\200\234Program\nming with Intel\302\256 Transactional Synchronization Extensions,\342\200\235 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1.\nThe input register contains information such as the preferred optimized state the processor should enter as described in the following table. Bits other than bit 0 are reserved and will result in #GP if non-zero.\nTable 4-19.  TPAUSE Input Register Bit Definitions\nBit Value\tState Name\tWakeup Time\tPower Savings\tOther Benefits\nbit[0] = 0\tC0.2\tSlower\tLarger\tImproves performance of the other SMT thread(s) on the same core.\nbit[0] = 1\tC0.1\tFaster\tSmaller\tNA\nbits[31:1]\tNA\tNA\tNA\tReserved\nThe instruction execution wakes up when the time-stamp counter reaches or exceeds the implicit EDX:EAX 64-bit input value.\nPrior to executing the TPAUSE instruction, an operating system may specify the maximum delay it allows the processor to suspend its operation. It can do so by writing TSC-quanta value to the following 32-bit MSR (IA32_UM WAIT_CONTROL at MSR index E1H):\n\342\200\242\tIA32_UM WAIT_CONTROL[31:2] - Determines the maximum time in TSC-quanta that the processor can reside in either C0.1 or C0.2. A zero value indicates no maximum time. The maximum time value is a 32-bit value where the upper 30 bits come from this field and the lower two bits are zero.\n\342\200\242\tIA32_UM WAIT_CONTROL[1] - Reserved.\n\342\200\242\tIA32_UM WAIT_CONTROL[0] - C0.2 is not allowed by the OS. Value of \342\200\2341\342\200\235 means all C0.2 requests revert to\nC0.1.\nIf the processor that executed a TPAUSE instruction wakes due to the expiration of the operating system time-limit, the instructions sets RFLAGS.CF; otherwise, that flag is cleared.\nThe following additional events cause the processor to exit the implementation-dependent optimized state: a store to the read-set range within the transactional region, an NMI or SMI, a debug exception, a machine check exception, the BINIT# signal, the INIT# signal, and the RESET# signal.\n1.\tThe Mod field of the ModR/M byte must have value 11B.\nOther implementation-dependent events may cause the processor to exit the implementation-dependent optimized state proceeding to the instruction following TPAUSE. In addition, an external interrupt causes the processor to exit the implementation-dependent optimized state regardless of whether maskable-interrupts are inhibited (EFLAGS.IF =0). It should be noted that if maskable-interrupts are inhibited execution will proceed to the instruction following TPAUSE."
  }
  instruction_groups {
    name: "EMMS"
    short_description: "Empty MMX Technology State"
    description: "Sets the values of all the tags in the x87 FPU tag word to empty (all 1s). This operation marks the x87 FPU data registers (which are aliased to the MMX technology registers) as available for use by x87 FPU floating-point instructions. (See Figure 8-7 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1, for the format of the x87 FPU tag word.) All other MMX instructions (other than the EMMS instruction) set all the tags in x87 FPU tag word to valid (all 0s).\nThe EMMS instruction must be used to clear the MMX technology state at the end of all MMX technology procedures or subroutines and before calling other procedures or subroutines that may execute x87 floating-point instructions.\nIf a floating-point instruction loads one of the registers in the x87 FPU data register stack before the x87 FPU tag word has been reset by the EMMS instruction, an x87 floating-point register stack overflow can occur that will result in an x87 floating-point exception or incorrect result.\nEMMS operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "INVLPG"
    short_description: "Invalidate TLB Entries"
    description: "Invalidates any translation lookaside buffer (TLB) entries specified with the source operand. The source operand is a memory address. The processor determines the page that contains that address and flushes all TLB entries for that page.1\nThe INVLPG instruction is a privileged instruction. When the processor is running in protected mode, the CPL must be 0 to execute this instruction.\nThe INVLPG instruction normally flushes TLB entries only for the specified page; however, in some cases, it may flush more entries, even the entire TLB. The instruction invalidates TLB entries associated with the current PCID and may or may not do so for TLB entries associated with other PCIDs. (If PCIDs are disabled\n- CR4.PCIDE = 0\n- the current PCID is 000H.) The instruction also invalidates any global TLB entries for the specified page, regardless of PCID.\nFor more details on operations that flush the TLB, see \342\200\234MOVMove to/from Control Registers\342\200\235 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 2B and Section 4.10.4.1, \342\200\234Operations that Invalidate TLBs and Paging-Structure Caches,\342\200\235 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3A.\nThis instruction\342\200\231s operation is the same in all non-64-bit modes. It also operates the same in 64-bit mode, except if the memory address is in non-canonical form. In this case, INVLPG is the same as a NOP."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "MOVQ"
    short_description: "Move Quadword"
    description: "Copies a quadword from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be MMX technology registers, XMM registers, or 64-bit memory locations. This instruction can be used to move a quadword between two MMX technology registers or between an MMX technology register and a 64-bit memory location, or to move data between two XMM registers or between an XMM register and a 64-bit memory location. The instruction cannot be used to transfer data between memory locations.\nWhen the source operand is an XMM register, the low quadword is moved; when the destination operand is an XMM register, the quadword is stored to the low quadword of the register, and the high quadword is cleared to all 0s.\nIn 64-bit mode and if not encoded using VEX/EVEX, use of the REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.\nIf VMOVQ is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "VRANGEPD"
    short_description: "Range Restriction Calculation For Packed Pairs of Float64 Values"
  }
  instruction_groups {
    name: "CLWB"
    short_description: "Cache Line Write Back"
    description: "Writes back to memory the cache line (if modified) that contains the linear address specified with the memory operand from any level of the cache hierarchy in the cache coherence domain. The line may be retained in the cache hierarchy in non-modified state. Retaining the line in the cache hierarchy is a performance optimization (treated as a hint by hardware) to reduce the possibility of cache miss on a subsequent access. Hardware may choose to retain the line at any of the levels in the cache hierarchy, and in some cases, may invalidate the line from the cache hierarchy. The source operand is a byte memory location.\nThe availability of CLWB instruction is indicated by the presence of the CPUID feature flag CLWB (bit 24 of the EBX register, see \342\200\234CPUID - CPU Identification\342\200\235 in this chapter). The aligned cache line size affected is also indicated with the CPUID instruction (bits 8 through 15 of the EBX register when the initial value in the EAX register is 1).\nThe memory attribute of the page containing the affected line has no effect on the behavior of this instruction. It should be noted that processors are free to speculatively fetch and cache data from system memory regions that are assigned a memory-type allowing for speculative reads (such as, the WB, WC, and WT memory types).\nPREFETCHh instructions can be used to provide the processor with hints for this speculative behavior. Because this speculative fetching can occur at any time and is not tied to instruction execution, the CLWB instruction is not ordered with respect to PREFETCHh instructions or any of the speculative fetching mechanisms (that is, data can be speculatively loaded into a cache line just before, during, or after the execution of a CLWB instruction that references the cache line).\nExecutions of the CLWB instruction are ordered with respect to fence instructions and to locked read-modify-write instructions; they are also ordered with respect to older writes to the cache line being written back. They are not ordered with respect to other executions of CLWB, to executions of CLFLUSH and CLFLUSHOPT, or to younger writes to the cache line being written back. Software can use the SFENCE instruction to order an execution of CLWB relative to one of those operations.\nFor usages that require only writing back modified data from cache lines to memory (do not require the line to be invalidated), and expect to subsequently access the data, software is recom mended to use CLWB (with appropriate\nfencing) instead of CLFLUSH or CLFLUSHOPT for improved performance.\nThe CLWB instruction can be used at all privilege levels and is subject to all permission checking and faults associated with a byte load. Like a load, the CLWB instruction sets the accessed flag but not the dirty flag in the page tables.\nIn some implementations, the CLWB instruction may always cause transactional abort with Transactional Synchronization Extensions (TSX). CLWB instruction is not expected to be com monly used inside typical transactional\nregions. However, program mers must not rely on CLWB instruction to force a transactional abort, since whether they cause transactional abort is implementation dependent."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "AESDEC"
    short_description: "Perform One Round of an AES Decryption Flow"
    description: "This instruction performs a single round of the AES decryption flow using the Equivalent Inverse Cipher, with the round key from the second source operand, operating on a 128-bit data (state) from the first source operand, and store the result in the destination operand.\nUse the AESDEC instruction for all but the last decryption round. For the last decryption round, use the AESDECLAST instruction.\nVEX and EVEX encoded versions of the instruction allow 3-operand (non-destructive) operation. The legacy encoded versions of the instruction require that the first source operand and the destination operand are the same and must be an XMM register.\nThe EVEX encoded form of this instruction does not support memory fault suppression."
  }
  instruction_groups {
    name: "FINCSTP"
    short_description: "Increment Stack-Top Pointer"
    description: "Adds one to the TOP field of the FPU status word (increments the top-of-stack pointer). If the TOP field contains a 7, it is set to 0. The effect of this instruction is to rotate the stack by one position. The contents of the FPU data registers and tag register are not affected. This operation is not equivalent to popping the stack, because the tag for the previous top-of-stack register is not marked empty.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "The C1 flag is set to 0. The C0, C2, and C3 flags are undefined."
    }
  }
  instruction_groups {
    name: "BEXTR"
    short_description: "Bit Field Extract"
    description: "Extracts contiguous bits from the first source operand (the second operand) using an index value and length value specified in the second source operand (the third operand). Bit 7:0 of the second source operand specifies the starting bit position of bit extraction. A START value exceeding the operand size will not extract any bits from the second source operand. Bit 15:8 of the second source operand specifies the maximum number of bits (LENGTH) beginning at the START position to extract. Only bit positions up to (OperandSize -1) of the first source operand are extracted. The extracted bits are written to the destination register, starting from the least significant bit. All higher order bits in the destination operand (starting at bit position LENGTH) are zeroed. The destination register is cleared if no bits are extracted.\nThis instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD."
    flags_affected {
      content: "ZF is updated based on the result. AF, SF, and PF are undefined. All other flags are cleared."
    }
  }
  instruction_groups {
    name: "MOVAPS"
    short_description: "Move Aligned Packed Single-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "DIV"
    short_description: "Unsigned Divide"
    description: "Divides unsigned the value in the AX, DX:AX, EDX:EAX, or RDX:RAX registers (dividend) by the source operand (divisor) and stores the result in the AX (AH:AL), DX:AX, EDX:EAX, or RDX:RAX registers. The source operand can be a general-purpose register or a memory location. The action of this instruction depends on the operand size (dividend/divisor). Division using 64-bit operand is available only in 64-bit mode.\nNon-integral results are truncated (chopped) towards 0. The remainder is always less than the divisor in magnitude. Overflow is indicated with the #DE (divide error) exception rather than with the CF flag.\nIn 64-bit mode, the instruction\342\200\231s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. In 64-bit mode when REX.W is applied, the instruction divides the unsigned value in RDX:RAX by the source operand and stores the quotient in RAX, the remainder in RDX.\nSee the sum mary chart at the beginning of this section for encoding data and limits. See Table 3-15.\nTable 3-15.  DIV Action\nOperand Size\tDividend\tDivisor\tQuotient\tRemainder\tMaximum Quotient\nWord/byte\tAX\tr/m8\tAL\tAH\t255\nDoubleword/word\tDX:AX\tr/m16\tAX\tDX\t65,535\nQuadword/doubleword\tEDX:EAX\tr/m32\tEAX\tEDX\t232 \342\210\222 1\nDoublequadword/ quadword\tRDX:RAX\tr/m64\tRAX\tRDX\t264 \342\210\222 1"
    flags_affected {
      content: "The CF, OF, SF, ZF, AF, and PF flags are undefined."
    }
  }
  instruction_groups {
    name: "VGATHERDPS/VGATHERDPD"
    short_description: "Gather Packed Single, Packed Double with Signed Dword"
  }
  instruction_groups {
    name: "PSUBUSB/PSUBUSW"
    short_description: "Subtract Packed Unsigned Integers with Unsigned Saturation"
    description: "Performs a SIMD subtract of the packed unsigned integers of the source operand (second operand) from the packed unsigned integers of the destination operand (first operand), and stores the packed unsigned integer results in the destination operand. See Figure 9-4 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with unsigned saturation, as described in the following paragraphs.\nThese instructions can operate on either 64-bit or 128-bit operands.\nThe (V)PSUBUSB instruction subtracts packed unsigned byte integers. When an individual byte result is less than zero, the saturated value of 00H is written to the destination operand.\nThe (V)PSUBUSW instruction subtracts packed unsigned word integers. When an individual word result is less than zero, the saturated value of 0000H is written to the destination operand.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE version 64-bit operand: The destination operand must be an MMX technology register and the source operand can be either an MMX technology register or a 64-bit memory location.\n128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded versions: The second source operand is an YMM register or an 256-bit memory location. The first source operand and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.\nEVEX encoded version: The second source operand is an ZMM/YMM/XMM register or an 512/256/128-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "ANDNPS"
    short_description: "Bitwise Logical AND NOT of Packed Single Precision Floating-Point Values"
    description: "Performs a bitwise logical AND NOT of the four, eight or sixteen packed single-precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand.\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\nVEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified."
  }
  instruction_groups {
    name: "LOOP/LOOPcc"
    short_description: "Loop According to ECX Counter"
    description: "Performs a loop operation using the RCX, ECX or CX register as a counter (depending on whether address size is 64 bits, 32 bits, or 16 bits). Note that the LOOP instruction ignores REX.W; but 64-bit address size can be over-ridden using a 67H prefix.\nEach time the LOOP instruction is executed, the count register is decremented, then checked for 0. If the count is 0, the loop is terminated and program execution continues with the instruction following the LOOP instruction. If the count is not zero, a near jump is performed to the destination (target) operand, which is presumably the instruction at the beginning of the loop.\nThe target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer in the IP/EIP/RIP register). This offset is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed, 8-bit im\nmediate value, which is added to the instruction pointer.\nOffsets of -128 to +127 are allowed with this instruction.\nSome forms of the loop instruction (LOOPcc) also accept the ZF flag as a condition for terminating the loop before the count reaches zero. With these forms of the instruction, a condition code (cc) is associated with each instruction to indicate the condition being tested for. Here, the LOOPcc instruction itself does not affect the state of the ZF flag; the ZF flag is changed by other instructions in the loop."
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "VFNMSUB132SD/VFNMSUB213SD/VFNMSUB231SD"
    short_description: "Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Val-"
  }
  instruction_groups {
    name: "ADDSS"
    short_description: "Add Scalar Single-Precision Floating-Point Values"
    description: "Adds the low single-precision floating-point values from the second source operand and the first source operand, and stores the double-precision floating-point result in the destination operand.\nThe second source operand can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers.\n128-bit Legacy SSE version: The first source and destination operands are the same. Bits (MAXVL-1:32) of the corresponding the destination register remain unchanged.\nEVEX and VEX.128 encoded version: The first source operand is encoded by EVEX.vvvv/VEX.vvvv. Bits (127:32) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\nEVEX version: The low doubleword element of the destination is updated according to the writemask.\nSoftware should ensure VADDSS is encoded with VEX.L=0. Encoding VADDSS with VEX.L=1 may encounter unpredictable behavior across different processor generations."
  }
  instruction_groups {
    name: "CLFLUSHOPT"
    short_description: "Flush Cache Line Optimized"
    description: "Invalidates from every level of the cache hierarchy in the cache coherence domain the cache line that contains the linear address specified with the memory operand. If that cache line contains modified data at any level of the cache hierarchy, that data is written back to memory. The source operand is a byte memory location.\nThe availability of CLFLUSHOPT is indicated by the presence of the CPUID feature flag CLFLUSHOPT (CPUID.(EAX=7,ECX=0):EBX[bit 23]). The aligned cache line size affected is also indicated with the CPUID instruction (bits 8 through 15 of the EBX register when the initial value in the EAX register is 1).\nThe memory attribute of the page containing the affected line has no effect on the behavior of this instruction. It should be noted that processors are free to speculatively fetch and cache data from system memory regions assigned a memory-type allowing for speculative reads (such as, the WB, WC, and WT memory types). PREFETCHh instructions can be used to provide the processor with hints for this speculative behavior. Because this speculative fetching can occur at any time and is not tied to instruction execution, the CLFLUSH instruction is not ordered with respect to PREFETCHh instructions or any of the speculative fetching mechanisms (that is, data can be speculatively loaded into a cache line just before, during, or after the execution of a CLFLUSH instruction that references the cache line).\nExecutions of the CLFLUSHOPT instruction are ordered with respect to fence instructions and to locked readmodify-write instructions; they are also ordered with respect to older writes to the cache line being invalidated.\nThey are not ordered with respect to other executions of CLFLUSHOPT, to executions of CLFLUSH and CLWB, or to younger writes to the cache line being invalidated. Software can use the SFENCE instruction to order an execution of CLFLUSHOPT relative to one of those operations.\nThe CLFLUSHOPT instruction can be used at all privilege levels and is subject to all permission checking and faults associated with a byte load (and in addition, a CLFLUSHOPT instruction is allowed to flush a linear address in an execute-only segment). Like a load, the CLFLUSHOPT instruction sets the A bit but not the D bit in the page tables.\nIn some implementations, the CLFLUSHOPT instruction may always cause transactional abort with Transactional Synchronization Extensions (TSX). The CLFLUSHOPT instruction is not expected to be com monly used inside\ntypical transactional regions. However, program mers must not rely on CLFLUSHOPT instruction to force a transactional abort, since whether they cause transactional abort is implementation dependent.\nCLFLUSHOPT operation is the same in non-64-bit modes and 64-bit mode."
  }
  instruction_groups {
    name: "NOT"
    short_description: "One\'s Complement Negation"
    description: "Performs a bitwise NOT operation (each 1 is set to 0, and each 0 is set to 1) on the destination operand and stores the result in the destination operand location. The destination operand can be a register or a memory location.\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.\nIn 64-bit mode, the instruction\342\200\231s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the sum mary chart at the beginning of this section for encoding data and limits."
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "FXAM"
    short_description: "Examine Floating-Point"
    description: "Examines the contents of the ST(0) register and sets the condition code flags C0, C2, and C3 in the FPU status word to indicate the class of value or number in the register (see the table below).\nTable 3-42.  FXAM Results\nClass\tC3\tC2\tC0\nUnsupported\t0\t0\t0\nNaN\t0\t0\t1\nNormal finite number\t0\t1\t0\nInfinity\t0\t1\t1\nZero\t1\t0\t0\nEmpty\t1\t0\t1\nDenormal number\t1\t1\t0\nThe C1 flag is set to the sign of the value in ST(0), regardless of whether the register is empty or full.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C1\tSign of value in ST(0).\nC0, C2, C3\tSee Table 3-42."
    }
  }
  instruction_groups {
    name: "VPERMQ"
    short_description: "Qwords Element Permutation"
  }
  instruction_groups {
    name: "VRNDSCALEPD"
    short_description: "Round Packed Float64 Values To Include A Given Number Of Fraction Bits"
  }
  instruction_groups {
    name: "VMPTRST"
    description: "Stores the current-VMCS pointer into a specified memory address. The operand of this instruction is always 64 bits and is always in memory."
    flags_affected {
      content: "See the operation section and Section 30.2."
    }
  }
  instruction_groups {
    name: "SQRTSS"
    short_description: "Compute Square Root of Scalar Single-Precision Value"
  }
  instruction_groups {
    name: "FSAVE/FNSAVE"
    short_description: "Store x87 FPU State"
    description: "Stores the current FPU state (operating environment and register stack) at the specified destination in memory, and then re-initializes the FPU. The FSAVE instruction checks for and handles pending unmasked floating-point exceptions before storing the FPU state; the FNSAVE instruction does not.\nThe FPU operating environment consists of the FPU control word, status word, tag word, instruction pointer, data pointer, and last opcode. Figures 8-9 through 8-12 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1, show the layout in memory of the stored environment, depending on the operating mode of the processor (protected or real) and the current operand-size attribute (16-bit or 32-bit). In virtual-8086 mode, the real mode layouts are used. The contents of the FPU register stack are stored in the 80 bytes im mediately follow\nthe operating environment image.\nThe saved image reflects the state of the FPU after all floating-point instructions preceding the FSAVE/FNSAVE instruction in the instruction stream have been executed.\nAfter the FPU state has been saved, the FPU is reset to the same default values it is set to with the FINIT/FNINIT instructions (see \342\200\234FINIT/FNINIT-Initialize Floating-Point Unit\342\200\235 in this chapter).\nThe FSAVE/FNSAVE instructions are typically used when the operating system needs to perform a context switch, an exception handler needs to use the FPU, or an application program needs to pass a \342\200\234clean\342\200\235 FPU to a procedure.\nThe assembler issues two instructions for the FSAVE instruction (an FWAIT instruction followed by an FNSAVE instruction), and the processor executes each of these instructions separately. If an exception is generated for either of these instructions, the save EIP points to the instruction that caused the exception.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "The C0, C1, C2, and C3 flags are saved and then cleared."
    }
  }
  instruction_groups {
    name: "FST/FSTP"
    short_description: "Store Floating Point Value"
    description: "The FST instruction copies the value in the ST(0) register to the destination operand, which can be a memory location or another register in the FPU register stack. When storing the value in memory, the value is converted to single-precision or double-precision floating-point format.\nThe FSTP instruction performs the same operation as the FST instruction and then pops the register stack. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.\nThe FSTP instruction can also store values in memory in double extended-precision floating-point format.\nIf the destination operand is a memory location, the operand specifies the address where the first byte of the destination value is to be stored. If the destination operand is a register, the operand specifies a register in the register stack relative to the top of the stack.\nIf the destination size is single-precision or double-precision, the significand of the value being stored is rounded to the width of the destination (according to the rounding mode specified by the RC field of the FPU control word), and the exponent is converted to the width and bias of the destination format. If the value being stored is too large for the destination format, a numeric overflow exception (#O) is generated and, if the exception is unmasked, no value is stored in the destination operand. If the value being stored is a denormal value, the denormal exception (#D) is not generated. This condition is simply signaled as a numeric underflow exception (#U) condition.\nIf the value being stored is \302\2610, \302\261\342\210\236, or a NaN, the least-significant bits of the significand and the exponent are truncated to fit the destination format. This operation preserves the value\342\200\231s identity as a 0, \342\210\236, or NaN.\nIf the destination operand is a non-empty register, the invalid-operation exception is not generated.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "C1\tSet to 0 if stack underflow occurred.\nIndicates rounding direction of if the floating-point inexact exception (#P) is generated: 0 := not roundup; 1 := roundup.\nC0, C2, C3\tUndefined."
    }
  }
  instruction_groups {
    name: "VPMOVQB/VPMOVSQB/VPMOVUSQB"
    short_description: "Down Convert QWord to Byte"
  }
  instruction_groups {
    name: "PMULHUW"
    short_description: "Multiply Packed Unsigned Integers and Store High Result"
    description: "Performs a SIMD unsigned multiply of the packed unsigned word integers in the destination operand (first operand) and the source operand (second operand), and stores the high 16 bits of each 32-bit intermediate results in the destination operand. (Figure 4-12 shows this operation when using 64-bit operands.)\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE version 64-bit operand: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register.\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed. VEX.L must be 0, otherwise the instruction will #UD.\nVEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\nSRC\tX3\tX2\tX1\tX0\nDEST\tY3\tY2\tY1\tY0\nTEMP\tZ3 = X3 \342\210\227 Y3\tZ2 = X2 \342\210\227 Y2\tZ1 = X1 \342\210\227 Y1\tZ0 = X0 \342\210\227 Y0\nDEST\tZ3[31:16]\tZ2[31:16]\tZ1[31:16]\tZ0[31:16]\nFigure 4-12.  PMULHUW and PMULHW Instruction Operation Using 64-bit Operands"
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "KORTESTW/KORTESTB/KORTESTQ/KORTESTD"
    short_description: "OR Masks And Set Flags"
    description: "Performs a bitwise OR between the vector mask register k2, and the vector mask register k1, and sets CF and ZF based on the operation result.\nZF flag is set if both sources are 0x0. CF is set if, after the OR operation is done, the operation result is all 1\342\200\231s."
    flags_affected {
      content: "The ZF flag is set if the result of OR-ing both sources is all 0s.\nThe CF flag is set if the result of OR-ing both sources is all 1s.\nThe OF, SF, AF, and PF flags are set to 0."
    }
  }
  instruction_groups {
    name: "MAXSS"
    short_description: "Return Maximum Scalar Single-Precision Floating-Point Value"
  }
  instruction_groups {
    name: "MOVNTDQ"
    short_description: "Store Packed Integers Using Non-Temporal Hint"
  }
  instruction_groups {
    name: "XACQUIRE/XRELEASE"
    short_description: "Hardware Lock Elision Prefix Hints"
    description: "The XACQUIRE prefix is a hint to start lock elision on the memory address specified by the instruction and the XRELEASE prefix is a hint to end lock elision on the memory address specified by the instruction.\nThe XACQUIRE prefix hint can only be used with the following instructions (these instructions are also referred to as XACQUIRE-enabled when used with the XACQUIRE prefix):\n\342\200\242\tInstructions with an explicit LOCK prefix (F0H) prepended to forms of the instruction where the destination operand is a memory operand: ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCHG8B, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD, and XCHG.\n\342\200\242 The XCHG instruction either with or without the presence of the LOCK prefix.\nThe XRELEASE prefix hint can only be used with the following instructions (also referred to as XRELEASE-enabled when used with the XRELEASE prefix):\n\342\200\242\tInstructions with an explicit LOCK prefix (F0H) prepended to forms of the instruction where the destination operand is a memory operand: ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCHG8B, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD, and XCHG.\n\342\200\242\tThe XCHG instruction either with or without the presence of the LOCK prefix.\n\342\200\242 The \342\200\234MOV mem, reg\342\200\235 (Opcode 88H/89H) and \342\200\234MOV mem, im m\342\200\235 (Opcode C6H/C7H) instructions. In these cases, the XRELEASE is recognized without the presence of the LOCK prefix.\nThe lock variables must satisfy the guidelines described in Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1, Section 16.3.3, for elision to be successful, otherwise an HLE abort may be signaled.\nIf an encoded byte sequence that meets XACQUIRE/XRELEASE requirements includes both prefixes, then the HLE semantic is determined by the prefix byte that is placed closest to the instruction opcode. For example, an F3F2C6 will not be treated as a XRELEASE-enabled instruction since the F2H (XACQUIRE) is closest to the instruction opcode C6. Similarly, an F2F3F0 prefixed instruction will be treated as a XRELEASE-enabled instruction since F3H (XRELEASE) is closest to the instruction opcode.\nIntel 64 and IA-32 Compatibility The effect of the XACQUIRE/XRELEASE prefix hint is the same in non-64-bit modes and in 64-bit mode.\nFor instructions that do not support the XACQUIRE hint, the presence of the F2H  prefix behaves the same way as prior hardware, according to\n\342\200\242\tREPNE/REPNZ semantics for string instructions,\n\342\200\242\tServe as SIMD prefix for legacy SIMD instructions operating on XMM register\n\342\200\242\tCause #UD if prepending the VEX prefix.\n\342\200\242 Undefined for non-string instructions or other situations.\nFor instructions that do not support the XRELEASE hint, the presence of the F3H prefix behaves the same way as in prior hardware, according to\n\342\200\242\tREP/REPE/REPZ semantics for string instructions,\n\342\200\242\tServe as SIMD prefix for legacy SIMD instructions operating on XMM register\n\342\200\242\tCause #UD if prepending the VEX prefix.\n\342\200\242\tUndefined for non-string instructions or other situations."
  }
  instruction_groups {
    name: "OUT"
    short_description: "Output to Port"
    description: "Copies the value from the second operand (source operand) to the I/O port specified with the destination operand (first operand). The source operand can be register AL, AX, or EAX, depending on the size of the port being accessed (8, 16, or 32 bits, respectively); the destination operand can be a byte-im mediate or the DX register.\nUsing a byte im mediate allows I/O port addresses 0 to 255 to be accessed; using the DX register as a source operand allows I/O ports from 0 to 65,535 to be accessed.\nThe size of the I/O port being accessed is determined by the opcode for an 8-bit I/O port or by the operand-size attribute of the instruction for a 16- or 32-bit I/O port.\nAt the machine code level, I/O instructions are shorter when accessing 8-bit I/O ports. Here, the upper eight bits of the port address will be 0.\nThis instruction is only useful for accessing I/O ports located in the processor\342\200\231s I/O address space. See Chapter 19, \342\200\234Input/Output,\342\200\235 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1, for more information on accessing I/O ports in the I/O address space.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "RORX"
    short_description: "Rotate Right Logical Without Affecting Flags"
    description: "Rotates the bits of second operand right by the count value specified in im m8 without affecting arithmetic flags.\nThe RORX instruction does not read or write the arithmetic flags.\nThis instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD."
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "WAIT/FWAIT"
    short_description: "Wait"
    description: "Causes the processor to check for and handle pending, unmasked, floating-point exceptions before proceeding.\n(FWAIT is an alternate mnemonic for WAIT.)\nThis instruction is useful for synchronizing exceptions in critical sections of code. Coding a WAIT instruction after a floating-point instruction ensures that any unmasked floating-point exceptions the instruction may raise are handled before the processor can modify the instruction\342\200\231s results. See the section titled \342\200\234Floating-Point Exception Synchronization\342\200\235 in Chapter 8 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1, for more information on using the WAIT/FWAIT instruction.\nThis instruction\342\200\231s operation is the same in non-64-bit modes and 64-bit mode."
    flags_affected {
      content: "The C0, C1, C2, and C3 flags are undefined."
    }
  }
  instruction_groups {
    name: "CVTPS2PD"
    short_description: "Convert Packed Single-Precision Floating-Point Values to Packed Double-Precision Floating-Point Values"
    description: "Converts two, four or eight packed single-precision floating-point values in the source operand (second operand) to two, four or eight packed double-precision floating-point values in the destination operand (first operand).\nEVEX encoded versions: The source operand is a YMM/XMM/XMM (low 64-bits) register, a 256/128/64-bit memory location or a 256/128/64-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\nVEX.256 encoded version: The source operand is an XMM register or 128- bit memory location. The destination operand is a YMM register. Bits (MAXVL-1:256) of the corresponding destination ZMM register are zeroed.\nVEX.128 encoded version: The source operand is an XMM register or 64- bit memory location. The destination operand is a XMM register. The upper Bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n128-bit Legacy SSE version: The source operand is an XMM register or 64- bit memory location. The destination operand is an XMM register. The upper Bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.\nSRC\tX3\tX2\tX1\tX0\nDEST\tX3\tX2\tX1\tX0\nFigure 3-14.  CVTPS2PD (VEX.256 encoded version)"
  }
  instruction_groups {
    name: "MOVLPD"
    short_description: "Move Low Packed Double-Precision Floating-Point Value"
  }
  instruction_groups {
    name: "VFMSUBADD132PD/VFMSUBADD213PD/VFMSUBADD231PD"
    short_description: "Fused Multiply-Alternating Subtract/Add of Packed Double-Precision"
  }
  instruction_groups {
    name: "VGETEXPPS"
    short_description: "Convert Exponents of Packed SP FP Values to SP FP Values"
  }
  instruction_groups {
    name: "LGDT/LIDT"
    short_description: "Load Global/Interrupt Descriptor Table Register"
    description: "Loads the values in the source operand into the global descriptor table register (GDTR) or the interrupt descriptor table register (IDTR). The source operand specifies a 6-byte memory location that contains the base address (a linear address) and the limit (size of table in bytes) of the global descriptor table (GDT) or the interrupt descriptor table (IDT). If operand-size attribute is 32 bits, a 16-bit limit (lower 2 bytes of the 6-byte data operand) and a 32- bit base address (upper 4 bytes of the data operand) are loaded into the register. If the operand-size attribute is 16\nbits, a 16-bit limit (lower 2 bytes) and a 24-bit base address (third, fourth, and fifth byte) are loaded. Here, the high-order byte of the operand is not used and the high-order byte of the base address in the GDTR or IDTR is filled with zeros.\nThe LGDT and LIDT instructions are used only in operating-system software; they are not used in application programs. They are the only instructions that directly load a linear address (that is, not a segment-relative address) and a limit in protected mode. They are com monly executed in real-address mode to allow processor\ninitialization prior to switching to protected mode.\nIn 64-bit mode, the instruction\342\200\231s operand size is fixed at 8+2 bytes (an 8-byte base and a 2-byte limit). See the sum mary chart at the beginning of this section for encoding data and limits.\nSee \342\200\234SGDT-Store Global Descriptor Table Register\342\200\235 in Chapter 4, Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 2B, for information on storing the contents of the GDTR and IDTR."
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "VMASKMOV"
    short_description: "Conditional SIMD Packed Loads and Stores"
    description: "Conditionally moves packed data elements from the second source operand into the corresponding data element of the destination operand, depending on the mask bits associated with each data element. The mask bits are specified in the first source operand.\nThe mask bit for each data element is the most significant bit of that element in the first source operand. If a mask is 1, the corresponding data element is copied from the second source operand to the destination operand. If the mask is 0, the corresponding data element is set to zero in the load form of these instructions, and unmodified in the store form.\nThe second source operand is a memory address for the load form of these instruction. The destination operand is a memory address for the store form of these instructions. The other operands are both XMM registers (for VEX.128 version) or YMM registers (for VEX.256 version).\nFaults occur only due to mask-bit required memory accesses that caused the faults. Faults will not occur due to referencing any memory location if the corresponding mask bit for that memory location is 0. For example, no faults will be detected if the mask bits are all zero.\nUnlike previous MASKMOV instructions (MASKMOVQ and MASKMOVDQU), a nontemporal hint is not applied to these instructions.\nInstruction behavior on alignment check reporting with mask bits of less than all 1s are the same as with mask bits of all 1s.\nVMASKMOV should not be used to access memory mapped I/O and un-cached memory as the access and the ordering of the individual loads or stores it does is implementation specific.\nIn cases where mask bits indicate data should not be loaded or stored paging A and D bits will be set in an implementation dependent way. However, A and D bits are always set for pages where data is actually loaded/stored.\nNote: for load forms, the first source (the mask) is encoded in VEX.vvvv; the second source is encoded in rm_field, and the destination register is encoded in reg_field.\nNote: for store forms, the first source (the mask) is encoded in VEX.vvvv; the second source register is encoded in reg_field, and the destination memory location is encoded in rm_field."
  }
  instruction_groups {
    name: "VREDUCEPD"
    short_description: "Perform Reduction Transformation on Packed Float64 Values"
  }
  instruction_groups {
    name: "ORPD"
    short_description: "Bitwise Logical OR of Packed Double Precision Floating-Point Values"
  }
  instruction_groups {
    name: "GF2P8AFFINEINVQB"
    short_description: "Galois Field Affine Transformation Inverse"
  }
  instruction_groups {
    name: "VGATHERDPD/VGATHERQPD"
    short_description: "Gather Packed DP FP Values Using Signed Dword/Qword Indices"
    description: "The instruction conditionally loads up to 2 or 4 double-precision floating-point values from memory addresses specified by the memory operand (the second operand) and using qword indices. The memory operand uses the VSIB form of the SIB byte to specify a general purpose register operand as the com mon base, a vector register for\nan array of indices relative to the base and a constant scale factor.\nThe mask operand (the third operand) specifies the conditional load operation from each memory address and the corresponding update of each data element of the destination operand (the first operand). Conditionality is specified by the most significant bit of each data element of the mask register. If an element\342\200\231s mask bit is not set, the corresponding element of the destination register is left unchanged. The width of data element in the destination register and mask register are identical. The entire mask register will be set to zero by this instruction unless the instruction causes an exception.\nUsing dword indices in the lower half of the mask register, the instruction conditionally loads up to 2 or 4 doubleprecision floating-point values from the VSIB addressing memory operand, and updates the destination register.\nThis instruction can be suspended by an exception if at least one element is already gathered (i.e., if the exception is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination register and the mask operand are partially updated; those elements that have been gathered are placed into the destination register and have their mask bits set to zero. If any traps or interrupts are pending from already gathered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction breakpoint is not re-triggered when the instruction is continued.\nIf the data size and index size are different, part of the destination register and part of the mask register do not correspond to any elements being gathered. This instruction sets those parts to zero. It may do this to one or both of those registers even if the instruction triggers an exception, and even if the instruction triggers the exception before gathering any elements.\nVEX.128 version: The instruction will gather two double-precision floating-point values. For dword indices, only the lower two indices in the vector index register are used.\nVEX.256 version: The instruction will gather four double-precision floating-point values. For dword indices, only the lower four indices in the vector index register are used.\nNote that:\n\342\200\242\tIf any pair of the index, mask, or destination registers are the same, this instruction results a #UD fault.\n\342\200\242\tThe values may be read from memory in any order. Memory ordering with other instructions follows the Intel- 64 memory-ordering model.\n\342\200\242\tFaults are delivered in a right-to-left manner. That is, if a fault is triggered by an element and delivered, all elements closer to the LSB of the destination will be completed (and non-faulting). Individual elements closer to the MSB may or may not be completed. If a given element triggers multiple faults, they are delivered in the conventional order.\n\342\200\242\tElements may be gathered in any order, but faults must be delivered in a right-to-left order; thus, elements to the left of a faulting one may be gathered before the fault is delivered. A given implementation of this instruction is repeatable - given the same input values and architectural state, the same set of elements to the left of the faulting one will be gathered.\n\342\200\242\tThis instruction does not perform AC checks, and so will never deliver an AC fault.\n\342\200\242\tThis instruction will cause a #UD if the address size attribute is 16-bit.\n\342\200\242\tThis instruction will cause a #UD if the memory operand is encoded without the SIB byte.\n\342\200\242\tThis instruction should not be used to access memory mapped I/O as the ordering of the individual loads it does is implementation specific, and some implementations may use loads larger than the data element size or load elements an indeterminate number of times.\n\342\200\242\tThe scaled index may require more bits to represent than the address bits used by the processor (e.g., in 32- bit mode, if the scale is greater than one). In this case, the most significant bits beyond the number of address bits are ignored."
  }
  instruction_groups {
    name: "CVTPD2PI"
    short_description: "Convert Packed Double-Precision FP Values to Packed Dword Integers"
    description: "Converts two packed double-precision floating-point values in the source operand (second operand) to two packed signed doubleword integers in the destination operand (first operand).\nThe source operand can be an XMM register or a 128-bit memory location. The destination operand is an MMX technology register.\nWhen a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.\nThis instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the CVTPD2PI instruction is executed.\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15)."
  }
  instruction_groups {
    name: "VPCMPQ/VPCMPUQ"
    short_description: "Compare Packed Integer Values into Mask"
  }
  instruction_groups {
    name: "MOVSD"
    short_description: "Move or Merge Scalar Double-Precision Floating-Point Value"
  }
  instruction_groups {
    name: "MULSS"
    short_description: "Multiply Scalar Single-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "VPDPBUSD"
    short_description: "Multiply and Add Unsigned and Signed Bytes"
  }
  instruction_groups {
    name: "XLAT/XLATB"
    short_description: "Table Look-up Translation"
    description: "Locates a byte entry in a table in memory, using the contents of the AL register as a table index, then copies the contents of the table entry back into the AL register. The index in the AL register is treated as an unsigned integer.\nThe XLAT and XLATB instructions get the base address of the table in memory from either the DS:EBX or the DS:BX registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). (The DS segment may be overridden with a segment override prefix.)\nAt the assembly-code level, two forms of this instruction are allowed: the \342\200\234explicit-operand\342\200\235 form and the \342\200\234nooperand\342\200\235 form. The explicit-operand form (specified with the XLAT mnemonic) allows the base address of the table to be specified explicitly with a symbol. This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the symbol does not have to specify the correct base address. The base address is always specified by the DS:(E)BX registers, which must be loaded correctly before the XLAT instruction is executed.\nThe no-operands form (XLATB) provides a \342\200\234short form\342\200\235 of the XLAT instructions. Here also the processor assumes that the DS:(E)BX registers contain the base address of the table.\nIn 64-bit mode, operation is similar to that in legacy or compatibility mode. AL is used to specify the table index (the operand size is fixed at 8 bits). RBX, however, is used to specify the table\342\200\231s base address. See the sum mary\nchart at the beginning of this section for encoding data and limits."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "VGATHERPF0DPS/VGATHERPF0QPS/VGATHERPF0DPD/VGATHERPF0QPD"
    short_description: "Sparse Prefetch Packed SP/DP Data Values with Signed"
  }
  instruction_groups {
    name: "VCVTPH2PS"
    short_description: "Convert 16-bit FP values to Single-Precision FP values"
  }
  instruction_groups {
    name: "CMOVcc"
    short_description: "Conditional Move"
    description: "Each of the CMOVcc instructions performs a move operation if the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) are in a specified state (or condition). A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move is not performed and execution continues with the instruction following the CMOVcc instruction.\nSpecifically, CMOVcc loads data from its source operand into a temporary register unconditionally (regardless of the condition code and the status flags in the EFLAGS register). If the condition code associated with the instruction (cc) is satisfied, the data in the temporary register is then copied into the instruction\'s destination operand.\nThese instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one general-purpose register to another. Conditional moves of 8-bit register operands are not supported.\nThe condition for each CMOVcc mnemonic is given in the description column of the above table. The terms \342\200\234less\342\200\235 and \342\200\234greater\342\200\235 are used for comparisons of signed integers and the terms \342\200\234above\342\200\235 and \342\200\234below\342\200\235 are used for unsigned integers.\nBecause a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE (conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.\nThe CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking the processor\342\200\231s feature information with the CPUID instruction (see \342\200\234CPUID-CPU Identification\342\200\235 in this chapter).\nIn 64-bit mode, the instruction\342\200\231s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the sum mary chart at the\nbeginning of this section for encoding data and limits."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "ADDPD"
    short_description: "Add Packed Double-Precision Floating-Point Values"
    description: "Adds two, four or eight packed double-precision floating-point values from the first source operand to the second source operand, and stores the packed double-precision floating-point result in the destination operand.\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\nVEX.128 encoded version: the first source operand is a XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper Bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified."
  }
  instruction_groups {
    name: "PAVGB/PAVGW"
    short_description: "Average Packed Integers"
    description: "Performs a SIMD average of the packed unsigned integers from the source operand (second operand) and the destination operand (first operand), and stores the results in the destination operand. For each corresponding pair of data elements in the first and second operands, the elements are added together, a 1 is added to the temporary sum, and that result is shifted right one bit position.\nThe (V)PAVGB instruction operates on packed unsigned bytes and the (V)PAVGW instruction operates on packed unsigned words.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.\n128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified.\nEVEX.512 encoded version: The first source operand is a ZMM register. The second source operand is a ZMM register or a 512-bit memory location. The destination operand is a ZMM register.\nVEX.256 and EVEX.256 encoded versions: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.\nVEX.128 and EVEX.128 encoded versions: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL- 1:128) of the corresponding register destination are zeroed."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "PCMPESTRI"
    short_description: "Packed Compare Explicit Length Strings, Return Index"
    description: "The instruction compares and processes data from two string fragments based on the encoded value in the Im m8\nControl Byte (see Section 4.1, \342\200\234Im m8 Control Byte Operation for PCMPESTRI / PCMPESTRM / PCMPISTRI / PCMPISTRM\342\200\235), and generates an index stored to the count register (ECX).\nEach string fragment is represented by two values. The first value is an xm m (or possibly m128 for the second operand) which contains the data elements of the string (byte or word data). The second value is stored in an input length register. The input length register is EAX/RAX (for xm m1) or EDX/RDX (for xm m2/m128). The length repre-\nsents the number of bytes/words which are valid for the respective xm m/m128 data.\nThe length of each input is interpreted as being the absolute-value of the value in the length register. The absolutevalue computation saturates to 16 (for bytes) and 8 (for words), based on the value of im m8[bit3] when the value\nin the length register is greater than 16 (8) or less than -16 (-8).\nThe comparison and aggregation operations are performed according to the encoded value of Im m8 bit fields (see\nSection 4.1). The index of the first (or last, according to im m8[6]) set bit of IntRes2 (see Section 4.1.4) is returned\nin ECX. If no bits are set in IntRes2, ECX is set to 16 (8).\nNote that the Arithmetic Flags are written in a non-standard manner in order to supply the most relevant information:\nCFlag - Reset if IntRes2 is equal to zero, set otherwise ZFlag - Set if absolute-value of EDX is < 16 (8), reset otherwise SFlag - Set if absolute-value of EAX is < 16 (8), reset otherwise OFlag - IntRes2[0] AFlag - Reset PFlag - Reset"
  }
  instruction_groups {
    name: "PSHUFB"
    short_description: "Packed Shuffle Bytes"
    description: "PSHUFB performs in-place shuffles of bytes in the destination operand (the first operand) according to the shuffle control mask in the source operand (the second operand). The instruction permutes the data in the destination operand, leaving the shuffle mask unaffected. If the most significant bit (bit[7]) of each byte of the shuffle control mask is set, then constant zero is written in the result byte. Each byte in the shuffle control mask forms an index to permute the corresponding byte in the destination operand. The value of each index is the least significant 4 bits (128-bit operation) or 3 bits (64-bit operation) of the shuffle control byte. When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.\nIn 64-bit mode and not encoded with VEX/EVEX, use the REX prefix to access XMM8-XMM15 registers.\nLegacy SSE version 64-bit operand: Both operands can be MMX registers.\n128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL- 1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The destination operand is the first operand, the first source operand is the second operand, the second source operand is the third operand. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded version: Bits (255:128) of the destination YMM register stores the 16-byte shuffle result of the upper 16 bytes of the first source operand, using the upper 16-bytes of the second source operand as control mask.\nThe value of each index is for the high 128-bit lane is the least significant 4 bits of the respective shuffle control byte. The index value selects a source data element within each 128-bit lane.\nEVEX encoded version: The second source operand is an ZMM/YMM/XMM register or an 512/256/128-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1.\nEVEX and VEX encoded version: Four/two in-lane 128-bit shuffles."
  }
  instruction_groups {
    name: "KXORW/KXORB/KXORQ/KXORD"
    short_description: "Bitwise Logical XOR Masks"
    description: "Performs a bitwise XOR between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1 (three-operand form)."
    flags_affected {
      content: "None\nSIMD Floating-Point Exceptions\nNone"
    }
  }
  instruction_groups {
    name: "VPCMPW/VPCMPUW"
    short_description: "Compare Packed Word Values Into Mask"
  }
  instruction_groups {
    name: "VPERMB"
    short_description: "Permute Packed Bytes Elements"
  }
  instruction_groups {
    name: "XOR"
    short_description: "Logical Exclusive OR"
    description: "Performs a bitwise exclusive OR (XOR) operation on the destination (first) and source (second) operands and stores the result in the destination operand location. The source operand can be an im\nmediate, a register, or a memory location; the destination operand can be a register or a memory location. (However, two memory operands cannot be used in one instruction.) Each bit of the result is 1 if the corresponding bits of the operands are different; each bit is 0 if the corresponding bits are the same.\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.\nIn 64-bit mode, using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the sum mary chart at the beginning of this\nsection for encoding data and limits."
    flags_affected {
      content: "The OF and CF flags are cleared; the SF, ZF, and PF flags are set according to the result. The state of the AF flag is undefined."
    }
  }
  instruction_groups {
    name: "EDBGWR"
  }
  instruction_groups {
    name: "PXOR"
    short_description: "Logical Exclusive OR"
    description: "Performs a bitwise logical exclusive-OR (XOR) operation on the source operand (second operand) and the destination operand (first operand) and stores the result in the destination operand. Each bit of the result is 1 if the corresponding bits of the two operands are different; each bit is 0 if the corresponding bits of the operands are the same.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE instructions 64-bit operand: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register.\n128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding register destination are zeroed.\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "DIVSS"
    short_description: "Divide Scalar Single-Precision Floating-Point Values"
    description: "Divides the low single-precision floating-point value in the first source operand by the low single-precision floatingpoint value in the second source operand, and stores the single-precision floating-point result in the destination operand. The second source operand can be an XMM register or a 32-bit memory location.\n128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL- 1:32) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The first source operand is an xm\nm register encoded by VEX.vvvv. The three high-order doublewords of the destination operand are copied from the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\nEVEX.128 encoded version: The first source operand is an xm\nm register encoded by EVEX.vvvv. The doubleword elements of the destination operand at bits 127:32 are copied from the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\nEVEX version: The low doubleword element of the destination is updated according to the writemask.\nSoftware should ensure VDIVSS is encoded with VEX.L=0. Encoding VDIVSS with VEX.L=1 may encounter unpredictable behavior across different processor generations."
  }
  instruction_groups {
    name: "ADDSUBPD"
    short_description: "Packed Double-FP Add/Subtract"
    description: "Adds odd-numbered double-precision floating-point values of the first source operand (second operand) with the corresponding double-precision floating-point values from the second source operand (third operand); stores the result in the odd-numbered values of the destination operand (first operand). Subtracts the even-numbered double-precision floating-point values from the second source operand from the corresponding double-precision floating values in the first source operand; stores the result into the even-numbered values of the destination operand.\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified. See Figure\n3-3.\nVEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.\nADDSUBPD xmm1, xmm2/m128\n[127:64]\t[63:0]\txmm2/m128\nxmm1[127:64] + xmm2/m128[127:64]\txmm1[63:0] - xmm2/m128[63:0]\tRESULT: xmm1\n[127:64]\t[63:0]\nFigure 3-3.  ADDSUBPD-Packed Double-FP Add/Subtract"
  }
  instruction_groups {
    name: "LDS/LES/LFS/LGS/LSS"
    short_description: "Load Far Pointer"
    description: "Loads a far pointer (segment selector and offset) from the second operand (source operand) into a segment register and the first operand (destination operand). The source operand specifies a 48-bit or a 32-bit pointer in memory depending on the current setting of the operand-size attribute (32 bits or 16 bits, respectively). The instruction opcode and the destination operand specify a segment register/general-purpose register pair. The 16- bit segment selector from the source operand is loaded into the segment register specified with the opcode (DS, SS, ES, FS, or GS). The 32-bit or 16-bit offset is loaded into the register specified with the destination operand.\nIf one of these instructions is executed in protected mode, additional information from the segment descriptor pointed to by the segment selector in the source operand is loaded in the hidden part of the selected segment register.\nAlso in protected mode, a NULL selector (values 0000 through 0003) can be loaded into DS, ES, FS, or GS registers without causing a protection exception. (Any subsequent reference to a segment whose corresponding segment register is loaded with a NULL selector, causes a general-protection exception (#GP) and no memory reference to the segment occurs.)\nIn 64-bit mode, the instruction\342\200\231s default operation size is 32 bits. Using a REX prefix in the form of REX.W promotes operation to specify a source operand referencing an 80-bit pointer (16-bit selector, 64-bit offset) in memory. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). See the sum mary chart at the\nbeginning of this section for encoding data and limits."
    flags_affected {
      content: "None"
    }
  }
  instruction_groups {
    name: "PUNPCKHBW/PUNPCKHWD/PUNPCKHDQ/PUNPCKHQDQ"
    short_description: "Unpack High Data"
    description: "Unpacks and interleaves the high-order data elements (bytes, words, doublewords, or quadwords) of the destination operand (first operand) and source operand (second operand) into the destination operand. Figure 4-20 shows\nthe unpack operation for bytes in 64-bit operands. The low-order data elements are ignored.\nSRC\tY7\tY6\tY5\tY4\tY3\tY2\tY1\tY0\tX7\tX6\tX5\tX4\tX3\tX2\tX1\tX0\tDEST\nDEST\tY7\tX7\tY6\tX6\tY5\tX5\tY4\tX4\nFigure 4-20.  PUNPCKHBW Instruction Operation Using 64-bit Operands\n255\t31\t0\t255\t31\t0\nSRC\tY7\tY6\tY5\tY4\tY3\tY2\tY1\tY0\tX7\tX6\tX5\tX4\tX3\tX2\tX1\tX0\n255\t0\nDEST\tY7\tX7\tY6\tX6\tY3\tX3\tY2\tX2\nFigure 4-21.  256-bit VPUNPCKHDQ Instruction Operation\nWhen the source data comes from a 64-bit memory operand, the full 64-bit operand is accessed from memory, but the instruction uses only the high-order 32 bits. When the source data comes from a 128-bit memory operand, an implementation may fetch only the appropriate 64 bits; however, alignment to a 16-byte boundary and normal segment checking will still be enforced.\nThe (V)PUNPCKHBW instruction interleaves the high-order bytes of the source and destination operands, the (V)PUNPCKHWD instruction interleaves the high-order words of the source and destination operands, the (V)PUNPCKHDQ instruction interleaves the high-order doubleword (or doublewords) of the source and destination operands, and the (V)PUNPCKHQDQ instruction interleaves the high-order quadwords of the source and destination operands.\nThese instructions can be used to convert bytes to words, words to doublewords, doublewords to quadwords, and quadwords to double quadwords, respectively, by placing all 0s in the source operand. Here, if the source operand contains all 0s, the result (stored in the destination operand) contains zero extensions of the high-order data elements from the original value in the destination operand. For example, with the (V)PUNPCKHBW instruction the high-order bytes are zero extended (that is, unpacked into unsigned word integers), and with the (V)PUNPCKHWD instruction, the high-order words are zero extended (unpacked into unsigned doubleword integers).\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE versions 64-bit operand: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register.\n128-bit Legacy SSE versions: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded versions: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded version: The second source operand is an YMM register or an 256-bit memory location. The first source operand and destination operands are YMM registers.\nEVEX encoded VPUNPCKHDQ/QDQ: The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1.\nEVEX encoded VPUNPCKHWD/BW: The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "VCVTTPS2UDQ"
    short_description: "Convert with Truncation Packed Single-Precision Floating-Point Values to Packed Unsigned Doubleword Integer Val-"
  }
  instruction_groups {
    name: "VFMADD132SD/VFMADD213SD/VFMADD231SD"
    short_description: "Fused Multiply-Add of Scalar Double-Precision Floating-Point Values"
  }
  instruction_groups {
    name: "VPBROADCAST"
    short_description: "Load Integer and Broadcast"
  }
  instruction_groups {
    name: "STOS/STOSB/STOSW/STOSD/STOSQ"
    short_description: "Store String"
    description: "In non-64-bit and default 64-bit mode; stores a byte, word, or doubleword from the AL, AX, or EAX register (respectively) into the destination operand. The destination operand is a memory location, the address of which is read from either the ES:EDI or ES:DI register (depending on the address-size attribute of the instruction and the mode of operation). The ES segment cannot be overridden with a segment override prefix.\nAt the assembly-code level, two forms of the instruction are allowed: the \342\200\234explicit-operands\342\200\235 form and the \342\200\234nooperands\342\200\235 form. The explicit-operands form (specified with the STOS mnemonic) allows the destination operand to be specified explicitly. Here, the destination operand should be a symbol that indicates the size and location of the destination value. The source operand is then automatically selected to match the size of the destination operand (the AL register for byte operands, AX for word operands, EAX for doubleword operands). The explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the destination operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword), but it does not have to specify the correct location. The location is always specified by the ES:(E)DI register. These must be loaded correctly before the store string instruction is executed.\nThe no-operands form provides \342\200\234short forms\342\200\235 of the byte, word, doubleword, and quadword versions of the STOS instructions. Here also ES:(E)DI is assumed to be the destination operand and AL, AX, or EAX is assumed to be the source operand. The size of the destination and source operands is selected by the mnemonic: STOSB (byte read from register AL), STOSW (word from AX), STOSD (doubleword from EAX).\nAfter the byte, word, or doubleword is transferred from the register to the memory location, the (E)DI register is incremented or decremented according to the setting of the DF flag in the EFLAGS register. If the DF flag is 0, the register is incremented; if the DF flag is 1, the register is decremented (the register is incremented or decremented by 1 for byte operations, by 2 for word operations, by 4 for doubleword operations).\nNOTE: To improve performance, more recent processors support modifications to the processor\342\200\231s operation during the string store operations initiated with STOS and STOSB. See Section 7.3.9.3 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1 for additional information on fast-string operation.\nIn 64-bit mode, the default address size is 64 bits, 32-bit address size is supported using the prefix 67H. Using a REX prefix in the form of REX.W promotes operation on doubleword operand to 64 bits. The promoted no-operand mnemonic is STOSQ. STOSQ (and its explicit operands variant) store a quadword from the RAX register into the destination addressed by RDI or EDI. See the sum mary chart at the beginning of this section for encoding data and\nlimits.\nThe STOS, STOSB, STOSW, STOSD, STOSQ instructions can be preceded by the REP prefix for block loads of ECX bytes, words, or doublewords. More often, however, these instructions are used within a LOOP construct because data needs to be moved into the AL, AX, or EAX register before it can be stored. See \342\200\234REP/REPE/REPZ /REPNE/REPNZ-Repeat String Operation Prefix\342\200\235 in this chapter for a description of the REP prefix."
    flags_affected {
      content: "None."
    }
  }
  instruction_groups {
    name: "CALL"
    short_description: "Call Procedure"
    description: "Saves procedure linking information on the stack and branches to the called procedure specified using the target operand. The target operand specifies the address of the first instruction in the called procedure. The operand can be an im mediate value, a general-purpose register, or a memory location.\nThis instruction can be used to execute four types of calls:\n\342\200\242\tNear Call - A call to a procedure in the current code segment (the segment currently pointed to by the CS register), sometimes referred to as an intra-segment call.\n\342\200\242\tFar Call - A call to a procedure located in a different segment than the current code segment, sometimes referred to as an inter-segment call.\n\342\200\242\tInter-privilege-level far call\n- A far call to a procedure in a segment at a different privilege level than that of the currently executing program or procedure.\n\342\200\242\tTask switch\t-\tA call to a procedure located in a different task.\nThe latter two call types (inter-privilege-level call and task switch) can only be executed in protected mode. See \342\200\234Calling Procedures Using Call and RET\342\200\235 in Chapter 6 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1, for additional information on near, far, and inter-privilege-level calls. See Chapter 7, \342\200\234Task Management,\342\200\235 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3A, for information on performing task switches with the CALL instruction.\nNear Call. When executing a near call, the processor pushes the value of the EIP register (which contains the offset of the instruction following the CALL instruction) on the stack (for use later as a return-instruction pointer). The processor then branches to the address in the current code segment specified by the target operand. The target operand specifies either an absolute offset in the code segment (an offset from the base of the code segment) or a relative offset (a signed displacement relative to the current value of the instruction pointer in the EIP register; this value points to the instruction following the CALL instruction). The CS register is not changed on near calls.\nFor a near call absolute, an absolute offset is specified indirectly in a general-purpose register or a memory location (r/m16, r/m32, or r/m64). The operand-size attribute determines the size of the target operand (16, 32 or 64 bits). When in 64-bit mode, the operand size for near call (and all near branches) is forced to 64-bits. Absolute offsets are loaded directly into the EIP(RIP) register. If the operand size attribute is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits. When accessing an absolute offset indirectly using the stack pointer [ESP] as the base register, the base value used is the value of the ESP before the instruction executes.\nA relative offset (rel16 or rel32) is generally specified as a label in assembly code. But at the machine code level, it is encoded as a signed, 16- or 32-bit im\nmediate value. This value is added to the value in the EIP(RIP) register. In 64-bit mode the relative offset is always a 32-bit im\nmediate value which is sign extended to 64-bits before it is added to the value in the RIP register for the target calculation. As with absolute offsets, the operand-size attribute determines the size of the target operand (16, 32, or 64 bits). In 64-bit mode the target operand will always be 64- bits because the operand size is forced to 64-bits for near branches.\nFar Calls in Real-Address or Virtual-8086 Mode. When executing a far call in real- address or virtual-8086 mode, the processor pushes the current value of both the CS and EIP registers on the stack for use as a return-instruction pointer. The processor then performs a \342\200\234far branch\342\200\235 to the code segment and offset specified with the target operand for the called procedure. The target operand specifies an absolute far address either directly with a pointer (ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 or m16:32). With the pointer method, the segment and offset of the called procedure is encoded in the instruction using a 4-byte (16-bit operand size) or 6- byte (32-bit operand size) far address im\nmediate. With the indirect method, the target operand specifies a memory location that contains a 4-byte (16-bit operand size) or 6-byte (32-bit operand size) far address. The operand-size attribute determines the size of the offset (16 or 32 bits) in the far address. The far address is loaded directly into the CS and EIP registers. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared.\nFar Calls in Protected Mode. When the processor is operating in protected mode, the CALL instruction can be used to perform the following types of far calls:\n\342\200\242\tFar call to the same privilege level\n\342\200\242\tFar call to a different privilege level (inter-privilege level call)\n\342\200\242\tTask switch (far call to another task)\nIn protected mode, the processor always uses the segment selector part of the far address to access the corresponding descriptor in the GDT or LDT. The descriptor type (code segment, call gate, task gate, or TSS) and access rights determine the type of call operation to be performed.\nIf the selected descriptor is for a code segment, a far call to a code segment at the same privilege level is performed. (If the selected code segment is at a different privilege level and the code segment is non-conforming, a general-protection exception is generated.) A far call to the same privilege level in protected mode is very similar to one carried out in real-address or virtual-8086 mode. The target operand specifies an absolute far address either directly with a pointer (ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 or m16:32). The operand- size attribute determines the size of the offset (16 or 32 bits) in the far address. The new code segment selector and its descriptor are loaded into CS register; the offset from the instruction is loaded into the EIP register.\nA call gate (described in the next paragraph) can also be used to perform a far call to a code segment at the same privilege level. Using this mechanism provides an extra level of indirection and is the preferred method of making calls between 16-bit and 32-bit code segments.\nWhen executing an inter-privilege-level far call, the code segment for the procedure being called must be accessed through a call gate. The segment selector specified by the target operand identifies the call gate. The target operand can specify the call gate segment selector either directly with a pointer (ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 or m16:32). The processor obtains the segment selector for the new code segment and the new instruction pointer (offset) from the call gate descriptor. (The offset from the target operand is ignored when a call gate is used.)\nOn inter-privilege-level calls, the processor switches to the stack for the privilege level of the called procedure. The segment selector for the new stack segment is specified in the TSS for the currently running task. The branch to the new code segment occurs after the stack switch. (Note that when using a call gate to perform a far call to a segment at the same privilege level, no stack switch occurs.) On the new stack, the processor pushes the segment selector and stack pointer for the calling procedure\342\200\231s stack, an optional set of parameters from the calling procedures stack, and the segment selector and instruction pointer for the calling procedure\342\200\231s code segment. (A value in the call gate descriptor determines how many parameters to copy to the new stack.) Finally, the processor branches to the address of the procedure being called within the new code segment.\nExecuting a task switch with the CALL instruction is similar to executing a call through a call gate. The target operand specifies the segment selector of the task gate for the new task activated by the switch (the offset in the target operand is ignored). The task gate in turn points to the TSS for the new task, which contains the segment selectors for the task\342\200\231s code and stack segments. Note that the TSS also contains the EIP value for the next instruction that was to be executed before the calling task was suspended. This instruction pointer value is loaded into the EIP register to re-start the calling task.\nThe CALL instruction can also specify the segment selector of the TSS directly, which eliminates the indirection of the task gate. See Chapter 7, \342\200\234Task Management,\342\200\235 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3A, for information on the mechanics of a task switch.\nWhen you execute at task switch with a CALL instruction, the nested task flag (NT) is set in the EFLAGS register and the new TSS\342\200\231s previous task link field is loaded with the old task\342\200\231s TSS selector. Code is expected to suspend this nested task by executing an IRET instruction which, because the NT flag is set, automatically uses the previous task link to return to the calling task. (See \342\200\234Task Linking\342\200\235 in Chapter 7 of the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3A, for information on nested tasks.) Switching tasks with the CALL instruction differs in this regard from JMP instruction. JMP does not set the NT flag and therefore does not expect an IRET instruction to suspend the task.\nMixing 16-Bit and 32-Bit Calls. When making far calls between 16-bit and 32-bit code segments, use a call gate. If the far call is from a 32-bit code segment to a 16-bit code segment, the call should be made from the first 64 KBytes of the 32-bit code segment. This is because the operand-size attribute of the instruction is set to 16, so only a 16-bit return address offset can be saved. Also, the call should be made using a 16-bit call gate so that 16-bit values can be pushed on the stack. See Chapter 21, \342\200\234Mixing 16-Bit and 32-Bit Code,\342\200\235 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 3B, for more information.\nFar Calls in Compatibility Mode. When the processor is operating in compatibility mode, the CALL instruction can be used to perform the following types of far calls:\n\342\200\242\tFar call to the same privilege level, remaining in compatibility mode\n\342\200\242\tFar call to the same privilege level, transitioning to 64-bit mode\n\342\200\242\tFar call to a different privilege level (inter-privilege level call), transitioning to 64-bit mode\nNote that a CALL instruction can not be used to cause a task switch in compatibility mode since task switches are not supported in IA-32e mode.\nIn compatibility mode, the processor always uses the segment selector part of the far address to access the corresponding descriptor in the GDT or LDT. The descriptor type (code segment, call gate) and access rights determine the type of call operation to be performed.\nIf the selected descriptor is for a code segment, a far call to a code segment at the same privilege level is performed. (If the selected code segment is at a different privilege level and the code segment is non-conforming, a general-protection exception is generated.) A far call to the same privilege level in compatibility mode is very similar to one carried out in protected mode. The target operand specifies an absolute far address either directly with a pointer (ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 or m16:32). The operand-size attribute determines the size of the offset (16 or 32 bits) in the far address. The new code segment selector and its descriptor are loaded into CS register and the offset from the instruction is loaded into the EIP register. The difference is that 64-bit mode may be entered. This specified by the L bit in the new code segment descriptor.\nNote that a 64-bit call gate (described in the next paragraph) can also be used to perform a far call to a code segment at the same privilege level. However, using this mechanism requires that the target code segment descriptor have the L bit set, causing an entry to 64-bit mode.\nWhen executing an inter-privilege-level far call, the code segment for the procedure being called must be accessed through a 64-bit call gate. The segment selector specified by the target operand identifies the call gate. The target\noperand can specify the call gate segment selector either directly with a pointer (ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 or m16:32). The processor obtains the segment selector for the new code segment and the new instruction pointer (offset) from the 16-byte call gate descriptor. (The offset from the target operand is ignored when a call gate is used.)\nOn inter-privilege-level calls, the processor switches to the stack for the privilege level of the called procedure. The segment selector for the new stack segment is set to NULL. The new stack pointer is specified in the TSS for the currently running task. The branch to the new code segment occurs after the stack switch. (Note that when using a call gate to perform a far call to a segment at the same privilege level, an implicit stack switch occurs as a result of entering 64-bit mode. The SS selector is unchanged, but stack segment accesses use a segment base of 0x0, the limit is ignored, and the default stack size is 64-bits. The full value of RSP is used for the offset, of which the upper 32-bits are undefined.) On the new stack, the processor pushes the segment selector and stack pointer for the calling procedure\342\200\231s stack and the segment selector and instruction pointer for the calling procedure\342\200\231s code segment. (Parameter copy is not supported in IA-32e mode.) Finally, the processor branches to the address of the procedure being called within the new code segment.\nNear/(Far) Calls in 64-bit Mode. When the processor is operating in 64-bit mode, the CALL instruction can be used to perform the following types of far calls:\n\342\200\242\tFar call to the same privilege level, transitioning to compatibility mode\n\342\200\242\tFar call to the same privilege level, remaining in 64-bit mode\n\342\200\242\tFar call to a different privilege level (inter-privilege level call), remaining in 64-bit mode\nNote that in this mode the CALL instruction can not be used to cause a task switch in 64-bit mode since task switches are not supported in IA-32e mode.\nIn 64-bit mode, the processor always uses the segment selector part of the far address to access the corresponding descriptor in the GDT or LDT. The descriptor type (code segment, call gate) and access rights determine the type of call operation to be performed.\nIf the selected descriptor is for a code segment, a far call to a code segment at the same privilege level is performed. (If the selected code segment is at a different privilege level and the code segment is non-conforming, a general-protection exception is generated.) A far call to the same privilege level in 64-bit mode is very similar to one carried out in compatibility mode. The target operand specifies an absolute far address indirectly with a memory location (m16:16, m16:32 or m16:64). The form of CALL with a direct specification of absolute far address is not defined in 64-bit mode. The operand-size attribute determines the size of the offset (16, 32, or 64 bits) in the far address. The new code segment selector and its descriptor are loaded into the CS register; the offset from the instruction is loaded into the EIP register. The new code segment may specify entry either into compatibility or 64-bit mode, based on the L bit value.\nA 64-bit call gate (described in the next paragraph) can also be used to perform a far call to a code segment at the same privilege level. However, using this mechanism requires that the target code segment descriptor have the L bit set.\nWhen executing an inter-privilege-level far call, the code segment for the procedure being called must be accessed through a 64-bit call gate. The segment selector specified by the target operand identifies the call gate. The target operand can only specify the call gate segment selector indirectly with a memory location (m16:16, m16:32 or m16:64). The processor obtains the segment selector for the new code segment and the new instruction pointer (offset) from the 16-byte call gate descriptor. (The offset from the target operand is ignored when a call gate is used.)\nOn inter-privilege-level calls, the processor switches to the stack for the privilege level of the called procedure. The segment selector for the new stack segment is set to NULL. The new stack pointer is specified in the TSS for the currently running task. The branch to the new code segment occurs after the stack switch.\nNote that when using a call gate to perform a far call to a segment at the same privilege level, an implicit stack switch occurs as a result of entering 64-bit mode. The SS selector is unchanged, but stack segment accesses use a segment base of 0x0, the limit is ignored, and the default stack size is 64-bits. (The full value of RSP is used for the offset.) On the new stack, the processor pushes the segment selector and stack pointer for the calling procedure\342\200\231s stack and the segment selector and instruction pointer for the calling procedure\342\200\231s code segment. (Parameter copy is not supported in IA-32e mode.) Finally, the processor branches to the address of the procedure being called within the new code segment.\nRefer to Chapter 6, \342\200\234Procedure Calls, Interrupts, and Exceptions\342\200\235 and Chapter 18, \342\200\234Control-Flow Enforcement Technology (CET)\342\200\235 in the Intel\302\256 64 and IA-32 Architectures Software Developer\342\200\231s Manual, Volume 1 for CET details.\nInstruction ordering. Instructions following a far call may be fetched from memory before earlier instructions complete execution, but they will not execute (even speculatively) until all instructions prior to the far call have completed execution (the later instructions may execute before data stored by the earlier instructions have become globally visible).\nCertain situations may lead to the next sequential instruction after a near indirect CALL being speculatively executed. If software needs to prevent this (e.g., in order to prevent a speculative execution side channel), then an INT3 or LFENCE instruction opcode can be placed after the near indirect CALL in order to block speculative execution."
    flags_affected {
      content: "All flags are affected if a task switch occurs; no flags are affected if a task switch does not occur."
    }
  }
  instruction_groups {
    name: "INC"
    short_description: "Increment by 1"
    description: "Adds 1 to the destination operand, while preserving the state of the CF flag. The destination operand can be a register or a memory location. This instruction allows a loop counter to be updated without disturbing the CF flag.\n(Use a ADD instruction with an im mediate operand of 1 to perform an increment operation that does updates the\nCF flag.)\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.\nIn 64-bit mode, INC r16 and INC r32 are not encodable (because opcodes 40H through 47H are REX prefixes).\nOtherwise, the instruction\342\200\231s 64-bit mode default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits."
    flags_affected {
      content: "The CF flag is not affected. The OF, SF, ZF, AF, and PF flags are set according to the result."
    }
  }
}
register_set {
  register_groups {
    name: "RAX group"
    description: "The group of registers aliased with RAX"
    registers {
      name: "RAX"
      position_in_group {
        msb: 63
      }
      register_class: GENERAL_PURPOSE_REGISTER_64_BIT
    }
    registers {
      name: "EAX"
      position_in_group {
        msb: 31
      }
      register_class: GENERAL_PURPOSE_REGISTER_32_BIT
    }
    registers {
      name: "AX"
      position_in_group {
        msb: 15
      }
      register_class: GENERAL_PURPOSE_REGISTER_16_BIT
    }
    registers {
      name: "AL"
      position_in_group {
        msb: 7
      }
      register_class: GENERAL_PURPOSE_REGISTER_8_BIT
    }
    registers {
      name: "AH"
      binary_encoding: 4
      position_in_group {
        msb: 15
        lsb: 8
      }
      register_class: GENERAL_PURPOSE_REGISTER_8_BIT
    }
  }
  register_groups {
    name: "RCX group"
    description: "The group of registers aliased with RCX"
    registers {
      name: "RCX"
      binary_encoding: 1
      position_in_group {
        msb: 63
      }
      register_class: GENERAL_PURPOSE_REGISTER_64_BIT
    }
    registers {
      name: "ECX"
      binary_encoding: 1
      position_in_group {
        msb: 31
      }
      register_class: GENERAL_PURPOSE_REGISTER_32_BIT
    }
    registers {
      name: "CX"
      binary_encoding: 1
      position_in_group {
        msb: 15
      }
      register_class: GENERAL_PURPOSE_REGISTER_16_BIT
    }
    registers {
      name: "CL"
      binary_encoding: 1
      position_in_group {
        msb: 7
      }
      register_class: GENERAL_PURPOSE_REGISTER_8_BIT
    }
    registers {
      name: "CH"
      binary_encoding: 5
      position_in_group {
        msb: 15
        lsb: 8
      }
      register_class: GENERAL_PURPOSE_REGISTER_8_BIT
    }
  }
  register_groups {
    name: "RDX group"
    description: "The group of registers aliased with RDX"
    registers {
      name: "RDX"
      binary_encoding: 2
      position_in_group {
        msb: 63
      }
      register_class: GENERAL_PURPOSE_REGISTER_64_BIT
    }
    registers {
      name: "EDX"
      binary_encoding: 2
      position_in_group {
        msb: 31
      }
      register_class: GENERAL_PURPOSE_REGISTER_32_BIT
    }
    registers {
      name: "DX"
      binary_encoding: 2
      position_in_group {
        msb: 15
      }
      register_class: GENERAL_PURPOSE_REGISTER_16_BIT
    }
    registers {
      name: "DL"
      binary_encoding: 2
      position_in_group {
        msb: 7
      }
      register_class: GENERAL_PURPOSE_REGISTER_8_BIT
    }
    registers {
      name: "DH"
      binary_encoding: 6
      position_in_group {
        msb: 15
        lsb: 8
      }
      register_class: GENERAL_PURPOSE_REGISTER_8_BIT
    }
  }
  register_groups {
    name: "RBX group"
    description: "The group of registers aliased with RBX"
    registers {
      name: "RBX"
      binary_encoding: 3
      position_in_group {
        msb: 63
      }
      register_class: GENERAL_PURPOSE_REGISTER_64_BIT
    }
    registers {
      name: "EBX"
      binary_encoding: 3
      position_in_group {
        msb: 31
      }
      register_class: GENERAL_PURPOSE_REGISTER_32_BIT
    }
    registers {
      name: "BX"
      binary_encoding: 3
      position_in_group {
        msb: 15
      }
      register_class: GENERAL_PURPOSE_REGISTER_16_BIT
    }
    registers {
      name: "BL"
      binary_encoding: 3
      position_in_group {
        msb: 7
      }
      register_class: GENERAL_PURPOSE_REGISTER_8_BIT
    }
    registers {
      name: "BH"
      binary_encoding: 7
      position_in_group {
        msb: 15
        lsb: 8
      }
      register_class: GENERAL_PURPOSE_REGISTER_8_BIT
    }
  }
  register_groups {
    name: "RBP group"
    description: "The group of registers aliased with RBP"
    registers {
      name: "RBP"
      binary_encoding: 4
      position_in_group {
        msb: 63
      }
      register_class: GENERAL_PURPOSE_REGISTER_64_BIT
    }
    registers {
      name: "EBP"
      binary_encoding: 4
      position_in_group {
        msb: 31
      }
      register_class: GENERAL_PURPOSE_REGISTER_32_BIT
    }
    registers {
      name: "BP"
      binary_encoding: 4
      position_in_group {
        msb: 15
      }
      register_class: GENERAL_PURPOSE_REGISTER_16_BIT
    }
    registers {
      name: "BPL"
      binary_encoding: 4
      position_in_group {
        msb: 7
      }
      register_class: GENERAL_PURPOSE_REGISTER_8_BIT
    }
  }
  register_groups {
    name: "RSP group"
    description: "The group of registers aliased with RSP"
    registers {
      name: "RSP"
      binary_encoding: 5
      position_in_group {
        msb: 63
      }
      register_class: GENERAL_PURPOSE_REGISTER_64_BIT
    }
    registers {
      name: "ESP"
      binary_encoding: 5
      position_in_group {
        msb: 31
      }
      register_class: GENERAL_PURPOSE_REGISTER_32_BIT
    }
    registers {
      name: "SP"
      binary_encoding: 5
      position_in_group {
        msb: 15
      }
      register_class: GENERAL_PURPOSE_REGISTER_16_BIT
    }
    registers {
      name: "SPL"
      binary_encoding: 5
      position_in_group {
        msb: 7
      }
      register_class: GENERAL_PURPOSE_REGISTER_8_BIT
    }
  }
  register_groups {
    name: "RSI group"
    description: "The group of registers aliased with RSI"
    registers {
      name: "RSI"
      binary_encoding: 6
      position_in_group {
        msb: 63
      }
      register_class: GENERAL_PURPOSE_REGISTER_64_BIT
    }
    registers {
      name: "ESI"
      binary_encoding: 6
      position_in_group {
        msb: 31
      }
      register_class: GENERAL_PURPOSE_REGISTER_32_BIT
    }
    registers {
      name: "SI"
      binary_encoding: 6
      position_in_group {
        msb: 15
      }
      register_class: GENERAL_PURPOSE_REGISTER_16_BIT
    }
    registers {
      name: "SIL"
      binary_encoding: 6
      position_in_group {
        msb: 7
      }
      register_class: GENERAL_PURPOSE_REGISTER_8_BIT
    }
  }
  register_groups {
    name: "RDI group"
    description: "The group of registers aliased with RDI"
    registers {
      name: "RDI"
      binary_encoding: 7
      position_in_group {
        msb: 63
      }
      register_class: GENERAL_PURPOSE_REGISTER_64_BIT
    }
    registers {
      name: "EDI"
      binary_encoding: 7
      position_in_group {
        msb: 31
      }
      register_class: GENERAL_PURPOSE_REGISTER_32_BIT
    }
    registers {
      name: "DI"
      binary_encoding: 7
      position_in_group {
        msb: 15
      }
      register_class: GENERAL_PURPOSE_REGISTER_16_BIT
    }
    registers {
      name: "DIL"
      binary_encoding: 7
      position_in_group {
        msb: 7
      }
      register_class: GENERAL_PURPOSE_REGISTER_8_BIT
    }
  }
  register_groups {
    name: "R8 group"
    description: "The group of registers aliased with R8"
    registers {
      name: "R8"
      binary_encoding: 8
      position_in_group {
        msb: 63
      }
      register_class: GENERAL_PURPOSE_REGISTER_64_BIT
    }
    registers {
      name: "R8D"
      binary_encoding: 8
      position_in_group {
        msb: 31
      }
      register_class: GENERAL_PURPOSE_REGISTER_32_BIT
    }
    registers {
      name: "R8W"
      binary_encoding: 8
      position_in_group {
        msb: 15
      }
      register_class: GENERAL_PURPOSE_REGISTER_16_BIT
    }
    registers {
      name: "R8B"
      binary_encoding: 8
      position_in_group {
        msb: 7
      }
      register_class: GENERAL_PURPOSE_REGISTER_8_BIT
    }
  }
  register_groups {
    name: "R9 group"
    description: "The group of registers aliased with R9"
    registers {
      name: "R9"
      binary_encoding: 9
      position_in_group {
        msb: 63
      }
      register_class: GENERAL_PURPOSE_REGISTER_64_BIT
    }
    registers {
      name: "R9D"
      binary_encoding: 9
      position_in_group {
        msb: 31
      }
      register_class: GENERAL_PURPOSE_REGISTER_32_BIT
    }
    registers {
      name: "R9W"
      binary_encoding: 9
      position_in_group {
        msb: 15
      }
      register_class: GENERAL_PURPOSE_REGISTER_16_BIT
    }
    registers {
      name: "R9B"
      binary_encoding: 9
      position_in_group {
        msb: 7
      }
      register_class: GENERAL_PURPOSE_REGISTER_8_BIT
    }
  }
  register_groups {
    name: "R10 group"
    description: "The group of registers aliased with R10"
    registers {
      name: "R10"
      binary_encoding: 10
      position_in_group {
        msb: 63
      }
      register_class: GENERAL_PURPOSE_REGISTER_64_BIT
    }
    registers {
      name: "R10D"
      binary_encoding: 10
      position_in_group {
        msb: 31
      }
      register_class: GENERAL_PURPOSE_REGISTER_32_BIT
    }
    registers {
      name: "R10W"
      binary_encoding: 10
      position_in_group {
        msb: 15
      }
      register_class: GENERAL_PURPOSE_REGISTER_16_BIT
    }
    registers {
      name: "R10B"
      binary_encoding: 10
      position_in_group {
        msb: 7
      }
      register_class: GENERAL_PURPOSE_REGISTER_8_BIT
    }
  }
  register_groups {
    name: "R11 group"
    description: "The group of registers aliased with R11"
    registers {
      name: "R11"
      binary_encoding: 11
      position_in_group {
        msb: 63
      }
      register_class: GENERAL_PURPOSE_REGISTER_64_BIT
    }
    registers {
      name: "R11D"
      binary_encoding: 11
      position_in_group {
        msb: 31
      }
      register_class: GENERAL_PURPOSE_REGISTER_32_BIT
    }
    registers {
      name: "R11W"
      binary_encoding: 11
      position_in_group {
        msb: 15
      }
      register_class: GENERAL_PURPOSE_REGISTER_16_BIT
    }
    registers {
      name: "R11B"
      binary_encoding: 11
      position_in_group {
        msb: 7
      }
      register_class: GENERAL_PURPOSE_REGISTER_8_BIT
    }
  }
  register_groups {
    name: "R12 group"
    description: "The group of registers aliased with R12"
    registers {
      name: "R12"
      binary_encoding: 12
      position_in_group {
        msb: 63
      }
      register_class: GENERAL_PURPOSE_REGISTER_64_BIT
    }
    registers {
      name: "R12D"
      binary_encoding: 12
      position_in_group {
        msb: 31
      }
      register_class: GENERAL_PURPOSE_REGISTER_32_BIT
    }
    registers {
      name: "R12W"
      binary_encoding: 12
      position_in_group {
        msb: 15
      }
      register_class: GENERAL_PURPOSE_REGISTER_16_BIT
    }
    registers {
      name: "R12B"
      binary_encoding: 12
      position_in_group {
        msb: 7
      }
      register_class: GENERAL_PURPOSE_REGISTER_8_BIT
    }
  }
  register_groups {
    name: "R13 group"
    description: "The group of registers aliased with R13"
    registers {
      name: "R13"
      binary_encoding: 13
      position_in_group {
        msb: 63
      }
      register_class: GENERAL_PURPOSE_REGISTER_64_BIT
    }
    registers {
      name: "R13D"
      binary_encoding: 13
      position_in_group {
        msb: 31
      }
      register_class: GENERAL_PURPOSE_REGISTER_32_BIT
    }
    registers {
      name: "R13W"
      binary_encoding: 13
      position_in_group {
        msb: 15
      }
      register_class: GENERAL_PURPOSE_REGISTER_16_BIT
    }
    registers {
      name: "R13B"
      binary_encoding: 13
      position_in_group {
        msb: 7
      }
      register_class: GENERAL_PURPOSE_REGISTER_8_BIT
    }
  }
  register_groups {
    name: "R14 group"
    description: "The group of registers aliased with R14"
    registers {
      name: "R14"
      binary_encoding: 14
      position_in_group {
        msb: 63
      }
      register_class: GENERAL_PURPOSE_REGISTER_64_BIT
    }
    registers {
      name: "R14D"
      binary_encoding: 14
      position_in_group {
        msb: 31
      }
      register_class: GENERAL_PURPOSE_REGISTER_32_BIT
    }
    registers {
      name: "R14W"
      binary_encoding: 14
      position_in_group {
        msb: 15
      }
      register_class: GENERAL_PURPOSE_REGISTER_16_BIT
    }
    registers {
      name: "R14B"
      binary_encoding: 14
      position_in_group {
        msb: 7
      }
      register_class: GENERAL_PURPOSE_REGISTER_8_BIT
    }
  }
  register_groups {
    name: "R15 group"
    description: "The group of registers aliased with R15"
    registers {
      name: "R15"
      binary_encoding: 15
      position_in_group {
        msb: 63
      }
      register_class: GENERAL_PURPOSE_REGISTER_64_BIT
    }
    registers {
      name: "R15D"
      binary_encoding: 15
      position_in_group {
        msb: 31
      }
      register_class: GENERAL_PURPOSE_REGISTER_32_BIT
    }
    registers {
      name: "R15W"
      binary_encoding: 15
      position_in_group {
        msb: 15
      }
      register_class: GENERAL_PURPOSE_REGISTER_16_BIT
    }
    registers {
      name: "R15B"
      binary_encoding: 15
      position_in_group {
        msb: 7
      }
      register_class: GENERAL_PURPOSE_REGISTER_8_BIT
    }
  }
  register_groups {
    name: "CR0 group"
    description: "The group of registers aliased with CR0"
    registers {
      name: "CR0"
      position_in_group {
        msb: 63
      }
      register_class: SPECIAL_REGISTER_CONTROL
    }
  }
  register_groups {
    name: "CR1 group"
    description: "The group of registers aliased with CR1"
    registers {
      name: "CR1"
      binary_encoding: 1
      position_in_group {
        msb: 63
      }
      register_class: SPECIAL_REGISTER_CONTROL
    }
  }
  register_groups {
    name: "CR2 group"
    description: "The group of registers aliased with CR2"
    registers {
      name: "CR2"
      binary_encoding: 2
      position_in_group {
        msb: 63
      }
      register_class: SPECIAL_REGISTER_CONTROL
    }
  }
  register_groups {
    name: "CR3 group"
    description: "The group of registers aliased with CR3"
    registers {
      name: "CR3"
      binary_encoding: 3
      position_in_group {
        msb: 63
      }
      register_class: SPECIAL_REGISTER_CONTROL
    }
  }
  register_groups {
    name: "CR4 group"
    description: "The group of registers aliased with CR4"
    registers {
      name: "CR4"
      binary_encoding: 4
      position_in_group {
        msb: 63
      }
      register_class: SPECIAL_REGISTER_CONTROL
    }
  }
  register_groups {
    name: "CR5 group"
    description: "The group of registers aliased with CR5"
    registers {
      name: "CR5"
      binary_encoding: 5
      position_in_group {
        msb: 63
      }
      register_class: SPECIAL_REGISTER_CONTROL
    }
  }
  register_groups {
    name: "CR6 group"
    description: "The group of registers aliased with CR6"
    registers {
      name: "CR6"
      binary_encoding: 6
      position_in_group {
        msb: 63
      }
      register_class: SPECIAL_REGISTER_CONTROL
    }
  }
  register_groups {
    name: "CR7 group"
    description: "The group of registers aliased with CR7"
    registers {
      name: "CR7"
      binary_encoding: 7
      position_in_group {
        msb: 63
      }
      register_class: SPECIAL_REGISTER_CONTROL
    }
  }
  register_groups {
    name: "CR8 group"
    description: "The group of registers aliased with CR8"
    registers {
      name: "CR8"
      binary_encoding: 8
      position_in_group {
        msb: 63
      }
      register_class: SPECIAL_REGISTER_CONTROL
    }
  }
  register_groups {
    name: "DR0 group"
    description: "The group of registers aliased with DR0"
    registers {
      name: "DR0"
      position_in_group {
        msb: 63
      }
      register_class: SPECIAL_REGISTER_DEBUG
    }
  }
  register_groups {
    name: "DR1 group"
    description: "The group of registers aliased with DR1"
    registers {
      name: "DR1"
      binary_encoding: 1
      position_in_group {
        msb: 63
      }
      register_class: SPECIAL_REGISTER_DEBUG
    }
  }
  register_groups {
    name: "DR2 group"
    description: "The group of registers aliased with DR2"
    registers {
      name: "DR2"
      binary_encoding: 2
      position_in_group {
        msb: 63
      }
      register_class: SPECIAL_REGISTER_DEBUG
    }
  }
  register_groups {
    name: "DR3 group"
    description: "The group of registers aliased with DR3"
    registers {
      name: "DR3"
      binary_encoding: 3
      position_in_group {
        msb: 63
      }
      register_class: SPECIAL_REGISTER_DEBUG
    }
  }
  register_groups {
    name: "DR4 group"
    description: "The group of registers aliased with DR4"
    registers {
      name: "DR4"
      binary_encoding: 4
      position_in_group {
        msb: 63
      }
      register_class: SPECIAL_REGISTER_DEBUG
    }
  }
  register_groups {
    name: "DR5 group"
    description: "The group of registers aliased with DR5"
    registers {
      name: "DR5"
      binary_encoding: 5
      position_in_group {
        msb: 63
      }
      register_class: SPECIAL_REGISTER_DEBUG
    }
  }
  register_groups {
    name: "DR6 group"
    description: "The group of registers aliased with DR6"
    registers {
      name: "DR6"
      binary_encoding: 6
      position_in_group {
        msb: 63
      }
      register_class: SPECIAL_REGISTER_DEBUG
    }
  }
  register_groups {
    name: "DR7 group"
    description: "The group of registers aliased with DR7"
    registers {
      name: "DR7"
      binary_encoding: 7
      position_in_group {
        msb: 63
      }
      register_class: SPECIAL_REGISTER_DEBUG
    }
  }
  register_groups {
    name: "DR8 group"
    description: "The group of registers aliased with DR8"
    registers {
      name: "DR8"
      binary_encoding: 8
      position_in_group {
        msb: 63
      }
      register_class: SPECIAL_REGISTER_DEBUG
    }
  }
  register_groups {
    name: "RFLAGS group"
    description: "The flags registers"
    registers {
      name: "EFLAGS"
      implicit_encoding_only: true
      position_in_group {
        msb: 31
      }
      subfields {
        bit_range {
        }
        name: "CF"
        description: "The carry flag."
      }
      subfields {
        bit_range {
          msb: 1
          lsb: 1
        }
        name: "reserved"
      }
      subfields {
        bit_range {
          msb: 2
          lsb: 2
        }
        name: "PF"
        description: "The parity flag."
      }
      subfields {
        bit_range {
          msb: 3
          lsb: 3
        }
        name: "reserved"
      }
      subfields {
        bit_range {
          msb: 4
          lsb: 4
        }
        name: "AF"
        description: "The auxiliary carry flag."
      }
      subfields {
        bit_range {
          msb: 5
          lsb: 5
        }
        name: "reserved"
      }
      subfields {
        bit_range {
          msb: 6
          lsb: 6
        }
        name: "ZF"
        description: "The zero flag."
      }
      subfields {
        bit_range {
          msb: 7
          lsb: 7
        }
        name: "SF"
        description: "The sign flag."
      }
      subfields {
        bit_range {
          msb: 8
          lsb: 8
        }
        name: "TF"
        description: "The trap flag."
      }
      subfields {
        bit_range {
          msb: 9
          lsb: 9
        }
        name: "IF"
        description: "The interrupt enable flag."
      }
      subfields {
        bit_range {
          msb: 10
          lsb: 10
        }
        name: "DF"
        description: "The direction flag."
      }
      subfields {
        bit_range {
          msb: 11
          lsb: 11
        }
        name: "OF"
        description: "The overflow flag."
      }
      subfields {
        bit_range {
          msb: 13
          lsb: 12
        }
        name: "IOPL"
        description: "The IO privilege level."
      }
      subfields {
        bit_range {
          msb: 14
          lsb: 14
        }
        name: "NT"
        description: "The nested task."
      }
      subfields {
        bit_range {
          msb: 15
          lsb: 15
        }
        name: "reserved"
      }
      subfields {
        bit_range {
          msb: 16
          lsb: 16
        }
        name: "RF"
        description: "The resume flag."
      }
      subfields {
        bit_range {
          msb: 17
          lsb: 17
        }
        name: "VM"
        description: "The virtual-8086 mode."
      }
      subfields {
        bit_range {
          msb: 18
          lsb: 18
        }
        name: "AC"
        description: "The alignment check/access control."
      }
      subfields {
        bit_range {
          msb: 19
          lsb: 19
        }
        name: "VIF"
        description: "The virtual interrupt flag."
      }
      subfields {
        bit_range {
          msb: 20
          lsb: 20
        }
        name: "VIP"
        description: "Virtual interrupt pending."
      }
      subfields {
        bit_range {
          msb: 21
          lsb: 21
        }
        name: "ID"
        description: "The ID flag."
      }
      subfields {
        bit_range {
          msb: 31
          lsb: 22
        }
        name: "reserved"
      }
      register_class: SPECIAL_REGISTER_FLAG
    }
    registers {
      name: "RFLAGS"
      implicit_encoding_only: true
      position_in_group {
        msb: 63
      }
      subfields {
        bit_range {
        }
        name: "CF"
        description: "The carry flag."
      }
      subfields {
        bit_range {
          msb: 1
          lsb: 1
        }
        name: "reserved"
      }
      subfields {
        bit_range {
          msb: 2
          lsb: 2
        }
        name: "PF"
        description: "The parity flag."
      }
      subfields {
        bit_range {
          msb: 3
          lsb: 3
        }
        name: "reserved"
      }
      subfields {
        bit_range {
          msb: 4
          lsb: 4
        }
        name: "AF"
        description: "The auxiliary carry flag."
      }
      subfields {
        bit_range {
          msb: 5
          lsb: 5
        }
        name: "reserved"
      }
      subfields {
        bit_range {
          msb: 6
          lsb: 6
        }
        name: "ZF"
        description: "The zero flag."
      }
      subfields {
        bit_range {
          msb: 7
          lsb: 7
        }
        name: "SF"
        description: "The sign flag."
      }
      subfields {
        bit_range {
          msb: 8
          lsb: 8
        }
        name: "TF"
        description: "The trap flag."
      }
      subfields {
        bit_range {
          msb: 9
          lsb: 9
        }
        name: "IF"
        description: "The interrupt enable flag."
      }
      subfields {
        bit_range {
          msb: 10
          lsb: 10
        }
        name: "DF"
        description: "The direction flag."
      }
      subfields {
        bit_range {
          msb: 11
          lsb: 11
        }
        name: "OF"
        description: "The overflow flag."
      }
      subfields {
        bit_range {
          msb: 13
          lsb: 12
        }
        name: "IOPL"
        description: "The IO privilege level."
      }
      subfields {
        bit_range {
          msb: 14
          lsb: 14
        }
        name: "NT"
        description: "The nested task."
      }
      subfields {
        bit_range {
          msb: 15
          lsb: 15
        }
        name: "reserved"
      }
      subfields {
        bit_range {
          msb: 16
          lsb: 16
        }
        name: "RF"
        description: "The resume flag."
      }
      subfields {
        bit_range {
          msb: 17
          lsb: 17
        }
        name: "VM"
        description: "The virtual-8086 mode."
      }
      subfields {
        bit_range {
          msb: 18
          lsb: 18
        }
        name: "AC"
        description: "The alignment check/access control."
      }
      subfields {
        bit_range {
          msb: 19
          lsb: 19
        }
        name: "VIF"
        description: "The virtual interrupt flag."
      }
      subfields {
        bit_range {
          msb: 20
          lsb: 20
        }
        name: "VIP"
        description: "Virtual interrupt pending."
      }
      subfields {
        bit_range {
          msb: 21
          lsb: 21
        }
        name: "ID"
        description: "The ID flag."
      }
      subfields {
        bit_range {
          msb: 63
          lsb: 22
        }
        name: "reserved"
      }
      register_class: SPECIAL_REGISTER_FLAG
    }
  }
  register_groups {
    name: "ST0 group"
    description: "The group of registers aliased with ST0"
    registers {
      name: "ST0"
      position_in_group {
        msb: 79
      }
      feature_name: "FPU"
      register_class: FLOATING_POINT_STACK_REGISTER
    }
    registers {
      name: "MM0"
      position_in_group {
        msb: 63
      }
      feature_name: "MMX"
      register_class: MMX_STACK_REGISTER
    }
  }
  register_groups {
    name: "ST1 group"
    description: "The group of registers aliased with ST1"
    registers {
      name: "ST1"
      binary_encoding: 1
      position_in_group {
        msb: 79
      }
      feature_name: "FPU"
      register_class: FLOATING_POINT_STACK_REGISTER
    }
    registers {
      name: "MM1"
      binary_encoding: 1
      position_in_group {
        msb: 63
      }
      feature_name: "MMX"
      register_class: MMX_STACK_REGISTER
    }
  }
  register_groups {
    name: "ST2 group"
    description: "The group of registers aliased with ST2"
    registers {
      name: "ST2"
      binary_encoding: 2
      position_in_group {
        msb: 79
      }
      feature_name: "FPU"
      register_class: FLOATING_POINT_STACK_REGISTER
    }
    registers {
      name: "MM2"
      binary_encoding: 2
      position_in_group {
        msb: 63
      }
      feature_name: "MMX"
      register_class: MMX_STACK_REGISTER
    }
  }
  register_groups {
    name: "ST3 group"
    description: "The group of registers aliased with ST3"
    registers {
      name: "ST3"
      binary_encoding: 3
      position_in_group {
        msb: 79
      }
      feature_name: "FPU"
      register_class: FLOATING_POINT_STACK_REGISTER
    }
    registers {
      name: "MM3"
      binary_encoding: 3
      position_in_group {
        msb: 63
      }
      feature_name: "MMX"
      register_class: MMX_STACK_REGISTER
    }
  }
  register_groups {
    name: "ST4 group"
    description: "The group of registers aliased with ST4"
    registers {
      name: "ST4"
      binary_encoding: 4
      position_in_group {
        msb: 79
      }
      feature_name: "FPU"
      register_class: FLOATING_POINT_STACK_REGISTER
    }
    registers {
      name: "MM4"
      binary_encoding: 4
      position_in_group {
        msb: 63
      }
      feature_name: "MMX"
      register_class: MMX_STACK_REGISTER
    }
  }
  register_groups {
    name: "ST5 group"
    description: "The group of registers aliased with ST5"
    registers {
      name: "ST5"
      binary_encoding: 5
      position_in_group {
        msb: 79
      }
      feature_name: "FPU"
      register_class: FLOATING_POINT_STACK_REGISTER
    }
    registers {
      name: "MM5"
      binary_encoding: 5
      position_in_group {
        msb: 63
      }
      feature_name: "MMX"
      register_class: MMX_STACK_REGISTER
    }
  }
  register_groups {
    name: "ST6 group"
    description: "The group of registers aliased with ST6"
    registers {
      name: "ST6"
      binary_encoding: 6
      position_in_group {
        msb: 79
      }
      feature_name: "FPU"
      register_class: FLOATING_POINT_STACK_REGISTER
    }
    registers {
      name: "MM6"
      binary_encoding: 6
      position_in_group {
        msb: 63
      }
      feature_name: "MMX"
      register_class: MMX_STACK_REGISTER
    }
  }
  register_groups {
    name: "ST7 group"
    description: "The group of registers aliased with ST7"
    registers {
      name: "ST7"
      binary_encoding: 7
      position_in_group {
        msb: 79
      }
      feature_name: "FPU"
      register_class: FLOATING_POINT_STACK_REGISTER
    }
    registers {
      name: "MM7"
      binary_encoding: 7
      position_in_group {
        msb: 63
      }
      feature_name: "MMX"
      register_class: MMX_STACK_REGISTER
    }
  }
  register_groups {
    name: "FPU status word"
    description: "The x87 FPU status word."
    registers {
      name: "FPSW"
      implicit_encoding_only: true
      position_in_group {
        msb: 15
      }
      subfields {
        bit_range {
        }
        name: "IE"
        description: "Invalid Operation"
      }
      subfields {
        bit_range {
          msb: 1
          lsb: 1
        }
        name: "DE"
        description: "Denormalized Operand"
      }
      subfields {
        bit_range {
          msb: 2
          lsb: 2
        }
        name: "ZE"
        description: "Zero Divide"
      }
      subfields {
        bit_range {
          msb: 3
          lsb: 3
        }
        name: "OE"
        description: "Overflow"
      }
      subfields {
        bit_range {
          msb: 4
          lsb: 4
        }
        name: "UE"
        description: "Underflow"
      }
      subfields {
        bit_range {
          msb: 5
          lsb: 5
        }
        name: "PE"
        description: "Precision"
      }
      subfields {
        bit_range {
          msb: 6
          lsb: 6
        }
        name: "SF"
        description: "Stack Fault"
      }
      subfields {
        bit_range {
          msb: 7
          lsb: 7
        }
        name: "ES"
        description: "Exception Summary absl::Status"
      }
      subfields {
        bit_range {
          msb: 10
          lsb: 8
        }
        name: "C0-C2"
        description: "Condition Code 0-2"
      }
      subfields {
        bit_range {
          msb: 13
          lsb: 11
        }
        name: "TOP"
        description: "Top of Stack Pointer"
      }
      subfields {
        bit_range {
          msb: 14
          lsb: 14
        }
        name: "C3"
        description: "Condition Code 3"
      }
      subfields {
        bit_range {
          msb: 15
          lsb: 15
        }
        name: "B"
        description: "FPU Busy"
      }
      register_class: SPECIAL_REGISTER_FLAG
    }
  }
  register_groups {
    name: "FPU control word"
    description: "The x87 FPU control word."
    registers {
      name: "FPCW"
      implicit_encoding_only: true
      position_in_group {
        msb: 15
      }
      subfields {
        bit_range {
        }
        name: "IM"
        description: "Invalid Operation Mask"
      }
      subfields {
        bit_range {
          msb: 1
          lsb: 1
        }
        name: "DM"
        description: "Denormalized Operand Mask"
      }
      subfields {
        bit_range {
          msb: 2
          lsb: 2
        }
        name: "ZM"
        description: "Zero Divide Mask"
      }
      subfields {
        bit_range {
          msb: 3
          lsb: 3
        }
        name: "OM"
        description: "Overflow Mask"
      }
      subfields {
        bit_range {
          msb: 4
          lsb: 4
        }
        name: "UM"
        description: "Underflow Mask"
      }
      subfields {
        bit_range {
          msb: 5
          lsb: 5
        }
        name: "PM"
        description: "Precision Mask"
      }
      subfields {
        bit_range {
          msb: 7
          lsb: 6
        }
        name: "reserved"
      }
      subfields {
        bit_range {
          msb: 9
          lsb: 8
        }
        name: "PC"
        description: "Precision Control"
      }
      subfields {
        bit_range {
          msb: 11
          lsb: 10
        }
        name: "RC"
        description: "Rounding Control"
      }
      subfields {
        bit_range {
          msb: 12
          lsb: 12
        }
        name: "X"
        description: "Infinity Control"
      }
      subfields {
        bit_range {
          msb: 15
          lsb: 13
        }
        name: "reserved"
      }
      register_class: SPECIAL_REGISTER_FLAG
    }
  }
  register_groups {
    name: "BND0 group"
    description: "The group of registers aliased with BND0"
    registers {
      name: "BND0"
      position_in_group {
        msb: 127
      }
      feature_name: "MPX"
      register_class: SPECIAL_REGISTER_MPX_BOUNDS
    }
  }
  register_groups {
    name: "BND1 group"
    description: "The group of registers aliased with BND1"
    registers {
      name: "BND1"
      binary_encoding: 1
      position_in_group {
        msb: 127
      }
      feature_name: "MPX"
      register_class: SPECIAL_REGISTER_MPX_BOUNDS
    }
  }
  register_groups {
    name: "BND2 group"
    description: "The group of registers aliased with BND2"
    registers {
      name: "BND2"
      binary_encoding: 2
      position_in_group {
        msb: 127
      }
      feature_name: "MPX"
      register_class: SPECIAL_REGISTER_MPX_BOUNDS
    }
  }
  register_groups {
    name: "BND3 group"
    description: "The group of registers aliased with BND3"
    registers {
      name: "BND3"
      binary_encoding: 3
      position_in_group {
        msb: 127
      }
      feature_name: "MPX"
      register_class: SPECIAL_REGISTER_MPX_BOUNDS
    }
  }
  register_groups {
    name: "BNDCFGU group"
    description: "The MPX userspace control register"
    registers {
      name: "BNDCFGU"
      implicit_encoding_only: true
      description: "The MPX userspace control register"
      position_in_group {
        msb: 63
      }
      subfields {
        bit_range {
        }
        name: "En"
        description: "Enable"
      }
      subfields {
        bit_range {
          msb: 1
          lsb: 1
        }
        name: "BNDPRESERVE"
        description: "Preserve bounds across calls."
      }
      subfields {
        bit_range {
          msb: 11
          lsb: 2
        }
        name: "reserved"
      }
      subfields {
        bit_range {
          msb: 63
          lsb: 12
        }
        name: "Base"
        description: "Base of the bound directory (linear address)"
      }
      register_class: SPECIAL_REGISTER_MEMORY
    }
  }
  register_groups {
    name: "BNDCFGS group"
    description: "The MPX supervisor control register"
    registers {
      name: "BNDCFGS"
      implicit_encoding_only: true
      description: "The MPX supervisor control register"
      position_in_group {
        msb: 63
      }
      subfields {
        bit_range {
        }
        name: "En"
        description: "Enable"
      }
      subfields {
        bit_range {
          msb: 1
          lsb: 1
        }
        name: "BNDPRESERVE"
        description: "Preserve bounds across calls."
      }
      subfields {
        bit_range {
          msb: 11
          lsb: 2
        }
        name: "reserved"
      }
      subfields {
        bit_range {
          msb: 63
          lsb: 12
        }
        name: "Base"
        description: "Base of the bound directory - Linear Address"
      }
      register_class: SPECIAL_REGISTER_MEMORY
    }
  }
  register_groups {
    name: "BNDSTATUS"
    description: "The MPX status register"
    registers {
      name: "BNDSTATUS"
      implicit_encoding_only: true
      description: "The MPX status register"
      position_in_group {
        msb: 63
      }
      subfields {
        bit_range {
          msb: 1
        }
        name: "EC"
        description: "Error code"
      }
      subfields {
        bit_range {
          msb: 63
          lsb: 2
        }
        name: "ABD"
        description: "Address Bound Directory Entry - Linear address"
      }
      register_class: SPECIAL_REGISTER_MEMORY
    }
  }
  register_groups {
    name: "k0 group"
    description: "The group of registers aliased with k0"
    registers {
      name: "k0"
      position_in_group {
        msb: 63
      }
      feature_name: "AVX512"
      register_class: MASK_REGISTER
    }
  }
  register_groups {
    name: "k1 group"
    description: "The group of registers aliased with k1"
    registers {
      name: "k1"
      binary_encoding: 1
      position_in_group {
        msb: 63
      }
      feature_name: "AVX512"
      register_class: MASK_REGISTER
    }
  }
  register_groups {
    name: "k2 group"
    description: "The group of registers aliased with k2"
    registers {
      name: "k2"
      binary_encoding: 2
      position_in_group {
        msb: 63
      }
      feature_name: "AVX512"
      register_class: MASK_REGISTER
    }
  }
  register_groups {
    name: "k3 group"
    description: "The group of registers aliased with k3"
    registers {
      name: "k3"
      binary_encoding: 3
      position_in_group {
        msb: 63
      }
      feature_name: "AVX512"
      register_class: MASK_REGISTER
    }
  }
  register_groups {
    name: "k4 group"
    description: "The group of registers aliased with k4"
    registers {
      name: "k4"
      binary_encoding: 4
      position_in_group {
        msb: 63
      }
      feature_name: "AVX512"
      register_class: MASK_REGISTER
    }
  }
  register_groups {
    name: "k5 group"
    description: "The group of registers aliased with k5"
    registers {
      name: "k5"
      binary_encoding: 5
      position_in_group {
        msb: 63
      }
      feature_name: "AVX512"
      register_class: MASK_REGISTER
    }
  }
  register_groups {
    name: "k6 group"
    description: "The group of registers aliased with k6"
    registers {
      name: "k6"
      binary_encoding: 6
      position_in_group {
        msb: 63
      }
      feature_name: "AVX512"
      register_class: MASK_REGISTER
    }
  }
  register_groups {
    name: "k7 group"
    description: "The group of registers aliased with k7"
    registers {
      name: "k7"
      binary_encoding: 7
      position_in_group {
        msb: 63
      }
      feature_name: "AVX512"
      register_class: MASK_REGISTER
    }
  }
  register_groups {
    name: "ES group"
    description: "The group of registers aliased with ES"
    registers {
      name: "ES"
      position_in_group {
        msb: 15
      }
      register_class: SPECIAL_REGISTER_SEGMENT
    }
  }
  register_groups {
    name: "CS group"
    description: "The group of registers aliased with CS"
    registers {
      name: "CS"
      binary_encoding: 1
      position_in_group {
        msb: 15
      }
      register_class: SPECIAL_REGISTER_SEGMENT
    }
  }
  register_groups {
    name: "SS group"
    description: "The group of registers aliased with SS"
    registers {
      name: "SS"
      binary_encoding: 2
      position_in_group {
        msb: 15
      }
      register_class: SPECIAL_REGISTER_SEGMENT
    }
  }
  register_groups {
    name: "DS group"
    description: "The group of registers aliased with DS"
    registers {
      name: "DS"
      binary_encoding: 3
      position_in_group {
        msb: 15
      }
      register_class: SPECIAL_REGISTER_SEGMENT
    }
  }
  register_groups {
    name: "FS group"
    description: "The group of registers aliased with FS"
    registers {
      name: "FS"
      binary_encoding: 4
      position_in_group {
        msb: 15
      }
      register_class: SPECIAL_REGISTER_SEGMENT
    }
  }
  register_groups {
    name: "GS group"
    description: "The group of registers aliased with GS"
    registers {
      name: "GS"
      binary_encoding: 5
      position_in_group {
        msb: 15
      }
      register_class: SPECIAL_REGISTER_SEGMENT
    }
  }
  register_groups {
    name: "MXCSR group"
    description: "The SIMD floating point operation control register."
    registers {
      name: "MXCSR"
      implicit_encoding_only: true
      description: "The SIMD floating point operation control register."
      position_in_group {
        msb: 31
      }
      subfields {
        bit_range {
        }
        name: "IE"
        description: "Invalid Operation Flag"
      }
      subfields {
        bit_range {
          msb: 1
          lsb: 1
        }
        name: "DE"
        description: "Denormal Flag"
      }
      subfields {
        bit_range {
          msb: 2
          lsb: 2
        }
        name: "ZE"
        description: "Divide-by-zero Flag"
      }
      subfields {
        bit_range {
          msb: 3
          lsb: 3
        }
        name: "OE"
        description: "Overflow Flag"
      }
      subfields {
        bit_range {
          msb: 4
          lsb: 4
        }
        name: "UE"
        description: "Underflow Flag"
      }
      subfields {
        bit_range {
          msb: 5
          lsb: 5
        }
        name: "PE"
        description: "Precision Flag"
      }
      subfields {
        bit_range {
          msb: 6
          lsb: 6
        }
        name: "DAZ"
        description: "Denormals Are Zeros"
      }
      subfields {
        bit_range {
          msb: 7
          lsb: 7
        }
        name: "IM"
        description: "Invalid Operation Mask"
      }
      subfields {
        bit_range {
          msb: 8
          lsb: 8
        }
        name: "DM"
        description: "Denormal Operation Mask"
      }
      subfields {
        bit_range {
          msb: 9
          lsb: 9
        }
        name: "ZM"
        description: "Divide-by-zero Mask"
      }
      subfields {
        bit_range {
          msb: 10
          lsb: 10
        }
        name: "OM"
        description: "Overflow Mask"
      }
      subfields {
        bit_range {
          msb: 11
          lsb: 11
        }
        name: "UM"
        description: "Underflow Mask"
      }
      subfields {
        bit_range {
          msb: 12
          lsb: 12
        }
        name: "PM"
        description: "Precision Mask"
      }
      subfields {
        bit_range {
          msb: 14
          lsb: 13
        }
        name: "RC"
        description: "Rounding Control"
      }
      subfields {
        bit_range {
          msb: 15
          lsb: 15
        }
        name: "FZ"
        description: "Flush to Zero"
      }
      subfields {
        bit_range {
          msb: 31
          lsb: 16
        }
        name: "reserved"
      }
      register_class: SPECIAL_REGISTER_FLAG
    }
  }
  register_groups {
    name: "XMM0 group"
    description: "The group of registers aliased with XMM0"
    registers {
      name: "XMM0"
      position_in_group {
        msb: 127
      }
      feature_name: "SSE"
      register_class: VECTOR_REGISTER_128_BIT
    }
    registers {
      name: "YMM0"
      position_in_group {
        msb: 255
      }
      feature_name: "AVX"
      register_class: VECTOR_REGISTER_256_BIT
    }
    registers {
      name: "ZMM0"
      position_in_group {
        msb: 511
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_512_BIT
    }
  }
  register_groups {
    name: "XMM1 group"
    description: "The group of registers aliased with XMM1"
    registers {
      name: "XMM1"
      binary_encoding: 1
      position_in_group {
        msb: 127
      }
      feature_name: "SSE"
      register_class: VECTOR_REGISTER_128_BIT
    }
    registers {
      name: "YMM1"
      binary_encoding: 1
      position_in_group {
        msb: 255
      }
      feature_name: "AVX"
      register_class: VECTOR_REGISTER_256_BIT
    }
    registers {
      name: "ZMM1"
      binary_encoding: 1
      position_in_group {
        msb: 511
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_512_BIT
    }
  }
  register_groups {
    name: "XMM2 group"
    description: "The group of registers aliased with XMM2"
    registers {
      name: "XMM2"
      binary_encoding: 2
      position_in_group {
        msb: 127
      }
      feature_name: "SSE"
      register_class: VECTOR_REGISTER_128_BIT
    }
    registers {
      name: "YMM2"
      binary_encoding: 2
      position_in_group {
        msb: 255
      }
      feature_name: "AVX"
      register_class: VECTOR_REGISTER_256_BIT
    }
    registers {
      name: "ZMM2"
      binary_encoding: 2
      position_in_group {
        msb: 511
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_512_BIT
    }
  }
  register_groups {
    name: "XMM3 group"
    description: "The group of registers aliased with XMM3"
    registers {
      name: "XMM3"
      binary_encoding: 3
      position_in_group {
        msb: 127
      }
      feature_name: "SSE"
      register_class: VECTOR_REGISTER_128_BIT
    }
    registers {
      name: "YMM3"
      binary_encoding: 3
      position_in_group {
        msb: 255
      }
      feature_name: "AVX"
      register_class: VECTOR_REGISTER_256_BIT
    }
    registers {
      name: "ZMM3"
      binary_encoding: 3
      position_in_group {
        msb: 511
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_512_BIT
    }
  }
  register_groups {
    name: "XMM4 group"
    description: "The group of registers aliased with XMM4"
    registers {
      name: "XMM4"
      binary_encoding: 4
      position_in_group {
        msb: 127
      }
      feature_name: "SSE"
      register_class: VECTOR_REGISTER_128_BIT
    }
    registers {
      name: "YMM4"
      binary_encoding: 4
      position_in_group {
        msb: 255
      }
      feature_name: "AVX"
      register_class: VECTOR_REGISTER_256_BIT
    }
    registers {
      name: "ZMM4"
      binary_encoding: 4
      position_in_group {
        msb: 511
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_512_BIT
    }
  }
  register_groups {
    name: "XMM5 group"
    description: "The group of registers aliased with XMM5"
    registers {
      name: "XMM5"
      binary_encoding: 5
      position_in_group {
        msb: 127
      }
      feature_name: "SSE"
      register_class: VECTOR_REGISTER_128_BIT
    }
    registers {
      name: "YMM5"
      binary_encoding: 5
      position_in_group {
        msb: 255
      }
      feature_name: "AVX"
      register_class: VECTOR_REGISTER_256_BIT
    }
    registers {
      name: "ZMM5"
      binary_encoding: 5
      position_in_group {
        msb: 511
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_512_BIT
    }
  }
  register_groups {
    name: "XMM6 group"
    description: "The group of registers aliased with XMM6"
    registers {
      name: "XMM6"
      binary_encoding: 6
      position_in_group {
        msb: 127
      }
      feature_name: "SSE"
      register_class: VECTOR_REGISTER_128_BIT
    }
    registers {
      name: "YMM6"
      binary_encoding: 6
      position_in_group {
        msb: 255
      }
      feature_name: "AVX"
      register_class: VECTOR_REGISTER_256_BIT
    }
    registers {
      name: "ZMM6"
      binary_encoding: 6
      position_in_group {
        msb: 511
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_512_BIT
    }
  }
  register_groups {
    name: "XMM7 group"
    description: "The group of registers aliased with XMM7"
    registers {
      name: "XMM7"
      binary_encoding: 7
      position_in_group {
        msb: 127
      }
      feature_name: "SSE"
      register_class: VECTOR_REGISTER_128_BIT
    }
    registers {
      name: "YMM7"
      binary_encoding: 7
      position_in_group {
        msb: 255
      }
      feature_name: "AVX"
      register_class: VECTOR_REGISTER_256_BIT
    }
    registers {
      name: "ZMM7"
      binary_encoding: 7
      position_in_group {
        msb: 511
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_512_BIT
    }
  }
  register_groups {
    name: "XMM8 group"
    description: "The group of registers aliased with XMM8"
    registers {
      name: "XMM8"
      binary_encoding: 8
      position_in_group {
        msb: 127
      }
      feature_name: "SSE"
      register_class: VECTOR_REGISTER_128_BIT
    }
    registers {
      name: "YMM8"
      binary_encoding: 8
      position_in_group {
        msb: 255
      }
      feature_name: "AVX"
      register_class: VECTOR_REGISTER_256_BIT
    }
    registers {
      name: "ZMM8"
      binary_encoding: 8
      position_in_group {
        msb: 511
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_512_BIT
    }
  }
  register_groups {
    name: "XMM9 group"
    description: "The group of registers aliased with XMM9"
    registers {
      name: "XMM9"
      binary_encoding: 9
      position_in_group {
        msb: 127
      }
      feature_name: "SSE"
      register_class: VECTOR_REGISTER_128_BIT
    }
    registers {
      name: "YMM9"
      binary_encoding: 9
      position_in_group {
        msb: 255
      }
      feature_name: "AVX"
      register_class: VECTOR_REGISTER_256_BIT
    }
    registers {
      name: "ZMM9"
      binary_encoding: 9
      position_in_group {
        msb: 511
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_512_BIT
    }
  }
  register_groups {
    name: "XMM10 group"
    description: "The group of registers aliased with XMM10"
    registers {
      name: "XMM10"
      binary_encoding: 10
      position_in_group {
        msb: 127
      }
      feature_name: "SSE"
      register_class: VECTOR_REGISTER_128_BIT
    }
    registers {
      name: "YMM10"
      binary_encoding: 10
      position_in_group {
        msb: 255
      }
      feature_name: "AVX"
      register_class: VECTOR_REGISTER_256_BIT
    }
    registers {
      name: "ZMM10"
      binary_encoding: 10
      position_in_group {
        msb: 511
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_512_BIT
    }
  }
  register_groups {
    name: "XMM11 group"
    description: "The group of registers aliased with XMM11"
    registers {
      name: "XMM11"
      binary_encoding: 11
      position_in_group {
        msb: 127
      }
      feature_name: "SSE"
      register_class: VECTOR_REGISTER_128_BIT
    }
    registers {
      name: "YMM11"
      binary_encoding: 11
      position_in_group {
        msb: 255
      }
      feature_name: "AVX"
      register_class: VECTOR_REGISTER_256_BIT
    }
    registers {
      name: "ZMM11"
      binary_encoding: 11
      position_in_group {
        msb: 511
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_512_BIT
    }
  }
  register_groups {
    name: "XMM12 group"
    description: "The group of registers aliased with XMM12"
    registers {
      name: "XMM12"
      binary_encoding: 12
      position_in_group {
        msb: 127
      }
      feature_name: "SSE"
      register_class: VECTOR_REGISTER_128_BIT
    }
    registers {
      name: "YMM12"
      binary_encoding: 12
      position_in_group {
        msb: 255
      }
      feature_name: "AVX"
      register_class: VECTOR_REGISTER_256_BIT
    }
    registers {
      name: "ZMM12"
      binary_encoding: 12
      position_in_group {
        msb: 511
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_512_BIT
    }
  }
  register_groups {
    name: "XMM13 group"
    description: "The group of registers aliased with XMM13"
    registers {
      name: "XMM13"
      binary_encoding: 13
      position_in_group {
        msb: 127
      }
      feature_name: "SSE"
      register_class: VECTOR_REGISTER_128_BIT
    }
    registers {
      name: "YMM13"
      binary_encoding: 13
      position_in_group {
        msb: 255
      }
      feature_name: "AVX"
      register_class: VECTOR_REGISTER_256_BIT
    }
    registers {
      name: "ZMM13"
      binary_encoding: 13
      position_in_group {
        msb: 511
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_512_BIT
    }
  }
  register_groups {
    name: "XMM14 group"
    description: "The group of registers aliased with XMM14"
    registers {
      name: "XMM14"
      binary_encoding: 14
      position_in_group {
        msb: 127
      }
      feature_name: "SSE"
      register_class: VECTOR_REGISTER_128_BIT
    }
    registers {
      name: "YMM14"
      binary_encoding: 14
      position_in_group {
        msb: 255
      }
      feature_name: "AVX"
      register_class: VECTOR_REGISTER_256_BIT
    }
    registers {
      name: "ZMM14"
      binary_encoding: 14
      position_in_group {
        msb: 511
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_512_BIT
    }
  }
  register_groups {
    name: "XMM15 group"
    description: "The group of registers aliased with XMM15"
    registers {
      name: "XMM15"
      binary_encoding: 15
      position_in_group {
        msb: 127
      }
      feature_name: "SSE"
      register_class: VECTOR_REGISTER_128_BIT
    }
    registers {
      name: "YMM15"
      binary_encoding: 15
      position_in_group {
        msb: 255
      }
      feature_name: "AVX"
      register_class: VECTOR_REGISTER_256_BIT
    }
    registers {
      name: "ZMM15"
      binary_encoding: 15
      position_in_group {
        msb: 511
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_512_BIT
    }
  }
  register_groups {
    name: "XMM16 group"
    description: "The group of registers aliased with XMM16"
    registers {
      name: "XMM16"
      binary_encoding: 16
      position_in_group {
        msb: 127
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_128_BIT
    }
    registers {
      name: "YMM16"
      binary_encoding: 16
      position_in_group {
        msb: 255
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_256_BIT
    }
    registers {
      name: "ZMM16"
      binary_encoding: 16
      position_in_group {
        msb: 511
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_512_BIT
    }
  }
  register_groups {
    name: "XMM17 group"
    description: "The group of registers aliased with XMM17"
    registers {
      name: "XMM17"
      binary_encoding: 17
      position_in_group {
        msb: 127
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_128_BIT
    }
    registers {
      name: "YMM17"
      binary_encoding: 17
      position_in_group {
        msb: 255
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_256_BIT
    }
    registers {
      name: "ZMM17"
      binary_encoding: 17
      position_in_group {
        msb: 511
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_512_BIT
    }
  }
  register_groups {
    name: "XMM18 group"
    description: "The group of registers aliased with XMM18"
    registers {
      name: "XMM18"
      binary_encoding: 18
      position_in_group {
        msb: 127
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_128_BIT
    }
    registers {
      name: "YMM18"
      binary_encoding: 18
      position_in_group {
        msb: 255
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_256_BIT
    }
    registers {
      name: "ZMM18"
      binary_encoding: 18
      position_in_group {
        msb: 511
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_512_BIT
    }
  }
  register_groups {
    name: "XMM19 group"
    description: "The group of registers aliased with XMM19"
    registers {
      name: "XMM19"
      binary_encoding: 19
      position_in_group {
        msb: 127
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_128_BIT
    }
    registers {
      name: "YMM19"
      binary_encoding: 19
      position_in_group {
        msb: 255
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_256_BIT
    }
    registers {
      name: "ZMM19"
      binary_encoding: 19
      position_in_group {
        msb: 511
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_512_BIT
    }
  }
  register_groups {
    name: "XMM20 group"
    description: "The group of registers aliased with XMM20"
    registers {
      name: "XMM20"
      binary_encoding: 20
      position_in_group {
        msb: 127
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_128_BIT
    }
    registers {
      name: "YMM20"
      binary_encoding: 20
      position_in_group {
        msb: 255
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_256_BIT
    }
    registers {
      name: "ZMM20"
      binary_encoding: 20
      position_in_group {
        msb: 511
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_512_BIT
    }
  }
  register_groups {
    name: "XMM21 group"
    description: "The group of registers aliased with XMM21"
    registers {
      name: "XMM21"
      binary_encoding: 21
      position_in_group {
        msb: 127
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_128_BIT
    }
    registers {
      name: "YMM21"
      binary_encoding: 21
      position_in_group {
        msb: 255
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_256_BIT
    }
    registers {
      name: "ZMM21"
      binary_encoding: 21
      position_in_group {
        msb: 511
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_512_BIT
    }
  }
  register_groups {
    name: "XMM22 group"
    description: "The group of registers aliased with XMM22"
    registers {
      name: "XMM22"
      binary_encoding: 22
      position_in_group {
        msb: 127
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_128_BIT
    }
    registers {
      name: "YMM22"
      binary_encoding: 22
      position_in_group {
        msb: 255
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_256_BIT
    }
    registers {
      name: "ZMM22"
      binary_encoding: 22
      position_in_group {
        msb: 511
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_512_BIT
    }
  }
  register_groups {
    name: "XMM23 group"
    description: "The group of registers aliased with XMM23"
    registers {
      name: "XMM23"
      binary_encoding: 23
      position_in_group {
        msb: 127
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_128_BIT
    }
    registers {
      name: "YMM23"
      binary_encoding: 23
      position_in_group {
        msb: 255
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_256_BIT
    }
    registers {
      name: "ZMM23"
      binary_encoding: 23
      position_in_group {
        msb: 511
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_512_BIT
    }
  }
  register_groups {
    name: "XMM24 group"
    description: "The group of registers aliased with XMM24"
    registers {
      name: "XMM24"
      binary_encoding: 24
      position_in_group {
        msb: 127
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_128_BIT
    }
    registers {
      name: "YMM24"
      binary_encoding: 24
      position_in_group {
        msb: 255
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_256_BIT
    }
    registers {
      name: "ZMM24"
      binary_encoding: 24
      position_in_group {
        msb: 511
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_512_BIT
    }
  }
  register_groups {
    name: "XMM25 group"
    description: "The group of registers aliased with XMM25"
    registers {
      name: "XMM25"
      binary_encoding: 25
      position_in_group {
        msb: 127
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_128_BIT
    }
    registers {
      name: "YMM25"
      binary_encoding: 25
      position_in_group {
        msb: 255
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_256_BIT
    }
    registers {
      name: "ZMM25"
      binary_encoding: 25
      position_in_group {
        msb: 511
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_512_BIT
    }
  }
  register_groups {
    name: "XMM26 group"
    description: "The group of registers aliased with XMM26"
    registers {
      name: "XMM26"
      binary_encoding: 26
      position_in_group {
        msb: 127
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_128_BIT
    }
    registers {
      name: "YMM26"
      binary_encoding: 26
      position_in_group {
        msb: 255
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_256_BIT
    }
    registers {
      name: "ZMM26"
      binary_encoding: 26
      position_in_group {
        msb: 511
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_512_BIT
    }
  }
  register_groups {
    name: "XMM27 group"
    description: "The group of registers aliased with XMM27"
    registers {
      name: "XMM27"
      binary_encoding: 27
      position_in_group {
        msb: 127
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_128_BIT
    }
    registers {
      name: "YMM27"
      binary_encoding: 27
      position_in_group {
        msb: 255
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_256_BIT
    }
    registers {
      name: "ZMM27"
      binary_encoding: 27
      position_in_group {
        msb: 511
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_512_BIT
    }
  }
  register_groups {
    name: "XMM28 group"
    description: "The group of registers aliased with XMM28"
    registers {
      name: "XMM28"
      binary_encoding: 28
      position_in_group {
        msb: 127
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_128_BIT
    }
    registers {
      name: "YMM28"
      binary_encoding: 28
      position_in_group {
        msb: 255
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_256_BIT
    }
    registers {
      name: "ZMM28"
      binary_encoding: 28
      position_in_group {
        msb: 511
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_512_BIT
    }
  }
  register_groups {
    name: "XMM29 group"
    description: "The group of registers aliased with XMM29"
    registers {
      name: "XMM29"
      binary_encoding: 29
      position_in_group {
        msb: 127
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_128_BIT
    }
    registers {
      name: "YMM29"
      binary_encoding: 29
      position_in_group {
        msb: 255
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_256_BIT
    }
    registers {
      name: "ZMM29"
      binary_encoding: 29
      position_in_group {
        msb: 511
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_512_BIT
    }
  }
  register_groups {
    name: "XMM30 group"
    description: "The group of registers aliased with XMM30"
    registers {
      name: "XMM30"
      binary_encoding: 30
      position_in_group {
        msb: 127
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_128_BIT
    }
    registers {
      name: "YMM30"
      binary_encoding: 30
      position_in_group {
        msb: 255
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_256_BIT
    }
    registers {
      name: "ZMM30"
      binary_encoding: 30
      position_in_group {
        msb: 511
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_512_BIT
    }
  }
  register_groups {
    name: "XMM31 group"
    description: "The group of registers aliased with XMM31"
    registers {
      name: "XMM31"
      binary_encoding: 31
      position_in_group {
        msb: 127
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_128_BIT
    }
    registers {
      name: "YMM31"
      binary_encoding: 31
      position_in_group {
        msb: 255
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_256_BIT
    }
    registers {
      name: "ZMM31"
      binary_encoding: 31
      position_in_group {
        msb: 511
      }
      feature_name: "AVX512"
      register_class: VECTOR_REGISTER_512_BIT
    }
  }
  register_groups {
    name: "GDTR group"
    description: "The Global Descriptor Table Register group"
    registers {
      name: "GDTR"
      position_in_group {
        msb: 63
      }
      register_class: SPECIAL_REGISTER_MEMORY
    }
  }
  register_groups {
    name: "LDTR group"
    description: "The Local Descriptor Table Register group"
    registers {
      name: "LDTR"
      position_in_group {
        msb: 63
      }
      register_class: SPECIAL_REGISTER_MEMORY
    }
  }
  register_groups {
    name: "IDTR group"
    description: "The Interrupt Descriptor Table Register group"
    registers {
      name: "IDTR"
      position_in_group {
        msb: 63
      }
      register_class: SPECIAL_REGISTER_MEMORY
    }
  }
  register_groups {
    name: "TR group"
    description: "The Task Register group"
    registers {
      name: "TR"
      position_in_group {
        msb: 63
      }
      register_class: SPECIAL_REGISTER_MEMORY
    }
  }
}
